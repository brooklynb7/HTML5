// This file has been generated by the SAPUI5 CreateModule Ant-Task
/*!
 * jQuery JavaScript Library v1.7.1
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Mon Nov 21 21:11:03 2011 -0500
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.1",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;

		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}

		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);

			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}

			return elems;
		}

		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!memory;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");
	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	div.innerHTML = "";

	// Check if div with explicit width and no margin-right incorrectly
	// gets computed margin-right based on width of container. For more
	// info see bug #3333
	// Fails in WebKit before Feb 2011 nightlies
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	if ( window.getComputedStyle ) {
		marginDiv = document.createElement( "div" );
		marginDiv.style.width = "0";
		marginDiv.style.marginRight = "0";
		div.style.width = "2px";
		div.appendChild( marginDiv );
		support.reliableMarginRight =
			( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
	}

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = marginDiv = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			conMarginTop, ptlm, vb, style, html,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
		vb = "visibility:hidden;border:0;";
		style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
		html = "<div " + style + "><div></div></div>" +
			"<table " + style + " cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Figure out if the W3C box model works as expected
		div.innerHTML = "";
		div.style.width = div.style.paddingLeft = "1px";
		jQuery.boxModel = support.boxModel = div.offsetWidth === 2;

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "";
			div.innerHTML = "<div style='width:4px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
		}

		div.style.cssText = ptlm + vb;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		body.removeChild( container );
		div  = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, attr, name,
			data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 && !jQuery._data( this[0], "parsedAttrs" ) ) {
					attr = this[0].attributes;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( this[0], name, data[ name ] );
						}
					}
					jQuery._data( this[0], "parsedAttrs", true );
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var self = jQuery( this ),
					args = [ parts[0], value ];

				self.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? parseFloat( data ) :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function() {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise();
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.prop );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;

					// See #9699 for explanation of this approach (setting first, then removal)
					jQuery.attr( elem, name, "" );
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( rboolean.test( name ) && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /\bhover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Determine handlers that should run if there are delegated events
		// Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !event.target.disabled && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
				selMatch = {};
				matches = [];
				jqcur[0] = cur;
				for ( i = 0; i < delegateCount; i++ ) {
					handleObj = handlers[ i ];
					sel = handleObj.selector;

					if ( selMatch[ sel ] === undefined ) {
						selMatch[ sel ] = (
							handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
						);
					}
					if ( selMatch[ sel ] ) {
						matches.push( handleObj );
					}
				}
				if ( matches.length ) {
					handlerQueue.push({ elem: cur, matches: matches });
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						// If form was submitted by the user, bubble the event up the tree
						if ( this.parentNode && !event.isTrigger ) {
							jQuery.event.simulate( "submit", this.parentNode, event, true );
						}
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on.call( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					doneName = match[0];
					parent = elem.parentNode;
	
					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent[ expando ] = doneName;
					}
					
					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					
					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				
				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
						
					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
							
						} else {
							return makeArray( [], extra );
						}
					}
					
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );
	
		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && ( 
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ? 
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];
		
		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || !rnoshimcache.test( "<" + elem.nodeName ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType;

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [], j;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

				} else {
					if ( ret[i].nodeType === 1 ) {
						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^([\-+])=([\-+.\de]+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWH( elem, name, extra );
				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				return val;
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat( value );

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				var ret;
				jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						ret = curCSS( elem, "margin-right", "marginRight" );
					} else {
						ret = elem.style.marginRight;
					}
				});
				return ret;
			}
		};
	}
});

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret === null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ( ret || 0 );
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight,
		i = 0,
		len = which.length;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i++ ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ] || 0;
	}
	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i++ ) {
			val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
			}
		}
	}

	return val + "px";
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefiler, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		( typeof s.data === "string" );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}
									responses.text = xhr.responseText;

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( display === "" && jQuery.css(elem, "display") === "none" ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			for ( p in prop ) {

				// property name normalization
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				val = prop[ name ];

				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				jQuery._data( self.elem, "fxshow" + self.prop, self.start );
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Adds width/height step functions
// Do not set anything below 0
jQuery.each([ "width", "height" ], function( i, prop ) {
	jQuery.fx.step[ prop ] = function( fx ) {
		jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
	};
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function( val ) {
		var elem, win;

		if ( val === undefined ) {
			elem = this[ 0 ];

			if ( !elem ) {
				return null;
			}

			win = getWindow( elem );

			// Return the scroll offset
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}

		// Set the scroll offset
		return this.each(function() {
			win = getWindow( this );

			if ( win ) {
				win.scrollTo(
					!i ? val : jQuery( win ).scrollLeft(),
					 i ? val : jQuery( win ).scrollTop()
				);

			} else {
				this[ method ] = val;
			}
		});
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		var elem = this[0];
		if ( !elem ) {
			return size == null ? null : this;
		}

		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		if ( jQuery.isWindow( elem ) ) {
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
			var docElemProp = elem.document.documentElement[ "client" + name ],
				body = elem.document.body;
			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				body && body[ "client" + name ] || docElemProp;

		// Get document width or height
		} else if ( elem.nodeType === 9 ) {
			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
			return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

		// Get or set width or height on the element
		} else if ( size === undefined ) {
			var orig = jQuery.css( elem, type ),
				ret = parseFloat( orig );

			return jQuery.isNumeric( ret ) ? ret : orig;

		// Set the width or height on the element (default to pixels if value is unitless)
		} else {
			return this.css( type, typeof size === "string" ? size : size + "px" );
		}
	};

});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );

/*!
 * jQuery UI Position 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var horizontalPositions = /left|center|right/,
	verticalPositions = /top|center|bottom/,
	center = "center",
	support = {},
	_position = $.fn.position,
	_offset = $.fn.offset;

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var target = $( options.of ),
		targetElem = target[0],
		collision = ( options.collision || "flip" ).split( " " ),
		offset = options.offset ? options.offset.split( " " ) : [ 0, 0 ],
		targetWidth,
		targetHeight,
		basePosition;

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: 0, left: 0 };
	// TODO: use $.isWindow() in 1.9
	} else if ( targetElem.setTimeout ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		basePosition = { top: options.of.pageY, left: options.of.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		basePosition = target.offset();
	}

	// force my and at to have valid horizontal and veritcal positions
	// if a value is missing or invalid, it will be converted to center 
	$.each( [ "my", "at" ], function() {
		var pos = ( options[this] || "" ).split( " " );
		if ( pos.length === 1) {
			pos = horizontalPositions.test( pos[0] ) ?
				pos.concat( [center] ) :
				verticalPositions.test( pos[0] ) ?
					[ center ].concat( pos ) :
					[ center, center ];
		}
		pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : center;
		pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : center;
		options[ this ] = pos;
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	// normalize offset option
	offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
	if ( offset.length === 1 ) {
		offset[ 1 ] = offset[ 0 ];
	}
	offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

	if ( options.at[0] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[0] === center ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[1] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[1] === center ) {
		basePosition.top += targetHeight / 2;
	}

	basePosition.left += offset[ 0 ];
	basePosition.top += offset[ 1 ];

	return this.each(function() {
		var elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseInt( $.curCSS( this, "marginLeft", true ) ) || 0,
			marginTop = parseInt( $.curCSS( this, "marginTop", true ) ) || 0,
			collisionWidth = elemWidth + marginLeft +
				( parseInt( $.curCSS( this, "marginRight", true ) ) || 0 ),
			collisionHeight = elemHeight + marginTop +
				( parseInt( $.curCSS( this, "marginBottom", true ) ) || 0 ),
			position = $.extend( {}, basePosition ),
			collisionPosition;

		if ( options.my[0] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[0] === center ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[1] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[1] === center ) {
			position.top -= elemHeight / 2;
		}

		// prevent fractions if jQuery version doesn't support them (see #5280)
		if ( !support.fractions ) {
			position.left = Math.round( position.left );
			position.top = Math.round( position.top );
		}

		collisionPosition = {
			left: position.left - marginLeft,
			top: position.top - marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[i] ] ) {
				$.ui.position[ collision[i] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: offset,
					my: options.my,
					at: options.at
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}
		elem.offset( $.extend( position, { using: options.using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft();
			position.left = over > 0 ? position.left - over : Math.max( position.left - data.collisionPosition.left, position.left );
		},
		top: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop();
			position.top = over > 0 ? position.top - over : Math.max( position.top - data.collisionPosition.top, position.top );
		}
	},

	flip: {
		left: function( position, data ) {
			if ( data.at[0] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(),
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					-data.targetWidth,
				offset = -2 * data.offset[ 0 ];
			position.left += data.collisionPosition.left < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		},
		top: function( position, data ) {
			if ( data.at[1] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(),
				myOffset = data.my[ 1 ] === "top" ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					-data.targetHeight,
				offset = -2 * data.offset[ 1 ];
			position.top += data.collisionPosition.top < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		}
	}
};

// offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
	$.offset.setOffset = function( elem, options ) {
		// set position first, in-case top/left are set even on static elem
		if ( /static/.test( $.curCSS( elem, "position" ) ) ) {
			elem.style.position = "relative";
		}
		var curElem   = $( elem ),
			curOffset = curElem.offset(),
			curTop    = parseInt( $.curCSS( elem, "top",  true ), 10 ) || 0,
			curLeft   = parseInt( $.curCSS( elem, "left", true ), 10)  || 0,
			props     = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};
		
		if ( 'using' in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	};

	$.fn.offset = function( options ) {
		var elem = this[ 0 ];
		if ( !elem || !elem.ownerDocument ) { return null; }
		if ( options ) {
			if ( $.isFunction( options ) ) {
				return this.each(function( i ) {
					$( this ).offset( options.call( this, i, $( this ).offset() ) );
				});
			}
			return this.each(function() {
				$.offset.setOffset( this, options );
			});
		}
		return _offset.call( this );
	};
}

// jQuery <1.4.3 uses curCSS, in 1.4.3 - 1.7.2 curCSS = css, 1.8+ only has css
if ( !$.curCSS ) {
	$.curCSS = $.css;
}

// fraction support test (older versions of jQuery don't support fractions)
(function () {
	var body = document.getElementsByTagName( "body" )[ 0 ], 
		div = document.createElement( "div" ),
		testElement, testElementParent, testElementStyle, offset, offsetTotal;

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( var i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;";

	offset = $( div ).offset( function( _, offset ) {
		return offset;
	}).offset();

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );

	offsetTotal = offset.top + offset.left + ( body ? 2000 : 0 );
	support.fractions = offsetTotal > 21 && offsetTotal < 22;
})();

}( jQuery ));

/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

/**
 * @class Provides base functionality of the SAP jQuery plugin as extension of the jQuery framework.<br/>
 * See also <a href="http://api.jquery.com/jQuery/">jQuery</a> for details.<br/>
 * Although these functions appear as static ones, they are meant to be used on jQuery instances.<br/>
 * If not stated differently, the functions follow the fluent interface paradigm and return the jQuery instance for chaining of statements.
 *
 * Example for usage of an instance method:
 * <pre>
 *   var oRect = jQuery("#myDiv").rect();
 *   alert("Top Position: " + oRect.top);
 * </pre>
 *
 * @name jQuery
 * @static
 * @public
 */

(function() {
	
	if (!window.jQuery ) {
		throw new Error("SAPUI5 requires jQuery as a prerequisite (>= version 1.7)");
	}

	/**
	 * Window that the sap plugin has been initialized for.
	 * @private
	 */
	var _window = window;

	var _earlyErrors = [];

	var _sBootstrapUrl = undefined;

	if ( parseFloat(jQuery.prototype.jquery) < 1.7 ) {
		_earlyErrors.push("SAPUI5 requires at least jQuery 1.7, current version is " + jQuery.prototype.jquery);
	}
	
	//ensure not to initialize twice
	if (jQuery.sap) {
		return;
	}

	// Fixes the CORS issue (introduced by jQuery 1.7) when loading resources
	// (e.g. SAPUI5 script) from other domains for IE browsers.
	// The CORS check in jQuery filters out such browsers who do not have the
	// property "withCredentials" which is the IE and Opera and prevents those
	// browsers to request data from other domains with jQuery.ajax. The CORS
	// requests are simply forbidden nevertheless if it works. In our case we
	// simply load our script resources from another domain when using the CDN
	// variant of SAPUI5. The following fix is also recommended by jQuery:
	if (jQuery.browser.msie) {
		jQuery.support.cors = true;
	}


	/**
	 * Find the script URL where the SAPUI5 is loaded from and return an object which
	 * contains the identified script-tag and resource root
	 */
	var _oBootstrap = (function() {
		var oTag, sUrl, sResourceRoot,
			reConfigurator = /\/download\/configurator[\/\?]/,
			reBootScripts = /\/(sap-ui-(core|custom|boot)(-.*)?)\.js([?#]|$)/,
			reResources = /^(.*\/)?resources\//;

		// check all script tags that have a src attribute
		jQuery("script[src]").each(function() {
			var src = this.getAttribute("src"),
				m;
			if ( m = src.match(reConfigurator) ) {
				// guess 1: script tag src contains "/download/configurator[/?]" (for dynamically created bootstrap files)
				oTag = this;
				sUrl = src;
				sResourceRoot = src.substring(0, m.index) + "/resources/";
				return false;
			} else if ( m = src.match(reBootScripts) ) {
				// guess 2: src contains one of the well known boot script names
				oTag = this;
				sUrl = src;
				sResourceRoot = src.substring(0, m.index) + "/";
				return false;
			} else if ( this.id == 'sap-ui-bootstrap' && (m=src.match(reResources)) ) {
				// guess 2: script tag has well known id and src contains "resources/"
				oTag = this;
				sUrl = src;
				sResourceRoot = m[0];
				return false;
			}
		});
		return {
			tag: oTag,
			url: sUrl,
			resourceRoot: sResourceRoot
		};
	})();

	/**
	 * Determine whether sap-bootstrap-debug is set, run debugger statement and allow
	 * to restart the core from a new URL
	 */
	(function() {
		if (/sap-bootstrap-debug=(true|x|X)/.test(location.search)) {
			window["sap-ui-bRestart"] = false;
			window["sap-ui-sRestartUrl"] = "http://localhost:8080/sapui5/resources/sap-ui-core.js";

			// function to replace the bootstrap tag with a newly created script tag to enable
			// restarting the core from a different server
			function restartCore() {
				var oScript = _oBootstrap.tag,
					sScript = "<script src=\"" + window["sap-ui-sRestartUrl"] + "\"";
				jQuery.each(oScript.attributes, function(i, oAttr) {
					if (oAttr.nodeName.indexOf("data-sap-ui-") == 0) {
						sScript += " " + oAttr.nodeName + "=\"" + oAttr.nodeValue + "\"";
					}
				});
				sScript += "></script>";
				oScript.parentNode.removeChild(oScript);
				
				// clean up cachebuster stuff
				jQuery("#sap-ui-bootstrap-cachebusted").remove();
				window["sap-ui-config"] && window["sap-ui-config"].resourceRoots && (window["sap-ui-config"].resourceRoots[""] = undefined);
				
				document.write(sScript);
				var oRestart = new Error("Aborting UI5 bootstrap and restarting from: " + window["sap-ui-sRestartUrl"]);
				oRestart.name = "Restart";
				
				// clean up
				delete window["sap-ui-bRestart"];
				delete window["sap-ui-sRestartUrl"];
				
				throw oRestart;
			};

			// debugger stops here. To restart UI5 from somewhere else (default: localhost), set:
			//    window["sap-ui-bRestart"] = true
			// If you want to restart from a different server than localhost, you can adapt the URL, e.g.: 
			//    window["sap-ui-sRestartUrl"] = "http://someserver:8080/sapui5/resources/sap-ui-core.js"
			debugger;
			if (window["sap-ui-bRestart"]) {
				restartCore();
			}
		}
	})();

	/**
	 * Determine whether to use debug sources depending on URL parameter and local storage
	 * and load debug library if necessary
	 */
	(function() {
		//Check URI param
		var bDebugSources = /sap-ui-debug=(true|x|X)/.test(location.search),
			bIsOptimized = window["sap-ui-optimized"];

		//Check local storage
		try { //Necessary for FF when Cookies are deactivated
			bDebugSources = bDebugSources || (window.localStorage.getItem("sap-ui-debug") == "X");
		} catch(e) {}

		window["sap-ui-debug"] = bDebugSources;

		// if bootstap URL already contains -dbg URL, just set sap-ui-loaddbg
		if (/-dbg\.js([?#]|$)/.test(_oBootstrap.url)) {
			window["sap-ui-loaddbg"] = true;
			window["sap-ui-debug"] = true;
		}

		// if current sources are optimized and debug sources are wanted, restart with debug URL
		if (bIsOptimized && bDebugSources) {
			var sDebugUrl = _oBootstrap.url.replace(/\/(?:sap-ui-cachebuster\/)?([^\/]+)\.js/, "/$1-dbg.js");
			window["sap-ui-optimized"] = false;
			window["sap-ui-loaddbg"] = true;
			document.write("<script type=\"text/javascript\" src=\"" + sDebugUrl + "\"></script>");
			var oRestart = new Error("Aborting UI5 bootstrap and restarting from: " + sDebugUrl);
			oRestart.name = "Restart";
			throw oRestart;
		}
	})();

	/*
	 * Merged, raw (un-interpreted) configuration data from the following sources
	 * (last one wins)
	 * <ol>
	 * <li>global configuration object <code>window["sap-ui-config"]</code>
	 * <li><code>data-sap-ui-config</code> attribute of the bootstrap script tag
	 * <li>other <code>data-sap-ui-<i>xyz</i></code> attributes of the bootstrap tag
	 * </ol>
	 */
	var oCfgData = _window["sap-ui-config"] = (function() {

		function normalize(o) {
			jQuery.each(o, function(i, v) {
				var il=i.toLowerCase();
				if ( !o.hasOwnProperty(il) ) {
					o[il] = v;
					delete o[i];
				}
			});
			return o;
		}

		var oCfg = normalize(_window["sap-ui-config"] || {}),
			oScriptTag = _oBootstrap.tag;

		oCfg.resourceroots = oCfg.resourceroots || {};
		oCfg.themeroots = oCfg.themeroots || {};
		oCfg.resourceroots[''] = oCfg.resourceroots[''] || _oBootstrap.resourceRoot;

		oCfg['xx-loadallmode'] = /(^|\/)(sap-?ui5|[^\/]+-all).js([?#]|$)/.test(_oBootstrap.url);

		// if a script tag has been identified, collect its configuration info
		if ( oScriptTag ) {
			// evaluate the config attribute first - if present
			var sConfig = oScriptTag.getAttribute("data-sap-ui-config");
			if ( sConfig ) {
				try {
				  jQuery.extend(oCfg, normalize((new Function("return {" + sConfig + "};"))())); // TODO jQuery.parseJSON would be better but imposes unwanted restrictions on valid syntax
				} catch(e) {
				  // no log yet, how to report this error?
				  _earlyErrors.push("failed to parse data-sap-ui-config attribute: " + (e.message || e));
				}
			}

			// merge with any existing "data-sap-ui-" attributes
			jQuery.each(oScriptTag.attributes, function(i, attr) {
				var m = attr.name.match(/^data-sap-ui-(.*)$/);
				if ( m ) {
					// the following (deactivated) conversion would implement multi-word names like "resource-roots"
					m = m[1].toLowerCase(); // .replace(/\-([a-z])/g, function(s,w) { return w.toUpperCase(); })
					if ( m === 'resourceroots' ) {
						// merge map entries instead of overwriting map
						jQuery.extend(oCfg[m], jQuery.parseJSON(attr.value));
					} else if ( m === 'theme-roots' ) {
						// merge map entries, but rename to camelCase
						jQuery.extend(oCfg.themeroots, jQuery.parseJSON(attr.value));
					} else if ( m !== 'config' ) {
						oCfg[m] = attr.value;
					}
				}
			});
		}

		return oCfg;
	}());

	// check whether noConflict must be used...
	if ( oCfgData.noconflict === true || oCfgData.noconflict === "true"  || oCfgData.noconflict === "x" ) {
		jQuery.noConflict();
	}

	/**
	 * Root Namespace for the jQuery plug-in provided by SAP AG.
	 *
	 * @version 1.10.0
	 * @namespace
	 * @public
	 * @static
	 */
	jQuery.sap = {};

	// -------------------------- DEBUG LOCAL STORAGE -------------------------------------

	jQuery.sap.debug = function(bEnable) {
		if(!window.localStorage){
			return null;
		}
		
		function reloadHint(bUsesDbgSrc){
			alert("Usage of debug sources is " + (bUsesDbgSrc ? "on" : "off") + " now.\nFor the change to take effect, you need to reload the page.");
		};

		if (bEnable === true) {
			window.localStorage.setItem("sap-ui-debug", "X");
			reloadHint(true);
		} else if (bEnable === false) {
			window.localStorage.removeItem("sap-ui-debug");
			reloadHint(false);
		}

		return window.localStorage.getItem("sap-ui-debug") == "X";
	};

	// -------------------------- Logging -------------------------------------

	(function() {

		var FATAL=0, ERROR=1, WARNING=2, INFO=3, DEBUG=4, TRACE=5;

		/**
		 * Unique prefix for this instance of the core in a multi-frame environment.
		 */
		var sWindowName = (window.top == window) ? "" : "[" + window.location.pathname.split('/').slice(-1)[0] + "] ";
		// Note: comparison must use type coercion (==, not ===), otherwise test fails in IE

		/**
		 * The array that holds the log entries that have been recorded so far
		 */
		var aLog = [];

		/**
		 * Maximum log level to be recorded (per component).
		 */
		var mMaxLevel = { '' : ERROR };

		/**
		 * Registered listener to be informed about new log entries.
		 */
		var oListener = null;

		function pad0(i,w) { return ("000" + String(i)).slice(-w); }

		function level(sComponent) {
			return (!sComponent || isNaN(mMaxLevel[sComponent])) ? mMaxLevel[''] : mMaxLevel[sComponent];
		}
		
		function listener(){
			if(!oListener){
				oListener = {
					listeners: [],
					onLogEntry: function(oLogEntry){
						for(var i=0; i<oListener.listeners.length; i++){
							if(oListener.listeners[i].onLogEntry){
								oListener.listeners[i].onLogEntry(oLogEntry);
							}
						}
					},
					attach: function(oLogger, oLstnr){
						if(oLstnr){
							oListener.listeners.push(oLstnr);
							if(oLstnr.onAttachToLog){
								oLstnr.onAttachToLog(oLogger);
							}
						}
					},
					detach: function(oLogger, oLstnr){
						for(var i=0; i<oListener.listeners.length; i++){
							if(oListener.listeners[i] === oLstnr){
								if(oLstnr.onDetachFromLog){
									oLstnr.onDetachFromLog(oLogger);
								}
								oListener.listeners.splice(i,1);
								return;
							}
						}
					}
				};
			}
			return oListener;
		}

		/**
		 * Creates a new log entry depending on its level and component.
		 *
		 * If the given level is higher than the max level for the given component
		 * (or higher than the global level, if no component is given),
		 * then no entry is created.
		 */
		function log(iLevel, sMessage, sDetails, sComponent) {
			if (iLevel <= level(sComponent) ) {
				var oNow = new Date(),
					oLogEntry = {
						time     : pad0(oNow.getHours(),2)+":"+pad0(oNow.getMinutes(),2)+":"+pad0(oNow.getSeconds(),2),
						date     : pad0(oNow.getFullYear(),4) + "-" + pad0(oNow.getMonth()+1,2) + "-" + pad0(oNow.getDate(),2),
						timestamp: oNow.getTime(),
						level    : iLevel,
						message  : sMessage || "",
						details  : sDetails || "",
						component: sComponent || ""
					};
				aLog.push( oLogEntry );
				if (oListener) {
					oListener.onLogEntry(oLogEntry);
				}

				/*
				 * Console Log, also tries to log to the window.console, if available.
				 *
				 * Unfortunately, the support for window.console is quite different between the UI5 browsers. The most important differences are:
				 * - in IE (checked until IE9), the console object does not exist in a window, until the developer tools are opened for that window.
				 *   After opening the dev tools, the console remains available even when the tools are closed again. Only using a new window (or tab)
				 *   restores the old state without console.
				 *   When the console is available, it provides most standard methods, but not debug and trace
				 * - in FF3.6 the console is not available, until FireBug is opened. It disappears again, when fire bug is closed.
				 *   But when the settings for a web site are stored (convenience), the console remains open
				 *   When the console is available, it supports all relevant methods
				 * - in FF9.0, the console is always available, but method assert is only available when firebug is open
				 * - in Webkit browsers, the console object is always available and has all required methods
				 *   - Exception: in the iOS Simulator, console.info() does not exist
				 */
				if (window.console) { // in IE and FF, console might not exist; in FF it might even disappear
					var logText = oLogEntry.date + " " + oLogEntry.time + " " + sWindowName + oLogEntry.message + " - " + oLogEntry.details + " " + oLogEntry.component;
					switch(iLevel) {
					case FATAL:
					case ERROR: console.error(logText); break;
					case WARNING: console.warn(logText); break;
					case INFO: console.info ? console.info(logText) : console.log(logText); break;    // info not available in iOS simulator
					case DEBUG: console.debug ? console.debug(logText) : console.log(logText); break; // debug not available in IE, fallback to log
					case TRACE: console.trace ? console.trace(logText) : console.log(logText); break; // trace not available in IE, fallback to log (no trace)
					}
				}
				return oLogEntry;
			}
		}

		/**
		 * @class A Logger class
		 * @param sDefaultComponent
		 * @name jQuery.sap.log.Logger
		 * @since 1.1.2
		 * @public
		 */
		function Logger(sDefaultComponent) {

			/**
			 * Creates a new fatal-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log instance for method chaining
			 * @name jQuery.sap.log.Logger#fatal
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.fatal = function (sMessage, sDetails, sComponent) {
				log(FATAL, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};

			/**
			 * Creates a new error-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log instance
			 * @name jQuery.sap.log.Logger#error
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.error = function error(sMessage, sDetails, sComponent) {
				log(ERROR, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};

			/**
			 * Creates a new warning-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log instance
			 * @name jQuery.sap.log.Logger#warning
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.warning = function warning(sMessage, sDetails, sComponent) {
				log(WARNING, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};
			/**
			 * Creates a new info-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log instance
			 * @name jQuery.sap.log.Logger#info
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.info = function info(sMessage, sDetails, sComponent) {
				log(INFO, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};
			/**
			 * Creates a new debug-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log instance
			 * @name jQuery.sap.log.Logger#debug
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.debug = function debug(sMessage, sDetails, sComponent) {
				log(DEBUG, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};
			/**
			 * Creates a new trace-level entry in the log with the given message, details and calling component.
			 *
			 * @param {string} sMessage Message text to display
			 * @param {string} [sDetails=""] Details about the message, might be omitted
			 * @param {string} [sComponent=""] Name of the component that produced the log entry
			 * @return {jQuery.sap.log.Logger} The log-instance
			 * @name jQuery.sap.log.Logger#trace
			 * @function
			 * @public
			 * @SecSink {0 1 2|SECRET} Could expose secret data in logs
			 */
			this.trace = function trace(sMessage, sDetails, sComponent) {
				log(TRACE, sMessage, sDetails, sComponent || sDefaultComponent);
				return this;
			};

			/**
			 * Defines the maximum jQuery.sap.log.Level of log entries that will be recorded.
			 * Log entries with a higher (less important) log level will be omitted from the log.
			 * When a component name is given, the log level will be configured for that component
			 * only, otherwise the log level for the default component of this logger is set.
			 * For the global logger, the global default level is set.
			 *
			 * <b>Note</b>: Setting a global default log level has no impact on already defined
			 * component log levels. They always override the global default log level.
			 *
			 * @param {jQuery.sap.log.Level} iLogLevel
			 * @param {string} [sComponent] The log component to set the log level for.
			 * @return {jQuery.sap.log} The global logger to allow method chaining
			 * @name jQuery.sap.log.Logger#setLevel
			 * @function
			 * @public
			 */
			this.setLevel = function setLevel(iLogLevel, sComponent) {
				sComponent = sComponent || sDefaultComponent || '';
				mMaxLevel[sComponent] = iLogLevel;
				var mBackMapping = [];
				jQuery.each(jQuery.sap.log.LogLevel, function(idx, v){
					mBackMapping[v] = idx;
				});
				log(INFO, "Changing log level " + (sComponent ? "for '" + sComponent + "' " : "") + "to " + mBackMapping[iLogLevel], "", "jQuery.sap.log");
				return this;
			};

			/**
			 * Returns the log level currently effective for the given component.
			 * If no component is given or when no level has been configured for a
			 * given component, the log level for the default component of this logger is returned.
			 *
			 * @param {string} [sComponent] Name of the component to retrieve the log level for
			 * @return {int} The log level for the given component or the default log level
			 * @name jQuery.sap.log.Logger#getLevel
			 * @function
			 * @public
			 * @since 1.1.2
			 */
			this.getLevel = function getLevel(sComponent) {
				return level(sComponent || sDefaultComponent);
			};

		}

		/**
		 * A Logging API for JavaScript.
		 *
		 * Provides methods to manage a client-side log and to create entries in it. Each of the logging methods
		 * {@link jQuery.sap.log.#debug}, {@link jQuery.sap.log.#info}, {@link jQuery.sap.log.#warning},
		 * {@link jQuery.sap.log.#error} and {@link jQuery.sap.log.#fatal} creates and records a log entry,
		 * containing a timestamp, a log level, a message with details and a component info.
		 * The log level will be one of {@link jQuery.sap.log.Level} and equals the name of the concrete logging method.
		 *
		 * By using the {@link jQuery.sap.log#setLevel} method, consumers can determine the least important
		 * log level which should be recorded. Less important entries will be filtered out. (Note that higher numeric
		 * values represent less important levels). The initially set level depends on the mode that UI5 is running in.
		 * When the optimized sources are executed, the default level will be {@link jQuery.sap.log.Level.ERROR}.
		 * For normal (debug sources), the default level is {@link jQuery.sap.log.Level.DEBUG}.
		 *
		 * All logging methods allow to specify a <b>component</b>. These components are simple strings and
		 * don't have a special meaning to the UI5 framework. However they can be used to semantically group
		 * log entries that belong to the same software component (or feature). There are two APIs that help
		 * to manage logging for such a component. With <code>{@link jQuery.sap.log.getLogger}(sComponent)</code>,
		 * one can retrieve a logger that automatically adds the given <code>sComponent</code> as component
		 * parameter to each log entry, if no other component is specified. Typically, JavaScript code will
		 * retrieve such a logger once during startup and reuse it for the rest of its lifecycle.
		 * Second, the {@link jQuery.sap.log.Logger#setLevel}(iLevel, sComponent) method allows to set the log level
		 * for a specific component only. This allows a more fine granular control about the created logging entries.
		 * {@link jQuery.sap.log.Logger.getLevel} allows to retrieve the currently effective log level for a given
		 * component.
		 *
		 * {@link jQuery.sap.log#getLog} returns an array of the currently collected log entries.
		 *
		 * Furthermore, a listener can be registered to the log. It will be notified whenever a new entry
		 * is added to the log. The listener can be used for displaying log entries in a separate page area,
		 * or for sending it to some external target (server).
		 *
		 * @author SAP AG
		 * @since 0.9.0
		 * @namespace
		 * @public
		 * @borrows jQuery.sap.log.Logger#fatal as this.fatal
		 * @borrows jQuery.sap.log.Logger#error as this.error
		 * @borrows jQuery.sap.log.Logger#warning as this.warning
		 * @borrows jQuery.sap.log.Logger#info as this.info
		 * @borrows jQuery.sap.log.Logger#debug as this.debug
		 * @borrows jQuery.sap.log.Logger#trace as this.trace
		 * @borrows jQuery.sap.log.Logger#getLevel as this.getLevel
		 * @borrows jQuery.sap.log.Logger#setLevel as this.setLevel
		 */
		jQuery.sap.log = jQuery.extend(new Logger(), /** @lends jQuery.sap.log */ {

			/**
			 * Enumeration of the configurable log levels that a Logger should persist to the log.
			 *
			 * Only if the current LogLevel is higher than the level {@link jQuery.sap.log.Level} of the currently added log entry,
			 * then this very entry is permanently added to the log. Otherwise it is ignored.
			 * @see jQuery.sap.log.Logger#setLevel
			 * @namespace
			 * @public
			 */
			Level : {

				/**
				 * Do not log anything
				 * @public
				 */
				NONE : FATAL-1,

				/**
				 * Fatal level. Use this for logging unrecoverable situations
				 * @public
				 */
				FATAL : FATAL,

				/**
				 * Error level. Use this for logging of erroneous but still recoverable situations
				 * @public
				 */
				ERROR : ERROR,

				/**
				 * Warning level. Use this for logging unwanted but foreseen situations
				 * @public
				 */
				WARNING : WARNING,

				/**
				 * Info level. Use this for logging information of purely informative nature
				 * @public
				 */
				INFO : INFO,

				/**
				 * Debug level. Use this for logging information necessary for debugging
				 * @public
				 */
				DEBUG : DEBUG,

				/**
				 * Trace level. Use this for tracing the program flow.
				 * @public
				 */
				TRACE : TRACE, /* TODO Think about changing to 10 and thus to pull out of logging... -> Make tracing explicit */

				/**
				 * Trace level to log everything.
				 */
				ALL : (TRACE + 1) /* TODO if TRACE is changed to make sure this is 6 again. There would then be some special TRACE handling. */
			},

			/**
			 * Returns a {@link jQuery.sap.log.Logger} for the given component.
			 *
			 * The method might or might not return the same logger object across multiple calls.
			 * While loggers are assumed to be light weight objects, consumers should try to
			 * avoid redundant calls and instead keep references to already retrieved loggers.
			 *
			 * @param {string} sComponent Component to create the logger for
			 * @return {jQuery.sap.log.Logger} A logger for the component.
			 * @public
			 * @static
			 * @since 1.1.2
			 */
			getLogger : function(sComponent) {
				return new Logger(sComponent);
			},

			/**
			 * Returns the logged entries recorded so far as an array.
			 *
			 * Log entries are plain JavaScript objects with the following properties
			 * <ul>
			 * <li>timestamp {number} point in time when the entry was created
			 * <li>level {int} LogLevel level of the entry
			 * <li>message {string} message text of the entry
			 * </ul>
			 *
			 * @return {object[]} an array containing the recorded log entries
			 * @public
			 * @static
			 * @since 1.1.2
			 */
			getLogEntries : function () {
				return aLog.slice();
			},
			
			/**
			 * Allows to add a new LogListener that will be notified for new log entries.
			 * The given object must provide method <code>onLogEntry</code> and can also be informed
			 * about <code>onDetachFromLog</code> and <code>onAttachToLog</code>
			 * @param {object} oListener The new listener object that should be informed
			 * @return {jQuery.sap.log} The global logger
			 * @public
			 * @static
			 */
			addLogListener : function(oListener) {
				listener().attach(this, oListener);
				return this;
			},
			
			/**
			 * Allows to remove a registered LogListener.
			 * @param {object} oListener The new listener object that should be removed
			 * @return {jQuery.sap.log} The global logger
			 * @public
			 * @static
			 */
			removeLogListener : function(oListener) {
				listener().detach(this, oListener);
				return this;
			}
			
		});

		/**
		 * Deprecated duplicate of {@link jQuery.sap.log.Level}.
		 * @deprecated Since 1.1.2. To streamline the Logging API a bit, the separation between Level and LogLevel has been given up.
		 * Use the (enriched) enumeration {@link jQuery.sap.log.Level} instead.
		 * @namespace Enumeration of levels that can be used in a call to {@link jQuery.sap.log.Logger#setLevel}(iLevel, sComponent).
		 * @public
		 */
		jQuery.sap.log.LogLevel = jQuery.sap.log.Level;

		/**
		 * Retrieves the currently recorded log entries.
		 * @deprecated Since 1.1.2. To avoid confusion with getLogger, this method has been renamed to {@link jQuery.sap.log.getLogEntries}.
		 * @function
		 * @public
		 * @static
		 */
		jQuery.sap.log.getLog = jQuery.sap.log.getLogEntries;

		/**
		 * A simple assertion mechanism that logs a message when a given condition is not met.
		 *
		 * <b>Note:</b> Calls to this method might be removed when the JavaScript code
		 *              is optimized during build. Therefore, callers should not rely on any side effects
		 *              of this method.
		 *
		 * @public
		 * @static
		 * @SecSink {1|SECRET} Could expose secret data in logs
		 */
		jQuery.sap.assert = function(bResult, sMessage) {
			if( !bResult ) {
				if ( window.console && console.assert ) {
					console.assert(bResult, sWindowName + sMessage);
				} else {
					// console is not always available (IE, FF) and IE doesn't support console.assert
					jQuery.sap.log.debug("[Assertions] " + sMessage);
				}
			}
		};

		// against all our rules: use side effect of assert to differentiate between optimized and productive code
		jQuery.sap.assert( !!(mMaxLevel[''] = DEBUG), "will be removed in optimized version");
		// evaluate configuration
		oCfgData.loglevel = oCfgData.loglevel || (function() { var m=/(?:\?|&)sap-ui-log(?:L|-l)evel=([^&]*)/.exec(window.location.search); return m && m[1];}());
		if ( oCfgData.loglevel ) {
			jQuery.sap.log.setLevel(jQuery.sap.log.Level[oCfgData.loglevel.toUpperCase()] || parseInt(oCfgData.loglevel,10));
		}

		jQuery.sap.log.info("SAP Logger started.");
		// log early errors
		jQuery.each(_earlyErrors, function(i,e) { jQuery.sap.log.error(e); }); _earlyErrors = null;


	}());

	// ---------------------------------------------------------------------------------------------------

	/**
	 * Returns a new constructor function that creates objects with
	 * the given prototype.
	 *
	 * @return {function} the newly created constructor function
	 * @public
	 * @static
	 */
	jQuery.sap.factory = function factory(oPrototype) {
		function Factory() {}
		Factory.prototype = oPrototype;
		return Factory;
	};

	/**
	 * Returns a new object which has the given oPrototype as its prototype.
	 *
	 * If several objects with the same prototype are to be created,
	 * {@link jQuery.sap.factory} should be used instead.
	 *
	 * @public
	 * @static
	 */
	jQuery.sap.newObject = function newObject(oPrototype) {
		return new (jQuery.sap.factory(oPrototype))();
	};

	/**
	 * Returns a new function that returns the given <code>oValue</code> (using its closure).
	 *
	 * Avoids the need for a dedicated member for the value.
	 *
	 * As closures don't come for free, this function should only be used when polluting
	 * the enclosing object is an absolute "must-not" (as it is the case in public base classes).
	 *
	 * @public
	 * @static
	 */
	jQuery.sap.getter = function getter(oValue) {
		return function() {
			return oValue;
		};
	};

	/**
	 * Returns a JavaScript object which is identified by a sequence of names.
	 *
	 * A call to <code>getObject("a.b.C")</code> has essentially the same effect
	 * as accessing <code>window.a.b.C</code> but with the difference that missing
	 * intermediate objects (a or b in the example above) don't lead to an exception.
	 *
	 * When the addressed object exists, it is simply returned. If it doesn't exists,
	 * the behavior depends on the value of the second, optional parameter
	 * <code>iNoCreates</code> (assuming 'n' to be the number of names in the name sequence):
	 * <ul>
	 * <li>NaN: if iNoCreates is not a number and the addressed object doesn't exist,
	 *          then <code>getObject()</code> returns <code>undefined</code>.
	 * <li>0 &lt; iNoCreates &lt; n: any non-existing intermediate object is created, except
	 *          the <i>last</i> <code>iNoCreates</code> ones.
	 * </ul>
	 *
	 * Example:
	 * <pre>
	 *   getObject()            -- returns the context object (either param or window)
	 *   getObject("a.b.C")     -- will only try to get a.b.C and return undefined if not found.
	 *   getObject("a.b.C", 0)  -- will create a, b, and C in that order if they don't exists
	 *   getObject("a.b.c", 1)  -- will create a and b, but not C.
	 * </pre>
	 *
	 * When a <code>oContext</code> is given, the search starts in that object.
	 * Otherwise it starts in the <code>window</code> object that this plugin
	 * has been created in.
	 *
	 * Note: Although this method internally uses <code>object["key"]</code> to address object
	 *       properties, it does not support all possible characters in a name.
	 *       Especially the dot ('.') is not supported in the individual name segments,
	 *       as it is always interpreted as a name separator.
	 *
	 * @param {string} sName  a dot separated sequence of names that identify the required object
	 * @param {int}    [iNoCreates=NaN] number of objects (from the right) that should not be created
	 * @param {object} [oContext=window] the context to execute the search in
	 *
	 * @public
	 * @static
	 */
	jQuery.sap.getObject = function getObject(sName, iNoCreates, oContext) {
		var oObject = oContext || _window,
			aNames = (sName || "").split("."),
			l = aNames.length,
			iEndCreate = isNaN(iNoCreates) ? 0 : l - iNoCreates,
			i;

		for (i=0; oObject && i<l; i++) {
			if (!oObject[aNames[i]] && i<iEndCreate ) {
				oObject[aNames[i]] = {};
			}
			oObject = oObject[aNames[i]];
		}
		return oObject;

	};

	/**
	 * Sets an object property to a given value, where the property is
	 * identified by a sequence of names (path).
	 *
	 * When a <code>oContext</code> is given, the path starts in that object.
	 * Otherwise it starts in the <code>window</code> object that this plugin
	 * has been created for.
	 *
	 * Note: Although this method internally uses <code>object["key"]</code> to address object
	 *       properties, it does not support all possible characters in a name.
	 *       Especially the dot ('.') is not supported in the individual name segments,
	 *       as it is always interpreted as a name separator.
	 *
	 * @param {string} sName  a dot separated sequence of names that identify the property
	 * @param {any}    vValue value to be set, can have any type
	 * @param {object} [oContext=window] the context to execute the search in
	 * @public
	 * @static
	 */
	jQuery.sap.setObject = function (sName, vValue, oContext) {
		var oObject = oContext || _window,
			aNames = (sName || "").split("."),
			l = aNames.length, i;

		if ( l>0 ) {
			for (i=0; oObject && i<l-1; i++) {
				if (!oObject[aNames[i]] ) {
					oObject[aNames[i]] = {};
				}
				oObject = oObject[aNames[i]];
			}
			oObject[aNames[l-1]] = vValue;
		}
	};

	// ---------------------- sync point -------------------------------------------------------------
	
	/*
	 * Internal class that can help to synchronize a set of asynchronous tasks.
	 * Each task must be registered in the sync point by calling startTask with 
	 * an (purely informative) title. The returned value must be used in a later 
	 * call to finishTask. 
	 * When finishTask has been called for all tasks that have been started, 
	 * the fnCallback will be fired. 
	 * When a timeout is given and reached, the callback is called at that 
	 * time, no matter whether all tasks have been finished or not. 
	 */
	function SyncPoint(sName, fnCallback, iTimeout) {
		var aTasks = [],
			iOpenTasks = 0,
			iFailures = 0,
			sTimer;

		this.startTask = function(sTitle) {
			var iId = aTasks.length;
			aTasks[iId] = { name : sTitle, finished : false };
			iOpenTasks++;
			return iId;
		};
		
		this.finishTask = function(iId, bSuccess) {
			if ( !aTasks[iId] || aTasks[iId].finished ) {
				throw new Error("trying to finish non existing or already finished task");
			}
			aTasks[iId].finished = true;
			iOpenTasks--;
			if ( bSuccess === false ) {
				iFailures++;
			}
			if (iOpenTasks === 0 ) {
				jQuery.sap.log.info("Sync point '" + sName + "' finished (tasks:" + aTasks.length + ", open:" + iOpenTasks + ", failures:" + iFailures + ")");
				if ( sTimer ) {
					clearTimeout(sTimer);
					sTimer = null;
				};
				finish();
			}
		};

		function finish() {
			fnCallback && fnCallback(iOpenTasks, iFailures);
			fnCallback = null;
		}
		
		if ( !isNaN(iTimeout) ) {
			sTimer = setTimeout(function() {
				jQuery.sap.log.info("Sync point '" + sName + "' timed out (tasks:" + aTasks.length + ", open:" + iOpenTasks + ", failures:" + iFailures + ")");
				finish();
			}, iTimeout);
		};
		
		jQuery.sap.log.info("Sync point '" + sName + "' created" + (iTimeout ? "(timeout after " + iTimeout + " ms)" : ""));
		
	}
	
	/**
	 * Internal function to create a sync point.
	 * @private
	 */
	jQuery.sap.syncPoint = function(sName, fnCallback, iTimeout) {
		return new SyncPoint(sName, fnCallback, iTimeout);
	}
	
	// ---------------------- require/declare --------------------------------------------------------

	/**
	 * A map of URL prefixes keyed by the corresponding module name prefix.
	 * @see jQuery.sap.registerModulePath
	 *
	 * Note that the empty prefix ('') will always match and thus serves as a fallback.
	 */
	var mUrlPrefixes = { '' : 'resources/' };

	// take resource roots from configuration
	if ( oCfgData.resourceroots ) {
		jQuery.extend(true, mUrlPrefixes, oCfgData.resourceroots);
	}

	// dump the URL prefixes
	jQuery.sap.log.info("URL prefixes set to:");
	for(var n in mUrlPrefixes) {
		jQuery.sap.log.info("  " + (n ? "'" + n + "'" : "(default)") + " : " + mUrlPrefixes[n]);
	}

	// find prefix for module name
	var _getModulePath = function _getModulePath(sModuleName, sSuffix) {

		// split name into segments
		var aSegments = sModuleName.split(/\./);

		// search for a defined name prefix, starting with the full name and successively removing one segment
		for(var l=aSegments.length; l>=0; l--) {
			var sNamePrefix = aSegments.slice(0, l).join('.');
			if ( mUrlPrefixes[sNamePrefix] ) {
				var sResult = mUrlPrefixes[sNamePrefix];
				if ( l < aSegments.length ) {
					sResult += aSegments.slice(l).join("/");
				}
				if ( sResult.slice(-1) === '/' ) {
					sResult = sResult.slice(0, -1);
				}
				return sResult + (sSuffix || '');
			}
		}

		jQuery.sap.assert(false, "should never happen");
	};

	/* ==== Begin of HACK ==== */
	// this HACK wraps the _getModulePath function to implement some special handling
	// for the jquery.sap. modules, which contain a dot in their name
	var _HACK_orig_getModulePath = _getModulePath;
	var _getModulePath = function HACK_modified_getModulePath(sModuleName, sSuffix) {
		if ( sModuleName.indexOf("jquery.sap.") === 0 ) {
			sModuleName = sModuleName.replace(/\./gi, "%2E");
			var sPath = _HACK_orig_getModulePath(sModuleName, sSuffix);
			return sPath.replace(/%2E/gi, ".");
		}
		return _HACK_orig_getModulePath(sModuleName, sSuffix);
	};
	/* ==== End of HACK ==== */

	/**
	 * Constructs an URL to load the module with the given name and file type (suffix).
	 *
	 * Searches the longest prefix of the given module name for which a registration
	 * exists (see {@link jQuery.sap.registerModulePath}) and replaces that prefix
	 * by the registered URL prefix.
	 *
	 * The remainder of the module name is appended to the URL, replacing any dot with a slash.
	 *
	 * Finally, the given suffix (typically a file name extension) is added (unconverted).
	 *
	 * The returned name (without the suffix) doesn't end with a slash.
	 *
	 * @public
	 * @static
	 */
	jQuery.sap.getModulePath = function(sModuleName, sSuffix) {
		return _getModulePath(sModuleName, sSuffix);
	};

	/**
	 * Registers an URL prefix for a module name prefix.
	 *
	 * Before a module is loaded, the longest registered prefix of its module name
	 * is searched for and the associated URL prefix is used as a prefix for the request URL.
	 * The remainder of the module name is attached to the request URL by replacing
	 * dots ('.') with slashes ('/').
	 *
	 * The registration and search operates on full name segments only. So when a prefix
	 *
	 *    'sap.com'  ->  'http://www.sap.com/ui5/resources/'
	 *
	 * is registered, then it will match the name
	 *
	 *    'sap.com.Button'
	 *
	 * but not
	 *
	 *    'sap.commons.Button'
	 *
	 * Note that the empty prefix ('') will always match and thus serves as a fallback for
	 * any search.
	 *
	 * @public
	 * @static
	 * @SecSink {1|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.registerModulePath = function registerModulePath(sModuleName, sUrlPrefix) {
		// must not be empty
		sUrlPrefix = sUrlPrefix || '.';

		// ensure that the prefix ends with a '/'
		if ( sUrlPrefix.slice(-1) != '/' ) {
			sUrlPrefix += '/';
		}

		mUrlPrefixes[sModuleName] = sUrlPrefix;

		jQuery.sap.log.info("sap.registerModulePath ('" + sModuleName + "', '" + sUrlPrefix + "')");

	};


	/**
	 * Set of modules that have been loaded (required) so far
	 * @private
	 */
	var mModules = {};

	// make the module loading more verbose
	var _verbose = false; // not yet configurable as Url params are not available here... oCfgData.debug === true || oCfgData.debug === "true" || oCfgData.debug === "x";

	/**
	 * Stack of modules that are currently executed.
	 * Allows to identify the containing module in case of multi module files (e.g. sap-ui-core)
	 */
	var _execStack = [ ];
	var sLogPrefix = "";

	/**
	 * Check whether a given module has been loaded / declared already.
	 * 
	 * Returns true as soon as a module has been required the first time, even when 
	 * loading/executing it has not finished yet. So the main assertion of a  
	 * return value of <code>true</code> is that the necessary actions have been taken
	 * to make the module available in the near future. It does not mean, that 
	 * the content of the module is already available!
	 * 
	 * This fuzzy behavior is necessary to avoid multiple requests for the same module. 
	 * As a consequence of the assertion above, a <i>preloaded</i> module does not
	 * count as <i>declared</i>. For preloaded modules, an explicit call to 
	 * <code>jQuery.sap.require</code> is necessary to make them available. 
	 * 
	 * @param {string} sModuleName name of the module to be checked
	 * @return {boolean} whether the module has been declared already
	 * @public
	 * @static
	 */
	jQuery.sap.isDeclared = function isDeclared(sModuleName) {
		return mModules[sModuleName] && mModules[sModuleName].state !== "preloaded";
	};
	
	/**
	 * Returns the names of all declared modules.
	 * @return {string[]} the names of all declared modules
	 * @see jQuery.sap.isDeclared
	 * @public
	 * @static
	 */
	jQuery.sap.getAllDeclaredModules = function() {
		var aModules = [];
		jQuery.each(mModules, function(i,v) {
			// filter out preloaded modules
			if ( jQuery.sap.isDeclared(i) ) {
				aModules.push(i);
			}
		});
		return aModules;
	};

	/**
	 * Declares a module as existing.
	 *
	 * By default, this function assumes that the module will create a JavaScript object
	 * with the same name as the module. As a convenience it ensures that the parent
	 * namespace for that object exists (by calling jQuery.sap.getObject).
	 * If such an object creation is not desired, <code>bCreateNamespace</code> must be set to false.
	 *
	 * @param {string || object} sModuleName name of the module to be declared
	 *                           or in case of an object {modName: "...", type: "..."}
	 *                           where modName is the name of the module and the type
	 *                           could be a specific dot separated extension e.g.
	 *                           <code>{modName: "sap.ui.core.Dev", type: "view"}</code>
	 *                           loads <code>sap/ui/core/Dev.view.js</code> and
	 *                           registers as <code>sap.ui.core.Dev.view</code>
	 * @param {string} [bCreateNamespace=true] whether to create the parent namespace
	 *
	 * @public
	 * @static
	 */
	jQuery.sap.declare = function declare(sModuleName, bCreateNamespace) {
		if ( _verbose ) {
			jQuery.sap.log.debug(sLogPrefix + "sap.declare '" + sModuleName + "'");
		}

		// check for an object as parameter for sModuleName
		// in case of this the object contains the module name and the type
		// which could be {modName: "sap.ui.core.Dev", type: "view"}
		var sType = "";
		if (typeof(sModuleName) === "object") {
			sType = sModuleName.type ? "." + sModuleName.type : "";
			sModuleName = sModuleName.modName + sType;
		}

		if ( !jQuery.sap.isDeclared(sModuleName) ) {
			if ( !mModules[sModuleName] ) {
				mModules[sModuleName] = { };
			}
			mModules[sModuleName].state = 'ready';
		}

		// identify the bootstrap module
		// Note: this is only a guess and fails e.g. when multiple modules are loaded via a script tag
		// to make it safe, we could convert 'declare' calls to e.g. 'subdeclare' calls at build time.
		if ( _execStack.length === 0 && sModuleName !== "jquery.sap.global" ) {
			_execStack.push(sModuleName);
			mModules[sModuleName].url = mModules[sModuleName].url || _sBootstrapUrl;
		}

		// remember parent module if any
		if ( !mModules[sModuleName].parent ) {
		  mModules[sModuleName].parent = _execStack[_execStack.length-1];
		}

		// ensure parent namespace even if module was declared already
		// (as declare might have been called by require)
		if (bCreateNamespace !== false) {
			// ensure parent namespace
			jQuery.sap.getObject(sModuleName, 1);
		}

		return this;
	};

	function requireModule(sModuleName) {

		// handle multiple imports
		if ( arguments.length > 1 ) {
			for(var i=0; i<arguments.length; i++) {
				jQuery.sap.require(arguments[i]);
			}
			return this;
		}

		// check for an object as parameter for sModuleName
		// in case of this the object contains the module name and the type
		// which could be {modName: "sap.ui.core.Dev", type: "view"}
		var sType = "";
		if (typeof(sModuleName) === "object") {
			sType = sModuleName.type ? "." + sModuleName.type : "";
			sModuleName = sModuleName.modName + sType;
		}

		if ( _verbose ) {
			jQuery.sap.log.debug(sLogPrefix + "require '" + sModuleName + "' of type '" + sType + "'");
		}

		// check if module has been loaded already
		if ( mModules[sModuleName] ) {
			if ( mModules[sModuleName].state === 'preloaded' ) {
				mModules[sModuleName].state = 'loaded';
				execModule(sModuleName);
			}

			if ( mModules[sModuleName].state === 'ready' ) {
				if ( _verbose ) {
					jQuery.sap.log.debug("module '" + sModuleName + "' has already been loaded (skipped).");
				}
				return this;
			} else if ( mModules[sModuleName].state === 'failed' ) {
				throw new Error("found in negative cache: '" + sModuleName+  "' from " + mModules[sModuleName].url + ": " + mModules[sModuleName].error);
			} else {
				// currently loading
				return this;
			}
		}

		// set marker for loading modules (to break cycles)
		var mod = mModules[sModuleName] = { state: 'loading' };

		// in case of having a type specified ignore the type for the module path creation and add it as file extension
		var sBaseName = sType ? sModuleName.substring(0, sModuleName.length - sType.length) : sModuleName;

		// if debug is enabled, try to load debug module first
		if (window["sap-ui-loaddbg"]) {
			// create module URL for the debug version
			mod.url = jQuery.sap.getModulePath(sBaseName + "-dbg", sType + '.js');
			if ( _verbose ) {
				jQuery.sap.log.debug("loading debug version of '" + sModuleName + "' from '" + mod.url + "'");
			}
			jQuery.ajax({
				url : mod.url,
				dataType : 'text',
				async : false,
				success : function(response, textStatus, xhr) {
					mod.state = 'loaded';
					mod.data = response;
				},
				error : function(xhr, textStatus, error) {
					mod.state = 'failed';
					mod.error = xhr ? xhr.status + " - " + xhr.statusText : textStatus;
				}
			});
		}

		// try to load the module, if debug was not enabled/not successful
		if ( mod.state !== 'loaded' ) {
			// create module URL
			mod.url = jQuery.sap.getModulePath(sBaseName, sType + '.js');
			if ( _verbose ) {
				jQuery.sap.log.debug("loading '" + sModuleName + "' from '" + mod.url + "'");
			}
			jQuery.ajax({
				url : mod.url,
				dataType : 'text',
				async : false,
				success : function(response, textStatus, xhr) {
					mod.state = 'loaded';
					mod.data = response;
				},
				error : function(xhr, textStatus, error) {
					mod.state = 'failed';
					mod.error = xhr ? xhr.status + " - " + xhr.statusText : textStatus;
				}
			});
		}

		// execute module __after__ loading it, this reduces the required stack space!
		if ( mod.state === 'loaded' ) {
			execModule(sModuleName);
		}

		if ( mod.state !== 'ready' ) {
			throw new Error("failed to load '" + sModuleName+  "' from " + mod.url + ": " + mod.error);
		}

		return this;

	}

	// max size a script should have when executing it with execScript (IE). Otherwise fallback to eval
	var MAX_EXEC_SCRIPT_LENGTH = 512*1024;
	
	function execModule(sModuleName) {

		var mod = mModules[sModuleName];

		if ( mod && mod.state === 'loaded' && typeof mod.data !== "undefined" ) {
			try {

				if ( _verbose ) {
					var oldPrefix = sLogPrefix;
					sLogPrefix = sLogPrefix + "  ";
					jQuery.sap.log.debug(sLogPrefix + "executing '" + sModuleName + "'");
				}

				// execute the script in the window context
				mod.state = 'executing';
				_execStack.push(sModuleName);
				if (_window.execScript && (!mod.data || mod.data.length < MAX_EXEC_SCRIPT_LENGTH) ) { 
					try {
						mod.data && _window.execScript(mod.data); // execScript fails if data is empty
					} catch (e) {
						_execStack.pop();
						// eval again with different approach - should fail with a more informative exception
						jQuery.sap.globalEval(mod.data);
						throw e; // rethrow err in case globalEval succeeded unexpectedly
					}
				} else {
					_window.eval(mod.data + "\r\n//@ sourceURL=" + mod.url); // Firebug and Safari debugging help, seems to cost ZERO performance
				}
				_execStack.pop();
				mod.state = 'ready';
				mod.data = undefined;
				if ( _verbose ) {
					jQuery.sap.log.debug(sLogPrefix + "finished executing '" + sModuleName + "'");
					sLogPrefix = oldPrefix;
				}

			} catch (err) {
				mod.state = 'failed';
				mod.error = ((err.toString && err.toString()) || err.message) + (err.line ? "(line " + err.line + ")" : "" );
				mod.data = undefined;
			}
		}
	}

	/**
	 * Ensures that the given module is loaded and executed before execution of the
	 * current script continues.
	 *
	 * By issuing a call to this method, the caller declares a dependency to the listed modules.
	 *
	 * Any required and not yet loaded script will be loaded and execute synchronously.
	 * Already loaded modules will be skipped.
	 *
	 * @param {string... || object} sModuleName one or more names of modules to be loaded
	 *                              or in case of an object {modName: "...", type: "..."}
	 *                              where modName is the name of the module and the type
	 *                              could be a specific dot separated extension e.g.
	 *                              <code>{modName: "sap.ui.core.Dev", type: "view"}</code>
	 *                              loads <code>sap/ui/core/Dev.view.js</code> and
	 *                              registers as <code>sap.ui.core.Dev.view</code>
	 *
	 * @public
	 * @static
	 * @function
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.require = requireModule;

	var mPreloadModules = {};
	
	jQuery.sap.preloadModules = function(sPreloadModule, bAsync, oSyncPoint) {
		
		jQuery.sap.assert(!bAsync ||oSyncPoint, "if mode is async, a syncpoint object must be given");
		
		if ( mPreloadModules[sPreloadModule] )
			return;

		mPreloadModules[sPreloadModule] = true;

		var sURL = jQuery.sap.getModulePath(sPreloadModule, ".json");
		
		jQuery.sap.log.debug("preload file " + sPreloadModule);
		var iTask = oSyncPoint && oSyncPoint.startTask("load " + sPreloadModule);
		jQuery.ajax({
			dataType : "json",
			async : bAsync,
			url : sURL,
			success : function(data) {
				if ( data ) {
					data.url = sURL;
				}
				jQuery.sap.registerPreloadedModules(data, bAsync, oSyncPoint);
				oSyncPoint && oSyncPoint.finishTask(iTask);
			},
			error : function(data) {
				oSyncPoint && oSyncPoint.finishTask(iTask, false);
			}
		});

	};
	
	jQuery.sap.registerPreloadedModules = function(oData, bAsync, oSyncPoint) {
		if ( _verbose ) {
			jQuery.sap.log.debug(sLogPrefix + "adding preloaded modules from '" + oData.url + "'");
		}
		jQuery.each(oData.modules, function(sName,sContent) {
			if ( !mModules[sName] ) {
				mModules[sName] = { state : 'preloaded', url : oData.url + "/" + sName, data : sContent };
			}
		});
		if ( oData.dependencies ) {
			jQuery.each(oData.dependencies, function(idx,sModuleName) {
				jQuery.sap.preloadModules(sModuleName, bAsync, oSyncPoint);
			});
		}
	};

	// declare our own module
	jQuery.sap.declare("jquery.sap.global", false);

	// --------------------- script and stylesheet handling --------------------------------------------------

	// appends a link object to the head
	function appendHead(oElement) {
		var head = window.document.getElementsByTagName("head")[0];
		if (head) {
			head.appendChild(oElement);
		}
	}

	/**
	 * Includes the script (via &lt;script&gt;-tag) into the head for the
	 * specified <code>sUrl</code> and optional <code>sId</code>.
	 *
	 * @param {string}
	 *            sUrl the URL of the script to load
	 * @param {string}
	 *            [sId] id that should be used for the script include tag
	 *
	 * @public
	 * @static
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.includeScript = function includeScript(sUrl, sId){
		var oScript = window.document.createElement("script");
		oScript.src = sUrl;
		oScript.type = "text/javascript";
		if (sId) {
			oScript.id = sId;
		}
		// jQuery("head").append(oScript) doesn't work because they filter for the script
		// and execute them directly instead adding the SCRIPT tag to the head
		appendHead(oScript);
	};

	/**
	 * Includes the specified stylesheet via a &lt;link&gt;-tag in the head of the current document.
	 * If there is call to <code>includeStylesheet</code> providing the sId of an already included stylesheet,
	 * the existing element will be replaced.
	 *
	 * @param {string} sUrl the URL of the script to load
	 * @param {string} [sId] id that should be used for the script include tag
	 *
	 * @public
	 * @static
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.includeStyleSheet = function includeStyleSheet(sUrl, sId){

		// create the new link element
		var oLink = document.createElement("link");
		oLink.type = "text/css";
		oLink.rel = "stylesheet";
		oLink.href = sUrl;
		if (sId) {
			oLink.id = sId;
		}

		// check for existence of the link
		var oOld, bReplace;
		if ((sId && (oOld = jQuery.sap.domById(sId)) && (bReplace = oOld.tagName === "LINK" && oOld.rel ==="stylesheet")) || window.document.body) {
			if (bReplace) {
				jQuery(oOld).replaceWith(oLink);
			} else {
				appendHead(oLink);
			}
		} else {
			appendHead(oLink);
		}

	};

	// TODO should be in core, but then the 'callback' could not be implemented
	if ( !(oCfgData.productive === true || oCfgData.productive === "true"  || oCfgData.productive === "x") ) {
		jQuery(function() {
			jQuery(document.body).keydown(function(e) {
				if ( e.keyCode == 80 && e.shiftKey && e.altKey && e.ctrlKey ) {
					try {
						jQuery.sap.require("sap.ui.debug.TechnicalInfo");
					} catch (e) {
						// alert("Sorry, failed to activate 'P'-mode!");
						return;
					}
					sap.ui.debug.TechnicalInfo.open(function() {
						return { modules : mModules, prefixes : mUrlPrefixes, config: oCfgData };
					});
				}
			});
		});
		
		jQuery(function() {
			jQuery(document.body).keydown(function(e) {
				if ( e.keyCode == 83 /*S*/ && e.shiftKey && e.altKey && e.ctrlKey ) { //TODO: Is this ok?
					try {
						jQuery.sap.require("sap.ui.core.support.Support");
						var oSupport = sap.ui.core.support.Support.getStub();
						if(oSupport.getType() != sap.ui.core.support.Support.StubType.APPLICATION){
							return;
						}
						oSupport.openSupportTool();
					} catch(e) {
					}
				}
			});
		});
	}

	// *********** feature detection, enriching jQuery.support *************
	// this might go into its own file once there is more stuff added

	if (!jQuery.support) {
		jQuery.support = {};
	}

	/**
	 * jQuery.support.flexBoxLayout is true if the current browser supports the OLD CSS3 Flexible Box Layout directly or via vendor prefixes
	 */
	if (jQuery.support.flexBoxLayout === undefined) {
		jQuery.support.flexBoxLayout =
			((document.documentElement.style.MozBoxFlex !== undefined) ||
				(document.documentElement.style.webkitBoxFlex !== undefined) ||
				(document.documentElement.style.boxFlex !== undefined));
	}

	/**
	 * jQuery.support.newFlexBoxLayout is true if the current browser supports the NEW CSS3 Flexible Box Layout directly or via vendor prefixes
	 */
	if (jQuery.support.newFlexBoxLayout === undefined) {
		jQuery.support.newFlexBoxLayout =
			((document.documentElement.style.MozFlex !== undefined) ||
				(document.documentElement.style.webkitFlex !== undefined) ||
				(document.documentElement.style.flex !== undefined));
	}

	// *********** fixes for (pending) jQuery bugs **********
	if (!jQuery.support.opacity) {
		(function() {
			// jQuery cssHook for setOpacity[IE8] doesn't properly cleanup the CSS filter property
			var oldSet = jQuery.cssHooks.opacity.set;
			jQuery.cssHooks.opacity.set = function( elem, value ) {
				oldSet.apply(this, arguments);
				if ( !jQuery.trim(elem.style.filter) ) {
					elem.style.removeAttribute("filter");
				}
			};
		}());
	}

	// *** Performance measure ***
	function PerfMeasurement(){

		function Measurement( sId, sInfo, iStart, iEnd ){
			this.id = sId;
			this.info = sInfo;
			this.start = iStart;
			this.end = iEnd;
			this.pause = 0;
			this.resume = 0;
			this.duration = 0; // used time
			this.time = 0; // time from start to end
		}

		var bActive = false;
		var fnAjax = jQuery.ajax;

		/**
		 * Gets the current state of the perfomance measurement functionality
		 *
		 * @return {boolean} current state of the perfomance measurement functionality
		 * @name jQuery.sap.measure#getActive
		 * @function
		 * @public
		 */
		this.getActive = function(){
			return bActive;
		};

		/**
		 * Activates or deactivates the performance measure functionality
		 *
		 * @param {boolean} bOn state of the perfomance measurement functionality to set
		 * @return {boolean} current state of the perfomance measurement functionality
		 * @name jQuery.sap.measure#setActive
		 * @function
		 * @public
		 */
		this.setActive = function( bOn ){

			if (bActive == bOn) {
				return bActive;
			}

			bActive = bOn;

			if (bActive){
				// redefine AJAX call
				jQuery.ajax = function( url, options ){
					jQuery.sap.measure.start(url.url, "Request for "+ url.url);
					fnAjax.apply(this,arguments);
					jQuery.sap.measure.end(url.url);
				};
			}else if(fnAjax){
				jQuery.ajax = fnAjax;
			}

			return bActive;

		};

		this.setActive(/sap-ui-measure=(true|x|X)/.test(location.search));

		this.mMeasurements = {};

		/**
		 * Starts a performance measure
		 *
		 * @param {string} sId ID of the measurement
		 * @param {string} sInfo Info for the measurement
		 * @return {object} current measurement containing id, info and start-timestamp (false if error)
		 * @name jQuery.sap.measure#start
		 * @function
		 * @public
		 */
		this.start = function( sId, sInfo ){
			if (!bActive) {
				return;
			}

			var iTime = new Date().getTime();
			var oMeasurement = new Measurement( sId, sInfo, iTime, 0);
//			jQuery.sap.log.info("Performance measurement start: "+ sId + " on "+ iTime);

			if (oMeasurement) {
				this.mMeasurements[sId] = oMeasurement;
				return({id: oMeasurement.id, info: oMeasurement.info, start: oMeasurement.start });
			}else{
				return false;
			}
		};

		/**
		 * Pauses a performance measure
		 *
		 * @param {string} sId ID of the measurement
		 * @return {object} current measurement containing id, info and start-timestamp, pause-timestamp (false if error)
		 * @name jQuery.sap.measure#pause
		 * @function
		 * @public
		 */
		this.pause = function( sId ){
			if (!bActive) {
				return;
			}

			var iTime = new Date().getTime();
			var oMeasurement = this.mMeasurements[sId];
			if(oMeasurement && oMeasurement.end > 0){
				// already ended -> no pause possible
				return false;
			}

			if (oMeasurement && oMeasurement.pause == 0) {
				// not already paused
				oMeasurement.pause = iTime;
				if (oMeasurement.pause >= oMeasurement.resume && oMeasurement.resume > 0) {
					oMeasurement.duration = oMeasurement.duration + oMeasurement.pause - oMeasurement.resume;
					oMeasurement.resume = 0;
				}else if (oMeasurement.pause >= oMeasurement.start) {
					oMeasurement.duration = oMeasurement.pause - oMeasurement.start;
				}
			}
//			jQuery.sap.log.info("Performance measurement pause: "+ sId + " on "+ iTime + " duration: "+ oMeasurement.duration);

			if (oMeasurement) {
				return({id: oMeasurement.id, info: oMeasurement.info, start: oMeasurement.start, pause: oMeasurement.pause });
			}else{
				return false;
			}
		};

		/**
		 * Resumes a performance measure
		 *
		 * @param {string} sId ID of the measurement
		 * @return {object} current measurement containing id, info and start-timestamp, resume-timestamp (false if error)
		 * @name jQuery.sap.measure#resume
		 * @function
		 * @public
		 */
		this.resume = function( sId ){
			if (!bActive) {
				return;
			}

			var iTime = new Date().getTime();
			var oMeasurement = this.mMeasurements[sId];
//			jQuery.sap.log.info("Performance measurement resume: "+ sId + " on "+ iTime + " duration: "+ oMeasurement.duration);

			if (oMeasurement && oMeasurement.pause > 0) {
				// already paused
				oMeasurement.pause = 0;
				oMeasurement.resume = iTime;
			}

			if (oMeasurement) {
				return({id: oMeasurement.id, info: oMeasurement.info, start: oMeasurement.start, resume: oMeasurement.resume });
			}else{
				return false;
			}
		};

		/**
		 * Ends a performance measure
		 *
		 * @param {string} sId ID of the measurement
		 * @return {object} current measurement containing id, info and start-timestamp, end-timestamp, time, duration (false if error)
		 * @name jQuery.sap.measure#end
		 * @function
		 * @public
		 */
		this.end = function( sId ){
			if (!bActive) {
				return;
			}

			var iTime = new Date().getTime();
			var oMeasurement = this.mMeasurements[sId];
//			jQuery.sap.log.info("Performance measurement end: "+ sId + " on "+ iTime);

			if (oMeasurement && !oMeasurement.end) {
				oMeasurement.end = iTime;
				if (oMeasurement.end >= oMeasurement.resume && oMeasurement.resume > 0) {
					oMeasurement.duration = oMeasurement.duration + oMeasurement.end - oMeasurement.resume;
					oMeasurement.resume = 0;
				}else if (oMeasurement.pause > 0) {
					// duration already calculated
					oMeasurement.pause = 0;
				}else if (oMeasurement.end >= oMeasurement.start) {
					oMeasurement.duration = oMeasurement.end - oMeasurement.start;
				}
				if (oMeasurement.end >= oMeasurement.start) {
					oMeasurement.time = oMeasurement.end - oMeasurement.start;
				}
			}

			if (oMeasurement) {
				return({id: oMeasurement.id,
					    info: oMeasurement.info,
					    start: oMeasurement.start,
					    end: oMeasurement.end,
					    time: oMeasurement.time,
					    duration: oMeasurement.duration});
			}else{
				return false;
			}
		};

		/**
		 * Gets a performance measure
		 *
		 * @param {string} sId ID of the measurement
		 * @return {object} current measurement containing id, info and start-timestamp, end-timestamp, time, duration (false if error)
		 * @name jQuery.sap.measure#getMeasurement
		 * @function
		 * @public
		 */
		this.getMeasurement = function( sId ){
			if (!bActive) {
				return;
			}

			var oMeasurement = this.mMeasurements[sId];

			if (oMeasurement) {
				return({id: oMeasurement.id,
						info: oMeasurement.info,
						start: oMeasurement.start,
						end: oMeasurement.end,
						time: oMeasurement.time,
						duration: oMeasurement.duration});
			}else{
				return false;
			}
		};

		/**
		 * Clears all performance measurements
		 *
		 * @return
		 * @name jQuery.sap.measure#clear
		 * @function
		 * @public
		 */
		this.clear = function( ){
			if (!bActive) {
				return;
			}

			this.mMeasurements = {};
			return;
		};

		/**
		 * Removes a performance measure
		 *
		 * @param {string} sId ID of the measurement
		 * @return
		 * @name jQuery.sap.measure#remove
		 * @function
		 * @public
		 */
		this.remove = function( sId ){
			if (!bActive) {
				return;
			}

			delete this.mMeasurements[sId];
			return;
		};

		/**
		 * Gets all performance measurements
		 *
		 * @return {object} [] current measurement containing id, info and start-timestamp, end-timestamp, time, duration (false if error)
		 * @name jQuery.sap.measure#getAllMeasurements
		 * @function
		 * @public
		 */
		this.getAllMeasurements = function( ){
			if (!bActive) {
				return;
			}

			var aMeasurements = new Array();

			jQuery.each(this.mMeasurements, function(sId, oMeasurement){
				aMeasurements.push({id: oMeasurement.id,
					                info: oMeasurement.info,
					                start: oMeasurement.start,
					                end: oMeasurement.end,
					                duration: oMeasurement.duration,
					                time: oMeasurement.time});
			});
			return aMeasurements;
		};

		/**
		 * Adds a performance measurement with all data 
		 * This is usefull to add external measurements (e.g. from a backend) to the common measurement UI
		 *
		 * @param {string} sId ID of the measurement
		 * @param {string} sInfo Info for the measurement
		 * @param {int} iStart start timestamp
		 * @param {int} iEnd end timestamp
		 * @param {int} iTime time in milliseconds
		 * @param {int} iDuration effective time in milliseconds
		 * @return {object} [] current measurement containing id, info and start-timestamp, end-timestamp, time, duration (false if error)
		 * @name jQuery.sap.measure#add
		 * @function
		 * @public
		 */
		this.add = function( sId, sInfo, iStart, iEnd, iTime, iDuration ){
			if (!bActive) {
				return;
			}

			var oMeasurement = new Measurement( sId, sInfo, iStart, iEnd);
			oMeasurement.time = iTime;
			oMeasurement.duration = iDuration;

			if (oMeasurement) {
				this.mMeasurements[sId] = oMeasurement;
				return({id: oMeasurement.id,
					    info: oMeasurement.info,
					    start: oMeasurement.start,
					    end: oMeasurement.end,
					    time: oMeasurement.time,
					    duration: oMeasurement.duration});
			}else{
				return false;
			}
		};
	}

	/**
	 * Namespace for the jQuery performance measurement plug-in provided by SAP AG.
	 *
	 * @namespace
	 * @name jQuery.sap.measure
	 * @public
	 * @static
	 */
	jQuery.sap.measure = new PerfMeasurement();

}());

/**
 * Executes an 'eval' for its arguments in the global context (without closure variables).
 *
 * This is a synchronous replacement for <code>jQuery.globalEval</code> which in some
 * browsers (e.g. FireFox) behaves asynchronously.
 *
 * @type void
 * @public
 * @static
 * @SecSink {0|XSS} Parameter is evaluated
 */
jQuery.sap.globalEval = function() {
	eval(arguments[0]);
};

jQuery.sap.declare('sap-ui-core');
jQuery.sap.declare('sap.ui.thirdparty.jquery.jquery-1.7.1'); // raw module, declared by SAPUI5 CreateModule Ant-Task
jQuery.sap.declare('sap.ui.thirdparty.jqueryui.jquery-ui-position'); // raw module, declared by SAPUI5 CreateModule Ant-Task
jQuery.sap.declare('jquery.sap.global'); // raw module, declared by SAPUI5 CreateModule Ant-Task
if ( !jQuery.sap.isDeclared('sap.ui.core.Core') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides the real core class sap.ui.core.Core of SAPUI5
jQuery.sap.declare("sap.ui.core.Core");

if ( !jQuery.sap.isDeclared('jquery.sap.dom') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides functionality related to DOM analysis and manipulation which is not provided by jQuery itself.
jQuery.sap.declare("jquery.sap.dom", false);

(function() {

	/**
	 * Shortcut for document.getElementById() with additionally an IE6/7 bug fixed.
	 * Used to replace the jQuery.sap.domById when running in IE < v8.
	 *
	 * @param {String} sId the id of the DOM element to return
	 * @param {window} oWindow the window (optional)
	 * @return {DOMNode} the DOMNode identified by the given sId
	 * @private
	 */
	var domByIdInternal = function(sId, oWindow) {

		if (!oWindow) {
			oWindow = window;
		}
		if (!sId || sId=="") {
			return null;
		}

		var oDomRef = oWindow.document.getElementById(sId);

		// IE also returns the element with the name or id whatever is first
		// => the following line makes sure that this was the id
		if (oDomRef && oDomRef.id == sId) {
			return oDomRef;
		}

		// otherwise try to lookup the name
		var oRefs = oWindow.document.getElementsByName(sId);
		for (var i=0;i<oRefs.length;i++) {
			oDomRef = oRefs[i];
			if (oDomRef && oDomRef.id == sId) {
				return oDomRef;
			}
		}

		return null;

	};

	/**
	 * Shortcut for document.getElementById(), including a bug fix for older IE versions.
	 *
	 * @param {String} sId The id of the DOM element to return
	 * @param {window} [oWindow=window] The window (optional)
	 * @return {DOMNode} The DOMNode identified by the given sId
	 * @public
	 * @function
	 * @since 0.9.0
	 */
	jQuery.sap.domById = jQuery.browser.msie && jQuery.browser.version < 8 ? domByIdInternal : function domById(sId, oWindow) {
		return sId ? (oWindow || window).document.getElementById(sId) : null;
	};


	/**
	 * Shortcut for jQuery("#" + id) with additionally the id being escaped properly.
	 * I.e.: returns the jQuery object for the DOM element with the given id
	 *
	 * Use this method instead of jQuery(...) if you know the argument is exactly one id and
	 * the id is not known in advance because it is in a variable (as opposed to a string
	 * constant with known content).
	 *
	 * @param {String} sId The id to search for and construct the jQuery object
	 * @param {DomNode} oContext The context DomNode
	 * @return {Object} The jQuery object for the DOM element identified by the given sId
	 * @public
	 * @since 0.9.1
	 */
	jQuery.sap.byId = function byId(sId, oContext) {
		var escapedId = "";
		if (sId) {
			escapedId = "#" + sId.replace(/(:|\.)/g,'\\$1');
		}
		return jQuery(escapedId, oContext);
	};


	/**
	 * Calls focus() on the given DOM element, but catches and ignores any errors that occur when doing so.
	 * (i.e. IE8 throws an error when the DOM element is invisible or disabled)
	 *
	 * @param {DomNode} oDomRef The DOM element to focus (or null - in this case the method does nothing)
	 * @return {boolean} Whether the focus() command was executed without an error
	 * @public
	 * @since 1.1.2
	 */
	jQuery.sap.focus = function focus(oDomRef) {
		if (!oDomRef) {
			return;
		}
		try {
			oDomRef.focus();
		} catch (e) {
			var id = (oDomRef && oDomRef.id) ? " (ID: '" + oDomRef.id + "')" : "";
			jQuery.sap.log.warning("Error when trying to focus a DOM element" + id + ": " + e.message);
			return false;
		}
		return true;
	};


	/**
	 * Sets or gets the position of the cursor in an element that supports cursor positioning
	 *
	 * @param {int} iPos The cursor position to set (or no parameter to retrieve the cursor position)
	 * @return {int | jQuery} The cursor position (or the jQuery collection if the position has been set)
	 * @public
	 * @methodOf jQuery.prototype
	 * @name cursorPos
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.cursorPos = function cursorPos(iPos) {
		var len = arguments.length,
			oTextRange,iLength,
			sTagName,
			sType;

		sTagName = this.prop("tagName");
		sType = this.prop("type");

		if( this.length === 1 && ((sTagName == "INPUT" && (sType == "text" || sType == "password" || sType == "search"))
				|| sTagName == "TEXTAREA" )) {

			var oDomRef = this.get(0);

			if (len > 0) { // SET

				if (oDomRef.createTextRange) { // IE method
					oTextRange = oDomRef.createTextRange();
					var iMaxLength = oDomRef.value.length;

					if(iPos < 0 || iPos > iMaxLength) {
						iPos = iMaxLength;
					}
					if(oTextRange) {
						oTextRange.collapse();
						oTextRange.moveEnd("character",iPos);
						oTextRange.moveStart("character",iPos);
						oTextRange.select();
					}
				} else if (typeof(oDomRef.selectionStart) == "number") { // FF method
					oDomRef.focus();
					oDomRef.selectionStart = iPos;
					oDomRef.selectionEnd = iPos;
				}

				return this;
				// end of SET

			} else { // GET

				if (oDomRef.createTextRange) { //IE
					oTextRange = window.document.selection.createRange();
					var oCopiedTextRange = oTextRange.duplicate();
					// Logic in TEXTAREA and INPUT is different in IE -> check for element type
					if(oDomRef.tagName == "TEXTAREA"){
						oCopiedTextRange.moveToElementText(oDomRef);
						var oCheckTextRange = oCopiedTextRange.duplicate();
						iLength = oCopiedTextRange.text.length;

						// first check if cursor on last position
						oCheckTextRange.moveStart("character", iLength);
						if(oCheckTextRange.inRange(oTextRange)){
							iStart = iLength;
						}else{
							// find out cursor position using a bisection algorithm
							var iCheckLength = iLength;
							var iStart = 0;
							while(iLength > 1){
								iCheckLength = Math.round(iLength / 2);
								iStart = iStart + iCheckLength;

								oCheckTextRange = oCopiedTextRange.duplicate();
								oCheckTextRange.moveStart("character", iStart);
								if(oCheckTextRange.inRange(oTextRange)){
									//cursor is after or on iStart -> Length = not checked Length
									iLength = iLength - iCheckLength;

								}else{
									//cursor is before iStart  -> Length = checked Length
									iStart = iStart - iCheckLength;
									iLength = iCheckLength;
								}
							}
						}
						return iStart;
					} else if (oCopiedTextRange.parentElement() === oDomRef) {
						// ensure there is only the cursor and not the range (as this would create erroneous position)!
						oCopiedTextRange.collapse();
						// now, move the selection range to the beginning of the inputField and simply get the selected range's length
						var iLength = oDomRef.value.length;
						oCopiedTextRange.moveStart('character', -iLength);
						return oCopiedTextRange.text.length;
					}
				} else if (typeof(oDomRef.selectionStart) == "number") { // Firefox etc.
					return oDomRef.selectionStart;
				}

				return -1;
			} // end of GET
		} else {
			// shouldn't really happen, but to be safe...
			return this;
		}
	};

	/**
	 * Sets the text selection in the first element of the collection
	 *
	 * @param {int} iStart Start position of the selection (inclusive)
	 * @param {int} iEnd End position of the selection (exclusive)
	 * @return {jQuery} The jQuery collection
	 * @public
	 * @methodOf jQuery.prototype
	 * @name selectText
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.selectText = function selectText(iStart, iEnd) {
		var oDomRef = this.get(0);

		if (oDomRef) {
			if(oDomRef.createTextRange) { // IE
				var oTextEditRange = oDomRef.createTextRange();
				oTextEditRange.collapse();
				oTextEditRange.moveStart('character', iStart);
				oTextEditRange.moveEnd('character', iEnd - iStart);
				oTextEditRange.select();
			} else if(typeof(oDomRef.selectionStart) == "number") { // Firefox
				// sanity checks
				if (iStart < 0) {
					iStart = 0;
				}
				if (iEnd > oDomRef.value.length) {
					iEnd = oDomRef.value.length;
				}
				if (!iEnd || iStart > iEnd) {
					iStart = 0;
					iEnd = 0;
				}
				oDomRef.selectionStart = iStart; // TODO: maybe need to decouple via setTimeout?
				oDomRef.selectionEnd = iEnd;
			}
		}

		return this;
	};


	/**
	 * Returns the outer HTML of the given HTML element
	 *
	 * @return {String} outer HTML
	 * @public
	 * @methodOf jQuery.prototype
	 * @name outerHTML
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.outerHTML = function outerHTML() {
		var oDomRef = this.get(0);

		if (oDomRef && oDomRef.outerHTML) {
			return jQuery.trim(oDomRef.outerHTML);
		} else {
			var doc = this[0] ? this[0].ownerDocument : document;

			var oDummy = doc.createElement("div");
			oDummy.appendChild(oDomRef.cloneNode(true));
			return oDummy.innerHTML;
		}
	};


	/**
	 * Returns whether oDomRefChild is oDomRefContainer or is contained in oDomRefContainer.
	 *
	 * This is a browser-independent version of the .contains method of Internet Explorer.
	 * For compatibility reasons it returns true if oDomRefContainer and oDomRefChild are equal.
	 *
	 * This method intentionally does not operate on the jQuery object, as the original jQuery.contains()
	 * method also does not do so.
	 *
	 * @param {DOMNode} oDomRefContainer The container element
	 * @param {DOMNode} oDomRefChild The child element (must not be a text node, must be an element)
	 * @return {boolean} 'true' if oDomRefChild is contained in oDomRefContainer or oDomRefChild is oDomRefContainer
	 * @public
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.sap.containsOrEquals = function containsOrEquals(oDomRefContainer, oDomRefChild) {
		if (oDomRefChild && oDomRefContainer && oDomRefChild != document && oDomRefChild != window) {
			return (oDomRefContainer === oDomRefChild) || jQuery.contains(oDomRefContainer, oDomRefChild);
		}
		return false;
	};


	/**
	 * Returns a rectangle describing the current visual positioning of the first DOM object in the collection
	 * (or null if no element was given)
	 *
	 * @return {object} An object with left, top, width and height
	 * @public
	 * @methodOf jQuery.prototype
	 * @name rect
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.rect = function rect() {
		var oDomRef = this.get(0);

		if (oDomRef) {
			// this should be available in all 'modern browsers'
			if (oDomRef.getBoundingClientRect) {
				var oClientRect = oDomRef.getBoundingClientRect();
				var oRect = { top : oClientRect.top,
						left : oClientRect.left,
						width : oClientRect.right - oClientRect.left,
						height : oClientRect.bottom - oClientRect.top };

				var oWnd = jQuery.sap.ownerWindow(oDomRef);
				oRect.left += jQuery(oWnd).scrollLeft();
				oRect.top += jQuery(oWnd).scrollTop();

				return oRect;
			} else {
				// IE6 and older; avoid crashing and give some hardcoded size
				return { top : 10, left : 10, width : oDomRef.offsetWidth, height : oDomRef.offsetWidth };
			}
		}
		return null;
	};


	/**
	 * Returns whether a point described by X and Y is inside this Rectangle's boundaries
	 *
	 * @param {int} iPosX
	 * @param {int} iPosY
	 * @return Whether X and Y are inside this Rectangle's boundaries
	 * @public
	 * @methodOf jQuery.prototype
	 * @name rectContains
	 * @author SAP AG
	 * @since 0.18.0
	 */
	jQuery.fn.rectContains = function rectContains(iPosX, iPosY) {
		jQuery.sap.assert(!isNaN(iPosX), "iPosX must be a number");
		jQuery.sap.assert(!isNaN(iPosY), "iPosY must be a number");

		var oRect = this.rect();

		if (oRect) {

			return iPosX >= oRect.left
				&& iPosX <= oRect.left + oRect.width
				&& iPosY >= oRect.top
				&& iPosY <= oRect.top + oRect.height;

		}
		return false;
	};


	/**
	 * Returns true if the first element has a set tabindex
	 *
	 * @return {boolean} If the first element has a set tabindex
	 * @public
	 * @methodOf jQuery.prototype
	 * @name hasTabIndex
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.hasTabIndex = function hasTabIndex() {
		var iTabIndex = this.prop("tabIndex");
		return !isNaN(iTabIndex) && iTabIndex >= 0;
	};


	/**
	 * Returns the first focusable domRef in a given container (the first element of the collection)
	 *
	 * @return {DOMNode} The domRef
	 * @public
	 * @methodOf jQuery.prototype
	 * @name firstFocusableDomRef
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.firstFocusableDomRef = function firstFocusableDomRef() {
		var oContainerDomRef = this.get(0);
		var visibilityHiddenFilter = function (idx){return jQuery(this).css("visibility") == "hidden";};
		if (!oContainerDomRef || jQuery(oContainerDomRef).is(':hidden') ||
				jQuery(oContainerDomRef).filter(visibilityHiddenFilter).length == 1) {
			return null;
		}

		var oCurrDomRef = oContainerDomRef.firstChild,
			oDomRefFound = null;

		while (oCurrDomRef) {
			if(oCurrDomRef.nodeType == 1 && jQuery(oCurrDomRef).is(':visible')) {
				if (jQuery(oCurrDomRef).hasTabIndex()) {
					return oCurrDomRef;
				}

				if(oCurrDomRef.childNodes) {
					oDomRefFound = jQuery(oCurrDomRef).firstFocusableDomRef();
					if(oDomRefFound) {
						return oDomRefFound;
					}
				}
			}
			oCurrDomRef = oCurrDomRef.nextSibling;
		}

		return null;
	};


	/**
	 * Returns the last focusable domRef in a given container
	 *
	 * @return {DOMNode} The last domRef
	 * @public
	 * @methodOf jQuery.prototype
	 * @name lastFocusableDomRef
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.lastFocusableDomRef = function lastFocusableDomRef() {
		var oContainerDomRef = this.get(0);
		var visibilityHiddenFilter = function (idx){return jQuery(this).css("visibility") == "hidden";};
		if (!oContainerDomRef || jQuery(oContainerDomRef).is(':hidden') ||
				jQuery(oContainerDomRef).filter(visibilityHiddenFilter).length == 1) {
			return null;
		}

		var oCurrDomRef = oContainerDomRef.lastChild,
			oDomRefFound = null;

		while (oCurrDomRef) {
			if(oCurrDomRef.nodeType == 1 && jQuery(oCurrDomRef).is(':visible')) {
				if(oCurrDomRef.childNodes) {
					oDomRefFound = jQuery(oCurrDomRef).lastFocusableDomRef();
					if(oDomRefFound) {
						return oDomRefFound;
					}
				}

				if (jQuery(oCurrDomRef).hasTabIndex()) {
					return oCurrDomRef;
				}
			}
			oCurrDomRef = oCurrDomRef.previousSibling;
		}

		return null;
	};


	/**
	 * Sets or returns the scrollLeft value of the first element in the given jQuery collection in right-to-left mode.
	 * Precondition: The element is rendered in RTL mode.
	 *
	 * Reason for this method is that the major browsers use three different values for the same scroll position when in RTL mode.
	 * This method hides those differences and returns/applies the same value that would be returned in LTR mode: The distance in px
	 * how far the given container is scrolled away from the leftmost scroll position.
	 *
	 * Returns "undefined" if no element and no iPos is given.
	 *
	 * @return {jQuery | int} The jQuery collection if iPos is given, otherwise the scroll position, counted from the leftmost position
	 * @public
	 * @methodOf jQuery.prototype
	 * @name scrollLeftRTL
	 * @author SAP AG
	 * @since 0.20.0
	 */
	jQuery.fn.scrollLeftRTL = function scrollLeftRTL(iPos) {
		var oDomRef = this.get(0);
		if (oDomRef) {

			if (iPos === undefined) { // GETTER code
				if (jQuery.browser.msie) {
					return oDomRef.scrollWidth - oDomRef.scrollLeft - oDomRef.clientWidth;

				} else if (jQuery.browser.webkit) {
					return oDomRef.scrollLeft;

				} else if (jQuery.browser.mozilla) {
					return oDomRef.scrollWidth + oDomRef.scrollLeft - oDomRef.clientWidth;

				} else {
					// unrecognized browser; it is hard to return a best guess, as browser strategies are very different, so return the actual value
					return oDomRef.scrollLeft;
				}

			} else { // SETTER code
				oDomRef.scrollLeft = jQuery.sap.denormalizeScrollLeftRTL(iPos);
				return this;
			}
		}
	};

	/**
	 * Returns the MIRRORED scrollLeft value of the first element in the given jQuery collection in right-to-left mode.
	 * Precondition: The element is rendered in RTL mode.
	 *
	 * Reason for this method is that the major browsers return three different values for the same scroll position when in RTL mode.
	 * This method hides those differences and returns the value that would be returned in LTR mode if the UI would be mirrored horizontally:
	 * The distance in px how far the given container is scrolled away from the rightmost scroll position.
	 *
	 * Returns "undefined" if no element is given.
	 *
	 * @return {int} The scroll position, counted from the rightmost position
	 * @public
	 * @methodOf jQuery.prototype
	 * @name scrollRightRTL
	 * @author SAP AG
	 * @since 0.20.0
	 */
	jQuery.fn.scrollRightRTL = function scrollRightRTL() {
		var oDomRef = this.get(0);
		if (oDomRef) {

			if (jQuery.browser.msie) {
				return oDomRef.scrollLeft;

			} else if (jQuery.browser.webkit) {
				return oDomRef.scrollWidth - oDomRef.scrollLeft - oDomRef.clientWidth;

			} else if (jQuery.browser.mozilla) {
				return (-oDomRef.scrollLeft);

			} else {
				// unrecognized browser; it is hard to return a best guess, as browser strategies are very different, so return the actual value
				return oDomRef.scrollLeft;
			}
		}
	};


	/**
	 * For the given scrollLeft value this method returns the scrollLeft value as understood by the current browser in RTL mode.
	 * This value is specific to the given DOM element, as the computation may involve its dimensions.
	 *
	 * So when oDomRef should be scrolled 2px from the leftmost position, the number "2" must be given as iNormalizedScrollLeft
	 * and the result of this method (which may be a large or even negative number, depending on the browser) can then be set as
	 * oDomRef.scrollLeft to achieve the desired (cross-browser-consistent) scrolling position.
	 *
	 * This method does no scrolling on its own, it only calculates the value to set (so it can also be used for animations).
	 *
	 * @param {int} iNormalizedScrollLeft The distance from the leftmost position to which the element should be scrolled
	 * @param {DOMNode} oDomRef The DOM element to which scrollLeft will be applied
	 * @return {int} The scroll position that must be set for the DOM element
	 * @public
	 * @author SAP AG
	 * @since 0.20.0
	 */
	jQuery.sap.denormalizeScrollLeftRTL = function byId(iNormalizedScrollLeft, oDomRef) {

		if (oDomRef) {
			if (jQuery.browser.msie) {
				return oDomRef.scrollWidth - oDomRef.clientWidth - iNormalizedScrollLeft;

			} else if (jQuery.browser.webkit) {
				return iNormalizedScrollLeft;

			} else if (jQuery.browser.mozilla) {
				return oDomRef.clientWidth + iNormalizedScrollLeft - oDomRef.scrollWidth;

			} else {
				// unrecognized browser; it is hard to return a best guess, as browser strategies are very different, so return the actual value
				return iNormalizedScrollLeft;
			}
		}
	};




	/*!
	 * The following functions are taken from jQuery UI 1.8.17 but modified
	 *
	 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
	 * Dual licensed under the MIT or GPL Version 2 licenses.
	 * http://jquery.org/license
	 *
	 * http://docs.jquery.com/UI
	 */
	function visible( element ) {
		// check if one of the parents (until it's position parent) is invisible
		// prevent that elements in static area are always checked as invisible
		
		// list all items until the offsetParent item (with jQuery >1.6 you can use parentsUntil)
		var oOffsetParent = jQuery(element).offsetParent();
		var bOffsetParentFound = false;
		var $refs = jQuery(element).parents().filter(function() {
			if (this === oOffsetParent) {
				bOffsetParentFound = true;
			}
			return bOffsetParentFound;
		});
		
		// check for at least one item to be visible
		return !jQuery(element).add($refs).filter(function() {
			return jQuery.css( this, "visibility" ) === "hidden" || jQuery.expr.filters.hidden( this );
		}).length;
	}

	function focusable( element, isTabIndexNotNaN ) {
		var nodeName = element.nodeName.toLowerCase();
		if ( "area" === nodeName ) {
			var map = element.parentNode,
				mapName = map.name,
				img;
			if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
				return false;
			}
			img = jQuery( "img[usemap=#" + mapName + "]" )[0];
			return !!img && visible( img );
		}
		return ( /input|select|textarea|button|object/.test( nodeName )
			? !element.disabled
			: "a" == nodeName
				? element.href || isTabIndexNotNaN
				: isTabIndexNotNaN)
			// the element and all of its ancestors must be visible
			&& visible( element );
	}


	if (!jQuery.expr[":"].focusable) {
		/*!
		 * The following function is taken from jQuery UI 1.8.17
		 *
		 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
		 * Dual licensed under the MIT or GPL Version 2 licenses.
		 * http://jquery.org/license
		 *
		 * http://docs.jquery.com/UI
		 *
		 * But since visible is modified, focusable is different too the jQuery UI version too.
		 */
		jQuery.extend( jQuery.expr[ ":" ], {
			/**
			 * This defines the jQuery ":focusable" selector; it is also defined in jQuery UI. If already present, nothing is
			 * done here, so we will not overwrite any previous implementation.
			 * If jQuery UI is loaded later on, this implementation here will be overwritten by that one, which is fine,
			 * as it is semantically the same thing and intended to do exactly the same.
			 */
			focusable: function( element ) {
				return focusable( element, !isNaN( jQuery.attr( element, "tabindex" ) ) );
			}
		});
	}

	if (!jQuery.expr[":"].sapFocusable) {
		/*!
		 * Do not use jQuery UI focusable because this might be overwritten if jQuery UI is loaded
		 */
		jQuery.extend( jQuery.expr[ ":" ], {
			/**
			 * This defines the jQuery ":sapFocusable" selector; If already present, nothing is
			 * done here, so we will not overwrite any previous implementation.
			 * If jQuery UI is loaded later on, this implementation here will NOT be overwritten by.
			 */
			sapFocusable: function( element ) {
				return focusable( element, !isNaN( jQuery.attr( element, "tabindex" ) ) );
			}
		});
	}

	/**
	 * Gets the next parent DOM element with a given attribute and attribute value starting above the first given element
	 *
	 * @param {String} sAttibute Name of the attribute
	 * @param {String} sValue Value of the attribute (optional)
	 * @return {DOMNode} null or the DOM reference
	 * @public
	 * @methodOf jQuery.prototype
	 * @name parentByAttribute
	 * @author SAP AG
	 * @since 0.9.0
	 */
	jQuery.fn.parentByAttribute = function parentByAttribute(sAttribute, sValue) {
		if (this.length>0) {
			if (sValue) {
				return this.first().parents("["+sAttribute+"='"+sValue+"']").get(0);
			} else {
				return this.first().parents("["+sAttribute+"]").get(0);
			}
		}
	};


	/**
	 * Returns the window reference for a DomRef
	 *
	 * @param {DOMNode} oDomRef The DOM reference
	 * @return {window} Window reference
	 * @public
	 * @since 0.9.0
	 */
	jQuery.sap.ownerWindow = function ownerWindow(oDomRef){
		if (oDomRef.ownerDocument.parentWindow) {
			return oDomRef.ownerDocument.parentWindow;
		}
		return oDomRef.ownerDocument.defaultView;
	};
	
	
	var _oScrollbarSize = {};
	
	/**
	 * Returns the size (width of the vertical / height of the horizontal) native browser scrollbars.
	 * 
	 * This function must only be used when the DOM is ready.
	 *
	 * @param {String} [sClasses=null] the CSS class that should be added to the test element.
	 * @param {boolean} [bForce=false] force recalculation of size (e.g. when CSS was changed). When no classes are passed all calculated sizes are reset.
	 * @return {object} JSON object with properties <code>width</code> and <code>height</code> (the values are of type number and are pixels).
	 * @public
	 * @since 1.4.0
	 */
	jQuery.sap.scrollbarSize = function(sClasses, bForce) {
		if (typeof sClasses === "boolean") {
			bForce = sClasses;
			sClasses = null;
		}

		var sKey = sClasses || "#DEFAULT"; // # is an invalid character for CSS classes

		if (bForce) {
			if (sClasses) {
				delete _oScrollbarSize[sClasses];
			} else {
				_oScrollbarSize = {};
			}
		}
		
		if(_oScrollbarSize[sKey]) {
			return _oScrollbarSize[sKey];
		}

		if(!document.body){
			return {width: 0, height: 0};
		}
		
		var $Area = jQuery("<DIV/>")
			.css("visibility", "hidden")
			.css("height", "0")
			.css("width", "0")
			.css("overflow", "hidden");

		if (sClasses) {
			$Area.addClass(sClasses);
		}

		$Area.prependTo(document.body);
		
		var $Dummy = jQuery("<div style=\"visibility:visible;position:absolute;height:100px;width:100px;overflow:scroll;opacity:0;\"></div>");
		$Area.append($Dummy);

		var oDomRef = $Dummy.get(0);
		var iWidth = oDomRef.offsetWidth - oDomRef.scrollWidth;
		var iHeight = oDomRef.offsetHeight - oDomRef.scrollHeight;

		$Area.remove();
		
		_oScrollbarSize[sKey] = {width: iWidth, height: iHeight};

		return _oScrollbarSize[sKey];
	};

}());

}; // end of jquery.sap.dom

if ( !jQuery.sap.isDeclared('jquery.sap.events') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides functionality related to eventing.
jQuery.sap.declare("jquery.sap.events");
if ( !jQuery.sap.isDeclared('jquery.sap.keycodes') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

/*
 * Provides constants for key codes. Useful in the implementation of keypress/keydown event handlers.
 */
jQuery.sap.declare("jquery.sap.keycodes", false);

/**
 * Enumeration of key codes.
 *
 * @namespace
 * @public
 * @since 0.9.0
 */
jQuery.sap.KeyCodes = {
	/**
	 * @type number
	 * @public
	 */
	BACKSPACE : 8,
	/**
	 * @type number
	 * @public
	 */
	TAB : 9,
	/**
	 * @type number
	 * @public
	 */
	ENTER : 13,
	/**
	 * @type number
	 * @public
	 */
	SHIFT : 16,
	/**
	 * @type number
	 * @public
	 */
	CONTROL : 17,
	/**
	 * @type number
	 * @public
	 */
	ALT : 18,
	/**
	 * @type number
	 * @public
	 */
	BREAK : 19,
	/**
	 * @type number
	 * @public
	 */
	CAPS_LOCK : 20,
	/**
	 * @type number
	 * @public
	 */
	ESCAPE : 27,
	/**
	 * @type number
	 * @public
	 */
	SPACE : 32,
	/**
	 * @type number
	 * @public
	 */
	PAGE_UP : 33,
	/**
	 * @type number
	 * @public
	 */
	PAGE_DOWN : 34,
	/**
	 * @type number
	 * @public
	 */
	END : 35,
	/**
	 * @type number
	 * @public
	 */
	HOME : 36,
	/**
	 * @type number
	 * @public
	 */
	ARROW_LEFT : 37,
	/**
	 * @type number
	 * @public
	 */
	ARROW_UP : 38,
	/**
	 * @type number
	 * @public
	 */
	ARROW_RIGHT : 39,
	/**
	 * @type number
	 * @public
	 */
	ARROW_DOWN : 40,
	/**
	 * @type number
	 * @public
	 */
	PRINT : 44,
	/**
	 * @type number
	 * @public
	 */
	INSERT : 45,
	/**
	 * @type number
	 * @public
	 */
	DELETE : 46,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_0 : 48,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_1 : 49,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_2 : 50,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_3 : 51,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_4 : 52,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_5 : 53,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_6 : 54,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_7 : 55,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_8 : 56,
	/**
	 * @type number
	 * @public
	 */
	DIGIT_9 : 57,
	/**
	 * @type number
	 * @public
	 */
	A : 65,
	/**
	 * @type number
	 * @public
	 */
	B : 66,
	/**
	 * @type number
	 * @public
	 */
	C : 67,
	/**
	 * @type number
	 * @public
	 */
	D : 68,
	/**
	 * @type number
	 * @public
	 */
	E : 69,
	/**
	 * @type number
	 * @public
	 */
	F : 70,
	/**
	 * @type number
	 * @public
	 */
	G : 71,
	/**
	 * @type number
	 * @public
	 */
	H : 72,
	/**
	 * @type number
	 * @public
	 */
	I : 73,
	/**
	 * @type number
	 * @public
	 */
	J : 74,
	/**
	 * @type number
	 * @public
	 */
	K : 75,
	/**
	 * @type number
	 * @public
	 */
	L : 76,
	/**
	 * @type number
	 * @public
	 */
	M : 77,
	/**
	 * @type number
	 * @public
	 */
	N : 78,
	/**
	 * @type number
	 * @public
	 */
	O : 79,
	/**
	 * @type number
	 * @public
	 */
	P : 80,
	/**
	 * @type number
	 * @public
	 */
	Q : 81,
	/**
	 * @type number
	 * @public
	 */
	R : 82,
	/**
	 * @type number
	 * @public
	 */
	S : 83,
	/**
	 * @type number
	 * @public
	 */
	T : 84,
	/**
	 * @type number
	 * @public
	 */
	U : 85,
	/**
	 * @type number
	 * @public
	 */
	V : 86,
	/**
	 * @type number
	 * @public
	 */
	W : 87,
	/**
	 * @type number
	 * @public
	 */
	X : 88,
	/**
	 * @type number
	 * @public
	 */
	Y : 89,
	/**
	 * @type number
	 * @public
	 */
	Z : 90,
	/**
	 * @type number
	 * @public
	 */
	WINDOWS : 91,
	/**
	 * @type number
	 * @public
	 */
	CONTEXT_MENU : 93,
	/**
	 * @type number
	 * @public
	 */
	TURN_OFF : 94,
	/**
	 * @type number
	 * @public
	 */
	SLEEP : 95,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_0 : 96,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_1 : 97,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_2 : 98,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_3 : 99,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_4 : 100,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_5 : 101,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_6 : 102,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_7 : 103,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_8 : 104,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_9 : 105,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_ASTERISK : 106,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_PLUS : 107,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_MINUS : 109,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_COMMA : 110,
	/**
	 * @type number
	 * @public
	 */
	NUMPAD_SLASH : 111,
	/**
	 * @type number
	 * @public
	 */
	F1 : 112,
	/**
	 * @type number
	 * @public
	 */
	F2 : 113,
	/**
	 * @type number
	 * @public
	 */
	F3 : 114,
	/**
	 * @type number
	 * @public
	 */
	F4 : 115,
	/**
	 * @type number
	 * @public
	 */
	F5 : 116,
	/**
	 * @type number
	 * @public
	 */
	F6 : 117,
	/**
	 * @type number
	 * @public
	 */
	F7 : 118,
	/**
	 * @type number
	 * @public
	 */
	F8 : 119,
	/**
	 * @type number
	 * @public
	 */
	F9 : 120,
	/**
	 * @type number
	 * @public
	 */
	F10 : 121,
	/**
	 * @type number
	 * @public
	 */
	F11 : 122,
	/**
	 * @type number
	 * @public
	 */
	F12 : 123,
	/**
	 * @type number
	 * @public
	 */
	NUM_LOCK : 144,
	/**
	 * @type number
	 * @public
	 */
	SCROLL_LOCK : 145,
	/**
	 * @type number
	 * @public
	 */
	OPEN_BRACKET : 186,
	/**
	 * @type number
	 * @public
	 */
	PLUS : 187,
	/**
	 * @type number
	 * @public
	 */
	COMMA : 188,
	/**
	 * @type number
	 * @public
	 */
	SLASH : 189,
	/**
	 * @type number
	 * @public
	 */
	DOT : 190,
	/**
	 * @type number
	 * @public
	 */
	PIPE : 191,
	/**
	 * @type number
	 * @public
	 */
	SEMICOLON : 192,
	/**
	 * @type number
	 * @public
	 */
	MINUS : 219,
	/**
	 * @type number
	 * @public
	 */
	GREAT_ACCENT : 220,
	/**
	 * @type number
	 * @public
	 */
	EQUALS : 221,
	/**
	 * @type number
	 * @public
	 */
	SINGLE_QUOTE : 222,
	/**
	 * @type number
	 * @public
	 */
	BACKSLASH : 226
};
}; // end of jquery.sap.keycodes



(function(){

	jQuery.sap._touchToMouseEvent = true;

	if (jQuery.browser.webkit && /Mobile/.test(navigator.userAgent) && "ontouchend" in document) {
		var bHandleEvent = false;
		var oTarget = null;
		var bIsMoved = false;
		var iStartX = null;
		var iStartY = null;

		/**
		 * Fires a synthetic mouse event for a given type and native touch event.
		 * @param {String} sType the type of the synthetic event to fire, e.g. "mousedown"
		 * @param {jQuery.Event} oEvent the event object
		 * @private
		 */
		var fireMouseEvent = function(sType, oEvent) {

			if (!bHandleEvent || !jQuery.sap._touchToMouseEvent) {
				return;
			}
			
			// we need mapping of the different event types to get the correct target
			var oMappedEvent = oEvent.type == "touchend" ? oEvent.changedTouches[0] : oEvent.touches[0]; 

			// create the synthetic event
			var newEvent = document.createEvent('MouseEvent');  // trying to create an actual TouchEvent will create an error
			newEvent.initMouseEvent(sType, true, true, window, oEvent.detail,
					oMappedEvent.screenX, oMappedEvent.screenY, oMappedEvent.clientX, oMappedEvent.clientY,
					oEvent.ctrlKey, oEvent.shiftKey, oEvent.altKey, oEvent.metaKey,
					oEvent.button, oEvent.relatedTarget);

			newEvent.isSynthetic = true;

			// Timeout needed. Do not interrupt the native event handling.
			window.setTimeout(function() {
				oTarget.dispatchEvent(newEvent);
			},0);
		};


		/**
		 * Checks if the target of the event is an input field.
		 * @param {jQuery.Event} oEvent the event object
		 * @return {Boolean} whether the target of the event is an input field.
		 */
		var isInputField = function(oEvent) {
			return oEvent.target.tagName.match(/input|textarea|select/i);
		};

		
		/**
		 * Mouse event handler. Prevents propagation for native events. 
		 * @param {jQuery.Event} oEvent the event object
		 * @private
		 */
		var onMouseEvent = function(oEvent) {
			if (!oEvent.isSynthetic && !isInputField(oEvent) && jQuery.sap._touchToMouseEvent) {
				oEvent.stopPropagation();
				oEvent.preventDefault();
			}
		};


		/**
		 * Touch start event handler. Called whenever a finger is added to the surface. Fires mouse start event.
		 * @param {jQuery.Event} oEvent the event object
		 * @private
		 */
		var onTouchStart = function(oEvent) {
			var oTouches = oEvent.touches;

			bHandleEvent = (oTouches.length == 1 && !isInputField(oEvent));

			if (bHandleEvent) {
				bIsMoved = false;
				var oTouch = oTouches[0];

				// As we are only interested in the first touch target, we remember it
				oTarget = oTouch.target;
				if(oTarget.nodeType == 3) {
					// no text node
					oTarget = oTarget.parentNode;
				}

				// Remember the start position of the first touch to determine if a click was performed or not.
				iStartX = oTouch.clientX;
				iStartY = oTouch.clientY;
				fireMouseEvent("mousedown", oEvent);
			}
		};


		/**
		 * Touch move event handler. Fires mouse move event.
		 * @param {jQuery.Event} oEvent the event object
		 * @private
		 */
		var onTouchMove = function(oEvent) {
			if (bHandleEvent) {
				var oTouch = oEvent.touches[0];
				// Check if the finger is moved. When the finger was moved, no "click" event is fired.
				if (Math.abs(oTouch.clientX - iStartX) > 10 || Math.abs(oTouch.clientY - iStartY) > 10) {
					bIsMoved = true;
				}
				if (bIsMoved) {
					// Fire "mousemove" event only when the finger was moved. This is to prevent unwanted movements. 
					fireMouseEvent("mousemove", oEvent);
				}
			}
		};


		/**
		 * Touch end event handler. Fires mouse up and click event.
		 * @param {jQuery.Event} oEvent the event object
		 * @private
		 */
		var onTouchEnd = function(oEvent) {
			fireMouseEvent("mouseup", oEvent);
			if (!bIsMoved) {
				fireMouseEvent("click", oEvent);
			}
		};

		
		/**
		 * Touch cancel event handler. Fires mouse up event.
		 * @param {jQuery.Event} oEvent the event object
		 * @private
		 */
		var onTouchCancel = function(oEvent) {
			fireMouseEvent("mouseup", oEvent);
		};

		// Add click on capturing phase to prevent propagation if necessary
		document.addEventListener('mousedown', onMouseEvent, true);
		document.addEventListener('mouseover', onMouseEvent, true);
		document.addEventListener('mouseup', onMouseEvent, true);
		document.addEventListener('mouseout', onMouseEvent, true);
		document.addEventListener('click', onMouseEvent, true);
		// Bind touch events
		document.addEventListener('touchstart', onTouchStart, true);
		document.addEventListener('touchmove', onTouchMove, true);
		document.addEventListener('touchend', onTouchEnd, true);
		document.addEventListener('touchcancel', onTouchCancel, true);
	}
	


	/**
	 * List of DOM events that a UIArea automatically takes care of.
	 *
	 * A control/element doesn't have to bind listeners for these events.
	 * It instead can implement an <code>on<i>event</i>(oEvent)</code> method
	 * for any of these events that it wants to be notified about.
	 *
	 * @public
	 */
	jQuery.sap.ControlEvents = [  // IMPORTANT: update the public documentation when extending this list
		"click",
		"dblclick",
		"focusin",
		"focusout",
		"keydown",
		"keypress",
		"keyup",
		"mousedown",
		"mouseout",
		"mouseover",
		"mouseup",
		"select",
		"selectstart",
		"dragstart",
		"dragenter",
		"dragover",
		"dragleave",
		"dragend",
		"drop",
		"paste",
		"cut"
	];


	/**
	 * Enumeration of all so called "pseudo events", a useful classification
	 * of standard browser events as implied by SAP product standards.
	 *
	 * Whenever a browser event is recognized as one or more pseudo events, then this
	 * classification is attached to the original {@link jQuery.Event} object and thereby
	 * delivered to any jQuery-style listeners registered for that browser event.
	 *
	 * Pure JavaScript listeners can evaluate the classification information using
	 * the {@link jQuery.Event#isPseudoType} method.
	 *
	 * Instead of using the procedure as described above, the SAPUI5 controls and elements
	 * should simply implement an <code>on<i>pseudo-event</i>(oEvent)</code> method. It will
	 * be invoked only when that specific pseudo event has been recognized. This simplifies event
	 * dispatching even further.
	 *
	 * @namespace
	 * @public
	 */
	jQuery.sap.PseudoEvents = { // IMPORTANT: update the public documentation when extending this list

		/* Pseudo keyboard events */

		/**
		 * Pseudo event for keyboard arrow down without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdown: {sName: "sapdown", aTypes: ["keydown"], fnCheck: function (oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard arrow down with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdownmodifiers: {sName: "sapdownmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'show' event (F4, Alt + down-Arrow)
		 * @public
		 */
		sapshow: {sName: "sapshow", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return (oEvent.keyCode == jQuery.sap.KeyCodes.F4 && !hasModifierKeys(oEvent)) ||
				(oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN && checkModifierKeys(oEvent, /*Ctrl*/false, /*Alt*/true, /*Shift*/false));
		}},
		/**
		 * Pseudo event for keyboard arrow up without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapup: {sName: "sapup", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard arrow up with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapupmodifiers: {sName: "sapupmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'hide' event (Alt + up-Arrow)
		 * @public
		 */
		saphide: {sName: "saphide", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP && checkModifierKeys(oEvent, /*Ctrl*/false, /*Alt*/true, /*Shift*/false);
		}},
		/**
		 * Pseudo event for keyboard arrow left without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapleft: {sName: "sapleft", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_LEFT && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard arrow left with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapleftmodifiers: {sName: "sapleftmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_LEFT && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard arrow right without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapright: {sName: "sapright", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_RIGHT && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard arrow right with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		saprightmodifiers: {sName: "saprightmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_RIGHT && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard Home/Pos1 with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		saphome: {sName: "saphome", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.HOME && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard Home/Pos1 without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		saphomemodifiers: {sName: "saphomemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.HOME && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for  pseudo top event
		 * @public
		 */
		saptop: {sName: "saptop", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.HOME && checkModifierKeys(oEvent, /*Ctrl*/true, /*Alt*/false, /*Shift*/false);
		}},
		/**
		 * Pseudo event for keyboard End without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapend: {sName: "sapend", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.END && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard End with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapendmodifiers: {sName: "sapendmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.END && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo bottom event
		 * @public
		 */
		sapbottom: {sName: "sapbottom", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.END && checkModifierKeys(oEvent, /*Ctrl*/true, /*Alt*/false, /*Shift*/false);
		}},
		/**
		 * Pseudo event for keyboard page up without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sappageup: {sName: "sappageup", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.PAGE_UP && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard page up with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sappageupmodifiers: {sName: "sappageupmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.PAGE_UP && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard page down without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sappagedown: {sName: "sappagedown", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.PAGE_DOWN && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard page down with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sappagedownmodifiers: {sName: "sappagedownmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.PAGE_DOWN && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'select' event... space, enter, ... without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapselect: {sName: "sapselect", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return (oEvent.keyCode == jQuery.sap.KeyCodes.ENTER || oEvent.keyCode == jQuery.sap.KeyCodes.SPACE) && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'select' event... space, enter, ... with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapselectmodifiers: {sName: "sapselectmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return (oEvent.keyCode == jQuery.sap.KeyCodes.ENTER || oEvent.keyCode == jQuery.sap.KeyCodes.SPACE) && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard space without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapspace: {sName: "sapspace", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.SPACE && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard space with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapspacemodifiers: {sName: "sapspacemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.SPACE && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard enter without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapenter: {sName: "sapenter", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ENTER && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard enter with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapentermodifiers: {sName: "sapentermodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ENTER && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard backspace without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapbackspace: {sName: "sapbackspace", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.BACKSPACE && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard backspace with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapbackspacemodifiers: {sName: "sapbackspacemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.BACKSPACE && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard delete without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdelete: {sName: "sapdelete", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.DELETE && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard delete with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdeletemodifiers: {sName: "sapdeletemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.DELETE && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo expand event (keyboard numpad +) without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapexpand: {sName: "sapexpand", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.NUMPAD_PLUS && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo expand event (keyboard numpad +) with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapexpandmodifiers: {sName: "sapexpandmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.NUMPAD_PLUS && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo collapse event (keyboard numpad -) without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapcollapse: {sName: "sapcollapse", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.NUMPAD_MINUS && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo collapse event (keyboard numpad -) with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapcollapsemodifiers: {sName: "sapcollapsemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.NUMPAD_MINUS && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo collapse event (keyboard numpad *)
		 * @public
		 */
		sapcollapseall: {sName: "sapcollapseall", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.NUMPAD_ASTERISK && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard escape
		 * @public
		 */
		sapescape: {sName: "sapescape", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.ESCAPE && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard tab (TAB + no modifier)
		 * @public
		 */
		saptabnext: {sName: "saptabnext", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.TAB && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for keyboard tab (TAB + shift modifier)
		 * @public
		 */
		saptabprevious: {sName: "saptabprevious", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.TAB && checkModifierKeys(oEvent, /*Ctrl*/false, /*Alt*/false, /*Shift*/true);
		}},
		/**
		 * Pseudo event for pseudo skip forward (F6 + no modifier)
		 * @public
		 */
		sapskipforward: {sName: "sapskipforward", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.F6 && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo skip back (F6 + shift modifier)
		 * @public
		 */
		sapskipback: {sName: "sapskipback", aTypes: ["keydown"], fnCheck: function(oEvent) {
			return oEvent.keyCode == jQuery.sap.KeyCodes.F6 && checkModifierKeys(oEvent, /*Ctrl*/false, /*Alt*/false, /*Shift*/true);
		}},
		//// contextmenu Shift-F10 hack
		//{sName: "sapcontextmenu", aTypes: ["keydown"], fnCheck: function(oEvent) {
		//	return oEvent.keyCode == jQuery.sap.KeyCodes.F10 && checkModifierKeys(oEvent, /*Ctrl*/false, /*Alt*/false, /*Shift*/true);
		//}},

		/**
		 * Pseudo event for pseudo 'decrease' event without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdecrease: {sName: "sapdecrease", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iPreviousKey = bRtl ? jQuery.sap.KeyCodes.ARROW_RIGHT : jQuery.sap.KeyCodes.ARROW_LEFT;
			return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN) && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'decrease' event with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapdecreasemodifiers: {sName: "sapdecreasemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iPreviousKey = bRtl ? jQuery.sap.KeyCodes.ARROW_RIGHT : jQuery.sap.KeyCodes.ARROW_LEFT;
			return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN) && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'increase' event without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapincrease: {sName: "sapincrease", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iNextKey = bRtl ? jQuery.sap.KeyCodes.ARROW_LEFT : jQuery.sap.KeyCodes.ARROW_RIGHT;
			return (oEvent.keyCode == iNextKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP) && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'increase' event with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapincreasemodifiers: {sName: "sapincreasemodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iNextKey = bRtl ? jQuery.sap.KeyCodes.ARROW_LEFT : jQuery.sap.KeyCodes.ARROW_RIGHT;
			return (oEvent.keyCode == iNextKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP) && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'previous' event without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapprevious: {sName: "sapprevious", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iPreviousKey = bRtl ? jQuery.sap.KeyCodes.ARROW_RIGHT : jQuery.sap.KeyCodes.ARROW_LEFT;
			return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP) && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'previous' event with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sappreviousmodifiers: {sName: "sappreviousmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iPreviousKey = bRtl ? jQuery.sap.KeyCodes.ARROW_RIGHT : jQuery.sap.KeyCodes.ARROW_LEFT;
			return (oEvent.keyCode == iPreviousKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_UP) && hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'next' event without modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapnext: {sName: "sapnext", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iNextKey = bRtl ? jQuery.sap.KeyCodes.ARROW_LEFT : jQuery.sap.KeyCodes.ARROW_RIGHT;
			return (oEvent.keyCode == iNextKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN) && !hasModifierKeys(oEvent);
		}},
		/**
		 * Pseudo event for pseudo 'next' event with modifiers (Ctrl, Alt or Shift)
		 * @public
		 */
		sapnextmodifiers: {sName: "sapnextmodifiers", aTypes: ["keydown"], fnCheck: function(oEvent) {
			var bRtl = sap.ui.getCore().getConfiguration().getRTL();
			var iNextKey = bRtl ? jQuery.sap.KeyCodes.ARROW_LEFT : jQuery.sap.KeyCodes.ARROW_RIGHT;
			return (oEvent.keyCode == iNextKey || oEvent.keyCode == jQuery.sap.KeyCodes.ARROW_DOWN) && hasModifierKeys(oEvent);
		}},
		//// pseudo hotkey event
		//{sName: "saphotkey", aTypes: ["keydown"], fnCheck: function(oEvent) {
		//  return false;
		//}},
		/* TODO: hotkeys: all other events could be hotkeys
		if(UCF_KeyboardHelper.bIsValidHotkey(iKey, bCtrl, bAlt, bShift)) {

			if (iKey == jQuery.sap.KeyCodes.F1 && bNoModifiers) {
				//special handling for FF - in IE the help is handeled by onHelp
				if (UCF_System.sDevice == "ff1") {
					this.fireSapEvent(this.E_SAP_EVENTS.hotkey, oEvent);
				}
			}
			else if (bCtrlOnly && iKey == jQuery.sap.KeyCodes.C && document.selection) {
				//handle ctrl+c centrally if text is selected to allow to copy it instead of firing the hotkey
				var oTextRange = document.selection.createRange();
				if (!oTextRange || oTextRange.text.length <= 0) {
					this.fireSapEvent(this.E_SAP_EVENTS.hotkey, oEvent);
				}
			}
			else {
				this.fireSapEvent(this.E_SAP_EVENTS.hotkey, oEvent);
			}
		}
		*/

		/*
		 * Other pseudo events
		 * @public
		 */

		/**
		 * Pseudo event indicating delayed double click (e.g. for inline edit)
		 * @public
		 */
		sapdelayeddoubleclick: {sName: "sapdelayeddoubleclick", aTypes: ["click"], fnCheck: function(oEvent) {
			var element = jQuery(oEvent.target);
			var currentTimestamp = oEvent.timeStamp;
			var data = element.data("sapdelayeddoubleclick_lastClickTimestamp");
			var lastTimestamp = data || 0;
			element.data("sapdelayeddoubleclick_lastClickTimestamp", currentTimestamp);
			var diff = currentTimestamp - lastTimestamp;
			return (diff >= 300 && diff <= 1300);
		}}

	};

	/**
	 * Ordered array of the {@link jQuery.sap.PseudoEvents}.
	 *
	 * Order is significant as some check methods rely on the fact that they are tested before other methods.
	 * The array is processed during event analysis (when classifying browser events as pseudo events).
	 * @private
	 */
	var PSEUDO_EVENTS = ["sapdown", "sapdownmodifiers", "sapshow", "sapup", "sapupmodifiers", "saphide", "sapleft", "sapleftmodifiers", "sapright", "saprightmodifiers", "saphome", "saphomemodifiers", "saptop", "sapend", "sapendmodifiers", "sapbottom", "sappageup", "sappageupmodifiers", "sappagedown", "sappagedownmodifiers", "sapselect", "sapselectmodifiers", "sapspace", "sapspacemodifiers", "sapenter", "sapentermodifiers", "sapexpand", "sapbackspace", "sapbackspacemodifiers", "sapdelete", "sapdeletemodifiers", "sapexpandmodifiers", "sapcollapse", "sapcollapsemodifiers", "sapcollapseall", "sapescape", "saptabnext", "saptabprevious", "sapskipforward", "sapskipback", "sapprevious", "sappreviousmodifiers", "sapnext", "sapnextmodifiers", "sapdecrease", "sapdecreasemodifiers", "sapincrease", "sapincreasemodifiers", "sapdelayeddoubleclick"];


	//Add mobile touch events if touch is supported or we run in special dev test mode
	(function initTouchEventSupport() {

		function simulateMobileTouchEventSupport(){
			var sConfigKey = "xx-test-mobile"; //see sap.ui.core.Configuration -> M_SETTINGS
			var oCfgData = window["sap-ui-config"];
			var bSimulate = document.location.search.indexOf("sap-ui-"+sConfigKey) > -1 || (oCfgData && oCfgData[sConfigKey]);
			
			// also simulate touch events when sap-ui-xx-fakeOS is set (independently of the value and the current browser)
			bSimulate = bSimulate || (document.location.search.indexOf("sap-ui-xx-fakeOS") > -1 || !!jQuery.sap.byId("sap-ui-bootstrap").attr("data-sap-ui-xx-fakeOS")); // only allowed as URL parameter or in the bootstrap tag
			
			return bSimulate;
		}

		jQuery.sap.touchEventMode = "OFF";

		var aAdditionalControlEvents = [];
		var aAdditionalPseudoEvents = [];

		if("ontouchend" in document){ //Touch events natively supported
			jQuery.sap.touchEventMode = "ON";

			//ensure that "oEvent.touches", ... works (and not only "oEvent.originalEvent.touches", ...)
			jQuery.event.props.push("touches", "targetTouches", "changedTouches");

			//Define additional native events to be added to the event list
			//TODO maybe add "gesturestart", "gesturechange", "gestureend" later ?
			// IMPORTANT: update the public documentation when extending this list
			aAdditionalControlEvents.push("touchstart", "touchend", "touchmove", "touchcancel");

		}else if(simulateMobileTouchEventSupport()){ //Touch Simulation mode
			jQuery.sap.touchEventMode = "SIM";
			jQuery.sap.log.warning("MOBILE TOUCH EVENT TEST MODE ACTIVE", "", "jQuery.sap.events");

			function createSimulatedTouch(sName, aOrigEvents) {
				var sHandlerKey = "__"+sName+"Handler";
				var sSapName = "sap"+sName;
				aAdditionalControlEvents.push(sSapName);
				aAdditionalPseudoEvents.push({sName: sName, aTypes: [sSapName], fnCheck: function (oEvent) { return true; }});

				jQuery.event.special[sSapName] = {
					add: function(oHandle) {
						var that = this,
						$this = jQuery(this);
						var fHandler = function(oEvent) {
							if(!(oEvent.type != "mouseout" || (oEvent.type === "mouseout" && jQuery.sap.checkMouseEnterOrLeave(oEvent, that)))){
								return;
							}
							var oNewEvent = jQuery.event.fix(oEvent.originalEvent);
							oNewEvent.type = sSapName;
							//reset the _sapui_handledByUIArea flag
							oNewEvent.originalEvent._sapui_handledByUIArea = false;
							
							//TODO Extend if necessary
							//Extended by adding changedTouches and targetTouches which equal to touches
							var aTouches = [{
								identifier: 1,
								pageX: oNewEvent.pageX,
								pageY: oNewEvent.pageY,
								clientX: oNewEvent.clientX,
								clientY: oNewEvent.clientY,
								screenX: oNewEvent.screenX,
								screenY: oNewEvent.screenY,
								radiusX: 1,
								radiusY: 1,
								rotationAngle: 0
							}];
							
							oNewEvent.touches = oNewEvent.changedTouches = oNewEvent.targetTouches = aTouches;
							
							//when touchend, the touches and targetTouches should be empty array
							if(sName === "touchend"){
								oNewEvent.touches = oNewEvent.targetTouches = [];
							}
							
							if(sName === "touchstart" || $this.data("__touch_in_progress")){
								$this.data("__touch_in_progress", "X");
								oHandle.handler.call(that, oNewEvent);
								if(sName === "touchend"){
									$this.removeData("__touch_in_progress");
								}
							}
						};
						$this.data(sHandlerKey + oHandle.guid, fHandler);
						for(var i=0; i<aOrigEvents.length; i++){
							$this.bind(aOrigEvents[i], fHandler);
						}
					},
					remove: function(oHandle) {
						var $this = jQuery(this);
						var fHandler = $this.data(sHandlerKey + oHandle.guid);
						$this.removeData(sHandlerKey + oHandle.guid);
						for(var i=0; i<aOrigEvents.length; i++){
							jQuery.event.remove(this, aOrigEvents[i], fHandler);
						}
					}
				};
			};

			createSimulatedTouch("touchstart", ["mousedown"]);
			createSimulatedTouch("touchend", ["mouseup", "mouseout"]);
			createSimulatedTouch("touchmove", ["mousemove"]);
		}

		if(jQuery.sap.touchEventMode != "OFF"){
			jQuery.sap.require("sap.ui.thirdparty.jquery-mobile-custom");

			//Define additional jQuery Mobile events to be added to the event list
			//TODO taphold cannot be used (does not bubble / has no target property) -> Maybe provide own solution
			// IMPORTANT: update the public documentation when extending this list
			aAdditionalControlEvents.push("swipe", "tap", "swipeleft", "swiperight", "scrollstart", "scrollstop");

			//Define additional pseudo events to be added to the event list
			aAdditionalPseudoEvents.push({sName: "swipebegin", aTypes: ["swipeleft", "swiperight"], fnCheck: function (oEvent) {
				var bRtl = sap.ui.getCore().getConfiguration().getRTL();
				return (bRtl && oEvent.type === "swiperight") || (!bRtl && oEvent.type === "swipeleft");
			}});
			aAdditionalPseudoEvents.push({sName: "swipeend", aTypes: ["swipeleft", "swiperight"], fnCheck: function (oEvent) {
				var bRtl = sap.ui.getCore().getConfiguration().getRTL();
				return (!bRtl && oEvent.type === "swiperight") || (bRtl && oEvent.type === "swipeleft");
			}});

			//Add all defined events to the event infrastructure
			jQuery.sap.ControlEvents = jQuery.sap.ControlEvents.concat(aAdditionalControlEvents);

			for(var i=0; i<aAdditionalPseudoEvents.length; i++){
				jQuery.sap.PseudoEvents[aAdditionalPseudoEvents[i].sName] = aAdditionalPseudoEvents[i];
				PSEUDO_EVENTS.push(aAdditionalPseudoEvents[i].sName);
			}
		}
	}());


	/**
	 * Function for initialization of an Array containing all basic event types of the available pseudo events.
	 * @private
	 */
	function initPseudoEventBasicTypes(){
		var mEvents = jQuery.sap.PseudoEvents;
		var aResult = [];
		for (var sName in mEvents) {
			if (mEvents[sName].aTypes) {
				for (var j = 0, js = mEvents[sName].aTypes.length; j < js; j++) {
					var sType = mEvents[sName].aTypes[j];
					if (jQuery.inArray(sType, aResult) == -1) {
						aResult.push(sType);
					}
				}
			}
		}
		return aResult;
	}

	/**
	 * Array containing all basic event types of the available pseudo events.
	 * @private
	 */
	var PSEUDO_EVENTS_BASIC_TYPES = initPseudoEventBasicTypes();

	/**
	 * Convenience method to check an event for a certain combination of modifier keys
	 * @private
	 */
	function checkModifierKeys(oEvent, bCtrlKey, bAltKey, bShiftKey) {
		return oEvent.shiftKey == bShiftKey && oEvent.altKey == bAltKey && getCtrlKey(oEvent) == bCtrlKey;
	}

	/**
	 * Convenience method to check an event for any modifier key
	 * @private
	 */
	function hasModifierKeys(oEvent) {
		return oEvent.shiftKey || oEvent.altKey || getCtrlKey(oEvent);
	}

	/**
	 * Convenience method for handling of Ctrl key, meta key etc.
	 * @private
	 */
	function getCtrlKey(oEvent) {
		return !!(oEvent.metaKey || oEvent.ctrlKey); // double negation doesn't have effect on boolean but ensures null and undefined are equivalent to false.
	}


	/**
	 * Returns an array of names (as strings) identifying {@link jQuery.sap.PseudoEvents} that are fulfilled by this very Event instance.
	 * @returns {String[]} Array of names identifying {@link jQuery.sap.PseudoEvents} that are fulfilled by this very Event instance.
	 * @public
	 */
	jQuery.Event.prototype.getPseudoTypes = function() {
		var aPseudoTypes = [];
		if (jQuery.inArray(this.type, PSEUDO_EVENTS_BASIC_TYPES) != -1) {
			var aPseudoEvents = PSEUDO_EVENTS;
			var ilength = aPseudoEvents.length;
			var oPseudo = null;
			for(var i=0; i<ilength; i++){
				oPseudo = jQuery.sap.PseudoEvents[aPseudoEvents[i]];
				if(oPseudo.aTypes
						&& jQuery.inArray(this.type, oPseudo.aTypes) > -1
						&& oPseudo.fnCheck
						&& oPseudo.fnCheck(this)){
					aPseudoTypes.push(oPseudo.sName);
				}
			}
		}

		this.getPseudoTypes = function(){return aPseudoTypes.slice();};

		return aPseudoTypes.slice();
	};

	/**
	 * Checks whether this instance of {@link jQuery.Event} is of the given <code>sType</code> pseudo type.
	 * @param {string} sType The name of the pseudo type this event should be checked for.
	 * @returns {boolean} <code>true</code> if this instance of jQuery.Event is of the given sType, <code>false</code> otherwise.
	 * @public
	 */
	jQuery.Event.prototype.isPseudoType = function(sType) {
		var aPseudoTypes = this.getPseudoTypes();
		if ( sType ) {
			return jQuery.inArray(sType, aPseudoTypes) > -1;
		} else {
			return aPseudoTypes.length > 0;
		}
	};


	/*
	 * store reference to original preventDefault method
	 */
	var _preventDefault = jQuery.Event.prototype.preventDefault;
	/*
	 * and introduce some keyCode fixing for IE...
	 * this e.g. suppresses the address-field drop down opening in case of sapshow (i.e. F4) in ComboBoxes
	 */
	jQuery.Event.prototype.preventDefault = function() {
		_preventDefault.apply(this, arguments);

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		if ( e.keyCode != 0 ) {
			try { // Sometimes setting keycode results in "Access Denied"
				if(!jQuery.browser.mozilla) {
					e.keyCode = 0;
				}
			} catch(ex) {}
		}

	};


	/**
	 * Binds all events for listening with the given callback function
	 * @param {function} fnCallback Callback function
	 * @public
	 */
	jQuery.sap.bindAnyEvent = function bindAnyEvent(fnCallback) {
		if (fnCallback) {
			jQuery(document).bind(jQuery.sap.ControlEvents.join(" "), fnCallback);
		}
	};

	/**
	 * Unbinds all events for listening with the given callback function
	 * @param {function} fnCallback Callback function
	 * @public
	 */
	jQuery.sap.unbindAnyEvent = function unbindAnyEvent(fnCallback) {
		if (fnCallback) {
			jQuery(document).unbind(jQuery.sap.ControlEvents.join(" "), fnCallback);
		}
	};

	/**
	 * Checks a given mouseover or mouseout event whether it is
	 * equivalent to a mouseenter or mousleave event regarding the given DOM reference.
	 * @param {jQuery.Event} oEvent
	 * @param {element} oDomRef
	 * @public
	 */
	jQuery.sap.checkMouseEnterOrLeave = function checkMouseEnterOrLeave(oEvent, oDomRef) {
		if(oEvent.type != "mouseover" && oEvent.type != "mouseout") {
			return false;
		}

		var isMouseEnterLeave = false;
		var element = oDomRef;
		var parent = oEvent.relatedTarget;
		try {
			while ( parent && parent !== element ) {
				parent = parent.parentNode;
			}
			if ( parent !== element ) {
				isMouseEnterLeave = true;
			}
		} catch(e) { }

		return isMouseEnterLeave;
	};

	/**
	 * Constructor for a jQuery.Event object.<br/>
	 * @see "http://www.jquery.com" and "http://api.jquery.com/category/events/event-object/".
	 *
	 * @class Check the jQuery.Event class documentation available under "http://www.jquery.com"<br/>
	 * and "http://api.jquery.com/category/events/event-object/" for details.
	 *
	 * @name jQuery.Event
	 * @public
	 */

	/**
	 * Returns OffsetX of Event. In jQuery there is a bug. In IE the value is in offsetX, in FF in layerX
	 * @returns offsetX
	 * @public
	 */
	jQuery.Event.prototype.getOffsetX = function() {

		if (this.type == 'click'){
			if (this.offsetX){
				return this.offsetX;
			}
			if (this.layerX){
				return this.layerX;
			}
			if (this.originalEvent.layerX){
				return this.originalEvent.layerX;
			}
		}
		// nothing defined -> offset = 0
		return 0;
	};

	/**
	 * Returns OffsetY of Event. In jQuery there is a bug. in IE the value is in offsetY, in FF in layerY
	 * @returns offsetY
	 * @public
	 */
	jQuery.Event.prototype.getOffsetY = function() {

		if (this.type == 'click'){
			if (this.offsetY){
				return this.offsetY;
			}
			if (this.layerY){
				return this.layerY;
			}
			if (this.originalEvent.layerY){
				return this.originalEvent.layerY;
			}
		}
		// nothing defined -> offset = 0
		return 0;
	};

	
	// we still call the original stopImmediatePropagation
	var fnStopImmediatePropagation = jQuery.Event.prototype.stopImmediatePropagation;
	
	/*
	 * PRIVATE EXTENSION: allows to immediately stop the propagation of events in
	 * the event handler execution - means that "before" delegates can stop the 
	 * propagation of the event to other delegates or the element and so on. 
	 * @see sap.ui.core.Element.prototype._callEventHandles 
	 * @param {boolean} bStopDelegate
	 */
	jQuery.Event.prototype.stopImmediatePropagation = function(bStopHandlers) {

		// execute the original function
		fnStopImmediatePropagation.apply(this, arguments);

		// only set the stop handlers flag if it is wished...
		if (bStopHandlers) {
			this._bIsStopHandlers = true;
		}
		
	};

	/*
	 * PRIVATE EXTENSION: check if the handler propagation has been stopped
	 * @see sap.ui.core.Element.prototype._callEventHandles 
	 */
	jQuery.Event.prototype.isImmediateHandlerPropagationStopped = function() {
			return !!this._bIsStopHandlers;
	}

}());

}; // end of jquery.sap.events

if ( !jQuery.sap.isDeclared('jquery.sap.mobile') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

//Provides common helper functions for the mobile version of UI5 
jQuery.sap.declare("jquery.sap.mobile");



(function( $ ) {
	var FAKE_OS_PATTERN = /(?:\?|&)sap-ui-xx-fakeOS=([^&]+)/;

	// OS overriding mechanism
	if (jQuery.browser.webkit && !jQuery.support.touch) { // on non-touch webkit browsers we are interested in overriding
		var result = document.location.search.match(FAKE_OS_PATTERN);
		var resultUA = result && result[1] || jQuery.sap.byId("sap-ui-bootstrap").attr("data-sap-ui-xx-fakeOS");
		if (resultUA) {
			var ua = { // for "ios"/"android"/"blackberry" we have defined fake user-agents; these will affect all other browser/platform detection mechanisms
					ios: "Mozilla/5.0 (iPhone; CPU iPhone OS 5_0_1 like Mac OS X) AppleWebKit/534.48 (KHTML, like Gecko) Version/5.1 Mobile/9A406 Safari/7534.48.3",
					iphone: "Mozilla/5.0 (iPhone; CPU iPhone OS 5_0_1 like Mac OS X) AppleWebKit/534.48 (KHTML, like Gecko) Version/5.1 Mobile/9A406 Safari/7534.48.3",
					ipad: "Mozilla/5.0 (iPad; CPU OS 5_1_1 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Mobile/9B206",
					android: "Mozilla/5.0 (Linux; U; Android 4.0.3; en-us; GT-I9100 Build/IML74K) AppleWebKit/534.46 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.46",
					android_phone: "Mozilla/5.0 (Linux; U; Android 4.0.3; en-us; GT-I9100 Build/IML74K) AppleWebKit/534.46 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.46",
					android_tablet: "Mozilla/5.0 (Linux; Android 4.1.2; Nexus 7 Build/JZ054K) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19",
					blackberry: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
					blackberry10: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+"
			}[resultUA];

			if (ua) {
				// code for modifying the real user-agent
				if (jQuery.browser.safari) {
					var __originalNavigator = window.navigator;
					window.navigator = new Object();
					window.navigator.__proto__ = __originalNavigator;
					window.navigator.__defineGetter__('userAgent', function(){ return ua; });

				} else { // Chrome - we have already verified we have a webkit browser
					window.navigator.__defineGetter__('userAgent', function(){ return ua; });
				}

				// all downstream checks will be fine with the faked user-agent. Now we also need to adjust the wrong upstream settings in jQuery:
				jQuery.browser.msie = jQuery.browser.opera = jQuery.browser.mozilla = false;
				jQuery.browser.webkit = true;
				jQuery.browser.version = "534.46"; // this is not exactly true for all UAs, but there are much bigger shortcomings of this approach than a minor version of the browser, so giving the exact value is not worth the effort
			}
		}
	}

	// OS detection
	function getOS(userAgent) {
		userAgent = userAgent || navigator.userAgent;
		var platform = /\(([a-zA-Z ]+);\s(?:[U]?[;]?)([\D]+)((?:[\d._]*))(?:.*[\)][^\d]*)([\d.]*)\s/;
		var result = userAgent.match(platform);
		if (result) {
			var appleDevices = /iPhone|iPad|iPod/;
			var bbDevices = /PlayBook|BlackBerry/;
			if (result[0].match(appleDevices)){
				result[3] = result[3].replace(/_/g, ".");
				//result[1] contains info of devices
				return({os:"ios", version:result[3]});
			} else if (result[2].match(/Android/)) {
				result[2] = result[2].replace(/\s/g, "");
				return({os:"android", version:result[3]});
			} else if (result[0].match(bbDevices)) {
				return({os:"blackberry", version:result[4]});
			} else {
				// currently we only support iOS, Android, BlackBerry 10.0+ , everything else will be ignored, if more platforms should be supported, logic can be placed here
				return;
			}
			
		} else if (userAgent.indexOf("(BB10;") > 0) { 
			// BlackBery 10 has a different structure...
			platform = /\sVersion\/([\d.]+)\s/;
			result = userAgent.match(platform);
			if (result){
				return {os: "blackberry", version:result[1]};
			} else {
				return {os: "blackberry", version:10};
			}
			
		} else {
			// Windows phone has a different structure, so we need to check with another regExp.
			platform = /Windows Phone (?:OS )?([\d.]*)/;
			result = userAgent.match(platform);
			if (result){
				return {os: "winphone", version:result[1]};
			} else {
				return;
			}
		}
	}

	var os = getOS() || {};
	var $window = $(window);

	if (os.os) {
		var f = parseFloat(os.version);

		/**
		 * Holds information about the current operating system
		 * 
		 * @name jQuery.os
		 * @namespace
		 * @public
		 */
		$.os = $.extend(/** @lends jQuery.os */ {
			/**
			 * The name of the operating system; currently supported are: "ios", "android", "blackberry"
			 * @type {string}
			 * @public
			 */
			os: os.os,
			/**
			 * The version of the operating system as a string (including minor versions)
			 * @type {string}
			 * @public
			 */
			version: os.version,
			/**
			 * The version of the operating system parsed as a float (major and first minor version)
			 * @type {float}
			 * @public
			 */
			fVersion: f
		}, $.os);
		$.os[os.os] = true;
		/**
		 * Whether the current operating system is Android
		 * @type {boolean}
		 * @public
		 * @name jQuery.os.android
		 */
		/**
		 * Whether the current operating system is BlackBerry
		 * @type {boolean}
		 * @public
		 * @name jQuery.os.blackberry
		 */
		/**
		 * Whether the current operating system is Apple iOS
		 * @type {boolean}
		 * @public
		 * @name jQuery.os.ios
		 */
	} else {
		if (!$.os) $.os = {};
	}

	// feature and state detection
	$.extend( $.support, {
		/**
		 * Whether the device has a retina display (window.devicePixelRatio >= 2)
		 * @type {boolean}
		 * @public 
		 */
		retina: window.devicePixelRatio >= 2
	});

	function isLandscape(){
		if(jQuery.sap.touchEventMode === "ON"){
			//if runs in real device, landscape/portrait is decided by the window.orientation
			//we can't simply compare the width and height on window because when keyboard is open in android, it makes the window smaller which can turn a device from portrait to landscape, for example in Nexus 7
			//because the height may get smaller than the width when keyboard opens.
			return window.orientation === undefined || window.orientation === 90 || window.orientation === -90;
		}else{
			return $window.width() > $window.height();
		}
	}

	var landscape = isLandscape();
	var android_phone = (/(?=android)(?=.*mobile)/i.test(navigator.userAgent));
	/**
	 * @name jQuery.device
	 * @namespace
	 * @public
	 */
	$.device = $.extend({}, $.device);

	/**
	 * Holds information about the current device and its state
	 * 
	 * @name jQuery.device.is
	 * @namespace
	 * @public
	 */
	$.device.is = $.extend( /** @lends jQuery.device.is */ {
		/**
		 * Whether the application runs in standalone mode without browser UI (launched from the iOS home screen)
		 * @type {boolean}
		 * @public 
		 */
		standalone: window.navigator.standalone,
		/**
		 * Whether the device is in "landscape" orientation (also "true" when the device does not know about the orientation)
		 * @type {boolean}
		 * @public 
		 */
		landscape: landscape,
		/**
		 * Whether the device is in portrait orientation
		 * @type {boolean}
		 * @public 
		 */
		portrait: !landscape,
		/**
		 * Whether the application runs on an iPhone
		 * @type {boolean}
		 * @public 
		 */
		iphone: /iphone/i.test(navigator.userAgent),
		/**
		 * Whether the application runs on an iPad
		 * @type {boolean}
		 * @public 
		 */
		ipad: /ipad/i.test(navigator.userAgent),
		/**
		 * Whether the application runs on an Android phone
		 * https://developers.google.com/chrome/mobile/docs/user-agent
		 * Some device vendors however do not follow this rule
		 * @type {boolean}
		 * @public
		 */
		android_phone: android_phone,
		/**
		 * Whether the application runs on an Android tablet
		 * https://developers.google.com/chrome/mobile/docs/user-agent
		 * Some device vendors however do not follow this rule
		 * @type {boolean}
		 * @public
		 */
		android_tablet: (!!$.os.android && !android_phone)
	},$.device.is);

	$(window).bind("resize", function(){
		var landscape = isLandscape(); 
		$.device.is.landscape = landscape;
		$.device.is.portrait = !landscape;
	});
	
	var tablet = (function(){
		if($.os.ios){
			return $.device.is.ipad;
		}else{
			//this is how android distinguishes between tablet and phone
			//http://android-developers.blogspot.de/2011/07/new-tools-for-managing-screen-sizes.html
			if(jQuery.sap.touchEventMode === "ON"){
				//in real mobile device
				return (Math.min(window.screen.width / window.devicePixelRatio, window.screen.height / window.devicePixelRatio) >= 600);
			}else{
				//in desktop browser
				//return (Math.min($window.width(), $window.height()) >= 600);
				return $.device.is.android_tablet;
			}
		}
	}());

	$.device.is = $.extend( /** @lends jQuery.device.is */ { 
		/**
		 * Whether the running device is a tablet. If the desktop browser runs with URL parameter sap-ui-xx-fakeOS or sap-ui-xx-test-mobile, this property will also be set according to the window size.
		 * This property will be false when runs in desktop browser without touch support. 
		 * This property will only be set once when the application starts up, and it won't be updated when the window resizes in a touch enabled desktop browser.
		 * @type {boolean}
		 * @public
		 */
		tablet: tablet && ($.sap.touchEventMode !== "OFF"),
		/**
		 * Whether the running device is a phone. If the desktop browser runs with URL parameter sap-ui-xx-fakeOS or sap-ui-xx-test-mobile, this property will also be set according to the window size.
		 * This property will be false when runs in desktop browser without touch support. 
		 * This property will only be set once when the application starts up, and it won't be updated when the window resizes in a touch enabled desktop browser.
		 * @type {boolean}
		 * @public
		 */
		phone: !tablet && ($.sap.touchEventMode !== "OFF"),
		/**
		 * Whether the running device is a desktop browser without touch support.
		 * @type {boolean}
		 * @public
		 */
		desktop: ($.sap.touchEventMode === "OFF")
	}, $.device.is);

	var _bInitMobileTriggered = false;

	/**
	 * Does some basic modifications to the HTML page that make it more suitable for mobile apps.
	 * The "options" parameter configures what exactly should be done.
	 *  
	 * It can have the following properties:
	 * <ul>
	 * <li>viewport: whether to set the viewport in a way that disables zooming (default: true)</li>
	 * <li>statusBar: the iOS status bar color, "default", "black" or "black-translucent" (default: "default")</li>
	 * <li>hideBrowser: whether the browser UI should be hidden as far as possible to make the app feel more native (default: true)</li>
	 * <li>preventScroll: whether native scrolling should be disabled in order to prevent the "rubber-band" effect where the whole window is moved (default: true)</li>
	 * <li>rootId: the ID of the root element that should be made fullscreen; only used when hideBrowser is set (default: the document.body)</li>
	 * <li>useFullScreenHeight: a boolean that defines whether the height of the html root element should be set to 100%, which is required for other elements to cover the full height (default: true)</li>
	 * <li>homeIcon: The icon to be displayed on the home screen of iOS devices after the user does "add to home screen" (default: no icon).
	 *     This icon must be in PNG format. The property can either hold the URL of one single icon which is used for all devices (and possibly scaled, 
	 *     which looks not perfect), or an object holding icon URLs for the different required sizes; one example is:
	 *     <pre>
	 *     {
	 *        'phone':'phone-icon.png',
	 *        'phone@2':'phone-retina.png',
	 *        'tablet':'tablet-icon.png',
	 *        'tablet@2':'tablet-retina.png'
	 *     }
	 *     </pre>
	 *     The respective image sizes are 57/114 px for the phone and 72/144 px for the tablet. If an object is given but the required size is missing 
	 *     from the object, the largest given URL will be used.</li>
	 * <li>homeIconPrecomposed: whether the home icon already has some glare effect (otherwise iOS will add it) (default: false)</li>
	 * </ul>
	 * 
	 * @param {object}  [options] configures what exactly should be done
	 * @param {boolean} [options.viewport=true] whether to set the viewport in a way that disables zooming
	 * @param {string}  [options.statusBar='default'] the iOS status bar color, "default", "black" or "black-translucent"
	 * @param {boolean} [options.hideBrowser=true] whether the browser UI should be hidden as far as possible to make the app feel more native
	 * @param {boolean} [options.preventScroll=true] whether native scrolling should be disabled in order to prevent the "rubber-band" effect where the whole window is moved
	 * @param {string}  [options.rootId] the ID of the root element that should be made fullscreen; only used when hideBrowser is set. If not set, the body is used
	 * @param {boolean} [options.useFullScreenHeight=true] whether the height of the html root element should be set to 100%, which is required for other elements to cover the full height 
	 * @param {string}  [options.homeIcon=undefined] The icon to be displayed on the home screen of iOS devices after the user does "add to home screen".
	 * @param {boolean} [options.homeIconPrecomposed=false] whether the home icon already has some glare effect (otherwise iOS will add it) 
	 * 
	 * @name jQuery.sap.initMobile
	 * @function
	 * @public
	 */
	$.sap.initMobile = function(options) {
		if (!_bInitMobileTriggered) { // only one initialization per HTML page
			_bInitMobileTriggered = true;

			options = $.extend({}, { // merge in the default values
				viewport: true,
				statusBar: "default",
				hideBrowser: true,
				preventScroll: true,
				useFullScreenHeight: true,
				homeIconPrecomposed: false
			}, options);

			$(function() {
				var $head = $("head");

				// initialize viewport
				if (options.viewport) {
					if ($.device.is.iphone && (Math.max(window.screen.height, window.screen.width) === 568)) {
						// iPhone 5
						$head.append($('<meta name="viewport" content="user-scalable=0, initial-scale=1.0">'));
					} else if ($.os.android && $.os.fVersion < 3){
						$head.append($('<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">'));
					} else {
						// all other devices
						$head.append($('<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">'));
					}
				}

				if ($.os.ios) {
					// enable fullscreen when possible
					$head.append($('<meta name="apple-mobile-web-app-capable" content="yes">')); // since iOS 2.1

					// set the status bar style on Apple devices
					$head.append($('<meta name="apple-mobile-web-app-status-bar-style" content="' + options.statusBar + '">')); // "default" or "black" or "black-translucent", since iOS 2.1

					// splash screen
					//<link rel="apple-touch-startup-image" href="/startup.png">

				} else if ($.browser.msie) {
					$head.append($('<meta http-equiv="cleartype" content="on">'));
				}

				// Home Icon (also working in Android depending on version and other circumstances)
				var icon = options.homeIcon;
				if (icon) {
					var precomposed = options.homeIconPrecomposed ? "-precomposed" : "";
					if (typeof icon === "string") { // case 1: one home icon to rule them all
						$head.append($('<link rel="apple-touch-icon' + precomposed + '" href="' + icon + '">'));

					} else if (typeof icon === "object") { // case 2: a config object with optimized home icons for different devices
						var getBestIcon = function(res) {
							return icon[res] || icon['tablet@2'] || icon['phone@2'] || icon['phone'] || icon['tablet']; // fallback logic
						};
						var requiredSize = ($.device.is.ipad ? "tablet" : "phone") + ($.support.retina ?  "@2": "");
						var size = ($.device.is.ipad ? 72 : 57) * ($.support.retina ?  2 : 1);
						var sizes = (size === 57) ? '' : 'sizes="' + size + 'x' + size + '"';
						$head.append($('<link rel="apple-touch-icon"' + precomposed + ' ' + sizes + ' href="' + getBestIcon(requiredSize) + '">'));
					}
				}

				// hide browser address bar
				if (options.hideBrowser && !jQuery.browser.msie) {
					/*var hideAddressBar = function() {
						document.body.style.height = (window.outerHeight + 120) + 'px'; // must be large enough to scroll out

						window.setTimeout(function(){
							window.scrollTo(0, 1); 
							var $root = options.rootId ? $.sap.byId(options.rootId) : $(document.body); // TODO: does body work?
							var height = window.innerHeight  + "px";
							$root.css("height", height);
						}, 0);
					};*/

					//	$(window)
					//		.bind("load", hideAddressBar)
					//		.bind("resize", hideAddressBar); // this one helps iOS, but only AFTER initial loading
					//.bind("orientationchange", hideAddressBar) // this one does not seem to be required
				}

				if (options.preventScroll) {
					$(window).bind("touchmove", function sapInitMobileTouchMoveHandle(oEvent){
						if (!oEvent.isDefaultPrevented()) {
							oEvent.preventDefault();	// this one prevents the rubber-band effect - and disables native scrolling
						}
					});
				}

				if (options.useFullScreenHeight) {
					$(function() {
						document.documentElement.style.height = "100%"; // set html root tag to 100% height
					});
				}
			});

			// platform depending checks to show mobile support message
			$(function() {
				var bShowSupportMessage = false;
				var sSupportMessage = "";
				var sPopupWidth = "240px";
				var iTimeOut = 3000;

				var getRB = sap.ui.getCore().getLibraryResourceBundle;

				// check mobile devices
				if (jQuery.device.is.ipad ||
						jQuery.device.is.iphone ||
						jQuery.os.os == "android" ||
						jQuery.os.os == "blackberry" ||
						jQuery.os.os == "winphone") {

					// check OS version
					if ((jQuery.os.ios && jQuery.os.fVersion < 5) ||
							(jQuery.os.android && jQuery.os.fVersion < 2.3) ||
							(jQuery.os.blackberry && jQuery.os.fVersion < 10) ||
							(jQuery.os.winphone) ||
							(!jQuery.browser.webkit)) { 
						bShowSupportMessage = true;
						sSupportMessage = getRB("sap.ui.core").getText("MOBILE_SUPPORT_MESSAGE_DEVICE", [jQuery.os.os, jQuery.os.fVersion]);
					}

					// check browser
				} else {

					// check if browser is webkit-based
					if (!jQuery.browser.webkit){
						sPopupWidth = "auto";
						bShowSupportMessage = true;
						sSupportMessage = getRB("sap.ui.core").getText("MOBILE_SUPPORT_MESSAGE_BROWSER");

					} else {
						// show message only if no URL parameter is set
						var result = window.location.search.match(FAKE_OS_PATTERN);
						var resultUA = result && result[1] || jQuery.sap.byId("sap-ui-bootstrap").attr("data-sap-ui-xx-fakeOS");
						if (!resultUA || (
								resultUA !== "ios" &&
								resultUA !== "iphone" && 
								resultUA !== "ipad" && 
								resultUA !== "android" && 
								resultUA !== "android_tablet" &&
								resultUA !== "android_phone" && 
								resultUA !== "blackberry")) {
							sPopupWidth = "480px";
							iTimeOut = 5000;
							bShowSupportMessage = true;
							sSupportMessage = getRB("sap.ui.core").getText("MOBILE_SUPPORT_MESSAGE_URL_PARAM");
						}

					}

				}

				if (bShowSupportMessage) {

					jQuery.sap.require("sap.ui.core.Popup");

					var oHtml = new sap.ui.core.HTML("mSAPUI5SupportMessage", {
						content: "<div id=\"mSAPUI5SupportMessage\"" +
						"style=\"" +
						"background-color:white;" +
						"border:solid 1px #cccccc;" +
						"border-radius:0.3125em;" +
						"-webkit-border-radius:0.3125em;" +
						"padding:0.3125em;" +
						"text-align:center;" +
						"width:" + sPopupWidth +
						"\"" +
						"tabindex=\"0\">" +
						"<img src=\"" + sap.ui.resource("sap.ui.core", "mimes/logo/icotxt_white_220x72.png") + "\"\>" +
						"<br>" +
						"<span style=\"color:#ff0000;\">" + sSupportMessage + "</span>" +
						"<br>" +
						"</div>"
					});

					var oPopup = new sap.ui.core.Popup(oHtml, false, true, false);

					window.setTimeout(function() {
						if(oPopup) {
							oPopup.open(0, "center center", "center center", document.body);
						}
					}, 0);

					window.setTimeout(function() {
						if(oPopup) {
							oPopup.close();
						}
					}, iTimeOut);

				}
			});

		}
	};

})( jQuery );

}; // end of jquery.sap.mobile

if ( !jQuery.sap.isDeclared('jquery.sap.properties') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides access to Java-like properties files
jQuery.sap.declare("jquery.sap.properties");
if ( !jQuery.sap.isDeclared('jquery.sap.sjax') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

/*
 * Provides convenience functions for synchronous communication, based on the jQuery.ajax() function.
 */
jQuery.sap.declare("jquery.sap.sjax", false);

(function() {

	jQuery.sap.sjaxSettings = {
		/**
		 * Whether to return an object consisting of data and status and error codes or only the simple data
		 */
		complexResult: true,

		/**
		 * fallback value when complexResult is set to false and an error occurred. Then fallback will be returned.
		 */
		fallback: undefined
	};

	/**
	 * Convenience wrapper around <code>jQuery.ajax()</code> that avoids the need for callback functions when
	 * synchronous calls are made. If the setting <code>complexResult</code> is true (default), then the return value
	 * is an object with the following properties
	 * <ul>
	 * <li><code>success</code> boolean whether the call succeeded or not
	 * <li><code>data</code> any the data returned by the call. For dataType 'text' this is a string,
	 *                       for JSON it is an object, for XML it is a document. When the call failed, then data is not defined
	 * <li><code>status</code> string a textual status ('success,', 'error', 'timeout',...)
	 * <li><code>statusCode</code> string the HTTP status code of the request
	 * <li><code>error</code> Error an error object (exception) in case an error occurred
	 * </ul>
	 *
	 * When <code>complexResult</code> is false, then in the case of success, only 'data' is returned, in case of an error the
	 * 'fallback' setting is returned (defaults to undefined).
	 *
	 * Note that async=false is always enforced by this method.
	 *
	 * @param {String} oOrigSettings the ajax() settings
	 * @return result, see above
	 *
	 * @public
	 * @since 0.9.0
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.sjax = function sjax(oOrigSettings) {

		var s = jQuery.extend(true, {}, jQuery.sap.sjaxSettings, oOrigSettings,

			// the following settings are enforced as this is the rightmost object in the extend call
			{
				async: false,
				success : function(data, textStatus, xhr) {
//					oResult = { success : true, data : data, status : textStatus, statusCode : xhr.status };
					oResult = { success : true, data : data, status : textStatus, statusCode : xhr&&xhr.status };
				},
				error : function(xhr, textStatus, error) {
					oResult = { success : false, data : undefined, status : textStatus, error : error, statusCode : xhr.status };
				}
			});

		var oResult = undefined;

		jQuery.ajax(s);

		if (!s.complexResult) {
			return oResult.success ? oResult.data : s.fallback;
		}

		return oResult;
	};

	/**
	 * Convenience wrapper that checks whether a given web resource could be accessed.
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 * @SecSource {return} Returned value is under control of an external resource
	 */
	jQuery.sap.syncHead = function(sUrl) {
		return jQuery.sap.sjax({type:'HEAD', url: sUrl}).success;
	};

	/**
	 * Convenience wrapper for {@link jQuery.sap.sjax} that enforeces the Http method GET and defaults the
	 * data type of the result to 'text'.
	 *
	 * @param {String} sUrl the URL
	 * @param {String|object} data request parameters in the format accepted by jQuery.ajax()
	 * @param {String} [sDataType='text'] the type of data expected from the server, default is "text"
	 * @return result @see jQuery.sap.sjax
	 *
	 * @public
	 * @since 0.9.0
	 * @SecSink {0 1|PATH} Parameter is used for future HTTP requests
	 * @SecSource {return} Returned value is under control of an external resource
	 */
	jQuery.sap.syncGet = function syncGet(sUrl, data, sDataType) {
		return jQuery.sap.sjax({
			url: sUrl,
			data: data,
			type: 'GET',
			dataType: sDataType || 'text'
		});
	};

	/**
	 * Convenience wrapper for {@link jQuery.sap.sjax} that enforces the Http method POST and defaults the
	 * data type of the result to 'text'.
	 *
	 * @param {String} sUrl the URL
	 * @param {String|object} data request parameters in the format accepted by jQuery.ajax()
	 * @param {String} [sDataType='text'] the type of data expected from the server, default is "text"
	 * @return result @see jQuery.sap.sjax
	 *
	 * @public
	 * @since 0.9.0
	 * @SecSink {0 1|PATH} Parameter is used for future HTTP requests
	 * @SecSource {return} Returned value is under control of an external resource
	 */
	jQuery.sap.syncPost = function syncPost(sUrl, data, sDataType) {
		return jQuery.sap.sjax({
			url: sUrl,
			data: data,
			type: 'POST',
			dataType: sDataType || 'text'
		});
	};

	/**
	 * Convenience wrapper for {@link jQuery.sap.sjax} that enforces the Http method GET and the data type 'text'.
	 * If a fallback value is given, the function simply returns the response as a text or - if some error occurred -
	 * the fallback value. This is useful for applications that don't require detailed error diagnostics.
	 *
	 * If applications need to know about occurring errors, they can either call <code>sjax()</code> directly
	 * or they can omit the fallback value (providing only two parameters to syncGetText()).
	 * They then receive the same complex result object as for the sjax() call.
	 *
	 * @param {String} sUrl the URL
	 * @param {String|object} data request parameters in the format accepted by jQuery.ajax()
	 * @param {String} [fallback] if set, only data is returned (and this fallback instead in case of errors); if unset, a result structure is returned
	 * @return  result @see jQuery.sap.sjax
	 *
	 * @public
	 * @since 0.9.0
	 * @SecSink {0 1|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.syncGetText = function syncGetText(sUrl, data, fallback) {
		return jQuery.sap.sjax({
			url: sUrl,
			data: data,
			type: 'GET',
			dataType: 'text',
			fallback: fallback,
			complexResult : (arguments.length < 3)
		});
	};

	/**
	 * Convenience wrapper for {@link jQuery.sap.sjax} that enforces the Http method GET and the data type 'json'.
	 * If a fallback value is given, the function simply returns the response as an object or - if some error occurred -
	 * the fallback value. This is useful for applications that don't require detailed error diagnostics.
	 *
	 * If applications need to know about occurring errors, they can either call <code>sjax()</code> directly
	 * or they can omit the fallback value (providing only two parameters to syncGetJSON()).
	 * They then receive the same complex result object as for the sjax() call.
	 *
	 * Note that providing "undefined" or "null" as a fallback is different from omitting the fallback (complex result).
	 *
	 * @param {String} sUrl the URL
	 * @param {String|object} data request parameters in the format accepted by jQuery.ajax()
	 * @param {object} [fallback] if set, only data is returned (and this fallback instead in case of errors); if unset, a result structure is returned
	 * @return result @see jQuery.sap.sjax
	 *
	 * @public
	 * @since 0.9.0
	 * @SecSink {0 1|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.syncGetJSON = function syncGetJSON(sUrl, data, fallback) {
		return jQuery.sap.sjax({
			url: sUrl,
			data: data || null,
			type: 'GET',
			dataType: 'json',
			fallback: fallback,
			complexResult : (arguments.length < 3)
		});
	};

}());
}; // end of jquery.sap.sjax


(function() {

	// Javadoc for private inner class "Properties" - this list of comments is intentional!
	/**
	 * @interface  Represents a list of properties (key/value pairs).
	 *
	 * Each key and its corresponding value in the property list is a string.
	 * Values are unicode escaped \ue0012.
	 * Keys are case-sensitive and only alpha-numeric characters with a leading character are allowed.
	 *
	 * Use {@link jQuery.sap.properties} to create an instance of jQuery.sap.util.Properties.
	 *
	 * The getProperty method is used to retrieve a value from the list.
	 * The setProperty method is used to store or change a property in the list.
	 * Additionally, the getKeys method can be used to retrieve an array of all keys that are
	 * currently in the list.
	 *
	 * @author SAP AG
	 * @version 1.10.0
	 * @since 0.9.0
	 * @name jQuery.sap.util.Properties
	 * @public
	 */
	/**
	 * Returns the value of a given key. Optionally, a given default value is returned if the requested key is not in the list.
	 * @param {string} sKey The key of the property
	 * @param {string} [sDefaultValue] Optional, the default value if the requested key is not in the list.
	 * @return {string} The value of a given key. The default value (if given) is returned if the requested key is not in the list.
	 *
	 * @function
	 * @name jQuery.sap.util.Properties.prototype.getProperty
	 */
	/**
	 * Returns an array of all keys in the property list.
	 * @return {array} All keys in the property list.
	 *
	 * @function
	 * @name jQuery.sap.util.Properties.prototype.getKeys
	 */
	/**
	 * Adds or changes a given key to/in the list.
	 * @param {string} sKey The key of the property
	 * @param {string} sValue The value for the key with unicode encoding.
	 *
	 * @function
	 * @name jQuery.sap.util.Properties.prototype.setProperty
	 */
	/**
	 * Creates and returns a clone of the property list.
	 * @return {jQuery.sap.util.Properties} A clone of the property list
	 *
	 * @function
	 * @name jQuery.sap.util.Properties.prototype.clone
	 */

	/*
	 * Implements jQuery.sap.util.Properties
	 */
	var Properties = function() {
		this.mProperties = {};
		this.aKeys = [];
	};

	/*
	 * Implements jQuery.sap.util.Properties.prototype.getProperty
	 */
	Properties.prototype.getProperty = function(sKey, sDefaultValue) {
		var sValue = this.mProperties[sKey];
		if (typeof(sValue)=="string") {
			return sValue;
		}
		else if(sDefaultValue) {
			return sDefaultValue;
		}
		return null;
	};

	/*
	 * Implements jQuery.sap.util.Properties.prototype.getKeys
	 */
	Properties.prototype.getKeys = function() {
		return this.aKeys;
	};

	/*
	 * Implements jQuery.sap.util.Properties.prototype.setProperty
	 */
	Properties.prototype.setProperty = function(sKey, sValue) {
		if (typeof(sValue) != "string") {
			return;
		}		
		if (typeof(this.mProperties[sKey])!="string") {
			this.aKeys.push(sKey);
		}
		this.mProperties[sKey] = sValue;
	};

	/*
	 * Implements jQuery.sap.util.Properties.prototype.clone
	 */
	Properties.prototype.clone = function() {
		var oClone = new Properties();
		oClone.mProperties = jQuery.extend({}, this.mProperties);
		oClone.aKeys = jQuery.merge([], this.aKeys);
		return oClone;
	};

	/*
	 * Saves the property list to a given URL using a POST request.
	 */
	//sap.ui.resource.Properties.prototype.save = function(sUrl) {
	//	return jQuery.sap.syncPost(sUrl, this.mProperties);
	//};

	/**
	 * RegExp used to split file into lines, also removes leading whitespace.
	 * Note: group must be non-capturing, otherwise the line feeds will be part of the split result.
	 */
	var rLines = /(?:^|\r\n|\r|\n)[ \t\f]*/;

	/**
	 * RegExp that handles escapes, continuation line markers and key/value separators
	 * 
	 *              [---unicode escape--] [esc] [cnt] [---key/value separator---]
	 */
	var rEscapes = /(\\u[0-9a-fA-F]{0,4})|(\\.)|(\\$)|([ \t\f]*[ \t\f:=][ \t\f]*)/g;
	
	/**
	 * Special escape characters as supported by properties format
	 * @see JDK API doc for java.util.Properties
	 */
	var mEscapes = {
		'\\f' : '\f',
		'\\n' : '\n',
		'\\r' : '\r',
		'\\t' : '\t'
	};

	/*
	 * Parses the given text sText and sets the properties
	 * in the properties object oProp accordingly.
	 * @param {string} sText the text to parse
	 * @param oProp the properties object to fill
	 * @private
	 */
	function parse(sText, oProp) {
		
		var aLines = sText.split(rLines), // split file into lines
			sLine,sKey,sValue,bKey,i,m,iLastIndex;
		
		oProp.mProperties = {};
		oProp.aKeys = [];

		for (i=0; i<aLines.length; i++) {
			sLine = aLines[i];
			// ignore empty lines
			if (sLine === "" || sLine.charAt(0) === "#" || sLine.charAt(0) === "!" ) {
				continue;
			}

			rEscapes.lastIndex = iLastIndex = 0;
			sValue = ""; 
			bKey = true;

			while ( m = rEscapes.exec(sLine) ) {
				// handle any raw, unmatched input
				if ( iLastIndex < m.index ) {
					sValue += sLine.slice(iLastIndex, m.index);
				}
				iLastIndex = rEscapes.lastIndex;
				if ( m[1] ) { 
					// unicode escape
					if ( m[1].length !== 6 ) {
						throw new Error("Incomplete Unicode Escape '" + m[1] + "'");
					}
					sValue += String.fromCharCode(parseInt(m[1].slice(2), 16));
				} else if ( m[2] ) { 
					// special or simple escape
					sValue += mEscapes[m[2]] || m[2].slice(1);
				} else if ( m[3] ) { 
					// continuation line marker
					sLine = aLines[++i];
					rEscapes.lastIndex = iLastIndex = 0;
				} else if ( m[4] ) { 
					// key/value separator					
					if ( bKey ) {
						bKey = false;
						sKey = sValue;
						sValue = "";
					} else {
						sValue += m[4];
					}
				}
			}
			if ( iLastIndex < sLine.length ) {
				sValue += sLine.slice(iLastIndex);
			}
			if ( bKey ) {
				sKey = sValue;
				sValue = "";
			}
			oProp.aKeys.push(sKey);
			oProp.mProperties[sKey] = sValue;
		}
		
		// remove duplicates from keyset (sideeffect:sort)
		jQuery.sap.unique(oProp.aKeys);
	}

	/**
	 * Creates and returns a new instance of {@link jQuery.sap.util.Properties}.
	 *
	 * If option 'url' is passed, immediately a load request for the given target is triggered.
	 * A property file that is loaded can contain comments with a leading ! or #.
	 * The loaded property list does not contain any comments.
	 *
	 * <b>Example for loading a property file:</b>
	 * <pre>
	 *  jQuery.sap.properties({url : "../myProperty.properties"});
	 * </pre>
	 *
	 * <b>Example for creating an empty properties instance:</b>
	 * <pre>
	 *  jQuery.sap.properties();
	 * </pre>
	 *
	 * <b>Examples for getting and setting properties:</b>
	 * <pre>
	 *	var oProperties = jQuery.sap.properties();
	 *	oProperties.setProperty("KEY_1","Test Key");
	 *	var sValue1 = oProperties.getProperty("KEY_1");
	 *	var sValue2 = oProperties.getProperty("KEY_2","Default");
	 * </pre>
	 *
	 * @public
	 * @param {object} [mParams] Parameters used to initialize the property list
	 * @param {string} [mParams.url] The URL to the .properties file which should be loaded.
	 * @param {object} [mParams.headers] A map of additional header key/value pairs to send along with the request (see headers option of jQuery.ajax). 
	 * @return {jQuery.sap.util.Properties} A new property list instance
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.properties = function properties(mParams) {
		var oProp = new Properties();
		mParams = jQuery.extend({url: undefined, headers: {}}, mParams);
		if (typeof(mParams.url) == "string"){
			var sText = jQuery.sap.sjax({
				url: mParams.url,
				type: 'GET',
				dataType: 'text',
				complexResult: false,
				fallback: undefined,
				headers: mParams.headers
			});
			
			if (typeof(sText) == "string") {
				parse(sText, oProp);
			}
		}
		return oProp;
	};

}());


}; // end of jquery.sap.properties

if ( !jQuery.sap.isDeclared('jquery.sap.resources') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides access to Java-like resource bundles in properties file format
jQuery.sap.declare("jquery.sap.resources");


(function() {

	// Javadoc for private inner class "Bundle" - this list of comments is intentional!
	/**
	 * @interface  Contains locale-specific texts.
	 *
	 * If you need a locale-specific text within your application, you can use the
	 * resource bundle to load the locale-specific file from the server and access
	 * the texts of it.
	 *
	 * Use {@link jQuery.sap.resources} to create an instance of jQuery.sap.util.ResourceBundle.
	 * There you have to specify the URL to the base .properties file of a bundle
	 * (.properties without any locale information, e.g. "mybundle.properties"), and optionally
	 * a locale. The locale is defined as a string of the language and an optional country code
	 * separated by underscore (e.g. "en_GB" or "fr"). If no locale is passed, the default
	 * locale is "en" if the SAPUI5 framework is not available. Otherwise the default locale is taken from
	 * the SAPUI5 configuration.
	 *
	 * With the getText() method of the resource bundle, a locale-specific string value
	 * for a given key will be returned.
	 *
	 * With the given locale, the ResourceBundle requests the locale-specific properties file
	 * (e.g. "mybundle_fr_FR.properties"). If no file is found for the requested locale or if the file
	 * does not contain a text for the given key, a sequence of fall back locales is tried one by one. 
	 * First, if the locale contains a region information (fr_FR), then the locale without the region is
	 * tried (fr). If that also can't be found or doesn't contain the requested text, the english file 
	 * is used (en - assuming that most development projects contain at least english texts).    
	 * If that also fails, the file without locale (base URL of the bundle) is tried.
	 * 
	 * If none of the requested files can be found or none of them contains a text for the given key,
	 * then the key itself is returned as text. 
	 *
	 * Exception: Fallback for "zh_HK" is "zh_TW" before zh.
	 *
	 * @author SAP AG
	 * @version 1.10.0
	 * @since 0.9.0
	 * @name jQuery.sap.util.ResourceBundle
	 * @public
	 */
	
	/**
	 * Returns a locale-specific string value for the given key sKey. 
	 * 
	 * The text is searched in this resource bundle according to the fallback chain described in 
	 * {@link jQuery.sap.util.ResourceBundle}. If no text could be found, the key itself is used as text.
	 * 
	 * If text parameters are given, then any occurrences of the pattern "{<i>n</i>}" with <i>n</i> being an integer 
	 * are replaced by the parameter value with index <i>n</i>.  Note: This replacement is also applied if no text had been found (key). 
	 * 
	 * @param {string} sKey
	 * @param {string[]} [aArgs] List of parameters which should replace the place holders "{n}" (n is the index) in the found locale-specific string value.
	 * @return {string} The value belonging to the key, if found; otherwise the key itself.
	 *
	 * @function
	 * @name jQuery.sap.util.ResourceBundle.prototype.getText
	 */

	/**
	 * A regular expression that describes language tags according to BCP-47.
	 * @see BCP47 "Tags for Identifying Languages" (http://www.ietf.org/rfc/bcp/bcp47.txt)
	 *
	 * The matching groups are
	 *  0=all
	 *  1=language (shortest ISO639 code + ext. language sub tags | 4digits (reserved) | registered language sub tags)
	 *  2=script (4 letters)
	 *  3=region (2letter language or 3 digits)
	 *  4=variants (separated by '-', Note: capturing group contains leading '-' to shorten the regex!)
	 *  5=extensions (including leading singleton, multiple extensions separated by '-')
	 *  6=private use section (including leading 'x', multiple sections separated by '-')
	 *  
	 *            [-------------------- language ----------------------][--- script ---][------- region --------][------------ variants --------------][--------- extensions --------------][------ private use -------]
	 */
	var rlocale=/^((?:[A-Z]{2,3}(?:-[A-Z]{3}){0,3})|[A-Z]{4}|[A-Z]{5,8})(?:-([A-Z]{4}))?(?:-([A-Z]{2}|[0-9]{3}))?(-[0-9A-Z]{5,8}|(?:[0-9][0-9A-Z]{3}))*(?:-([0-9A-WYZ](?:-[0-9A-Z]{2,8})+))*(?:-(X(?:-[0-9A-Z]{1,8})+))?$/i;

	/**
	 * Resource bundles are stored according to the Java Development Kit conventions.
	 * JDK uses old language names for a few ISO639 codes ("iw" for "he", "ji" for "yi", "in" for "id" and "sh" for "sr").
	 * Make sure to convert newer codes to older ones before creating file names.
	 */
	var M_ISO639_NEW_TO_OLD = {
		"he" : "iw",
		"yi" : "ji",
		"id" : "in", 
		"sr" : "sh" 
	};
	var M_ISO639_OLD_TO_NEW = {
		"iw" : "he",
		"ji" : "yi",
		"in" : "id",
		"sn" : "sr"
	};

	/**
	 * Helper to normalize the given locale (in BCP-47 syntax) to the java.util.Locale format.
	 * @return {string} Normalized locale or undefined if the locale can't be normalized
	 */
	function normalize(sLocale) {
		var m;
		if ( typeof sLocale === 'string' && (m = rlocale.exec(sLocale.replace(/_/g, '-'))) ) {
			var sLanguage = m[1].toLowerCase();
			sLanguage = M_ISO639_NEW_TO_OLD[sLanguage] || sLanguage;
			return sLanguage + (m[3] ? "_" + m[3].toUpperCase() + (m[4] ? "_" + m[4].slice(1).replace("-","_") : "") : "");
		}
	}
	
	/**
	 * Returns the default locale (the locale defined in UI5 configuration if available, else "en")
	 * @return {string} The default locale
	 */
	function defaultLocale() {
		var sLocale;
		if(window.sap && sap.ui && sap.ui.getCore){
			sLocale = sap.ui.getCore().getConfiguration().getLanguage();
			sLocale = normalize(sLocale);
		}
		return sLocale || "en";
	}
	
	/**
	 * Helper to normalize the given locale (java.util.Locale format) to the BCP-47 syntax.
	 * @return {string} Normalized locale or undefined if the locale can't be normalized
	 */
	function convertLocaleToBCP47(sLocale) {
		var m;
		if ( typeof sLocale === 'string' && (m = rlocale.exec(sLocale.replace(/_/g, '-'))) ) {
			var sLanguage = m[1].toLowerCase();
			sLanguage = M_ISO639_OLD_TO_NEW[sLanguage] || sLanguage;
			return sLanguage + (m[3] ? "-" + m[3].toUpperCase() + (m[4] ? "-" + m[4].slice(1).replace("_","-") : "") : "");
		}
	}

    /**
     * A regular expression to split a URL into
     * <ol> 
     * <li>a part before the file extension 
     * <li>the file extension itself
     * <li>any remaining part after the file extension (query, hash - optional)
     * </ol>.
     * 
     * Won't match for URLs without a file extension.
     *
     *           [------- prefix ------][----ext----][-------suffix--------]
     *                                               ?[--query--]#[--hash--]
     */
	var rUrl = /^((?:[^?#]*\/)?[^\/?#]*)(\.[^.\/?#]+)((?:\?([^#]*))?(?:#(.*))?)$/;

    /**
     * List of supported file extensions. 
     *
     * Could be enriched in future or even could be made
     * extensible to support other formats as well.
     */
	var aValidFileTypes = [ ".properties", ".hdbtextbundle"]; 

    /**
     * Helper to split a URL with the above regex.
     * Either returns an object with the parts or undefined.
     */
	function splitUrl(sUrl) {
		var m = rUrl.exec(sUrl);
		return m && { url : sUrl, prefix : m[1], ext : m[2], query: m[4], hash: (m[5] || ""), suffix : m[2] + (m[3] || "") };
	}

	/*
	 * Implements jQuery.sap.util.ResourceBundle
	 */
	var Bundle = function(sUrl, sLocale, bIncludeInfo){
		//last fallback is english if no or no valid locale is given
		//TODO: If the browsers allow to access the users language preference this should be the fallback
		this.sLocale = normalize(sLocale) || defaultLocale();
		this.oUrlInfo = splitUrl(sUrl);
		if ( !this.oUrlInfo || jQuery.inArray(this.oUrlInfo.ext, aValidFileTypes) < 0 ) {
			throw new Error("resource URL '" + sUrl + "' has unknown type (should be one of " + aValidFileTypes.join(",") + ")");
		}
		this.bIncludeInfo = bIncludeInfo;
		//declare list of property files that are loaded
		this.aPropertyFiles = [];
		this.aLocales = [];
		//load the most specific property file
		load(this, this.sLocale);
	};

	Bundle.prototype = {};

	/*
	 * Implements jQuery.sap.util.ResourceBundle.prototype.getText
	 */
	Bundle.prototype.getText = function(sKey, aArgs){
		var sValue = null;
		//loop over all loaded property files and return the value for the key if any
		for(var i=0; i<this.aPropertyFiles.length; i++){
			sValue = this.aPropertyFiles[i].getProperty(sKey);
			if(typeof(sValue)==="string") {
				break;
			}
		}

		//value for this key was not found in the currently loaded property files,
		//load the fallback locales
		if(typeof(sValue)!=="string"){
			var sTempLocale = this.aLocales[0];
			while(sTempLocale.length > 0){
				if(sTempLocale == "zh_HK"){
					sTempLocale = "zh_TW";
				}else{
					if(sTempLocale.length > 2){
						sTempLocale = sTempLocale.substring(0,2);
					}else if(sTempLocale != "en"){
						sTempLocale = "en";
					}else{
						sTempLocale = "";
					}
				}

				var oProperties = load(this, sTempLocale);
				if(oProperties == null) {
					continue;
				}

				//check whether the key is included in the newly loaded property file
				sValue = oProperties.getProperty(sKey);
				if (typeof(sValue)==="string") {
					break;
				}
			}
		}

		if(typeof(sValue)!=="string"){
			sValue = sKey;
		}

		if(aArgs){
			for(var index=0; index<aArgs.length; index++){
				sValue = sValue.replace("{"+index+"}", aArgs[index]);
			}
		}

		if (this.bIncludeInfo) {
			sValue = new String(sValue);
			sValue.originInfo = {
				source: "Resource Bundle",
				url: this.oUrlInfo.url,
				locale: this.sLocale,
				key: sKey
			};
		}

		return sValue;
	};

	/*
	 * If a .properties file for the given locale is not loaded yet
	 * in the given bundle, this method loads the .properties file and
	 * adds it to the bundle.
	 * @param {string} sLocale the text to parse
	 * @param oBundle the resource bundle to extend
	 * @return The newly loaded properties or <code>null</code>
	 *         when the properties for the given locale already loaded.
	 * @private
	 */
	function load(oBundle, sLocale) {
		var oUrl = oBundle.oUrlInfo; 
		if(jQuery.inArray(sLocale, oBundle.aLocales) == -1){
			var oHeader = null;
			var sTempUrl;
			switch (oUrl.ext) {
				case '.hdbtextbundle':
					sLocale = convertLocaleToBCP47(sLocale);
					oHeader = {
						"Accept-Language": sLocale
					};
					sTempUrl = oUrl.url;
					//Alternative: add locale as query
					//sTempUrl = oUrl.prefix + oUrl.suffix + '?' + (oUrl.query ? oUrl.query + "&" : "") + "locale=" + sLocale + (oUrl.hash ? "#" + oUrl.hash : "");
					break;
				default:
					sTempUrl = oUrl.prefix + (sLocale ? "_" + sLocale : "") + oUrl.suffix;
					break;
			}

			var props = jQuery.sap.properties({url : sTempUrl, headers: oHeader});
			oBundle.aPropertyFiles.push(props);
			oBundle.aLocales.push(sLocale);
			return props;
		}
		return null;
	}

	/**
	 * Creates and returns a new instance of {@link jQuery.sap.util.ResourceBundle}
	 * using the given URL and locale to determine what to load.
	 *
	 * @public
	 * @param {object} [mParams] Parameters used to initialize the resource bundle
	 * @param {string} [mParams.url=""] The URL to the base .properties file of a bundle (.properties file without any locale information, e.g. "mybundle.properties")
	 * @param {string} [mParams.locale="en"] Optional string of the language and an optional country code separated by underscore (e.g. "en_GB" or "fr")
	 * @param {boolean} [mParams.includeInfo=false] Optional boolean whether to include origin information into the returned property values
	 * @return {jQuery.sap.util.ResourceBundle} A new resource bundle instance
	 * @SecSink {0|PATH} Parameter is used for future HTTP requests
	 */
	jQuery.sap.resources = function resources(mParams) {
		mParams = jQuery.extend({url: "", locale: undefined, includeInfo: false}, mParams);
		var oBundle = new Bundle(mParams.url, mParams.locale, mParams.includeInfo);
		return oBundle;
	};

}());

}; // end of jquery.sap.resources

if ( !jQuery.sap.isDeclared('jquery.sap.script') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides miscellaneous utility functions that might be useful for any script
jQuery.sap.declare("jquery.sap.script", false);

(function() {

	/**
	 * Some private variable used for creation of (pseudo-)unique ids.
	 * @type integer
	 * @private
	 */
	var iIdCounter = 0;

	/**
	 * Creates and returns a pseudo-unique id.
	 *
	 * No means for detection of overlap with already present or future UIDs.
	 *
	 * @return {string} A pseudo-unique id.
	 * @public
	 */
	jQuery.sap.uid = function uid() {
		return "id-" + new Date().valueOf() + "-" + iIdCounter++;
	};

	/**
	 * Calls a method after a given delay and returns an id for this timer
	 *
	 * @param {int} iDelay Delay time in milliseconds
	 * @param {object} oObject Object from which the method should be called
	 * @param {string|object} Method function pointer or name of the method
	 * @param {array} [aParameters] Method parameters
	 * @return {string} Id which can be used to cancel the timer with clearDelayedCall
	 * @public
	 */
	jQuery.sap.delayedCall = function delayedCall(iDelay, oObject, method, aParameters) {
		return setTimeout(function(){
			if (jQuery.type(method) == "string") {
				method = oObject[method];
			}
			method.apply(oObject, aParameters ||[]);
		}, iDelay);
	};

	/**
	 * Stops the delayed call.
	 *
	 * The function given when calling delayedCall is not called anymore.
	 *
	 * @param {string} sDelayedCallId The id returned, when calling delayedCall
	 * @public
	 */
	jQuery.sap.clearDelayedCall = function clearDelayedCall(sDelayedCallId) {
		clearTimeout(sDelayedCallId);
		return this;
	};

	/**
	 * Calls a method after a given interval and returns an id for this interval.
	 *
	 * @param {int} iInterval Interval time in milliseconds
	 * @param {object} oObject Object from which the method should be called
	 * @param {string|object} Method function pointer or name of the method
	 * @param {array} [aParameters] Method parameters
	 * @return {string} Id which can be used to cancel the interval with clearIntervalCall
	 * @public
	 */
	jQuery.sap.intervalCall = function intervalCall(iInterval, oObject, method, aParameters) {
		return setInterval(function(){
			if (jQuery.type(method) == "string") {
				method = oObject[method];
			}
			method.apply(oObject, aParameters ||[]);
		}, iInterval);
	};

	/**
	 * Stops the interval call.
	 *
	 * The function given when calling intervalCall is not called anymore.
	 *
	 * @param {string} sIntervalCallId The id returned, when calling intervalCall
	 * @public
	 */
	jQuery.sap.clearIntervalCall = function clearIntervalCall(sIntervalCallId) {
		clearInterval(sIntervalCallId);
		return this;
	};

	// Javadoc for private inner class "UriParams" - this list of comments is intentional!
	/**
	 * @interface  Encapsulates all URI parameters of the current windows location (URL).
	 *
	 * Use {@link jQuery.sap.getUriParameters} to create an instance of jQuery.sap.util.UriParameters.
	 *
	 * @author SAP AG
	 * @version 1.10.0
	 * @since 0.9.0
	 * @name jQuery.sap.util.UriParameters
	 * @public
	 */
	/**
	 * Returns the value(s) of the URI parameter with the given name sName.
	 *
	 * If the boolean parameter bAll is <code>true</code>, an array of string values of all
	 * occurrences of the URI parameter with the given name is returned. This array is empty
	 * if the URI parameter is not contained in the windows URL.
	 *
	 * If the boolean parameter bAll is <code>false</code> or is not specified, the value of the first
	 * occurrence of the URI parameter with the given name is returned. Might be <code>null</code>
	 * if the URI parameter is not contained in the windows URL.
	 *
	 * @param {string} sName The name of the URI parameter.
	 * @param {boolean} [bAll=false] Optional, specifies whether all or only the first parameter value should be returned.
	 * @return {string|array} The value(s) of the URI parameter with the given name
	 * @SecSource {return|XSS} Return value contains URL parameters
	 *
	 * @function
	 * @name jQuery.sap.util.UriParameters.prototype.get
	 */

	/*
	 * Implements jQuery.sap.util.UriParameters
	 */
	var UriParams = function(sUri) {
		this.mParams = {};
		var sQueryString = sUri || window.location.href;
		if ( sQueryString.indexOf('#') >= 0 ) {
			sQueryString = sQueryString.slice(0, sQueryString.indexOf('#'));
		}
		if(sQueryString.indexOf("?") >= 0){
			sQueryString = sQueryString.slice(sQueryString.indexOf("?") + 1);
			var aParameters = sQueryString.split("&"),
				mParameters = {},
				aParameter,
				sName,
				sValue;
			for(var i=0; i<aParameters.length; i++){
				aParameter = aParameters[i].split("=");
				sName = decodeURIComponent(aParameter[0]);
				sValue = aParameter.length > 1 ? decodeURIComponent(aParameter[1].replace(/\+/g,' ')) : "";
				if(sName){
					if(!Object.prototype.hasOwnProperty.call(mParameters, sName)){
						mParameters[sName] = [];
					}
					mParameters[sName].push(sValue);
				}
			}
			this.mParams = mParameters;
		}
	};

	UriParams.prototype = {};

	/*
	 * Implements jQuery.sap.util.UriParameters.prototype.get
	 */
	UriParams.prototype.get = function(sName, bAll) {
		var aValues = Object.prototype.hasOwnProperty.call(this.mParams, sName) ? this.mParams[sName] : [];
		return bAll === true ? aValues : (aValues[0] || null);
	};

	/**
	 * Creates and returns a new instance of {@link jQuery.sap.util.UriParameters}.
	 *
	 * Example for reading a single URI parameter (or the value of the first
	 * occurrence of the URI parameter):
	 * <pre>
	 *  var sValue = jQuery.sap.getUriParameters().get("myUriParam");
	 * </pre>
	 *
	 * Example for reading the values of the first of the URI parameter
	 * (with multiple occurrences):
	 * <pre>
	 *  var aValues = jQuery.sap.getUriParameters().get("myUriParam", true);
	 *  for(i in aValues){
	 *	var sValue = aValues[i];
	 *  }
	 * </pre>
	 *
	 * @public
	 * @return {jQuery.sap.util.UriParameters} A new URI parameters instance
	 */
	jQuery.sap.getUriParameters = function getUriParameters(sUri) {
		return new UriParams(sUri);
	};

	/**
	 * Sorts the given array in-place and removes any duplicates (identified by "===").
	 *
	 * Use <code>jQuery.unique()</code> for arrays of DOMElements.
	 *
	 * @param {Array} a An Array of any type
	 * @return {Array} Same array as given (for chaining)
	 * @public
	 */
	jQuery.sap.unique = function(a) {
		jQuery.sap.assert(a instanceof Array, "unique: a must be an array");
		var l=a.length;
		if ( l > 1 ) {
			a.sort();
			for(var i=1,j=0; i<l; i++) {
				// invariant: i is the entry to check, j is the last unique entry known so far
				if ( a[i] !== a[j] ) {
					a[++j] = a[i];
				}
			}
			// cut off the rest - if any
			if ( ++j < l ) {
				a.splice(j, l-j);
			}
		}
		return a;
	};

	/**
	 * Compares the two given values for equality, especially takes care not to compare
	 * arrays and objects by reference, but compares their content.
	 * Note: function does not work with comparing XML objects
	 *
	 * @param {any} a A value of any type
	 * @param {any} b A value of any type
	 * @param {int} [maxDepth=10] Maximum recursion depth
	 * 
	 * @return {boolean} Whether a and b are equal
	 * @public
	 */
	jQuery.sap.equal = function(a, b, maxDepth, depth) {
		if (!depth) depth = 0;
		if (!maxDepth) maxDepth = 10;
		if (depth > maxDepth) return false;
		if (a === b) return true;
		if (jQuery.isArray(a) && jQuery.isArray(b)) {
			if (a.length != b.length) { return false; }
			for (var i = 0; i < a.length; i++) {
				if (!jQuery.sap.equal(a[i], b[i], maxDepth, depth + 1)) { 
						return false;
				}
			}
			return true;
		}
		if (typeof a == "object" && typeof b == "object") {
			if (!a || !b) {
				return false;
			}
			if (a.constructor != b.constructor) {
				return false;
			}
			if (a instanceof Date) {
				return a.valueOf() == b.valueOf();
			}
			for (var i in a) {
				if (!jQuery.sap.equal(a[i], b[i], maxDepth, depth + 1)) { 
					return false;
				}
			}
			for (var i in b) {
				if (a[i] === undefined) { 
					return false;
				}
			}
			return true;
		}
		return false;
	};
	
	/**
	 * Substitute for <code>for(n in o)</code> loops which fixes the 'Don'tEnum' bug of IE8.
	 * 
	 * Iterates over all enumerable properties of the given object and calls the
	 * given callback function for each of them. The assumed signature of the 
	 * callback function is 
	 * 
	 *   fnCallback(name, value)
	 *   
	 * where name is the name of the property and value is its value.
	 * 
	 * When an object in IE8 overrides a property of Object.prototype
	 * that has been marked as 'don't enum', then IE8 by mistake also 
	 * doesn't enumerate the overriding property. 
	 * 
	 * A 100% complete substitute is hard to achieve. The current implementation 
	 * enumerates an overridden property when it either is an 'own' property 
	 * (hasOwnProperty(name) is true) or when the property value is different 
	 * from the value in the Object.prototype object.
	 * 
   * @param {object} oObject object to enumerate the properties of
   * @param {function} fnCallback function to call for each property name
	 * @function
	 * @since 1.7.1
	 */
	jQuery.sap.forIn = {toString:null}.propertyIsEnumerable("toString") ?
	    // for browsers without the bug we use the straight forward implementation of a for in loop
      function(oObject, fnCallback) {
        for(var n in oObject) {
          if ( fnCallback(n, oObject[n]) === false ) {
            return;
          }
        }
      } : 
      // use a special implementation for IE8 
      (function() {
        var DONT_ENUM_KEYS = ["toString","valueOf","toLocaleString", "hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],
            DONT_ENUM_KEYS_LENGTH = DONT_ENUM_KEYS.length,
            oObjectPrototype = Object.prototype,
            fnHasOwnProperty = oObjectPrototype.hasOwnProperty;
            
        return function(oObject, fnCallback) {
          var n,i;
          
          // standard for(in) loop
          for(n in oObject) {
            if ( fnCallback(n, oObject[n]) === false ) {
              return;
            }
          }
          // additionally check the known 'don't enum' names
          for(var i=0; i<DONT_ENUM_KEYS_LENGTH; i++) {
            n = DONT_ENUM_KEYS[i];
            // assume an enumerable property if it is either an own property
            // or if its value differes fro mthe value in the Object.prototype
            if ( fnHasOwnProperty.call(oObject,n) || oObject[n] !== oObjectPrototype[n] ) {
              if ( fnCallback(n, oObject[n]) === false ) {
                return;
              }
            }
          }
          // Note: this substitute implementation still fails in several regards
          // - it fails when oObject is identical to Object.prototype (iterates non-enumerable properties)
          // - it fails when one of the don't enum properties by intention has been overridden in the 
          //   prototype chain with a value identical to the value in Object.prototype
          // - the don't enum properties are handled out of order. This is okay with the ECMAScript
          //   spec but might be unexpected for some callers
        }
     	}());
	
}());

}; // end of jquery.sap.script

if ( !jQuery.sap.isDeclared('sap.ui.Global') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

/**
 * @overview Initialization for the SAP UI Library
 *
 * This module creates the main SAP namespaces {@link sap} and automatically
 * registers it to the OpenAjax hub if that exists.
 *
 * This class provides method {@link #namespace} to register namespaces to the
 * SAP UI Library.
 *
 * @sample
 * Ensures a control can be used afterwards but does not load immediately
 * sap.ui.lazyRequire("sap.ui.core/Control");
 * sap.ui.lazyRequire("sap.ui.commons/Button");
 *
 * @version 1.10.0
 * @author  Martin Schaus, Daniel Brinkmann
 * @public
 */

/*global OpenAjax */// declare unusual global vars for JSLint/SAPUI5 validation

// Register to the OpenAjax Hub if it exists
if (window.OpenAjax && window.OpenAjax.hub) {
	OpenAjax.hub.registerLibrary("sap", "http://www.sap.com/", "0.1", {});
}

jQuery.sap.declare("sap.ui.Global");


/**
 * Root namespace for JavaScript functionality provided by SAP AG.
 *
 * The <code>sap</code> namespace is automatically registered with the
 * OpenAjax hub if it exists.
 *
 * @version 1.10.0
 * @namespace
 * @public
 * @name sap
 */
if ( typeof window.sap !== "object" && typeof window.sap !== "function"  ) {
  window.sap = {};
}

/**
 * The <code>sap.ui</code> namespace is the central OpenAjax compliant entry
 * point for UI related JavaScript functionality provided by SAP.
 *
 * @version 1.10.0
 * @namespace
 * @name sap.ui
 * @public
 */
if ( typeof window.sap.ui !== "object") {
	window.sap.ui = {};
}
sap.ui = jQuery.extend(sap.ui, {
		/**
		 * The version of the SAP UI Library
		 * @type string
		 */
		version: "1.10.0",
		buildinfo : { lastchange : "e9296120a45088f6cbfd9ee06d396733fbf04d6f", buildtime : "201301291602" }
	});

/**
 * Ensures that a given a namespace or hierarchy of nested namespaces exists in the
 * current <code>window</code>.
 *
 * @return {object} the innermost namespace of the hierarchy
 * @public
 * @static
 * @deprecated Use jQuery.sap.declare or jQuery.sap.getObject(...,0) instead
 */
sap.ui.namespace = function(sNamespace){

	jQuery.sap.assert(false, "sap.ui.namespace is long time deprecated and shouldn't be used");

	return jQuery.sap.getObject(sNamespace, 0);
};

/**
 * Creates a lazy loading stub for a given class <code>sClassName</code>.
 *
 * If the class has been loaded already, nothing is done. Otherwise a stub object
 * or constructor and - optionally - a set of stub methods are created.
 * All created stubs will load the corresponding module on execution
 * and then delegate to their counterpart in the loaded module.
 *
 * When no methods are given or when the list of methods contains the special name
 * "new" (which is an operator can't be used as method name in JavaScript), then a
 * stub <b>constructor</b> for class <code>sClassName</code> is created.
 * Otherwise,  a plain object is created.
 *
 * <b>Note</b>: Accessing any stub as a plain object without executing it (no matter
 * whether it is a function or an object) won't load the module and therefore most like
 * won't work as expected. This is a fundamental restriction of the lazy loader approach.
 * It could only be fixed with JavaScript 1.5 features that are not available in all
 * UI5 target browsers (e.g. not in IE8).
 *
 * <b>Note</b>: As a side effect of this method, the namespace containing the given
 * class is created <b>immediately</b>.
 *
 * @param {string} sClassName Fully qualified name (dot notation) of the class that should be prepared
 * @param {string} [sMethods='new'] space separated list of additional (static) methods that should be created as stubs
 * @param {string} [sModuleName] name of the module to load, defaults to the class name
 * @public
 * @static
 */
sap.ui.lazyRequire = function(sClassName, sMethods, sModuleName) {

	jQuery.sap.assert(typeof sClassName === "string" && sClassName, "lazyRequire: sClassName must be a non-empty string");
	jQuery.sap.assert(!sMethods || typeof sMethods === "string", "lazyRequire: sMethods must be empty or a string");

	var sFullClass = sClassName.replace(/\//gi,"\."),
		iLastDotPos = sFullClass.lastIndexOf("."),
		sPackage = sFullClass.substr(0, iLastDotPos),
		sClass = sFullClass.substr(iLastDotPos + 1),
		oPackage = jQuery.sap.getObject(sPackage, 0),
		oClass = oPackage[sClass],
		aMethods = (sMethods || "new").split(" "),
		iConstructor = jQuery.inArray("new", aMethods);

	sModuleName = sModuleName || sFullClass;

	if (!oClass) {

		if ( iConstructor >= 0 ) {

			// Create dummy constructor which loads the class on demand
			oClass = function() {
				jQuery.sap.log.debug("lazy stub for '" + sFullClass + "' (constructor) called.");
				jQuery.sap.require(sModuleName);
				var oRealClass = oPackage[sClass];
				jQuery.sap.assert(typeof oRealClass === "function", "lazyRequire: oRealClass must be a function after loading");
				if ( oRealClass._sapUiLazyLoader ) {
					throw new Error("lazyRequire: stub '" + sFullClass + "'has not been replaced by module '" + sModuleName + "'");
				}

				// create a new instance and invoke the constructor
				var oInstance = jQuery.sap.newObject(oRealClass.prototype);
				var oResult = oRealClass.apply(oInstance, arguments);
				if (oResult && (typeof oResult === "function" || typeof oResult === "object")) {
					oInstance = oResult;
				}
				return oInstance;
			};
			// mark the stub as lazy loader
			oClass._sapUiLazyLoader = true;

			aMethods.splice(iConstructor,1);

		} else {

			// Create dummy object
			oClass = {};

		}

		// remember the stub
		oPackage[sClass] = oClass;

	}


	// add stub methods to it
	jQuery.each(aMethods, function (i,sMethod) {
		// check whether method is already available
		if (!oClass[sMethod]) {
			oClass[sMethod] = function() {
				jQuery.sap.log.debug("lazy stub for '" + sFullClass + "." + sMethod + "' called.");
				jQuery.sap.require(sModuleName);
				var oRealClass = oPackage[sClass];
				jQuery.sap.assert(typeof oRealClass === "function" || typeof oRealClass === "object", "lazyRequire: oRealClass must be a function or object after loading");
				jQuery.sap.assert(typeof oRealClass[sMethod] === "function", "lazyRequire: method must be a function");
				if (oRealClass[sMethod]._sapUiLazyLoader ) {
					throw new Error("lazyRequire: stub '" + sFullClass + "." + sMethod + "' has not been replaced by loaded module '" + sModuleName + "'");
				}
				return oRealClass[sMethod].apply(oRealClass, arguments);
			};
			oClass[sMethod]._sapUiLazyLoader = true;
		}
	});

};

/**
 * Returns the URL of a resource that belongs to the given library and has the given relative location within the library.
 * This is mainly meant for static resources like images that are inside the library.
 * It is NOT meant for access to JavaScript modules or anything for which a different URL has been registered with jQuery.sap.registerModulePath(). For
 * these cases use jQuery.sap.getModulePath().
 * It DOES work, however, when the given sResourcePath starts with "themes/" (= when it is a theme-dependent resource). Even when for this theme a different
 * location outside the normal library location is configured.
 *
 * @param sLibraryName the name of a library, like "sap.ui.commons"
 * @param sResourcePath the relative path of a resource inside this library, like "img/mypic.png" or "themes/my_theme/img/mypic.png"
 * @returns the URL of the requested resource
 *
 * @static
 * @public
 */
sap.ui.resource = function(sLibraryName, sResourcePath) {
	jQuery.sap.assert(typeof sLibraryName === "string", "sLibraryName must be a string");
	jQuery.sap.assert(typeof sResourcePath === "string", "sResourcePath must be a string");

	// special handling for theme-dependent resources: move theme folder into module name
	var match = sResourcePath.match(/^themes\/([^\/]+)\//);
	if (match) {
		sLibraryName += ".themes." + match[1];
		sResourcePath = sResourcePath.substr(match[0].length);
	}

	return jQuery.sap.getModulePath(sLibraryName, '/') + sResourcePath;
};

/**
 * Redirects access to resources that are part of the given namespace to a location
 * relative to the assumed <b>application root folder</b>.
 *
 * Any UI5 managed resource (view, controller, control, JavaScript module, CSS file, etc.)
 * whose resource name starts with <code>sNamespace</code>, will be loaded from an
 * equally named subfolder of the <b>application root folder</b>.
 * If the resource name consists of multiple segments (separated by a dot), each segment
 * is assumed to represent an individual folder. In other words: when a resource name is
 * converted to an URL, any dots ('.') are converted to slashes ('/').
 *
 * <b>Limitation:</b> For the time being, the <b>application root folder</b> is assumed to be
 * the same as the folder where the current page resides in.
 *
 * Usage sample:
 * <pre>
 *   // Let UI5 know that resources, whose name starts with "com.mycompany.myapp"
 *   // should be loaded from the URL location "./com/mycompany/myapp"
 *   sap.ui.localResources("com.mycompany.myapp");
 *
 *   // The following call implicitly will use the mapping done by the previous line
 *   // It will load a view from ./com/mycompany/myapp/views/Main.view.xml
 *   sap.ui.view({ view : "com.mycompany.myapp.views.Main", type : sap.ui.core.mvc.ViewType.XML});
 * </pre>
 *
 * When applications need a more flexible mapping between resource names and their location,
 * they can use {@link jQuery.sap.registerModulePath}.
 *
 * It is intended to make this configuration obsolete in future releases, but for the time
 * being, applications must call this method when they want to store resources relative to
 * the assumed application root folder.
 *
 * @param {String} sNamespace Namespace prefix for which to load resources relative to the application root folder
 * @public
 * @static
 * @see jQuery.sap.registerModulePath
 */
sap.ui.localResources = function(sNamespace) {
	jQuery.sap.assert(sNamespace, "sNamespace must not be empty");
	jQuery.sap.registerModulePath(sNamespace, "./" + sNamespace.replace(/\./g, "/"));
};

}; // end of sap.ui.Global

if ( !jQuery.sap.isDeclared('sap.ui.base.EventProvider') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.EventProvider
jQuery.sap.declare("sap.ui.base.EventProvider");
if ( !jQuery.sap.isDeclared('sap.ui.base.Object') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

/**
 * SAPUI5 base classes
 *
 * @namespace
 * @name sap.ui.base
 * @public
 */

// Provides class sap.ui.base.Object
jQuery.sap.declare("sap.ui.base.Object");
if ( !jQuery.sap.isDeclared('sap.ui.base.Interface') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.Interface
jQuery.sap.declare("sap.ui.base.Interface");

/**
 * Constructs an instance of sap.ui.base.Interface which restricts access to methods marked as public.
 *
 * @class A class that creates an Interface for an existing class. If a class returns the interface in its constructor,
 *        only the defined functions will be visible, no internals of the class can be accessed.
 *
 * @author Malte Wedel, Daniel Brinkmann
 * @version 1.10.0
 * @param {sap.ui.base.Object}
 *            oObject the instance that needs an interface created
 * @param {string[]}
 *            aMethods the names of the methods, that should be available on this interface
 * @constructor
 * @public
 */
sap.ui.base.Interface = function(oObject, aMethods) {

	// if object is null or undefined, return itself
	if (!oObject) {
		return oObject;
	}

	// this function is inline to not appear as a method on the interface

	function fCreateDelegator(oObject, sMethodName) {
		return function() {
//				return oObject[sMethodName].apply(oObject, arguments);
				var tmp = oObject[sMethodName].apply(oObject, arguments);
				return (!(tmp instanceof sap.ui.core.Element)&&(tmp instanceof sap.ui.base.Object))?tmp.getInterface():tmp;
			};
	}

	// if there are no methods return
	if (!aMethods) {
		return {};
	}

	var sMethodName;

	// create functions for all delegated methods
	// PERFOPT: 'cache' length of aMethods to reduce # of resolutions
	for (var i = 0, ml = aMethods.length; i < ml; i++) {
		sMethodName = aMethods[i];
		this[sMethodName] = fCreateDelegator(oObject, sMethodName);
	}

};
}; // end of sap.ui.base.Interface

if ( !jQuery.sap.isDeclared('sap.ui.base.Metadata') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.Metadata
jQuery.sap.declare("sap.ui.base.Metadata");


/**
 * Creates a new metadata object from the given static infos.
 *
 * @param {string} sClassName fully qualified name of the class that is described by this metadata object
 * @param {object} oClassInfo info to construct the class and its metadata from
 *
 * @class Metadata for a class.
 * @author Frank Weigel
 * @version 1.10.0
 * @since 0.8.6
 * @public
 */
sap.ui.base.Metadata = function(sClassName, oClassInfo) {

	jQuery.sap.assert(typeof sClassName === "string" && sClassName, "Metadata: sClassName must be a non-empty string");
	jQuery.sap.assert(typeof oClassInfo === "object", "Metadata: oClassInfo must be empty or an object");

	// support for old usage of Metadata
	if ( !oClassInfo || typeof oClassInfo.metadata !== "object" ) {
		oClassInfo = {
			metadata : oClassInfo || {},
			// retrieve class by its name. Using a lookup costs time but avoids the need for redundant arguments to this function
			constructor : jQuery.sap.getObject(sClassName)
		};
		oClassInfo.metadata.__version = 1.0;
	}
	oClassInfo.metadata.__version = oClassInfo.metadata.__version || 2.0;
	if ( typeof oClassInfo.constructor !== "function" ) {
		throw Error("constructor for class " + sClassName + " must have been declared before creating metadata for it");
	}

	// invariant: oClassInfo exists, oClassInfo.metadata exists, oClassInfo.constructor exists
	this._sClassName = sClassName;
	this._oClass = oClassInfo.constructor;
	this.extend(oClassInfo);
};

/**
 * @private
 * @final
 */
sap.ui.base.Metadata.prototype.extend = function(oClassInfo) {
	this.applySettings(oClassInfo);
	this.afterApplySettings();
};

/**
 * @private
 * @since 1.3.1
 */
sap.ui.base.Metadata.prototype.applySettings = function(oClassInfo) {

	var that = this,
	  oStaticInfo = oClassInfo.metadata,
		oPrototype, n;

	if ( oStaticInfo.baseType ) {
		// lookup base class by its name - same reasoning as above
		var oParentClass = jQuery.sap.getObject(oStaticInfo.baseType);
		if ( typeof oParentClass !== "function" ) {
			jQuery.sap.log.fatal("base class '" + oStaticInfo.baseType + "' does not exist");
		}
		// link metadata with base metadata
		if ( oParentClass.getMetadata ) {
			this._oParent = oParentClass.getMetadata();
			jQuery.sap.assert(oParentClass === oParentClass.getMetadata().getClass(), "Metadata: oParentClass must match the class in the parent metadata");
		} else {
			// fallback, if base class has no metadata
			this._oParent = new sap.ui.base.Metadata(oStaticInfo.baseType, {});
		}
	} else {
		this._oParent = undefined;
	}

	this._bAbstract = !!oStaticInfo["abstract"];
	this._bFinal = !!oStaticInfo["final"];

	// handle interfaces
	this._aInterfaces = jQuery.sap.unique(oStaticInfo.interfaces || []);

	// take over metadata from static info
	this._aPublicMethods = jQuery.sap.unique(oStaticInfo.publicMethods || []);

	// enrich prototype
	oPrototype = this._oClass.prototype;
	jQuery.sap.forIn(oClassInfo, function(n, v) {
		if ( n !== "metadata" && n !== "constructor" ) {
			oPrototype[n] = v;
			if ( !n.match(/^_|^on|^init$|^exit$/) ) {
				// TODO hard coded knowledge about event handlers ("on") and about init/exit hooks is not nice....
				that._aPublicMethods.push(n);
			}
		}
	});
	
};

/**
 * Called after new settings have been applied.
 *
 * Typically, this method is used to do some cleanup (e.g. uniqueness)
 * or to calculate an optimized version of some data.
 * @private
 * @since 1.3.1
 */
sap.ui.base.Metadata.prototype.afterApplySettings = function() {
	// create the flattened "all" view
	if ( this._oParent ) {
		//this._aAllInterfaces = jQuery.sap.unique(this._oParent._aAllInterfaces.concat(this._aInterfaces));
		this._aAllPublicMethods = jQuery.sap.unique(this._oParent._aAllPublicMethods.concat(this._aPublicMethods));
	} else {
		//this._aAllInterfaces = this._aInterfaces;
		this._aAllPublicMethods = this._aPublicMethods;
	}

};

/**
 * Returns the fully qualified name of the class that is described by this metadata object
 * @return {string} name of the described class
 * @public
 */
sap.ui.base.Metadata.prototype.getName = function() {
	return this._sClassName;
};

/**
 * Returns the (constructor of the) class described by this metadata object.
 * @return {function} class described by this metadata
 * @public
 */
sap.ui.base.Metadata.prototype.getClass = function() {
	return this._oClass;
};

/**
 * Returns the metadata object of the base class of the class described by this metadata object
 * or null if the class has no (documented) base class.
 *
 * @return {sap.ui.base.Metadata} metadata of the base class
 * @public
 */
sap.ui.base.Metadata.prototype.getParent = function() {
	return this._oParent;
};

/**
 * Returns an array with the names of the public methods declared by this class.
 *
 * @return {string[]} array with names of public methods declared by this class
 * @public
 */
sap.ui.base.Metadata.prototype.getPublicMethods = function() {
	return this._aPublicMethods;
};

/**
 * Returns an array with the names of all public methods declared by this class
 * and its ancestors.
 *
 * @return {string[]} array with names of all public methods provided by this class and its ancestors
 * @public
 */
sap.ui.base.Metadata.prototype.getAllPublicMethods = function() {
	return this._aAllPublicMethods;
};

/**
 * Returns the names of interfaces implemented by this class.
 * As the representation of interfaces is not clear yet, this method is still private.
 *
 * @return {string} array of names of implemented interfaces
 * @private
 */
sap.ui.base.Metadata.prototype.getInterfaces = function() {
	return this._aInterfaces;
};

/**
 * Checks whether the class described by this object or one of its ancestors
 * implements the given interface.
 *
 * @param {string} sInterface name of the interface to test for (in dot notation)
 * @return {boolean} whether this class implements the interface
 * @public
 */
sap.ui.base.Metadata.prototype.isInstanceOf = function(sInterface) {
	if ( this._oParent ) {
		if ( this._oParent.isInstanceOf(sInterface) ) {
			return true;
		}
	};

	var a=this._aInterfaces;
	for(var i=0,l=a.length; i<l; i++) {
		// FIXME doesn't handle interface inheritance (requires object representation for interfaces)
		if ( a[i] === sInterface ) {
			return true;
		}
	}

	return false;
};

sap.ui.base.Metadata.prototype.isFinal = function() {
	return this._bFinal;
};

/**
 * Adds one or more new methods to the list of API methods.
 *
 * Can be used by contributer classes (like the EnabledPropagator) to enrich the declared set of methods.
 * The method can either be called with multiple names (strings) or with one array of strings.
 *
 * <b>Note</b>: the newly added method(s) will only be visible in {@link sap.ui.base.Interface interface}
 * objects that are created <i>after</i> this method has been called.
 *
 * @param {string||string[]} sMethod name(s) of the new method(s)
 */
sap.ui.base.Metadata.prototype.addPublicMethods = function(sMethod /* ... */) {
	var aNames = (sMethod instanceof Array) ? sMethod : arguments;
	function upush(a,v) {
		Array.prototype.push.apply(a, v); // appends "inplace"
		jQuery.sap.unique(a);
	}
	upush(this._aPublicMethods, aNames);
	upush(this._aAllPublicMethods, aNames);
};

/**
 * @since 1.3.1
 * @private
 */
sap.ui.base.Metadata.createClass = function (fnBaseClass, sClassName, oClassInfo, FNMetaImpl) {

	if ( typeof fnBaseClass === "string" ) {
		FNMetaImpl = oClassInfo;
		oClassInfo = sClassName;
		sClassName = fnBaseClass;
		fnBaseClass = null;
	}

	jQuery.sap.assert(!fnBaseClass || typeof fnBaseClass === "function");
	jQuery.sap.assert(typeof sClassName === "string" && !!sClassName);
	jQuery.sap.assert(!oClassInfo || typeof oClassInfo === "object");
	jQuery.sap.assert(!FNMetaImpl || typeof FNMetaImpl === "function");

	// normalize oClassInfo
	oClassInfo = oClassInfo || {};
	oClassInfo.metadata = oClassInfo.metadata || {};
	if ( !oClassInfo.hasOwnProperty('constructor') ) {
		oClassInfo.constructor = undefined;
	}
	FNMetaImpl = FNMetaImpl || sap.ui.base.Metadata;

	var fnClass = oClassInfo.constructor;
	jQuery.sap.assert(!fnClass || typeof fnClass === "function");

	// ensure defaults
	if ( fnBaseClass ) {
		// default constructor just delegates to base class
		if ( !fnClass ) {
			if ( oClassInfo.metadata.deprecated ) {
			  // create default factory with deprecation warning
				fnClass = function() {
					jQuery.sap.log.warning("Usage of deprecated class: " + sClassName);
					fnBaseClass.apply(this, arguments); 
				};
			} else {
        // create default factory 
				fnClass = function() { 
					fnBaseClass.apply(this, arguments); 
				};
			}
		}
		// create prototype chain
		fnClass.prototype = jQuery.sap.newObject(fnBaseClass.prototype);
		fnClass.prototype.constructor = fnClass;
		// enforce correct baseType
		oClassInfo.metadata.baseType = fnBaseClass.getMetadata().getName();
	} else {
		// default constructor does nothing
		fnClass = fnClass || function() { };
		// enforce correct baseType
		delete oClassInfo.metadata.baseType;
	}
	oClassInfo.constructor = fnClass;

	// make the class visible as JS Object
	jQuery.sap.setObject(sClassName, fnClass);

	// add metadata
	var oMetadata = new FNMetaImpl(sClassName, oClassInfo);
	fnClass.getMetadata = fnClass.prototype.getMetadata = jQuery.sap.getter(oMetadata);

	// enrich function
	if ( !fnClass.getMetadata().isFinal() ) {
		fnClass.extend = function(sSCName, oSCClassInfo, fnSCMetaImpl) {
			return sap.ui.base.Metadata.createClass(fnClass, sSCName, oSCClassInfo, fnSCMetaImpl || FNMetaImpl);
		};
	}

	return fnClass;
};


}; // end of sap.ui.base.Metadata


/**
 * Constructor for a sap.ui.base.Object.
 *
 * @class Base class for all SAPUI5 Objects
 * @abstract
 * @author Malte Wedel
 * @version 1.10.0
 * @public
 * @name sap.ui.base.Object
 */
sap.ui.base.Metadata.createClass("sap.ui.base.Object", {

	constructor : function() {
		// complain if 'this' is not an instance of a subclass
		if ( !(this instanceof sap.ui.base.Object) ) {
			throw Error("Cannot instantiate object: \"new\" is missing!");
		}
	}

});

/**
 * Destructor method for objects
 * @public
 */
sap.ui.base.Object.prototype.destroy = function() {
};

/**
 * Returns the public interface of the object.
 *
 * @return {sap.ui.base.Interface} the public interface of the object
 * @public
 */
sap.ui.base.Object.prototype.getInterface = function() {
	// New implementation that avoids the overhead of a dedicated member for the interface
	// initially, an Object instance has no associated Interface and the getInterface
	// method is defined only in the prototype. So the code here will be executed.
	// It creates an interface (basically the same code as in the old implementation)
	var oInterface = new sap.ui.base.Interface(this, this.getMetadata().getAllPublicMethods());
	// Now this Object instance gets a new, private implementation of getInterface
	// that returns the newly created oInterface. Future calls of getInterface on the
	// same Object therefore will return the already created interface
	this.getInterface = jQuery.sap.getter(oInterface);
	// as the first caller doesn't benefit from the new method implementation we have to
	// return the created interface as well.
	return oInterface;
};

/**
 * Returns the metadata for the class that this object belongs to.
 * This method is only defined when metadata has been declared by using {@link #defineClass}.
 *
 * @name sap.ui.base.Object.prototype#getMetadata
 * @function
 * @public
 */

/**
 * Creates a subclass of class sap.ui.base.Object with name <code>sClassName</code>
 * and enriches it with the information contained in <code>oClassInfo</code>.
 *
 * <code>oClassInfo</code> might contain three kinds of informations:
 * <ul>
 * <li><code>metadata:</code> an (optional) object literal with metadata about the class.
 * The information in the object literal will be wrapped by an instance of {@link sap.ui.base.Metadata Metadata}
 * and might contain the following information
 * <ul>
 * <li><code>interfaces:</code> {string[]} (optional) set of names of implemented interfaces (defaults to no interfaces)</li>
 * <li><code>publicMethods:</code> {string[]} (optional) list of methods that should be part of the public
 * facade of the class</li>
 * <li><code>abstract:</code> {boolean} (optional) flag that marks the class as abstract (purely informational, defaults to false)</li>
 * <li><code>final:</code> {boolean} (optional) flag that marks the class as final (defaults to false)</li>
 * </ul>
 * Subclasses of sap.ui.base.Object can enrich the set of supported metadata (e.g. see {@link sap.ui.core.Element.extend}).
 * </li>
 *
 * <li><code>constructor:</code> a function that serves as a constructor function for the new class.
 * If no constructor function is given, the framework creates a default implementation that delegates all
 * its arguments to the constructor function of the base class.
 * </li>
 *
 * <li><i>any-other-name:</i> any other property in the <code>oClassInfo</code> is copied into the prototype
 * object of the newly created class. Callers can thereby add methods or properties to all instances of the
 * class. But be aware that the given values are shared between all instances of the class. Usually, it doesn't
 * make sense to use primitive values here other than to declare public constants.
 * </li>
 *
 * </ul>
 *
 * The prototype object of the newly created class uses the same prototype as instances of the base class
 * (prototype chaining).
 *
 * A metadata object is always created, even if there is no <code>metadata</code> entry in the <code>oClassInfo</code>
 * object. A getter for the metadata is always attached to the prototype and to the class (constructor function)
 * itself.
 *
 * Last but not least, with the third argument <code>FNMetaImpl</code> the constructor of a metadata class
 * can be specified. Instances of that class will be used to represent metadata for the newly created class
 * and for any subclass created from it. Typically, only frameworks will use this parameter to enrich the
 * metadata for a new class hierarchy they introduce (e.g. {@link sap.ui.core.Element.extend Element}).
 *
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] structured object with informations about the class
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.base.Metadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.base.Object.extend
 * @function
 * @since 1.3.1
 */

/**
 * Creates metadata for a given class and attaches it to the constructor and prototype of that class.
 *
 * After creation, metadata can be retrieved with getMetadata().
 *
 * The static info can at least contain the following entries:
 * <ul>
 * <li>baseType: {string} fully qualified name of a base class or empty
 * <li>publicMethods: {string} an array of method names that will be visible in the interface proxy returned by {@link #getInterface}
 * </ul>
 *
 * @param {string} sClassName name of an (already declared) constructor function
 * @param {object} oStaticInfo static info used to create the metadata object
 * @param {string} oStaticInfo.baseType qualified name of a base class
 * @param {string[]} oStaticInfo.publicMethods array of names of public methods
 * @param {function} [xMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.base.Metadata.
 *
 * @return {sap.ui.base.Metadata} the created metadata object
 * @public
 * @static
 * @deprecated Since 1.3.1. Use the static <code>extend</code> method of the desired base class (e.g. {@link sap.ui.base.Object.extend})
 */
sap.ui.base.Object.defineClass = function(sClassName, oStaticInfo, FNMetaImpl) {
	// create Metadata object
	var oMetadata = new (FNMetaImpl || sap.ui.base.Metadata)(sClassName, oStaticInfo);
	var fnClass = oMetadata.getClass();
	fnClass.getMetadata = fnClass.prototype.getMetadata = jQuery.sap.getter(oMetadata);
	// enrich function
	if ( !oMetadata.isFinal() ) {
		fnClass.extend = function(sSCName, oSCClassInfo, fnSCMetaImpl) {
			return sap.ui.base.Metadata.createClass(fnClass, sSCName, oSCClassInfo, fnSCMetaImpl || FNMetaImpl);
		};
	}
	jQuery.sap.log.debug("defined class '" + sClassName + "'" + (oMetadata.getParent() ? " as subclass of " + oMetadata.getParent().getName() : "") );
	return oMetadata;
};

}; // end of sap.ui.base.Object

if ( !jQuery.sap.isDeclared('sap.ui.base.Event') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.Event
jQuery.sap.declare("sap.ui.base.Event");


/**
 * Creates an event with the given sId, linked to the provided oSource and enriched with the mParameters.
 *
 * @param {string} sId The id of the event
 * @param {sap.ui.base.EventProvider} oSource The source of the event
 * @param {Object} mParameters A map of parameters for this event
 *
 * @class An Event object consisting of an id, a source and a map of parameters
 * @extends sap.ui.base.Object
 * @implements sap.ui.base.Poolable
 * @author Malte Wedel, Daniel Brinkmann
 * @version 1.10.0
 * @public
 */
// TODO Previous documentation stated that sId is numerical, but this seems not to be true
sap.ui.base.Event = function(sId, oSource, mParameters) {

	sap.ui.base.Object.apply(this);

	if (arguments.length > 0) {
		this.init(sId, oSource, mParameters);
	}

};
sap.ui.base.Event.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);

/**
 * Init this event with its data.
 *
 * The <code>init</code> method is called by an object pool when the
 * object is (re-)activated for a new caller.
 *
 * When no <code>mParameters</code> are given, an empty object is used instead.
 *
 * @param {string} sId The id of the event
 * @param {sap.ui.base.EventProvider} oSource The source of the event
 * @param {Object} [mParameters] the event parameters
 *
 * @see sap.ui.base.Poolable.prototype#init
 */
sap.ui.base.Event.prototype.init = function(sId, oSource, mParameters) {
	jQuery.sap.assert(typeof sId === "string", "Event.init: sId must be a string");
	jQuery.sap.assert(oSource instanceof sap.ui.base.EventProvider, "Event.init: oSource must be an EventProvider");

	this.sId = sId;
	this.oSource = oSource;
	this.mParameters = mParameters || {};
	this.bCancelBubble = false;
	this.bPreventDefault = false;
};

/**
 * Reset event data, needed for pooling
 * @see sap.ui.base.Poolable.prototype#reset
 */
sap.ui.base.Event.prototype.reset = function() {
	this.sId = "";
	this.oSource = null;
	this.mParameters = null;
	this.bCancelBubble = false;
	this.bPreventDefault = false;
};

/**
 * Returns the id of the event
 * @return {string} The id of the event
 * @public
 */
sap.ui.base.Event.prototype.getId = function() {

	return this.sId;

};

/**
 * Returns the source of the event
 * @return {sap.ui.base.EventProvider} The source of the event
 * @public
 */
sap.ui.base.Event.prototype.getSource = function() {

	return this.oSource;

};

/**
 * Returns all parameter values of the event keyed by their names.
 * @return {map} All parameters of the event keyed by name
 * @public
 */
sap.ui.base.Event.prototype.getParameters = function() {

	return this.mParameters;

};

/**
 * Returns the value of the parameter with the given sName.
 *
 * @param {string} sName the name of the parameter to return
 * @return {any} the value for the named parameter
 * @public
 */
sap.ui.base.Event.prototype.getParameter = function(sName) {

	jQuery.sap.assert(typeof sName === "string" && sName, "Event.getParameter: sName must be a non-empty string");

	return this.mParameters[sName];

};

/**
 * Cancel bubbling of the event.
 * @public
 */
sap.ui.base.Event.prototype.cancelBubble = function() {

	this.bCancelBubble = true;

};

/**
 * Prevent the default action of this event.
 * @public
 */
sap.ui.base.Event.prototype.preventDefault = function() {

	this.bPreventDefault = true;

};


}; // end of sap.ui.base.Event

if ( !jQuery.sap.isDeclared('sap.ui.base.ObjectPool') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.ObjectPool
jQuery.sap.declare("sap.ui.base.ObjectPool");


/**
 * Creates an ObjectPool instance based on the given oObjectClass.&lt;br/&gt;
 * If there is a free pooled instance, returns that one, otherwise creates a new one.&lt;br/&gt;
 * In order to be maintained by the ObjectPool, oObjectClass must implement
 * methods described in the class description.
 *
 * @param {function} oObjectClass constructor for the class of objects that this pool should manage
 *
 * @class Manages a pool of objects all of the same type;
 * the type has to be specified at pool construction time.
 *
 * Maintains a list of free objects of the given type.
 * If {@link sap.ui.base.ObjectPool.prototype.borrowObject} is called, an existing free object
 * is taken from the pool and the <code>init</code> method is called on this
 * object.
 *
 * When no longer needed, any borrowed object should be returned to
 * the pool by calling {@link #returnObject}. At that point in time,
 * the reset method is called on the object and the object is added to the
 * list of free objects.
 *
 * See {@link sap.ui.base.Poolable} for a description of the contract for poolable objects.
 *
 * Example:
 * <pre>
 *   this.oEventPool = new sap.ui.base.ObjectPool(sap.ui.base.Event);
 *   var oEvent = this.oEventPool.borrowObject(iEventId, mParameters);
 * </pre>
 *
 * @extends sap.ui.base.Object
 * @author Malte Wedel
 * @version 1.10.0
 * @constructor
 * @public
 */
sap.ui.base.ObjectPool = function(oObjectClass) {

	sap.ui.base.Object.apply(this);

	this.oObjectClass = oObjectClass;

	this.aFreeObjects = [];
//	this.aUsedObjects = []; //PERFOPT: Holding those is currently senseless.

};

sap.ui.base.ObjectPool.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);

/**
 * Borrows a free object from the pool. Any arguments to this method
 * are forwarded to the init method of the borrowed object.
 *
 * @param {any} [any] optional initialization parameters for the borrowed object
 * @return {object} the borrowed object of the same type that has been specified for this pool
 * @public
 */
sap.ui.base.ObjectPool.prototype.borrowObject = function() {

	// PERFOPT: Reduced callstack
	var oObject = this.aFreeObjects.length == 0 ?
			new this.oObjectClass() :
				this.aFreeObjects.pop();
	oObject.init.apply(oObject, arguments);
//	this.aUsedObjects.push(oObject); //PERFOPT: Holding those is currently senseless.

	return oObject;
};

/**
 * Returns an object to the pool. The object must have been borrowed from this
 * pool beforehand. The reset method is called on the object before it is added
 * to the set of free objects.
 *
 * @param {object} the object to return to the pool
 * @public
 */
sap.ui.base.ObjectPool.prototype.returnObject = function(oObject) {

	oObject.reset();
	// If the next line is ever activated again, ensure not simply the topmost object is poped but the one returned!!
//	this.aUsedObjects.pop(); //PERFOPT: Holding those is currently senseless.
	this.aFreeObjects.push(oObject);

};


/**
 * Poolable objects must provide a no-arg constructor which is used by the pool
 * to construct new, unused objects.
 *
 * To be more convenient to use, poolable objects should implement their constructor
 * in a way that it either can be called with no arguments (used by the pool) or
 * with the same signature as their {@link #init} method (to be used by applications).
 *
 * @name sap.ui.base.Poolable
 * @interface Contract for objects that can be pooled by ObjectPool
 * @constructor
 * @public
 */

/**
 * Called by the object pool when this instance will be actived for a caller.
 * The same method will be called after a new instance has been created by an otherwise
 * exhausted pool.
 *
 * If the caller provided any arguments to {@link sap.ui.base.ObjectPool#borrowObject}
 * all arguments will be propagated to this method.
 *
 * @name sap.ui.base.Poolable.prototype.init
 * @function
 * @public
 */

/**
 * Called by the object pool when an instance is returned to the pool.
 * While no specific implementation is required, poolable objects in general
 * should clean all caller specific state (set to null) in this method to
 * avoid memory leaks and to enforce garbage collection of the caller state.
 *
 * @name sap.ui.base.Poolable.prototype.reset
 * @function
 * @public
 */
}; // end of sap.ui.base.ObjectPool


/**
 * Creates an instance of EventProvider.
 * @class Provides internal eventing facilities for objects, so other objects can attach
 * and detach events, and are notified, when events are fired
 *
 * @abstract
 * @extends sap.ui.base.Object
 * @author Malte Wedel, Daniel Brinkmann
 * @version 1.10.0
 * @constructor
 * @public
 * @name sap.ui.base.EventProvider
 */
sap.ui.base.Object.extend("sap.ui.base.EventProvider", /* @lends sap.ui.base.EventProvider */ {

	constructor : function() {

		sap.ui.base.Object.apply(this);

		/**
		 * A map of arrays of event registrations keyed by the event names
		 * @private
		 */
		this.mEventRegistry = {};

	}

});

/**
 * Map of event names and ids, that are provided by this class
 * @private
 * @static
 */
sap.ui.base.EventProvider.M_EVENTS = {EventHandlerChange:"EventHandlerChange"};

/**
 * Pool is defined on the prototype to be shared among all EventProviders
 * @private
 */
sap.ui.base.EventProvider.prototype.oEventPool = new sap.ui.base.ObjectPool(sap.ui.base.Event);

/**
 * Adds an event registration for the given object and given event name
 *
 * @param {String}
 *            sEventId The identifier of the event to listen for
 * @param {Object}
 *            [oData] The object, that should be passed along with the event-object when firing the event
 * @param {Function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or on the event provider-instance
 * @param {Object}
 *            [oListener] The object, that wants to be notified, when the event occurs
 * @return {sap.ui.base.EventProvider} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.base.EventProvider.prototype.attachEvent = function(sEventId, oData, fnFunction, oListener) {
	jQuery.sap.assert(typeof(sEventId) === "string" && sEventId, "EventProvider.attachEvent: sEventId must be a non-empty string");
	if(typeof(oData) === "function") {
	//one could also increase the check in the line above
	//if(typeof(oData) === "function" && oListener === undefined) {
		oListener = fnFunction;
		fnFunction = oData;
		oData = undefined;
	}
	jQuery.sap.assert(typeof(fnFunction) === "function", "EventProvider.attachEvent: fnFunction must be a function");
	jQuery.sap.assert(!oListener || typeof(oListener) === "object", "EventProvider.attachEvent: oListener must be empty or an object");

	if (!this.mEventRegistry[sEventId]) {
		this.mEventRegistry[sEventId] = [];
	}
	this.mEventRegistry[sEventId].push({oListener:oListener, fFunction:fnFunction, oData: oData});

	// Inform interested parties about changed EventHandlers
	this.fireEvent(sap.ui.base.EventProvider.M_EVENTS.EventHandlerChange, {EventId: sEventId, type: 'listenerAttached'});

	return this;
};

/**
 * Removes an event registration for the given object and given event name.
 *
 * The passed parameters must match those used for registration with {@link #attachEvent } beforehand!
 *
 * @param {String}
 *            sEventId The identifier of the event to detach from
 * @param {Function}
 *            fFunction The function to call, when the event occurs.
 * @param {Object}
 *            [oListener] The object, that wants to be notified, when the event occurs
 * @return {sap.ui.base.EventProvider} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.base.EventProvider.prototype.detachEvent = function(sEventId, fnFunction, oListener) {

	jQuery.sap.assert(typeof(sEventId) === "string" && sEventId, "EventProvider.detachEvent: sEventId must be a non-empty string" );
	jQuery.sap.assert(typeof(fnFunction) === "function", "EventProvider.detachEvent: fnFunction must be a function");
	jQuery.sap.assert(!oListener || typeof(oListener) === "object", "EventProvider.detachEvent: oListener must be empty or an object");

	var aEventListeners = this.mEventRegistry[sEventId];
	if (!aEventListeners) {
		return this;
	}
	//PERFOPT use array. remember length to not re-calculate over and over again
	for (var i = 0, iL = aEventListeners.length; i < iL; i++) {
		//PERFOPT check for identity instead of equality... avoid type conversion
		if (aEventListeners[i].fFunction === fnFunction && aEventListeners[i].oListener === oListener) {
			//delete aEventListeners[i];
			aEventListeners.splice(i,1);
			break;
		}
	}
	// If we just deleted the last registered EventHandler, remove the whole entry from our map.
	if(aEventListeners.length == 0) {
		delete this.mEventRegistry[sEventId];
	}

	// Inform interested parties about changed EventHandlers
	this.fireEvent(sap.ui.base.EventProvider.M_EVENTS.EventHandlerChange, {EventId: sEventId, type: 'listenerDetached' });

	return this;
};

/**
 * Fires the given event and notifies all listeners. Listeners must not change
 * the content of the event.
 *
 * @param {String} sEventId the event id
 * @param {Object} [mParameters] the parameter map
 * @param {boolean} [bAllowPreventDefault] whether prevent default is allowed
 * @param {boolean} [bEnableEventBubbling] whether event bubbling is enabled
 * @return {sap.ui.base.EventProvider|boolean} Returns <code>this</code> to allow method chaining or
 *		   whether the default action should be executed, when bAllowPreventDefault has been set to true
 * @protected
 */
sap.ui.base.EventProvider.prototype.fireEvent = function(sEventId, mParameters, bAllowPreventDefault, bEnableEventBubbling) {

	// at least in BrowserEventManager when firing events of its E_EVENTS enumeration, the type will be an integer... thus avoid this check
//	jQuery.sap.assert(typeof (sEventId) == "string");

	// get optional parameters right
	if (typeof mParameters == "boolean") {
		bEnableEventBubbling = bAllowPreventDefault;
		bAllowPreventDefault = mParameters;
	}

	var aEventListeners = this.mEventRegistry[sEventId],
		bPreventDefault = false,
		oEvent, oParent, oInfo;

	if (aEventListeners && jQuery.isArray(aEventListeners)) {

		// this ensures no 'concurrent modification exception' occurs (e.g. an event listener deregisters itself).
		aEventListeners = aEventListeners.slice();

		oEvent = this.oEventPool.borrowObject(sEventId, this, mParameters);

		//PERFOPT use array. remember length to not re-calculate over and over again
		for (var i = 0, iL = aEventListeners.length; i < iL; i++) {
			oInfo = aEventListeners[i];
			oInfo.fFunction.call(oInfo.oListener || this, oEvent, oInfo.oData);
		}

		// In case this is a bubbling event and object has a getParent method, also fire on parents
		if (bEnableEventBubbling) {
			oParent = this.getEventingParent();
			while (oParent && !oEvent.bCancelBubble) {
				aEventListeners = oParent.mEventRegistry[sEventId];
				if (aEventListeners && aEventListeners instanceof Array) {
					aEventListeners = aEventListeners.slice();
					for (var i = 0, iL = aEventListeners.length; i < iL; i++) {
						oInfo = aEventListeners[i];
						oInfo.fFunction.call(oInfo.oListener || oParent, oEvent, oInfo.oData);
					}
				}
				oParent = oParent.getEventingParent();
			}
		}

		// Store prevent default state, before returning event to the pool
		bPreventDefault = oEvent.bPreventDefault;

		this.oEventPool.returnObject(oEvent);
	}

	// Only return prevent default result in case it has been enabled, for compatibility
	if (bAllowPreventDefault) {
		return !bPreventDefault;
	}
	else {
		return this;
	}
};

/**
 * Returns whether there are any listeners for the given event ID.
 *
 * @param {String} sEventId the ID of the event
 * @return {boolean} whether there are any listeners
 * @private
 */
sap.ui.base.EventProvider.prototype.hasListeners = function(sEventId) {
	return !!this.mEventRegistry[sEventId];
};

/**
 * Returns the list of events currently having listeners attached.
 *
 * Introduced for lightspeed support to ensure that only relevant events are attached to the LS-world.
 *
 * This is a static method to avoid the pollution of the Element/Control namespace.
 * As the callers are limited and known and for performance reasons the internal event registry
 * is returned. It contains more information than necessary, but needs no expensive conversion.
 *
 * @return {object} the list of events currently having listeners attached
 * @private
 * @static
 */
sap.ui.base.EventProvider.getEventList = function(oEventProvider) {
	return oEventProvider.mEventRegistry;
};

/**
 * Returns the parent in the eventing hierarchy of this object.
 *
 * Per default this returns null, but if eventing is used in objects, which are hierarchically
 * structured, this can be overwritten to make the object hierarchy visible to the eventing and
 * enables the use of event bubbling within this object hierarchy.
 *
 * @return {sap.ui.base.EventProvider} the parent event provider
 * @protected
 */
sap.ui.base.EventProvider.prototype.getEventingParent = function() {
	return null;
};

/**
 * Returns a string representation of this object.
 *
 * In case there is no class or id information, a simple static string is returned.
 * Subclasses should override this method.
 *
 * @return {string} a string description of this eventProvider
 * @public
 */
sap.ui.base.EventProvider.prototype.toString = function() {
	if ( this.getMetadata ) {
		return "EventProvider " + this.getMetadata().getName();
	}
	else {
		return "EventProvider";
	}
};

///**
// * Destroy this instance of the EventProvider.
// * @protected
// */
//sap.ui.base.EventProvider.prototype.exit = function() {
//	this.mEventRegistry = null;
//};
}; // end of sap.ui.base.EventProvider

if ( !jQuery.sap.isDeclared('sap.ui.base.DataType') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.DataType
jQuery.sap.declare("sap.ui.base.DataType");

/**
 * @class Describes the metadata of a data type and provides methods for validation.
 * @author Frank Weigel
 * @since 0.9.0
 */
sap.ui.base.DataType = function() {
	// Avoid construction of a DataType.
	// DataType is only a function to support the "instanceof" operator.
	throw new Error();
};

/**
 * The qualified name of the data type.
 * Note that this name usually equals the design time name of the type.
 * Only for primitive types it differs, namely it omits the package 'sap.ui.core'.
 * @return {string} name of the data type
 * @public
 */
sap.ui.base.DataType.prototype.getName = function() {
	return undefined;
};

/**
 * The base type of this type or undefined if this is a primitive type.
 * @return {sap.ui.base.DataType} base type or undefined
 * @public
 */
sap.ui.base.DataType.prototype.getBaseType = function() {
	return undefined;
};

/**
 * The component type of this type or undefined if this is not an array.
 * @return {sap.ui.base.DataType} component type or undefined
 * @public
 */
sap.ui.base.DataType.prototype.getComponentType = function() {
	return undefined;
};

/**
 * The default value for this type. Each type must define a default value.
 * @return {any} default value of the data type. The type of the returned value
 *    must match the JavaScript type of the data type (a string for string types etc.)
 * @public
 */
sap.ui.base.DataType.prototype.getDefaultValue = function() {
	return undefined;
};

/**
 * Whether this type is an array type.
 * @return {boolean} whether this type is an array type
 * @public
 */
sap.ui.base.DataType.prototype.isArrayType = function() {
	return undefined;
};

/**
 * Parses the given string value and converts it into the specific data type.
 * @param {string} sValue string representation for a value of this type
 * @return the value in the correct internal format
 * @public
 */
sap.ui.base.DataType.prototype.parseValue = function(sValue) {
	// currently this function considers to handle primitive values
	// - in future may be other values might be also relevant.
	var sType = this.getName();
	if (sType == "string") {
		return sValue;
	} else if (sType == "boolean") {
		return sValue == "true";
	} else if (sType == "int") {
		return parseInt(sValue, 10);
	} else if (sType == "float") {
		return parseFloat(sValue);
	} else {
		// support for other types like e.g.
		// sap.ui.core.CSSSize (just apply)
		return sValue;
	}
};

/**
 * A validation check. To be implemented by concrete types.
 * @param {any} vValue the value to be checked
 * @return {boolean} whether the given value is valid for this data type (without conversion)
 * @public
 */
sap.ui.base.DataType.prototype.isValid = undefined;

(function() {

	function createType(name, s, base) {

		jQuery.sap.assert(typeof name === "string" && !!name, "DataType.<createType>: type name must be a string");
		jQuery.sap.assert(!base || base instanceof sap.ui.base.DataType, "DataType.<createType>: base type must be empty or a DataType");
		s = s || {};
		base = base || sap.ui.base.DataType.prototype;

		// create a new type object with the base type as prototype
		var type = jQuery.sap.newObject(base);

		// getter for the name
		type.getName = function() { return name; };

		// if a default value is specified, create a getter for it
		if ( s.hasOwnProperty("defaultValue") ) {
			var vDefault = s.defaultValue;
			type.getDefaultValue = function() { return vDefault; };
		}

		// if a validator is specified either chain it with the base type validator
		// or set it if no base validator exists
		if ( s.hasOwnProperty("isValid") ) {
			var fnIsValid = s.isValid;
			type.isValid = base.isValid ? function(vValue) {
				if ( !base.isValid(vValue) ) {
					return false;
				}
				return fnIsValid(vValue);
			} : fnIsValid;
		};

		// not an array type
		type.isArrayType = function() { return false; };
		
		return type;
	}

	function createArrayType(componentType) {
		jQuery.sap.assert(componentType instanceof sap.ui.base.DataType, "DataType.<createArrayType>: compoinentType must be a DataType");

		// create a new type object with the base type as prototype
		var type = jQuery.sap.newObject(sap.ui.base.DataType.prototype);

		// getter for the name
		type.getName = function() { return componentType.getName() + "[]"; };

		// getter for component type
		type.getComponentType = function() { return componentType; };

		// array validator
		type.isValid = function(aValues) {
			if (aValues === null) {
				return true;
			}
			if (jQuery.isArray(aValues)) {
				for (var i = 0; i < aValues.length; i++) {
					if (!componentType.isValid(aValues[i])) {
						return false;
					}
				}
				return true;
			}
			return false;
		};

		// array parser
		type.parseValue = function(sValue) {
			var aValues = sValue.split(",");
			for (var i = 0; i < aValues.length; i++) {
				aValues[i] = componentType.parseValue(aValues[i]);
			}
			return aValues;
		};

		// is an array type
		type.isArrayType = function() { return true; };

		return type;
	}

	var PREDEFINED_TYPES = {

		"any" :
				createType("any", {
					defaultValue : null,
					isValid : function(vValue) {
						return true;
					}
				}),

		"boolean" :
			createType("boolean", {
				defaultValue : false,
				isValid : function(vValue) {
					return typeof vValue === "boolean";
				}
			}),

		"int" :
			createType("int", {
				defaultValue : 0,
				isValid : function(vValue) {
					return typeof vValue === "number" && Math.floor(vValue) == vValue;
				}
			}),

		"float" :
			createType("float", {
				defaultValue : 0.0,
				isValid : function(vValue) {
					return typeof vValue === "number";
				}
			}),

		"string" :
			createType("string", {
				defaultValue : "",
				isValid : function(vValue) {
					return typeof vValue === "string" || vValue instanceof String;
				}
			}),
		"object" :
			createType("object", {
				defaultValue : null,
				isValid : function(vValue) {
					return typeof vValue === "object" || typeof vValue === "function";
				}
			})
	};

	/**
	 * Returns the type object for the type with the given name.
	 * @return the type object or undefined when no such type object exists.
	 * @public
	 */
	sap.ui.base.DataType.getType = function(sTypeName) {
		if (sTypeName.indexOf("[]") > 0) {
			var sComponentTypeName = sTypeName.substr(0, sTypeName.length - 2),
				oComponentType = this.getType(sComponentTypeName);
			return oComponentType && createArrayType(oComponentType);
		} else {
			return PREDEFINED_TYPES[sTypeName] || jQuery.sap.getObject(sTypeName);
		}
	};

	/**
	 * Creates a new type as a subtype of a given type.
	 * @param {string} sName the unique name of the new type
	 * @param {object} [mSettings settings] for the new type
	 * @param {any} [mSettings.defaultValue] the default value for the new type
	 * @param {function} [mSettings.isValid] a validator function for values of the new type
	 * @param {sap.ui.base.DataType} [base] the base type for the new type
	 * @public
	 */
	sap.ui.base.DataType.createType = createType;

	// ---- minimal support for interface types ----
	
	var mInterfaces = {};
	
	/**
	 * Registers the given array of type names as known interface types.
	 * Only purpose is to enable the {@link #isInterfaceType} check.
	 * @param {string[]} aTypes interface types to be reigstered  
	 * @private
	 */
	sap.ui.base.DataType.registerInterfaceTypes = function(aTypes) {
		for(var i=0; i<aTypes.length; i++) {
			jQuery.sap.setObject(aTypes[i], mInterfaces[aTypes[i]] = new String(aTypes[i]));
		}
	};
	
	/**
	 * @param {string} sType name of type to check
	 * @return {boolean} whether the given type is known to be an interface type
	 * @private 
	 */
	sap.ui.base.DataType.isInterfaceType = function(sType) {
		return mInterfaces.hasOwnProperty(sType) && jQuery.sap.getObject(sType) === mInterfaces[sType];
	};

}());
}; // end of sap.ui.base.DataType

if ( !jQuery.sap.isDeclared('sap.ui.core.Configuration') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

//Provides class sap.ui.core.Configuration
jQuery.sap.declare("sap.ui.core.Configuration");


(function() {

	/**
	 * Creates a new Configuration object.
	 *
	 * @class Collects and stores the configuration of the current environment.
	 *
	 * The Configuration is initialized once when the {@link sap.ui.core.Core} is created.
	 * There are different ways to set the environment configuration (in ascending priority):
	 * <ol>
	 * <li>System defined defaults
	 * <li>Server wide defaults, read from /sap-ui-config.json
	 * <li>Properties of the global configuration object window["sap-ui-config"]
	 * <li>A configuration string in the data-sap-ui-config attribute of the bootstrap tag
	 * <li>Individual data-sap-ui-xyz attributes of the bootstrap tag
	 * <li>Using URL parameters
	 * <li>Setters in this Configuration object (only for some parameters)
	 * </ol>
	 *
	 * That is, attributes of the DOM reference override the system defaults, URL parameters
	 * override the DOM attributes (where empty URL parameters set the parameter back to its
	 * system default). Calling setters at runtime will override any previous settings
	 * calculated during object creation.
	 *
	 * The naming convention for parameters is:
	 * <ul>
	 * <li>in the URL : sap-ui-<i>PARAMETER-NAME</i>="value"
	 * <li>in the DOM : data-sap-ui-<i>PARAMETER-NAME</i>="value"
	 * </ul>
	 * where <i>PARAMETER-NAME</i> is the name of the parameter in lower case.
	 *
	 * Values of boolean parameters are case insensitive where "true" and "x" are interpreted as true.
	 *
	 * @extends sap.ui.base.Object
	 * @author Frank Weigel (Martin Schaus)
	 * @constructor
	 * @public
	 * @name sap.ui.core.Configuration
	 */
	sap.ui.base.Object.extend("sap.ui.core.Configuration", /** @lends sap.ui.core.Configuration.prototype */ {

		constructor : function() {
			
			function detectLanguage() {
				var match;
				if (jQuery.os.android) {
					// on Android, navigator.language is hardcoded to 'en', so check UserAgent string instead 
					match = navigator.userAgent.match(/\s([a-z]{2}-[a-z]{2})[;)]/i);
					if ( match ) {
						return match[1];
					}
          // okay, we couldn't find a language setting. It might be better to fallback to 'en' instead of having no language 
				} 
				return navigator.language || navigator.userLanguage || navigator.browserLanguage;
			}
			
			// definition of supported settings
			var M_SETTINGS = {
					"theme"           : { type : "string",   defaultValue : "base" },
					"language"        : { type : "string",   defaultValue : detectLanguage() },
					"formatLocale"    : { type : "string",   defaultValue : null },
					// "timezone"      : "UTC",
					"accessibility"   : { type : "boolean",  defaultValue : true },
					"animation"       : { type : "boolean",  defaultValue : true },
					"rtl"             : { type : "boolean",  defaultValue : false },
					"debug"           : { type : "boolean",  defaultValue : false },
					"inspect"         : { type : "boolean",  defaultValue : false },
					"originInfo"      : { type : "boolean",  defaultValue : false },
					"noConflict"      : { type : "boolean",  defaultValue : false,     noUrl:true },
					"noDuplicateIds"  : { type : "boolean",  defaultValue : true },
					"trace"           : { type : "boolean",  defaultValue : false,     noUrl:true },
					"modules"         : { type : "string[]", defaultValue : [],        noUrl:true },
					"areas"           : { type : "string[]", defaultValue : null,      noUrl:true },
					// "libs"			  : { type : "string[]", defaultValue : [],        noUrl:true }, deprecated, handled below
					"onInit"          : { type : "code",     defaultValue : undefined, noUrl:true },
					"uidPrefix"       : { type : "string",   defaultValue : "__",      noUrl:true },
					"ignoreUrlParams" : { type : "boolean",  defaultValue : false,     noUrl:true },
					"weinreServer"    : { type : "string",   defaultValue : "",		   noUrl:true },
					"weinreId"        : { type : "string",   defaultValue : "" },
					"xx-loadAllMode"  : { type : "boolean",  defaultValue : false,     noUrl:true },
					"preload"         : { type : "string",   defaultValue : 'auto' },
					"xx-test-mobile"  : { type : "boolean",  defaultValue : false },
					"appCacheBuster"  : { type : "boolean",  defaultValue : false },
					"xx-bootTask"     : { type : "function", defaultValue : undefined, noUrl:true }
			};

			this.oFormatSettings = new sap.ui.core.Configuration.FormatSettings(this);

			/* Object that carries the real configuration data */
			var config = this;

			function setValue(sName, sValue) {
				if ( typeof sValue === "undefined" || sValue === null ) {
					return;
				}
				switch(M_SETTINGS[sName].type) {
				case "boolean":
					if ( typeof sValue === "string" ) {
						if (M_SETTINGS[sName].defaultValue) {
							config[sName] = sValue.toLowerCase() != "false";
						} else {
							config[sName] = sValue.toLowerCase() === "true" || sValue.toLowerCase() === "x";
						}
					} else {
						// boolean etc.
						config[sName] = !!sValue;
					}
					break;
				case "string":
					config[sName] = "" + sValue; // enforce string
					break;
				case "code":
					config[sName] = typeof sValue === "function" ? sValue : String(sValue);
					break;
				case "function":
					if ( typeof sValue !== "function" ) {
						throw new Error("unsupported value");
					}
					config[sName] = sValue;
					break;
				case "string[]":
					if ( jQuery.isArray(sValue) ) {
						config[sName] = sValue;
					} else if ( typeof sValue === "string" ) {
						config[sName] = jQuery.map(sValue.split(/[ ,;]/), function($) { return jQuery.trim($); });
					} else {
						throw new Error("unsupported value");
					}
					break;
				default:
					throw new Error("illegal state");
				}
			}

			// 1. collect the defaults
			for (var n in M_SETTINGS ) {
				config[n] = M_SETTINGS[n].defaultValue;
			}

			// 2. read server wide sapui5 configuration
			/* TODO: RETHINK server wide sapui5 configuration to make it optional
    			 currently it is forcing a request which is annoying customers :
    			   - Think about an option which enables loading of server wide config!
    	var sUrl = "/sap-ui-config.json";
    	var oResponse = jQuery.sap.sjax({url:sUrl});
    	if (oResponse.success) {
    		var oServerCfg = {};
    		if (typeof oResponse.data == "string") {
    			try {
    				oServerCfg = jQuery.parseJSON(oResponse.data);
    			} catch(ex) {
    				jQuery.sap.log.warning("Error when parsing the JSON configuration content from " + sUrl + " : " + ex);
    			}
    		} else {
    			oServerCfg = oResponse.data;
    		}
    		for (var n in M_SETTINGS) {
    			if (oServerCfg[n]) {
    				setValue(n, oServerCfg[n]);
    			}
    		}
    	}
			 */

			// 3.-5. apply settings from global config object (already merged with script tag attributes)
			var oCfg = window["sap-ui-config"] || {};
			oCfg.oninit = oCfg.oninit || oCfg["evt-oninit"];
			for (var n in M_SETTINGS) {
				setValue(n, oCfg[n.toLowerCase()]);
			}
			// if libs are configured, convert them to modules and prepend them to the existing modules list
			if ( oCfg.libs ) {
				config.modules = jQuery.map(oCfg.libs.split(","), function($) { return jQuery.trim($)+".library"; }).concat(config.modules);
			}

			// 6. apply the settings from the url (only if not blocked by app configuration)
			if ( !config.ignoreUrlParams ) {
				var sUrlPrefix = "sap-ui-";
				var oUriParams = jQuery.sap.getUriParameters();

				// map SAP parameters (if later as sap-ui parameter set this wins)
				if (oUriParams.mParams['sap-locale'] || oUriParams.mParams['sap-language']) {
					// map sap-locale or sap-language to sap-ui-language
					var sValue = oUriParams.get('sap-locale') || oUriParams.get('sap-language');
					if (sValue === "") {
						//empty URL parameters set the parameter back to its system default
						config['language'] = M_SETTINGS['language'].defaultValue;
					} else {
						//sets the value (null or empty value ignored)
						setValue('language', sValue);
					}
				}

				if (oUriParams.mParams['sap-accessibility']) {
					// "" = false, "X", "x" = true
					var sValue = oUriParams.get('sap-accessibility');
					if (sValue === "X" || sValue === "x") {
						setValue('accessibility', true);
					} else {
						setValue('accessibility', false);
					}
				}

				if (oUriParams.mParams['sap-rtl']) {
					// "" = false, "X", "x" = true
					var sValue = oUriParams.get('sap-rtl');
					if (sValue === "X" || sValue === "x") {
						setValue('rtl', true);
					} else {
						setValue('rtl', false);
					}
				}

				if (oUriParams.mParams['sap-theme']) {
					var sValue = oUriParams.get('sap-theme');
					if (sValue === "") {
						// empty URL parameters set the parameter back to its system default
						config['theme'] = M_SETTINGS['theme'].defaultValue;
					} else {
						// check if @ in theme - not allowed yet
						var iIndex = sValue.indexOf("@");
						if (iIndex >= 0) {
							jQuery.sap.log.warning("@ not allowed in theme name (theme-root not supported!)");
							if (iIndex == 0) {
								config['theme'] = M_SETTINGS['theme'].defaultValue;
							}else{
								// use part before @ as theme
								setValue('theme', sValue.slice(0, iIndex));
							}
						}else{
							setValue('theme', sValue);
						}
					}
				}

				// now analyze sap-ui parameters
				for (var n in M_SETTINGS) {
					if ( M_SETTINGS[n].noUrl ) {
						continue;
					}
					var sValue = oUriParams.get(sUrlPrefix + n);
					if (sValue === "") {
						//empty URL parameters set the parameter back to its system default
						config[n] = M_SETTINGS[n].defaultValue;
					} else {
						//sets the value (null or empty value ignored)
						setValue(n, sValue);
					}
				}
			}

			for (var n in M_SETTINGS) {
				if ( config[n] !== M_SETTINGS[n].defaultValue ) {
					jQuery.sap.log.info("  " + n + " = " + config[n]);
				}
			}
		},

		/**
		 * Returns the theme name
		 * @return {string} the theme name
		 * @public
		 */
		getTheme : function () {
			return this.theme;
		},

		/**
		 * Allows setting the theme name
		 * @param {string} sTheme the theme name
		 * @return {sap.ui.core.Configuration} <code>this</code> to allow method chaining
		 * @private
		 */
		_setTheme : function (sTheme) {
			this.theme = sTheme;
			return this;
		},

		/**
		 * Returns the language string with language and country code
		 * @return {string} the language string with language and country code
		 * @public
		 */
		getLanguage : function () {
			return this.language;
		},

		/**
		 * Returns the active locale for the current session. 
		 * The locale is derived from the {@link #getLanguage language} property.  
		 * @return {sap.ui.core.Locale} the locale
		 * @public
		 */
		getLocale : function () {
			return new sap.ui.core.Locale(this.language);
		},

		/**
		 * Returns the format locale string with language and region code. Falls back to language configuration,
		 * in case it has not been explicitly defined.
		 * @return {string} the format locale string with language and country code
		 * @public
		 */
		getFormatLocale : function () {
			return this.formatLocale || this.language;
		},

		/**
		 * Returns whether the accessibility mode is used or not
		 * @return {boolean} whether the accessibility mode is used or not
		 * @public
		 */
		getAccessibility : function () {
			return this.accessibility;
		},

		/**
		 * Returns whether the animations are globally used
		 * @return {boolean} whether the animations are globally used
		 * @public
		 */
		getAnimation : function () {
			return this.animation;
		},

		/**
		 * Returns whether the page uses the RTL text direction
		 * @return {boolean} whether the page uses the RTL text direction
		 * @public
		 */
		getRTL : function () {
			return this.rtl;
		},

		/**
		 * Returns whether the page runs in debug mode
		 * @return {boolean} whether the page runs in debug mode
		 * @public
		 */
		getDebug : function () {
			return this.debug;
		},

		/**
		 * Returns whether the UI5 control inspector is displayed
		 * Has only an effect when the sap-ui-debug module has been loaded
		 * @return {boolean} whether the UI5 control inspector is displayed
		 * @public
		 */
		getInspect : function () {
			return this.inspect;
		},

		/**
		 * Returns whether the text origin information is collected
		 * @return {boolean} whether the text info is collected
		 * @public
		 */
		getOriginInfo : function () {
			return this.originInfo;
		},

		/**
		 * Returns whether there should be an exception on any duplicate element IDs
		 * @return {boolean} whether there should be an exception on any duplicate element IDs
		 * @public
		 */
		getNoDuplicateIds : function () {
			return this.noDuplicateIds;
		},

		/**
		 * Whether a trace view should be shown or not.
		 * Has only an effect when the sap-ui-debug module has been loaded
		 * either by explicitly loading it or by setting the 'debug' option to true.
		 * @return {boolean} whether a trace view should be shown
		 */
		getTrace : function () {
			return this.trace;
		},

		/**
		 * Prefix to be used for automatically generated control IDs.
		 * Default is a double underscore "__".
		 *
		 * @returns {string} the prefix to be used
		 * @public
		 */
		getUIDPrefix : function() {
			return this.uidPrefix;
		},

		/**
		 * WEINRE server URL
		 *
		 * @returns {string} the base URL of the WEINRE server
		 * @public
		 */
		getWeinreServer : function() {
			var sWeinreServer = this.weinreServer;
			if (!sWeinreServer) {
				// if not weinre server is configured - we expect that the weinre server
				// is installed on the same machine with port no of the app + 1
				sWeinreServer = window.location.protocol + "//" + window.location.hostname + ":";
				sWeinreServer += (parseInt(window.location.port, 10) || 8080) + 1;
			}
			return sWeinreServer;
		},

		/**
		 * WEINRE session ID
		 *
		 * @returns {string} the ID to use for the WEINRE server
		 * @public
		 */
		getWeinreId : function() {
			return this.weinreId;
		},

		/**
		 * URL to AppCacheBuster Etag-Index file
		 *
		 * @returns {string} URL
		 * @public
		 */
		getAppCacheBuster : function() {
			return this.appCacheBuster;
		},

		/**
		 * Returns a configuration object that bundles the format settings of UI5.
		 *
		 * @return {sap.ui.core.Configuration.FormatSettings} A FormatSettings object.
		 * @public
		 */
		getFormatSettings : function() {
			return this.oFormatSettings;
		}

	});

	var M_ABAP_DATE_FORMAT_PATTERN = {
			"" : {pattern: null},
			"1": {pattern: "dd.MM.yyyy"},
			"2": {pattern: "MM/dd/yyyy"},
			"3": {pattern: "MM-dd-yyyy"},
			"4": {pattern: "yyyy.MM.dd"},
			"5": {pattern: "yyyy/MM/dd"},
			"6": {pattern: "yyyy-MM-dd"}
	};

	var M_ABAP_TIME_FORMAT_PATTERN = {
			"" : {pattern: null, dayPeriods: null},
			"0": {pattern: "HH:mm:ss", dayPeriods : null},
			"1": {pattern: "hh:mm:ss a", dayPeriods: ["AM", "PM"]},
			"2": {pattern: "hh:mm:ss a", dayPeriods: ["am", "pm"]},
			"3": {pattern: "KK:mm:ss a", dayPeriods: ["AM", "PM"]},
			"4": {pattern: "KK:mm:ss a", dayPeriods: ["am", "pm"]}
	};

	var M_ABAP_NUMBER_FORMAT_SYMBOLS = {
			"" : {groupingSeparator: null, decimalSeparator: null},
			" ": {groupingSeparator: ".", decimalSeparator: ","},
			"X": {groupingSeparator: ",", decimalSeparator: "."},
			"Y": {groupingSeparator: " ", decimalSeparator: ","}
	};

	function check(bCondition, sMessage) {
		if ( !bCondition ) {
			throw new Error(sMessage);
		}
	}

	/**
	 * @class Encapsulates configuration settings that are related to data formatting/parsing.
	 * 
	 * <b>Note:</b> When format configuration settings are modified through this class, 
	 * UI5 only ensures that formatter objects created after that point in time will honor
	 * the modifications. To be on the safe side, applications should do any modifications 
	 * early in their lifecycle or recreate any model/UI that is locale dependent. 
	 * 
	 * @name sap.ui.core.Configuration.FormatSettings
	 * @extends sap.ui.base.Object
	 * @public
	 */
	sap.ui.base.Object.extend("sap.ui.core.Configuration.FormatSettings", /** @lends sap.ui.core.Configuration.FormatSettings.prototype */ {
		constructor : function(oConfiguration) {
			this.oConfiguration = oConfiguration;
			this.mSettings = {};
			this.sLegacyDateFormat = undefined;
			this.sLegacyTimeFormat = undefined;
			this.sLegacyNumberFormatSymbolSet = undefined;
		},

		/**
		 * Returns the locale to be used for formatting. 
		 * 
		 * If no such locale has been defined, this method falls back to the language,
		 * see {@link sap.ui.core.Configuration#getLanguage Configuration.getLanguage()}.
		 * 
		 * If any user preferences for date, time or number formatting have been set,
		 * and if no format locale has been specified, then a special private use subtag
		 * is added to the locale, indicating to the framework that these user preferences 
		 * should be applied. 
		 *  
		 * @return {sap.ui.core.Locale} the format locale 
		 * @public
		 */
		getFormatLocale : function() {
			function fallback(that) {
				var l=that.oConfiguration.language;
				// if any user settings have been defined, add the private use subtag "sapufmt"    
				if ( !jQuery.isEmptyObject(that.mSettings) ) {
					// TODO move to Locale/LocaleData
					if ( l.indexOf("-x-") < 0 ) {
						l = l + "-x-sapufmt";
					} else if ( l.indexOf("-sapufmt") <= l.indexOf("-x-") ) {
						l = l + "-sapufmt";
					}
				}
				return l;
			}
			return new sap.ui.core.Locale(this.oConfiguration.formatLocale || fallback(this));
		},

		_set : function(sKey, oValue) {
			if ( oValue != null ) {
				this.mSettings[sKey] = oValue;
			} else {
				delete this.mSettings[sKey];
			} 
		},

		/**
		 * Returns the currently set date pattern or undefined if no pattern has been defined. 
		 * @public
		 */
		getDatePattern : function(sStyle) {
			jQuery.sap.assert(sStyle == "short" || sStyle == "medium" || sStyle == "long" || sStyle == "full", "sStyle must be short, medium, long or full");
			return this.mSettings["dateFormat-" + sStyle];
		},

		/**
		 * Defines the preferred format pattern for the given date format style. 
		 * Calling this method with a null or undefined pattern removes a previously set pattern. 
		 * 
		 * If a pattern is defined, it will be preferred over patterns derived from the current locale.
		 * 
		 * See class {@link sap.ui.core.format.DateFormat} for details about the pattern syntax.
		 *  
		 * @param {string} sStyle must be one of short, medium, long or full.
		 * @param {string} sPattern the format pattern to be used in LDML syntax.
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public   
		 */
		setDatePattern : function(sStyle, sPattern) {
			check(sStyle == "short" || sStyle == "medium" || sStyle == "long" || sStyle == "full", "sStyle must be short, medium, long or full");
			this._set("dateFormat-" + sStyle, sPattern);
			return this;
		},

		/**
		 * Returns the currently set time pattern or undefined if no pattern has been defined.
		 * @public
		 */
		getTimePattern : function(sStyle) {
			jQuery.sap.assert(sStyle == "short" || sStyle == "medium" || sStyle == "long" || sStyle == "full", "sStyle must be short, medium, long or full");
			return this.mSettings["timeFormat-" + sStyle];
		},

		/**
		 * Defines the preferred format pattern for the given time format style.
		 * Calling this method with a null or undefined pattern removes a previously set pattern. 
		 *  
		 * If a pattern is defined, it will be preferred over patterns derived from the current locale.
		 * 
		 * See class {@link sap.ui.core.format.DateFormat} for details about the pattern syntax.
		 *  
		 * @param {string} sStyle must be one of short, medium, long or full.
		 * @param {string} sPattern the format pattern to be used in LDML syntax.
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public
		 */
		setTimePattern : function(sStyle, sPattern) {
			check(sStyle == "short" || sStyle == "medium" || sStyle == "long" || sStyle == "full", "sStyle must be short, medium, long or full");
			this._set("timeFormat-" + sStyle, sPattern);
			return this;
		},

		/**
		 * Returns the currently set number symbol of the given type or undefined if no symbol has been defined.
		 * @public
		 */
		getNumberSymbol : function(sType) {
			jQuery.sap.assert(sType == "decimal" || sType == "group" || sType == "plusSign" || sType == "minusSign", "sType must be decimal, group, plusSign or minusSign");
			return this.mSettings["symbols-latn-" + sType];
		},

		/**
		 * Defines the string to be used for the given number symbol.
		 * Calling this method with a null or undefined symbol removes a previously set symbol string.
		 * Note that an empty string is explicitly allowed.  
		 * 
		 * If a symbol is defined, it will be preferred over symbols derived from the current locale.
		 * 
		 * See class {@link sap.ui.core.format.NumberFormat} for details about the symbols.
		 *  
		 * @param {string} sStyle must be one of decimal, group, plusSign, minusSign.
		 * @param {string} sSymbol will be used to represent the given symbol type
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public   
		 */
		setNumberSymbol : function(sType, sSymbol) {
			check(sType == "decimal" || sType == "group" || sType == "plusSign" || sType == "minusSign", "sType must be decimal, group, plusSign or minusSign");
			this._set("symbols-latn-" + sType, sSymbol);
			return this;
		},

		_setDayPeriods : function(sWidth, aTexts) {
			jQuery.sap.assert(sWidth == "narrow" || sWidth == "abbreviated" || sWidth == "wide", "sWidth must be narrow, abbreviated or wide");
			this._set("dayPeriods-format-" + sWidth, aTexts);
			return this;
		},

		/**
		 * Returns the currently set legacy ABAP date format (its id) or undefined if none has been set.
		 *  
		 * @public
		 */
		getLegacyDateFormat : function() {
			return this.sLegacyDateFormat || undefined;
		},

		/**
		 * Allows to specify one of the legacy ABAP date formats. 
		 * 
		 * This method modifies the date patterns for 'short' and 'medium' style with the corresponding ABAP 
		 * format. When called with a null or undefined format id, any previously applied format will be removed.
		 * 
		 * @param {string} sFormatId id of the ABAP data format (one of '1','2','3','4','5','6')
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public
		 */
		setLegacyDateFormat : function(sFormatId) {
			check(!sFormatId || M_ABAP_DATE_FORMAT_PATTERN.hasOwnProperty(sFormatId), "sFormatId must be one of ['1','2','3','4','5','6'] or empty");
			this.sLegacyDateFormat = sFormatId = sFormatId || "";
			this.setDatePattern("short", M_ABAP_DATE_FORMAT_PATTERN[sFormatId].pattern);
			this.setDatePattern("medium", M_ABAP_DATE_FORMAT_PATTERN[sFormatId].pattern);
			return this;
		},

		/**
		 * Returns the currently set legacy ABAP time format (its id) or undefined if none has been set.
		 *  
		 * @public
		 */
		getLegacyTimeFormat : function() {
			return this.sLegacyTimeFormat || undefined;
		},

		/**
		 * Allows to specify one of the legacy ABAP time formats.
		 * 
		 * This method sets the time patterns for 'short' and 'medium' style to the corresponding ABAP 
		 * formats and sets the day period texts to "AM"/"PM" or "am"/"pm" respectively. When called 
		 * with a null or undefined format id, any previously applied format will be removed.
		 * 
		 * @param {string} sFormatId id of the ABAP time format (one of '0','1','2','3','4')
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public
		 */
		setLegacyTimeFormat : function(sFormatId) {
			check(!sFormatId || M_ABAP_TIME_FORMAT_PATTERN.hasOwnProperty(sFormatId), "sFormatId must be one of ['0','1','2','3','4'] or empty");
			this.sLegacyTimeFormat = sFormatId = sFormatId || "";
			this.setTimePattern("short", M_ABAP_TIME_FORMAT_PATTERN[sFormatId].pattern);
			this.setTimePattern("medium", M_ABAP_TIME_FORMAT_PATTERN[sFormatId].pattern);
			this._setDayPeriods("abbreviated", M_ABAP_TIME_FORMAT_PATTERN[sFormatId].dayPeriods);
			return this;
		},

		/**
		 * Returns the currently set legacy ABAP number format (its id) or undefined if none has been set.
		 *  
		 * @public
		 */
		getLegacyNumberFormat : function() {
			return this.sLegacyNumberFormat || undefined;
		},

		/**
		 * Allows to specify one of the legacy ABAP number format.
		 * 
		 * This method will modify the 'group' and 'decimal' symbols. When called with a null 
		 * or undefined format id, any previously applied format will be removed.
		 * 
		 * @param {string} sFormatId id of the ABAP number format set (one of ' ','X','Y')
		 * @return {sap.ui.core.Configuration.FormatSettings} Returns <code>this</code> to allow method chaining
		 * @public
		 */
		setLegacyNumberFormat : function(sFormatId) {
			sFormatId = sFormatId ? sFormatId.toUpperCase() : "";
			check(!sFormatId || M_ABAP_NUMBER_FORMAT_SYMBOLS.hasOwnProperty(sFormatId), "sFormatId must be one of [' ','X','Y'] or empty");
			this.sLegacyNumberFormat = sFormatId;
			this.setNumberSymbol("group", M_ABAP_NUMBER_FORMAT_SYMBOLS[sFormatId].groupingSeparator);
			this.setNumberSymbol("decimal", M_ABAP_NUMBER_FORMAT_SYMBOLS[sFormatId].decimalSeparator);
		},

		/*
		 * Returns a live object with the current settings
		 * TODO this method is part of the facade to be accessible from LocaleData, but it shouldn't be
		 * @private
		 */
		getCustomLocaleData : function() {
			return this.mSettings;
		}
	});

}());

}; // end of sap.ui.core.Configuration

if ( !jQuery.sap.isDeclared('sap.ui.core.Control') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides base class sap.ui.core.Control for all controls
jQuery.sap.declare("sap.ui.core.Control");
if ( !jQuery.sap.isDeclared('sap.ui.core.Element') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides the base class for all controls and UI elements.
jQuery.sap.declare("sap.ui.core.Element");

if ( !jQuery.sap.isDeclared('jquery.sap.strings') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides useful string operations not available in pure JavaScript.
jQuery.sap.declare("jquery.sap.strings", false);

(function(){


	/**
	 * Checks whether a given sString ends with sEndString
	 * respecting the case of the strings.
	 *
	 * @param {string} sString The string to be checked
	 * @param {string} sEndString The end string to be searched
	 * @return True if sString ends with sEndString
	 * @type {boolean}
	 * @see jQuery.sap.endsWithIgnoreCase
	 * @public
	 */
	jQuery.sap.endsWith = function endsWith(sString, sEndString) {
		if (typeof(sEndString)!="string" || sEndString=="") {
			return false;
		}
		var iPos = sString.lastIndexOf(sEndString);
		return iPos >= 0 && iPos == sString.length - sEndString.length;
	};

	/**
	 * Checks whether a given sString ends with sEndString
	 * ignoring the case of the strings.
	 *
	 * @param {string} sString the string to be checked
	 * @param {string} sEndString the end string to be searched
	 * @return true if sString ends with sEndString
	 * @type {boolean}
	 * @see jQuery.sap.endsWith
	 * @public
	 */
	jQuery.sap.endsWithIgnoreCase = function endsWithIgnoreCase(sString, sEndString) {
		if (typeof(sEndString)!="string" || sEndString=="") {
			return false;
		}
		sString = sString.toUpperCase();
		sEndString = sEndString.toUpperCase();
		return jQuery.sap.endsWith(sString,sEndString);
	};

	/**
	 * Checks whether a given sString starts with sStartString
	 * respecting the case of the strings.
	 *
	 * @param {string} sString The string to be checked
	 * @param {string} sStartString The start string to be searched
	 * @return True if sString ends with sEndString
	 * @type {boolean}
	 * @see jQuery.sap.startsWithIgnoreCase
	 * @public
	 */
	jQuery.sap.startsWith = function startsWith(sString, sStartString) {
		if (typeof(sStartString)!="string" || sStartString=="") {
			return false;
		}
		if (sString == sStartString) {
			return true;
		}
		return sString.indexOf(sStartString) == 0;
	};

	/**
	 * Checks whether a given sString starts with sStartString
	 * ignoring the case of the strings.
	 *
	 * @param {string} sString The string to be checked
	 * @param {string} sStartString The start string to be searched
	 * @return True if sString ends with sEndString
	 * @type {boolean}
	 * @see jQuery.sap.startsWith
	 * @public
	 */
	jQuery.sap.startsWithIgnoreCase = function startsWithIgnoreCase(sString, sStartString) {
		if (typeof(sStartString)!="string" || sStartString=="") {
			return false;
		}
		sString = sString.toUpperCase();
		sStartString = sStartString.toUpperCase();
		return jQuery.sap.startsWith(sString,sStartString);
	};

	/**
	 * Converts a character of the string to upper case.<br/>
	 * If no pos is defined as second parameter or pos is negative or greater than sString the first character will be
	 * converted into upper case. the first char position is 0.
	 *
	 * @param {string} sString The string to be checked
	 * @param {integer} iPos the position of the character that will be uppercase
	 * @return The string with the firstletter in upper case
	 * @type {string}
	 * @public
	 * @SecPassthrough {0|return}
	 */
	jQuery.sap.charToUpperCase = function charToUpperCase(sString,iPos) {
		if (!sString) {
			return sString;
		}
		if (!iPos || isNaN(iPos) || iPos <= 0 || iPos >= sString.length) {
			iPos = 0;
		}
		var sChar = sString.charAt(iPos).toUpperCase();
		if (iPos>0) {
			return sString.substring(0,iPos) + sChar + sString.substring(iPos+1);
		}
		return sChar + sString.substring(iPos+1);
	};

	/**
	 * Pads a string on the left side until is has the given length.<br/>
	 *
	 * @param {string} sString The string to be padded
	 * @param {string} sPadChar The char to use for the padding
	 * @param {integer} iLength the target length of the string
	 * @return The padded string
	 * @type {string}
	 * @public
	 * @SecPassthrough {0 1|return}
	 */
	jQuery.sap.padLeft = function padLeft(sString, sPadChar, iLength) {
		if (!sString) {
			sString = "";
		}
		while (sString.length < iLength) {
			sString = sPadChar + sString;
		}
		return sString;
	};

	/**
	 * Pads a string on the right side until is has the given length.<br/>
	 *
	 * @param {string} sString The string to be padded
	 * @param {string} sPadChar The char to use for the padding
	 * @param {integer} iLength the target length of the string
	 * @return The padded string
	 * @type {string}
	 * @public
	 * @SecPassthrough {0 1|return}
	 */
	jQuery.sap.padRight = function padRight(sString, sPadChar, iLength) {
		if (!sString) {
			sString = "";
		}
		while (sString.length < iLength) {
			sString = sString + sPadChar;
		}
		return sString;
	};


	var rCamelCase = /-(.)/ig;

	/**
	 * Transforms a hyphen separated string to an camel case string. 
	 *
     * @param {string} sString Hyphen separated string
     * @return The transformed string
     * @type {string}
     * @since 1.7.0
     * @public
     * @SecPassthrough {0|return}
     */
	jQuery.sap.camelCase = function camelCase(sString) { 
		return sString.replace( rCamelCase, function( sMatch, sChar ) {
			return sChar.toUpperCase();
		});
	};
	
	var rEscapeRegExp = /[-[\]{}()*+?.,\\^$|#\s]/g;

	/**
	 * This function escapes the reserved letters in Regular Expression
   * @param {string} sString string to escape
   * @return The escaped string
   * @type {string}
   * @since 1.9.3
   * @public
   * @SecPassthrough {0|return}
	 */
	jQuery.sap.escapeRegExp = function escapeRegExp(sString) {
		return sString.replace(rEscapeRegExp, "\\$&");
	};
	
}());
}; // end of jquery.sap.strings

if ( !jQuery.sap.isDeclared('sap.ui.base.ManagedObject') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides the base class for all objects with managed properties and aggregations.
jQuery.sap.declare("sap.ui.base.ManagedObject");





if ( !jQuery.sap.isDeclared('sap.ui.base.ManagedObjectMetadata') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.base.ManagedObjectMetadata
jQuery.sap.declare("sap.ui.base.ManagedObjectMetadata");



/**
 * Creates a new metadata object for a Element subclass.
 *
 * @param {string} sClassName fully qualified name of the class that is described by this metadata object
 * @param {object} oStaticInfo static info to construct the metadata from
 *
 * @class
 * @author Frank Weigel
 * @version 1.10.0
 * @since 0.8.6
 */
sap.ui.base.ManagedObjectMetadata = function(sClassName, oClassInfo) {

	// call super constructor
	sap.ui.base.Metadata.apply(this, arguments);

};

//chain the prototypes
sap.ui.base.ManagedObjectMetadata.prototype = jQuery.sap.newObject(sap.ui.base.Metadata.prototype);

/**
 * @private
 */
sap.ui.base.ManagedObjectMetadata.prototype.applySettings = function(oClassInfo) {

	var oStaticInfo = oClassInfo.metadata;

	sap.ui.base.Metadata.prototype.applySettings.call(this, oClassInfo);

	var rPlural = /(children|ies|ves|oes|ses|ches|shes|xes|s)$/i;
	var mSingular = {'children' : -3, 'ies' : 'y', 'ves' : 'f', 'oes' : -2, 'ses' : -2, 'ches' : -2, 'shes' : -2, 'xes' : -2, 's' : -1 };

	function normalize(mInfoMap, sDefaultName, oDefaultValues) {
		var sName,oInfo;
		mInfoMap = mInfoMap || {};
		for(sName in mInfoMap) {
			oInfo = mInfoMap[sName];
			// if settings are not an object literal and if there is a default setting, set it
			if ( sDefaultName && typeof oInfo !== "object" ) {
				oInfo = {};
				oInfo[sDefaultName] = mInfoMap[sName];
			}
			oInfo = jQuery.extend({}, oDefaultValues, oInfo);
			oInfo.name = sName;
			// if info contains a multiple flag but no singular name, calculate one
			if ( oInfo.multiple === true && !oInfo.singularName) {
				oInfo.singularName = sName.replace(rPlural, function($,sPlural) {
					var vRepl = mSingular[sPlural.toLowerCase()];
					return typeof vRepl === "string" ? vRepl : sPlural.slice(0,vRepl);
				});
			}
			mInfoMap[sName] = oInfo;
		}
		return mInfoMap;
	}

  var rLibName = /([a-z][^.]*(?:\.[a-z][^.]*)*)\./;

	function defaultLibName(sName) {
	  var m = rLibName.exec(sName);
	  return (m && m[1]) || "";
	}

	// init basic metadata from static infos and fallback to defaults
	this._sLibraryName = oStaticInfo.library || defaultLibName(this.getName());
	this._mProperties = normalize(oStaticInfo.properties, "type", { type : "string", group : "Misc" });
	this._mAggregations = normalize(oStaticInfo.aggregations, "type", { type : "sap.ui.core.Control", multiple : true });
	this._sDefaultAggregation = oStaticInfo.defaultAggregation || null;
	this._mAssociations = normalize(oStaticInfo.associations, "type", { type : "sap.ui.core.Control", multiple : false});
	this._mEvents = normalize(oStaticInfo.events, /* no default setting */ null, { allowPreventDefault : false });

	this._bEnriched = false;

	if ( oClassInfo.metadata.__version > 1.0 ) {
		this.generateAccessors();
	}

};

/**
 * @private
 */
sap.ui.base.ManagedObjectMetadata.prototype.afterApplySettings = function() {

	sap.ui.base.Metadata.prototype.afterApplySettings.call(this);

	// if there is a parent class, produce the flattened "all" views for the element specific metadata
	// PERFOPT: this could be done lazily
	var oParent = this.getParent();
	if ( oParent && oParent instanceof sap.ui.base.ManagedObjectMetadata ) {
		this._mAllEvents = jQuery.extend({},oParent._mAllEvents, this._mEvents);
		this._mAllProperties = jQuery.extend({},oParent._mAllProperties, this._mProperties);
		this._mAllAggregations = jQuery.extend({},oParent._mAllAggregations, this._mAggregations);
		this._mAllAssociations = jQuery.extend({},oParent._mAllAssociations, this._mAssociations);
		this._sDefaultAggregation = this._sDefaultAggregation || oParent._sDefaultAggregation;
		if ( oParent._mHiddenAggregations ) {
		  this._mHiddenAggregations = jQuery.extend({},oParent._mHiddenAggregations);
		}
	} else {
		this._mAllEvents = this._mEvents;
		this._mAllProperties = this._mProperties;
		this._mAllAggregations = this._mAggregations;
		this._mAllAssociations = this._mAssociations;
	}

};

sap.ui.base.ManagedObjectMetadata.Kind = {
  PROPERTY :0, SINGLE_AGGREGATION : 1, MULTIPLE_AGGREGATION : 2, SINGLE_ASSOCIATION : 3, MULTIPLE_ASSOCIATION : 4, EVENT : 5
};


/**
 * Returns the name of the library that contains the described UIElement.
 * @return {string} the name of the library
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.getLibraryName = function() {
	return this._sLibraryName;
};

/**
 * Returns whether the class/control is abstract
 * @return {boolean} whether the class/control is abstract
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.isAbstract = function() {
	return this._bAbstract;
};

/**
 * Declares an additional property for the UIElement class described by this metadata.
 *
 * Any property declaration via this method must happen before the described class
 * is subclassed, or the added property will not be visible in the subclass.
 *
 * Typically used to enrich UIElement classes in an aspect oriented manner.
 * @public
 * @see sap.ui.core.EnabledPropagator
 */
sap.ui.base.ManagedObjectMetadata.prototype.addProperty = function(sName, oInfo) {
	oInfo.name = sName;
	this._mProperties[sName] = oInfo;
	if(!this._mAllProperties[sName]) {// ensure extended AllProperties meta-data is also enriched
		this._mAllProperties[sName] = oInfo;
	}

	if ( this._bEnriched ) { // does not seem right! this is the 'drop out' condition for _enrichChildInfos() -> senseless
		this._enrichChildInfos();
	}
	// TODO notify listeners (subclasses) about change
};

/**
 * Checks the existance of the given property by its name
 * @param {string} sName name of the property
 * @return {boolean} true, if the property exists
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.hasProperty = function(sName) {
	return !!this._mAllProperties[sName];
};

/**
 * Returns infos about the properties declared by the UIElement class
 * described by this metadata object. Properties from ancestor classes
 * are not returned.
 *
 * The returned map contains property info objects keyed by the property name.
 *
 * @return {map} Map of property infos keyed by property names
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.getProperties = function() {
	return this._mProperties;
};

/**
 * Returns infos about all properties declared by the UIElement class
 * described by this metadata object as well as properties from base classes.
 *
 * The returned map contains property info objects keyed by the property name.
 *
 * @return {map} Map of property infos keyed by property names
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.getAllProperties = function() {
	return this._mAllProperties;
};

/**
 * Returns infos about the aggregations declared by the UIElement class
 * described by this metadata object. Aggregations from ancestor classes
 * are not returned.
 *
 * The returned map contains aggregation info objects keyed by the aggregation name.
 * In case of 0..1 aggregations this is the singular name, otherwise it is the plural
 * name.
 *
 * @return {map} Map of aggregation infos keyed by aggregation names
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.getAggregations = function() {
	return this._mAggregations;
};

/**
 * Checks the existance of the given aggregation by its name
 * @param {string} sName name of the aggregation
 * @return {boolean} true, if the aggregation exists
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.hasAggregation = function(sName) {
	return !!this._mAllAggregations[sName];
};

/**
 * Returns infos about all aggregations declared by the UIElement class
 * described by this metadata object as well as aggregations from base classes.
 *
 * The returned map contains aggregation info objects keyed by the aggregation name.
 * In case of 0..1 aggregations this is the singular name, otherwise it is the plural
 * name.
 *
 * @return {map} Map of aggregation infos keyed by aggregation names
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.getAllAggregations = function() {
	return this._mAllAggregations;
};

/**
 * Returns the name of the default aggregation of this control.
 * If the control itself does not define a default aggregation, then the
 * default aggregation of the parent is returned. If no control in the
 * hierarchy defines a default aggregation, null is returned.
 *
 * @return {string} Name of the default aggregation for this class
 */
sap.ui.base.ManagedObjectMetadata.prototype.getDefaultAggregationName = function() {
	return this._sDefaultAggregation;
};

/**
 * Returns the name of the default aggregation of this control.
 * If the control itself does not define a default aggregation, then the
 * default aggregation of the parent is returned.
 *
 * @return {string} Name of the default aggregation for this class
 */
sap.ui.base.ManagedObjectMetadata.prototype.getDefaultAggregation = function() {
	return this._sDefaultAggregation && this.getAllAggregations()[this._sDefaultAggregation];
};

/**
 * Returns infos about the associations declared by the UIElement class
 * described by this metadata object. Associations from ancestor classes
 * are not returned.
 *
 * The returned map contains association info objects keyed by the association name.
 * In case of 0..1 associations this is the singular name, otherwise it is the plural
 * name.
 *
 * @return {map} Map of association infos keyed by association names
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.getAssociations = function() {
	return this._mAssociations;
};

/**
 * Checks the existance of the given association by its name
 * @param {string} sName name of the association
 * @return {boolean} true, if the association exists
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.hasAssociation = function(sName) {
	return !!this._mAllAssociations[sName];
};

/**
 * Returns infos about all associations declared by the UIElement class
 * described by this metadata object as well as associations from base classes.
 *
 * The returned map contains association info objects keyed by the association name.
 * In case of 0..1 associations this is the singular name, otherwise it is the plural
 * name.
 *
 * @return {map} Map of association infos keyed by association names
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.getAllAssociations = function() {
	return this._mAllAssociations;
};

/**
 * Returns infos about the events declared by the UIElement class
 * described by this metadata object. Events from ancestor classes
 * are not returned.
 *
 * The returned map contains events info objects keyed by the events name.
 *
 * @return {map} Map of event infos keyed by event names
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.getEvents = function() {
	return this._mEvents;
};

/**
 * Checks the existance of the given event by its name
 * @param {string} sName name of the event
 * @return {boolean} true, if the event exists
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.hasEvent = function(sName) {
	return !!this._mAllEvents[sName];
};

/**
 * Returns infos about all events declared by the UIElement class
 * described by this metadata object as well as events from base classes.
 *
 * The returned map contains event info objects keyed by the event name.
 *
 * @return {map} Map of event infos keyed by event names
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.getAllEvents = function() {
	return this._mAllEvents;
};

/**
 * Returns a map of default values for all properties declared by the
 * described class and its ancestors, keyed by the property name.
 *
 * @return {map} Map of default values keyed by property names
 * @public
 */
sap.ui.base.ManagedObjectMetadata.prototype.getPropertyDefaults = function() {

	var mDefaults = this._mDefaults,
		oType;
	if ( mDefaults ) {
		return mDefaults;
	}

	if ( this.getParent() instanceof sap.ui.base.ManagedObjectMetadata ) {
		mDefaults = jQuery.sap.newObject(this.getParent().getPropertyDefaults());
	} else {
		mDefaults = {};
	}

	for(var s in this._mProperties) {
		if ( this._mProperties[s].defaultValue !== null ) {
			mDefaults[s] = this._mProperties[s].defaultValue;
		} else {
			oType = sap.ui.base.DataType.getType(this._mProperties[s].type);
			if (oType instanceof sap.ui.base.DataType) {
				mDefaults[s] = oType.getDefaultValue();
			} else { // Enumeration
				for (var i in oType) {
					mDefaults[s] = oType[i];
					break;
				}
			}
		}
	}
	return (this._mDefaults = mDefaults);
};


sap.ui.base.ManagedObjectMetadata.prototype.createPropertyBag = function() {
	if ( !this._fnPropertyBagFactory ) {
		this._fnPropertyBagFactory = jQuery.sap.factory(this.getPropertyDefaults());
	}
	return new (this._fnPropertyBagFactory)();
};

/**
 * Helper method that enriches the (generated) information objects for children
 * (e.g. properties, aggregations, ...) of this Element.
 *
 * Also ensures that the parent metadata is enriched.
 *
 * @private
 */
sap.ui.base.ManagedObjectMetadata.prototype._enrichChildInfos = function() {

	if ( this._bEnriched ) {
		return;
	}

	if ( this.getParent() instanceof sap.ui.base.ManagedObjectMetadata ) {
		this.getParent()._enrichChildInfos();
	}

	var m,sName,oInfo;
	function method(sPrefix, sName) {
		return sPrefix + sName.substring(0,1).toUpperCase() + sName.substring(1);
	}

	// adapt properties
	m=this._mProperties;
	for(sName in m) {
		oInfo = m[sName];
		oInfo._sName = sName;
		oInfo._sUID = sName;
		oInfo._oParent = this;
		oInfo._iKind = sap.ui.base.ManagedObjectMetadata.Kind.PROPERTY;
		oInfo._sMutator = method("set", sName);
		oInfo._sGetter = method("get", sName);
	}

	// adapt aggregations
	m=this._mAggregations;
	for(sName in m) {
		oInfo = m[sName];
		oInfo._sName = sName;
		oInfo._sUID = "aggregation:" + sName;
		oInfo._oParent = this;
		oInfo._sDestructor = method("destroy", sName);
		oInfo._sGetter = method("get", sName);
		if ( oInfo.multiple ) {
			oInfo._iKind = sap.ui.base.ManagedObjectMetadata.Kind.MULTIPLE_AGGREGATION;
			oInfo._sMutator = method("add", oInfo.singularName);
			oInfo._sRemoveMutator = method("remove", oInfo.singularName);
		} else {
			oInfo._iKind = sap.ui.base.ManagedObjectMetadata.Kind.SINGLE_AGGREGATION;
			oInfo._sMutator = method("set", sName);
		}
	}

	// adapt associations
	m=this._mAssociations;
	for(sName in m) {
		oInfo = m[sName];
		oInfo._sName = sName;
		oInfo._sUID = "association:" + sName;
		oInfo._oParent = this;
		oInfo._sGetter = method("get", sName);
		if ( oInfo.multiple ) {
			oInfo._iKind = sap.ui.base.ManagedObjectMetadata.Kind.MULTIPLE_ASSOCIATION;
			oInfo._sMutator = method("add", oInfo.singularName);
		} else {
			oInfo._iKind = sap.ui.base.ManagedObjectMetadata.Kind.SINGLE_ASSOCIATION;
			oInfo._sMutator = method("set", sName);
		}
	}

	// adapt events
	m=this._mEvents;
	for(sName in m) {
		oInfo = m[sName];
		oInfo._sName = sName;
		oInfo._sUID = "event:" + sName;
		oInfo._oParent = this;
		oInfo._iKind = sap.ui.base.ManagedObjectMetadata.Kind.EVENT;
		oInfo._sMutator = method("attach", sName);
	}

	this._bEnriched = true;
};

/**
 * Builds a "reflection like" map of setters/type infos keyed by the possible JSON names.
 * Mainly used for the {@link sap.ui.core.Element.applySettings} method.
 *
 * @see sap.ui.core.Element.prototype.applySettings
 * @private
 */
sap.ui.base.ManagedObjectMetadata.prototype.getJSONKeys = function() {

	if ( this._mJSONKeys ) {
		return this._mJSONKeys;
	}

	this._enrichChildInfos();

	var mJSONKeys = {};
	function addKeys(m) {
		var sName, oInfo;
		for(sName in m) {
			oInfo = m[sName];
			if ( !mJSONKeys[sName] || oInfo._iKind < mJSONKeys[sName]._iKind ) {
				mJSONKeys[sName] = oInfo;
			};
			mJSONKeys[oInfo._sUID] = oInfo;
		};
	}

	addKeys(this.getAllProperties());
	addKeys(this.getAllAggregations());
	addKeys(this.getAllAssociations());
	addKeys(this.getAllEvents());

	return (this._mJSONKeys = mJSONKeys);
};

sap.ui.base.ManagedObjectMetadata.prototype.generateAccessors = function() {

	var meta=this;
	var proto = this.getClass().prototype;
	function method(sPrefix, sName, fn, bDeprecated) {
		var sName = sPrefix + sName.substring(0,1).toUpperCase() + sName.substring(1);
		if ( !proto[sName] ) {
			proto[sName] = bDeprecated ? function() {
				jQuery.sap.log.warning("Usage of deprecated feature: " + meta.getName() + "." + sName);
				return fn.apply(this, arguments);
			} : fn; 
			meta._aPublicMethods.push(sName);
		}
	}

	jQuery.each(this._mProperties, function(n,info) {
		method("get", n, function() { return this.getProperty(n); });
		method("set", n, function(v) { this.setProperty(n,v); return this; }, info.deprecated);
		if ( info.bindable ) {
			method("bind", n, function(p,fn,m) { this.bindProperty(n,p,fn,m); return this; }, info.deprecated);
			method("unbind", n, function(p) { this.unbindProperty(n,p); return this; });
		}
	});
	jQuery.each(this._mAggregations, function(n,info) {
		if ( !info.multiple ) {
			method("get", n, function() { return this.getAggregation(n); });
			method("set", n, function(v) { this.setAggregation(n,v); return this; }, info.deprecated);
		} else {
			var n1 = info.singularName;
			method("get", n, function() { return this.getAggregation(n,[]); });
			method("add", n1, function(a) { this.addAggregation(n,a); return this; }, info.deprecated);
			method("insert", n1, function(i,a) { this.insertAggregation(n,i,a); return this; }, info.deprecated);
			method("remove", n1, function(a) { return this.removeAggregation(n,a); });
			method("removeAll", n, function() { return this.removeAllAggregation(n); });
			method("indexOf", n1, function(a) { return this.indexOfAggregation(n,a); });
		}
		method("destroy", n, function() { this.destroyAggregation(n); return this; });
		if ( info.bindable ) {
			method("bind", n, function(p,t,s,f) { this.bindAggregation(n,p,t,s,f); return this; }, info.deprecated);
			method("unbind", n, function(p) { this.unbindAggregation(n,p); return this; });
		}
	});
	jQuery.each(this._mAssociations, function(n,info) {
		if ( !info.multiple ) {
			method("get", n, function() { return this.getAssociation(n); });
			method("set", n, function(v) { this.setAssociation(n,v); return this; }, info.deprecated);
		} else {
			var n1 = info.singularName;
			method("get", n, function() { return this.getAssociation(n,[]); });
			method("add", n1, function(a) { this.addAssociation(n,a); return this; }, info.deprecated);
			method("remove", n1, function(a) { return this.removeAssociation(n,a); });
			method("removeAll", n, function() { return this.removeAllAssociation(n); });
		}
	});
	jQuery.each(this._mEvents, function(n,info) {
		method("attach", n, function(d,f,o) { this.attachEvent(n,d,f,o); return this; }, info.deprecated);
		method("detach", n, function(f,o) { this.detachEvent(n,f,o); return this; });
		var n1 = !!info.allowPreventDefault;
		method("fire", n, function(p) { return this.fireEvent(n,p, n1); });
	});

};

(function() {

	/**
	 * Usage counters for the different UID tokens
	 */
	var mUIDCounts = {};

	function uid(sId) {
		jQuery.sap.assert(!/[0-9]+$/.exec(sId), "AutoId Prefixes must not end with numbers");

		sId = sap.ui.getCore().getConfiguration().getUIDPrefix() + sId;

		// initialize counter
		mUIDCounts[sId] = mUIDCounts[sId] || 0;

		// combine prefix + counter
		// concatenating sId and a counter is only safe because we don't allow trailing numbers in sId!
		return (sId + mUIDCounts[sId]++);
	}

	/**
	 * Calculates a new id based on a prefix.
	 *
	 * @return {string} A (hopefully unique) control id
	 * @public
	 * @function
	 */
	sap.ui.base.ManagedObjectMetadata.uid = uid;

	/**
	 * Calculates a new id for an instance of this class.
	 *
	 * Note that the calculated short name part is usually not unique across
	 * all classes, but doesn't have to be. It might even be empty when the
	 * class name consists of invalid characters only.
	 *
	 * @return {string} A (hopefully unique) control id
	 * @public
	 */
	sap.ui.base.ManagedObjectMetadata.prototype.uid = function() {

		var sId = this._sUIDToken;
		if ( typeof sId !== "string" ) {
			// start with qualified class name
			sId  = this.getName();
			// reduce to unqualified name
			sId = sId.slice(sId.lastIndexOf('.')+1);
			// reduce a camel case, multi word name to the last word
			sId = sId.replace(/([a-z])([A-Z])/g, "$1 $2").split(" ").slice(-1)[0];
			// remove unwanted chars (and no trailing digits!) and convert to lower case
			sId = this._sUIDToken = sId.replace(/([^A-Za-z0-9-_.:])|([0-9]$)/g,"").toLowerCase();
		}

		return uid(sId);
	};

}());
}; // end of sap.ui.base.ManagedObjectMetadata

if ( !jQuery.sap.isDeclared('sap.ui.model.Model') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides the base implementation for all model implementations
jQuery.sap.declare("sap.ui.model.Model");

if ( !jQuery.sap.isDeclared('sap.ui.model.BindingMode') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides enumeration sap.ui.model.FilterOperator
jQuery.sap.declare("sap.ui.model.BindingMode");

/**
* @class
* Binding type definitions.
*
* @static
* @public
*/
sap.ui.model.BindingMode = {

		/**
		 * BindingMode default means that the binding mode of the model is used
		 * @public
		 */
		Default: "Default",

		/**
		 * BindingMode one time means value is only read from the model once
		 * @public
		 */
		OneTime: "OneTime",

		/**
		 * BindingMode one way means from model to view
		 * @public
		 */
		OneWay: "OneWay",

		/**
		 * BindingMode two way means from model to view and vice versa
		 * @public
		 */
		TwoWay: "TwoWay"

};
}; // end of sap.ui.model.BindingMode

if ( !jQuery.sap.isDeclared('sap.ui.model.Context') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides an abstraction for model bindings
jQuery.sap.declare("sap.ui.model.Context");


/**
 * Constructor for Context class.
 *
 * @class
 * The Context is a pointer to an object in the model data, which is used to 
 * allow definition of relative bindings, which are resolved relative to the
 * defined object.
 * Context elements are created either by the ListBinding for each list entry
 * or by using createBindingContext.
 *
 * @param {sap.ui.model.Model} the model
 * @param {String} sPath the path
 * @param {Object} oContext the context object
 * @abstract
 * @public
 * @name sap.ui.model.Context
 */
sap.ui.base.Object.extend("sap.ui.model.Context", /** @lends sap.ui.model.Context */ {
	
	constructor : function(oModel, sPath){

		sap.ui.base.Object.apply(this);
	
		this.oModel = oModel;
		this.sPath = sPath;
	
	},
	
	metadata : {
		"abstract" : true,
	  publicMethods : [
			"getModel", "getPath", "getProperty", "getObject"
		]
	}

});

/**
 * Creates a new subclass of class sap.ui.model.Context with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * For a detailed description of <code>oClassInfo</code> or <code>FNMetaImpl</code> 
 * see {@link sap.ui.base.C.extend Object.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] alternative constructor for a metadata object
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.model.Context.extend
 * @function
 */

// Getter
/**
 * Getter for model
 * @public
 * @return {sap.ui.core.Model} the model
 */
sap.ui.model.Context.prototype.getModel = function() {
	return this.oModel;
};

/**
 * Getter for path
 * @public
 * @return {String} the binding path
 */
sap.ui.model.Context.prototype.getPath = function() {
	return this.sPath;
};

/**
 * Gets the property with the given relative binding path
 * @public
 * @param {String} sPath the binding path
 * @return {any} the property value
 */
sap.ui.model.Context.prototype.getProperty = function(sPath) {
	return this.oModel.getProperty(sPath, this);
};

/**
 * Gets the (model dependent) object the context points to
 * @public
 * @return {object} the context object
 */
sap.ui.model.Context.prototype.getObject = function() {
	return this.oModel.getProperty(this.sPath);
};

/** 
 * toString method returns path for compatbility
 */
sap.ui.model.Context.prototype.toString = function() {
	return this.sPath;
};

}; // end of sap.ui.model.Context


/**
 * The SAPUI5 Data Binding API.
 *
 * The default binding mode for model implementations (if not implemented otherwise) is two way and the supported binding modes by the model
 * are one way, two way and one time. The default binding mode can be changed by the application for each model instance.
 * A model implementation should specify its supported binding modes and set the default binding mode accordingly
 * (e.g. if the model supports only one way binding the default binding mode should also be set to one way).
 *
 * @namespace
 * @name sap.ui.model
 * @public
 */

/**
 * Constructor for a new Model.
 *
 * @class
 * This is an abstract base class for model objects.
 * @abstract
 *
 * @extends sap.ui.base.Object
 *
 * @author SAP AG
 * @version 1.10.0
 *
 * @constructor
 * @public
 * @name sap.ui.model.Model
 */
sap.ui.base.EventProvider.extend("sap.ui.model.Model", /** @lends sap.ui.model.Model */ {
	
	constructor : function () {
		sap.ui.base.EventProvider.apply(this, arguments);
	
		this.oData = {};
		this.aBindings = [];
		this.mContexts = {};
		this.iSizeLimit = 100;
		this.sDefaultBindingMode = sap.ui.model.BindingMode.TwoWay;
		this.mSupportedBindingModes = {"OneWay": true, "TwoWay": true, "OneTime": true};
		this.bLegacySyntax = false;
	},

	metadata : {

		"abstract" : true,
		publicMethods : [
			// methods
			"bindProperty", "bindList", "bindTree", "createBindingContext", "destroyBindingContext", "getProperty",
			"getDefaultBindingMode", "setDefaultBindingMode", "isBindingModeSupported", "attachParseError", "detachParseError",
			"attachRequestCompleted", "detachRequestCompleted", "attachRequestFailed", "detachRequestFailed", "attachRequestSent",
			"detachRequestSent", "setSizeLimit"
	  ]
	
	  /* the following would save code, but requires the new ManagedObject (1.9.1) 
	  , events : {
	  	"parseError" : {},
	  	"requestFailed" : {},
	  	"requestSent" : {},
	  	"requestCompleted" ; {} 
	  }
	  */
	
	}

});

/**
 * Creates a new subclass of class sap.ui.model.Model with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * For a detailed description of <code>oClassInfo</code> or <code>FNMetaImpl</code> 
 * see {@link sap.ui.base.Object.extend Object.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] alternative constructor for a metadata object
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.model.Model.extend
 * @function
 */


/**
 * Map of event names, that are provided by the model.
 */
sap.ui.model.Model.M_EVENTS = {
	/**
	 * Depending on the model implementation a ParseError should be fired if a parse error occurred.
	 * Contains the parameters:
	 * errorCode, url, reason, srcText, line, linepos, filepos
	 */
	ParseError : "parseError",

	/**
	 * Depending on the model implementation a RequestFailed should be fired if a request to a backend failed.
	 * Contains the parameters:
	 * message, statusCode, statusText and responseText
	 */
	RequestFailed : "requestFailed",

	/**
	 * Depending on the model implementation a RequestSent should be fired when a request to a backend is sent.
	 * Contains Parameters: url, type, async, info
	 */
	RequestSent : "requestSent",

	/**
	 * Depending on the model implementation a RequestCompleted should be fired when a request to a backend is completed regardless if the request failed or succeeded.
	 * Contains Parameters: url, type, async, info
	 */
	RequestCompleted : "requestCompleted"
};

/**
 * The 'requestFailed' event is fired, when data retrieval from a backend failed.
 *
 * @name sap.ui.model.Model#requestFailed
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {string} oControlEvent.getParameters.message A text that describes the failure.
 * @param {string} oControlEvent.getParameters.statusCode HTTP status code returned by the request (if available)
 * @param {string} oControlEvent.getParameters.statusText The status as a text, details not specified, intended only for diagnosis output
 * @param {string} oControlEvent.getParameters.responseText Response that has been received for the request ,as a text string
 * @public
 */

/**
 * Attach event-handler <code>fnFunction</code> to the 'requestFailed' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 *
 * @param {object}
 *            [oData] The object, that should be passed along with the event-object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, this Model is used.
 *
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.attachRequestFailed = function(oData, fnFunction, oListener) {
	this.attachEvent("requestFailed", oData, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'requestFailed' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.detachRequestFailed = function(fnFunction, oListener) {
	this.detachEvent("requestFailed", fnFunction, oListener);
	return this;
};

/**
 * Fire event requestFailed to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'message' of type <code>string</code> A text that describes the failure.</li>
 * <li>'statusCode' of type <code>string</code> HTTP status code returned by the request (if available)</li>
 * <li>'statusText' of type <code>string</code> The status as a text, details not specified, intended only for diagnosis output</li>
 * <li>'responseText' of type <code>string</code> Response that has been received for the request ,as a text string</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.model.Model.prototype.fireRequestFailed = function(mArguments) {
	this.fireEvent("requestFailed", mArguments);
	return this;
};


/**
 * The 'parseError' event is fired when parsing of a model document (e.g. XML response) fails.
 *
 * @name sap.ui.model.Model#parseError
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {int} oControlEvent.getParameters.errorCode
 * @param {string} oControlEvent.getParameters.url
 * @param {string} oControlEvent.getParameters.reason
 * @param {string} oControlEvent.getParameters.srcText
 * @param {int} oControlEvent.getParameters.line
 * @param {int} oControlEvent.getParameters.linepos
 * @param {int} oControlEvent.getParameters.filepos
 * @public
 */

/**
 * Attach event-handler <code>fnFunction</code> to the 'parseError' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 *
 * @param {object}
 *            [oData] The object, that should be passed along with the event-object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, the global context (window) is used.
 *
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.attachParseError = function(oData, fnFunction, oListener) {
	this.attachEvent("parseError", oData, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'parseError' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.detachParseError = function(fnFunction, oListener) {
	this.detachEvent("parseError", fnFunction, oListener);
	return this;
};

/**
 * Fire event parseError to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'errorCode' of type <code>int</code> </li>
 * <li>'url' of type <code>string</code> </li>
 * <li>'reason' of type <code>string</code> </li>
 * <li>'srcText' of type <code>string</code> </li>
 * <li>'line' of type <code>int</code> </li>
 * <li>'linepos' of type <code>int</code> </li>
 * <li>'filepos' of type <code>int</code> </li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.model.Model.prototype.fireParseError = function(mArguments) {
	this.fireEvent("parseError", mArguments);
	return this;
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'requestSent' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 *
 * @param {object}
 *            [oData] The object, that should be passed along with the event-object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, the global context (window) is used.
 *
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.attachRequestSent = function(oData, fnFunction, oListener) {
	this.attachEvent("requestSent", oData, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'requestSent' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.detachRequestSent = function(fnFunction, oListener) {
	this.detachEvent("requestSent", fnFunction, oListener);
	return this;
};

/**
 * Fire event requestSent to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'url' of type <code>string</code> The url which is sent to the backend.</li>
 * <li>'type' of type <code>string</code> The type of the request (if available)</li>
 * <li>'async' of type <code>boolean</code> If the request is synchronous or asynchronous (if available)</li>
 * <li>'info' of type <code>string</code> additional information for the request (if available)</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.model.Model.prototype.fireRequestSent = function(mArguments) {
	this.fireEvent("requestSent", mArguments);
	return this;
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'requestCompleted' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 *
 * @param {object}
 *            [oData] The object, that should be passed along with the event-object when firing the event.
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, the global context (window) is used.
 *
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.attachRequestCompleted = function(oData, fnFunction, oListener) {
	this.attachEvent("requestCompleted", oData, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'requestCompleted' event of this <code>sap.ui.model.Model</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.model.Model.prototype.detachRequestCompleted = function(fnFunction, oListener) {
	this.detachEvent("requestCompleted", fnFunction, oListener);
	return this;
};

/**
 * Fire event requestCompleted to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'url' of type <code>string</code> The url which was sent to the backend.</li>
 * <li>'type' of type <code>string</code> The type of the request (if available)</li>
 * <li>'async' of type <code>boolean</code> If the request was synchronous or asynchronous (if available)</li>
 * <li>'info' of type <code>string</code> additional information for the request (if available)</li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.model.Model} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.model.Model.prototype.fireRequestCompleted = function(mArguments) {
	this.fireEvent("requestCompleted", mArguments);
	return this;
};


// the 'abstract methods' to be implemented by child classes

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.bindProperty
 * @function
 * @param {string}
 *         sPath the path pointing to the property that should be bound
 * @param {object}
 *         [oContext=null] the context object for this databinding (optional)
 * @param {object}
 *         [mParameters=null] additional model specific parameters (optional)
 * @return {sap.ui.model.PropertyBinding}
 *
 * @public
 */

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.bindList
 * @function
 * @param {string}
 *         sPath the path pointing to the list / array that should be bound
 * @param {object}
 *         [oContext=null] the context object for this databinding (optional)
 * @param {sap.ui.model.Sorter}
 *         [oSorter=null] initial sort order (optional)
 * @param {array}
 *         [aFilters=null] predefined filter/s contained in an array (optional)
 * @param {object}
 *         [mParameters=null] additional model specific parameters (optional)
 * @return {sap.ui.model.ListBinding}

 * @public
 */

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.bindTree
 * @function
 * @param {string}
 *         sPath the path pointing to the tree / array that should be bound
 * @param {object}
 *         [oContext=null] the context object for this databinding (optional)
 * @param {array}
 *         [aFilters=null] predefined filter/s contained in an array (optional)
 * @param {object}
 *         [mParameters=null] additional model specific parameters (optional)
 * @return {sap.ui.model.TreeBinding}

 * @public
 */

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.createBindingContext
 * @function
 * @param {string}
 *         sPath the path to create the new context from
 * @param {object}
 *		   [oContext=null] the context which should be used to create the new binding context
 * @param {object}
 *		   [mParameters=null] the parameters used to create the new binding context
 * @param {function}
 *         fnCallBack the function which should be called after the binding context has been created

 * @public
 */

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.destroyBindingContext
 * @function
 * @param {object}
 *         oContext to destroy

 * @public
 */

/**
 * Implement in inheriting classes
 * @abstract
 *
 * @name sap.ui.model.Model.prototype.getProperty
 * @function
 * @param {string}
 *         sPath the path to where to read the attribute value
 * @param {object}
 *		   [oContext=null] the context with which the path should be resolved
 * @public
 */

/**
 * Gets a binding context. If context already exists, return it from the map,
 * otherwise create one using the context constructor.
 *
 * @param {string} sPath the path
 */
sap.ui.model.Model.prototype.getContext = function(sPath) {
	var oContext = this.mContexts[sPath];
	if (!oContext) {
		 if (!jQuery.sap.startsWith(sPath, "/")) {
			 sPath = "/" + sPath;
		 }
		oContext = new sap.ui.model.Context(this, sPath);
		this.mContexts[sPath] = oContext;
	}
	return oContext;
};

/**
 * Resolve the path relative to the given context
 */
sap.ui.model.Model.prototype.resolve = function(sPath, oContext) {
	var bIsRelative = !jQuery.sap.startsWith(sPath, "/"),
		sResolvedPath = sPath,
		sContextPath;
	if (bIsRelative) {
		if (oContext) {
			sContextPath = oContext.getPath();
			sResolvedPath = sContextPath + (jQuery.sap.endsWith(sContextPath, "/") ? "" : "/") + sPath;
		}
		else {
			sResolvedPath = this.isLegacySyntax() ? "/" + sPath : "";
		}
	}
	if (jQuery.sap.endsWith(sResolvedPath, "/")) {
		sResolvedPath = sResolvedPath.substr(0, sResolvedPath.length - 1);
	}
	return sResolvedPath;
};

/**
 * Add a binding to this model
 *
 * @param {sap.ui.model.Binding} oBinding the binding to be added
 */
sap.ui.model.Model.prototype.addBinding = function(oBinding) {
	this.aBindings.push(oBinding);
};

/**
 * Remove a binding from the model
 *
 * @param {sap.ui.model.Binding} oBinding the binding to be removed
 */
sap.ui.model.Model.prototype.removeBinding = function(oBinding) {
	for (var i = 0; i < this.aBindings.length; i++) {
		if (this.aBindings[i] == oBinding) {
			this.aBindings.splice(i, 1);
			break;
		}
	}
};

/**
 * Get the default binding mode for the model
 *
 * @return {sap.ui.model.BindingMode} default binding mode of the model
 *
 * @public
 */
sap.ui.model.Model.prototype.getDefaultBindingMode = function() {
	return this.sDefaultBindingMode;
};

/**
 * Set the default binding mode for the model. If the default binding mode should be changed,
 * this method should be called directly after model instance creation and before any binding creation.
 * Otherwise it is not guaranteed that the existing bindings will be updated with the new binding mode.
 *
 * @param {sap.ui.model.BindingMode} sMode the default binding mode to set for the model
 *
 * @public
 */
sap.ui.model.Model.prototype.setDefaultBindingMode = function(sMode) {
	if (this.isBindingModeSupported(sMode)) {
		this.sDefaultBindingMode = sMode;
	}
	else {
		throw new Error("Binding mode " + sMode + " is not supported by this model.");
	}
};

/**
 * Check if the specified binding mode is supported by the model.
 *
 * @param {sap.ui.model.BindingMode} sMode the binding mode to check
 *
 * @public
 */
sap.ui.model.Model.prototype.isBindingModeSupported = function(sMode) {
	return (sMode in this.mSupportedBindingModes);
};

/**
 * Enables legacy path syntax handling
 * 
 * This defines, whether relative bindings, which do not have a defined
 * binding context, should be compatible to earlier releases which means
 * they are resolved relative to the root element or handled strict and
 * stay unresolved until a binding context is set
 *
 * @param {boolean} bCompatibleSyntax the path syntax to use
 *
 * @public
 */
sap.ui.model.Model.prototype.setLegacySyntax = function(bLegacySyntax) {
	this.bLegacySyntax = bLegacySyntax;
};

/**
 * Returns whether legacy path syntax is used
 *
 * @return {boolean} 
 * 
 * @public
 */
sap.ui.model.Model.prototype.isLegacySyntax = function() {
	return this.bLegacySyntax;
};

/**
 * Set the maximum number of entries which are used for for list bindings.
 * @param {int} collection size limit  
 * @public
 */
sap.ui.model.Model.prototype.setSizeLimit = function(iSizeLimit) {
	this.iSizeLimit = iSizeLimit;
};

sap.ui.model.Model.prototype.getInterface = function() {
	return this;
};


}; // end of sap.ui.model.Model

if ( !jQuery.sap.isDeclared('sap.ui.model.Type') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides the base implementation for all model implementations
jQuery.sap.declare("sap.ui.model.Type");


/**
 * Constructor for a new Type.
 *
 * @class
 * This is an abstract base class for type objects.
 * @abstract
 *
 * @extends sap.ui.base.Object
 *
 * @author SAP AG
 * @version 1.10.0
 *
 * @constructor
 * @public
 * @name sap.ui.model.Type
 */
sap.ui.base.Object.extend("sap.ui.model.Type", /** @lends sap.ui.model.Type */ {
	
	constructor : function () {
		sap.ui.base.Object.apply(this, arguments);
		this.sName = "Type";
	},

	metadata : {
		"abstract" : true,
		publicMethods : [
	    // methods
	    "getName"
	  ]
	}
	
});

/**
 * Creates a new subclass of class sap.ui.model.Type with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * For a detailed description of <code>oClassInfo</code> or <code>FNMetaImpl</code> 
 * see {@link sap.ui.base.Object.extend Object.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] alternative constructor for a metadata object
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.model.Type.extend
 * @function
 */


/**
 * Returns the name of this type.
 *
 * @return {String} the name of this type
 * @public
 */
sap.ui.model.Type.prototype.getName = function() {
	return this.sName;
};
}; // end of sap.ui.model.Type

if ( !jQuery.sap.isDeclared('sap.ui.model.CompositeBinding') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides an abstract property binding.
jQuery.sap.declare("sap.ui.model.CompositeBinding");
if ( !jQuery.sap.isDeclared('sap.ui.model.PropertyBinding') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides an abstract property binding.
jQuery.sap.declare("sap.ui.model.PropertyBinding");
if ( !jQuery.sap.isDeclared('sap.ui.model.Binding') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides an abstraction for model bindings
jQuery.sap.declare("sap.ui.model.Binding");


/**
 * Constructor for Binding class.
 *
 * @class
 * The Binding is the object, which holds the necessary information for a data binding,
 * like the binding path and the binding context, and acts like an interface to the
 * model for the control, so it is the event provider for changes in the data model
 * and provides getters for accessing properties or lists.
 *
 * @param {sap.ui.model.Model} the model
 * @param {String} sPath the path
 * @param {Object} oContext the context object
 * @abstract
 * @public
 * @name sap.ui.model.Binding
 */
sap.ui.base.EventProvider.extend("sap.ui.model.Binding", /** @lends sap.ui.model.Binding */ {
	
	constructor : function(oModel, sPath, oContext, mParameters){
		sap.ui.base.EventProvider.apply(this);
	
		this.sPath = sPath;
		this.oContext = oContext;
		this.oModel = oModel;
		this.mParameters = mParameters;
	
	},

	metadata : {
		"abstract" : true,
	  publicMethods : [
			// methods
			"getPath", "getContext", "getModel", "attachChange", "detachChange"
	  ]
	
	}

});

/**
 * Creates a new subclass of class sap.ui.model.Binding with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * For a detailed description of <code>oClassInfo</code> or <code>FNMetaImpl</code> 
 * see {@link sap.ui.base.Object.extend Object.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] alternative constructor for a metadata object
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.model.Binding.extend
 * @function
 */

// Getter
/**
 * Getter for path
 * @return {String} the binding path
 */
sap.ui.model.Binding.prototype.getPath = function() {
	return this.sPath;
};

/**
 * Getter for context
 * @return {Object} the context object
 */
sap.ui.model.Binding.prototype.getContext = function() {
	return this.oContext;
};

/**
 * Setter for context
 * @param {Object} oContext the new context object
 */
sap.ui.model.Binding.prototype.setContext = function(oContext) {
	if (this.oContext != oContext) {
		this.oContext = oContext;
		this._fireChange();
	}
};

/**
 * Getter for model
 * @return {sap.ui.core.Model} the model
 */
sap.ui.model.Binding.prototype.getModel = function() {
	return this.oModel;
};

// Eventing and related
/**
 * Attach event-handler <code>fnFunction</code> to the '_change' event of this <code>sap.ui.model.Model</code>.<br/>
 * @param {function} fnFunction The function to call, when the event occurs.
 * @param {object} [oListener] object on which to call the given function.
 * @protected
 */
sap.ui.model.Binding.prototype.attachChange = function(fnFunction, oListener) {
	if (!this.hasListeners("_change")) {
		this.oModel.addBinding(this);
	}
	this.attachEvent("_change", fnFunction, oListener);
};

/**
 * Detach event-handler <code>fnFunction</code> from the '_change' event of this <code>sap.ui.model.Model</code>.<br/>
 * @param {function} fnFunction The function to call, when the event occurs.
 * @param {object} [oListener] object on which to call the given function.
 * @protected
 */
sap.ui.model.Binding.prototype.detachChange = function(fnFunction, oListener) {
	this.detachEvent("_change", fnFunction, oListener);
	if (!this.hasListeners("_change")) {
		this.oModel.removeBinding(this);
	}
};

/**
 * Fire event _change to attached listeners.

 * @param {Map}
 *         mArguments the arguments to pass along with the event.
 * @private
 */
sap.ui.model.Binding.prototype._fireChange = function(mArguments) {
	this.fireEvent("_change", mArguments);
};

/**
 * Determines if the binding should be updated by comparing the current model against a specified model.
 * @param {object} oModel The model instance to compare against
 * @returns {boolean} true if this binding should be updated
 * @protected
 */
sap.ui.model.Binding.prototype.updateRequired = function(oModel) {
	return oModel && this.getModel() === oModel;
};

}; // end of sap.ui.model.Binding

if ( !jQuery.sap.isDeclared('sap.ui.model.SimpleType') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides the base implementation for all model implementations
jQuery.sap.declare("sap.ui.model.SimpleType");

if ( !jQuery.sap.isDeclared('sap.ui.model.ParseException') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides a filter for list bindings
jQuery.sap.declare("sap.ui.model.ParseException");
if ( !jQuery.sap.isDeclared('sap.ui.base.Exception') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides a filter for list bindings
jQuery.sap.declare("sap.ui.base.Exception");

/**
 * Exception class
 *
 * This is the base exception class. In contrary to the Error an Exception
 * should be thrown in cases, where the exception can, and should, be handled
 * within the framework, instead of causing the application to exit.
 *
 * The try/catch statement in JavaScript can not catch specific exceptions, so
 * when catching internal exceptions you should make sure to rethrow other errors:
 *
 * try {
 *     ...
 * }
 * catch (oException) {
 *     if (oException instanceof sap.ui.base.Exception) {
 *         ... handle exception ...
 *     }
 *     else {
 *         throw oException;
 *     }
 * }
 *
 */
sap.ui.base.Exception = function(message) {
	this.name = "Exception";
	this.message = message;
};

}; // end of sap.ui.base.Exception


/**
 * ParseException class
 *
 * This exception is thrown, when a parse error occurs while converting a
 * string value to a specific property type in the model.
 */
sap.ui.model.ParseException = function(message) {
	this.name = "ParseException";
	this.message = message;
};
sap.ui.model.ParseException.prototype = jQuery.sap.newObject(sap.ui.base.Exception.prototype);
}; // end of sap.ui.model.ParseException

if ( !jQuery.sap.isDeclared('sap.ui.model.ValidateException') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides a filter for list bindings
jQuery.sap.declare("sap.ui.model.ValidateException");


/**
 * ValidateException class
 *
 * This exception is thrown, when a validation error occurs while checking the
 * defined constraints for a type.
 */
sap.ui.model.ValidateException = function(message, violatedConstraints) {
	this.name = "ValidateException";
	this.message = message;
	this.violatedConstraints = violatedConstraints;
};
sap.ui.model.ValidateException.prototype = jQuery.sap.newObject(sap.ui.base.Exception.prototype);

}; // end of sap.ui.model.ValidateException

if ( !jQuery.sap.isDeclared('sap.ui.model.FormatException') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides a filter for list bindings
jQuery.sap.declare("sap.ui.model.FormatException");


/**
 * FormatException class
 *
 * This exception is thrown, when an error occurs while trying to convert a value of the model to
 * a specific property value in the UI.
 *
 */
sap.ui.model.FormatException = function(message) {
	this.name = "FormatException";
	this.message = message;
};
sap.ui.model.FormatException.prototype = jQuery.sap.newObject(sap.ui.base.Exception.prototype);
}; // end of sap.ui.model.FormatException



/**
 * Constructor for a new SimpleType.
 *
 * @class
 * This is an abstract base class for simple types.
 * @abstract
 *
 * @extends sap.ui.model.Type
 *
 * @author SAP AG
 * @version 1.10.0
 *
 * @constructor
 * @param {object} [oFormatOptions] options as provided by concrete subclasses
 * @param {object} [oConstraints] constraints as supported by concrete subclasses
 * @public
 * @name sap.ui.model.SimpleType
 */
sap.ui.model.Type.extend("sap.ui.model.SimpleType", /** @lends sap.ui.model.SimpleType */ {

	constructor : function(oFormatOptions, oConstraints) {
		sap.ui.model.Type.apply(this, arguments);
		this.setFormatOptions(oFormatOptions || {});
		this.setConstraints(oConstraints || {});
		this.sName = "SimpleType";
	},

  metadata : {
  	"abstract" : true,
  	publicMethods : [
	    "setConstraints", "setFormatOptions", "formatValue", "parseValue", "validateValue"
	  ]
  }
	
});

/**
 * Creates a new subclass of class sap.ui.model.SimpleType with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * For a detailed description of <code>oClassInfo</code> or <code>FNMetaImpl</code> 
 * see {@link sap.ui.base.Object.extend Object.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] alternative constructor for a metadata object
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.model.SimpleType.extend
 * @function
 */


/**
 * Format the given value in model representation to an output value in the given
 * internal type. This happens according to the format options, if target type is 'string'.
 * If oValue is not defined or null, null will be returned.
 *
 * @function
 * @name sap.ui.model.SimpleType.prototype.formatValue
 * @param {any} oValue the value to be formatted
 * @param {string} sInternalType the target type
 * @return {any} the formatted output value
 *
 * @public
 */

/**
 * Parse a value of an internal type to the expected value of the model type.
 *
 * @function
 * @name sap.ui.model.SimpleType.prototype.parseValue
 * @param {any} oValue the value to be parsed
 * @param {string} sInternalType the source type
 * @return {any} the parse result
 *
 * @public
 */

/**
 * Validate whether a given value in model representation is valid and meets the
 * defined constraints (if any).
 *
 * @function
 * @name sap.ui.model.SimpleType.prototype.validateValue
 * @param {any} oValue the value to be validated
 *
 * @public
 */

/**
 * Sets constraints for this type. This is meta information used when validating the
 * value, to ensure it meets certain criteria, e.g. maximum length, minimal amount
 *
 * @param {object} oConstraints the constraints to set for this type
 */
sap.ui.model.SimpleType.prototype.setConstraints = function(oConstraints) {
	this.oConstraints = oConstraints;
};

/**
 * Set format options for this type. This is meta information used when formatting and
 * parsing values, such as patterns for number and date formatting or maximum length
 *
 * @param {object} oFormatOptions the options to set for this type
 */
sap.ui.model.SimpleType.prototype.setFormatOptions = function(oFormatOptions) {
	this.oFormatOptions = oFormatOptions;
};
}; // end of sap.ui.model.SimpleType


/**
 * Constructor for PropertyBinding
 *
 * @class
 * The PropertyBinding is used to access single data values in the data model.
 *
 * @param {sap.ui.model.Model} oModel
 * @param {String} sPath
 * @param {Object} oContext
 * @abstract
 * @public
 * @name sap.ui.model.PropertyBinding
 */

sap.ui.model.Binding.extend("sap.ui.model.PropertyBinding", /** @lends sap.ui.model.PropertyBinding */ {

	constructor : function (oModel, sPath, oContext, mParameters) {
		sap.ui.model.Binding.apply(this, arguments);
		this.oType;
		this.fnFormatter;
		this.sInternalType;
	},
	metadata : {
		"abstract" : true,
		
	  publicMethods : [
		  "getValue", "setValue", "setType", "getType", "setFormatter", "getFormatter", "getExternalValue", "setExternalValue"
	  ]
	}

});

/**
 * Creates a new subclass of class sap.ui.model.PropertyBinding with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * For a detailed description of <code>oClassInfo</code> or <code>FNMetaImpl</code> 
 * see {@link sap.ui.base.Object.extend Object.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] alternative constructor for a metadata object
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.model.PropertyBinding.extend
 * @function
 */

// the 'abstract methods' to be implemented by child classes
/**
 * Returns the current value of the bound target
 *
 * @function
 * @name sap.ui.model.PropertyBinding.prototype.getValue
 * @return {object} the current value of the bound target
 *
 * @public
 */

/**
 * Sets the value for this binding. A model implementation should check if the current default binding mode permits
 * setting the binding value and if so set the new value also in the model.
 *
 * @function
 * @name sap.ui.model.PropertyBinding.prototype.setValue
 * @param {object} oValue the value to set for this binding
 *
 * @public
 */

/**
 * Returns the current external value of the bound target which is formatted via a type or formatter function. 
 *
 * @throws sap.ui.model.FormatException
 *
 * @return {object} the current value of the bound target
 *
 * @public
 */
sap.ui.model.PropertyBinding.prototype.getExternalValue = function() {	
	var oValue = this.getValue();
	if (this.oType) {
		oValue = this.oType.formatValue(oValue, this.sInternalType);
	}
	if (this.fnFormatter) {
		oValue = this.fnFormatter(oValue);
	}
	return oValue;
};


/**
 * Sets the value for this binding. The value is parsed and validated against its type and then set to the binding.
 * A model implementation should check if the current default binding mode permits
 * setting the binding value and if so set the new value also in the model.
 *
 * @param {object} oValue the value to set for this binding
 * 
 * @throws sap.ui.model.ParseException
 * @throws sap.ui.model.ValidateException
 *
 * @public
 */
sap.ui.model.PropertyBinding.prototype.setExternalValue = function(oValue) {
	// formatter doesn't support two way binding
	if (this.fnFormatter) {
		return;
	}
	if (this.oType) {
		oValue = this.oType.parseValue(oValue, this.sInternalType);
		this.oType.validateValue(oValue);
	}
	// if no type specified set value directly
	this.setValue(oValue);
};

/**
 * Sets the optional type and internal type for the binding. The type and internal type are used to do the parsing/formatting correctly.
 * The internal type is the property type of the element which the value is formatted to.  
 *
 * @param {object} oType the sap.ui.model.Type for the binding
 * @param {String} sInternalType the internal type of the element property which this binding is bound against.
 * 
 * @public
 */
sap.ui.model.PropertyBinding.prototype.setType = function(oType, sInternalType) {
	this.oType = oType;
	this.sInternalType = sInternalType;
};

/**
 *  Returns the type if any for the binding.
 *  @returns the binding type
 *  @public
 */
sap.ui.model.PropertyBinding.prototype.getType = function() {
	return this.oType;
};

/**
 * Sets the optional formatter function for the binding.

 * @param {function} fnFormatter the formatter function for the binding
 * 
 * @public
 */
sap.ui.model.PropertyBinding.prototype.setFormatter = function(fnFormatter) {
	this.fnFormatter = fnFormatter;
};

/**
 *  Returns the formatter function
 *  @returns the formatter function
 *  @public
 */
sap.ui.model.PropertyBinding.prototype.getFormatter = function() {
	return this.fnFormatter;
};

}; // end of sap.ui.model.PropertyBinding



/**
 * Constructor for CompositeBinding
 *
 * @class
 * The CompositeBinding is used to bundle multiple property bindings which are be used to provide a single binding against
 * these property bindings. Note: Only One Way binding is supported. So setValue and setExternalValue throw exceptions.
 *
 * @public
 * @name sap.ui.model.CompositeBinding
 */

sap.ui.model.PropertyBinding.extend("sap.ui.model.CompositeBinding", /** @lends sap.ui.model.CompositeBinding */ {

	constructor : function (aBindings, bRawValues) {
		sap.ui.model.Binding.apply(this, arguments); // TODO is this needed?
		this.aBindings = aBindings;
		this.bRawValues = bRawValues;
	},
	metadata : {
		
	  publicMethods : [
	          "getBindings", "attachChange", "detachChange"
	  ]
	}

});

sap.ui.model.CompositeBinding.prototype.getPath = function() {
	jQuery.sap.assert(null, "Composite Binding has no path!");
	return null;
};

sap.ui.model.CompositeBinding.prototype.getModel = function() {
	jQuery.sap.assert(null, "Composite Binding has no model!");
	return null;
};

sap.ui.model.CompositeBinding.prototype.getContext = function() {
	jQuery.sap.assert(null, "Composite Binding has no context!");
	return null;
};

sap.ui.model.CompositeBinding.prototype.getType = function() {
	jQuery.sap.assert(null, "Composite Binding type is not supported!");
	return null;
};

/**
 * sets the context for each property binding in this composite binding
 * @param {object} oContext the new context for the bindings
 */
sap.ui.model.CompositeBinding.prototype.setContext = function(oContext) {
	jQuery.each(this.aBindings, function(i, oBinding){
		// null context could also be set
		if(!oContext || oBinding.updateRequired(oContext.getModel())) {
			oBinding.setContext(oContext);
		}
	});
};

/**
 * Not supported for CompositeBinding as a composite binding contains an array of property bindings. 
 * An exception will be thrown. 
 *
 * @param {object} oValue the value to set for this binding
 * 
 * @throws sap.ui.base.Exception
 *
 * @public
 */
sap.ui.model.CompositeBinding.prototype.setValue = function(oValue) {
	throw new sap.ui.base.Exception("Composite Binding does not support setValue because it contains multiple property bindings!");
};

/**
 * Returns the raw values of the property bindings in an array.
 *
 * @return {object} the values of the internal property bindings in an array
 *
 * @public
 */
sap.ui.model.CompositeBinding.prototype.getValue = function() {	
	var aValues = [],
	oValue;

	jQuery.each(this.aBindings, function(i, oBinding) {
		oValue = oBinding.getValue();
		aValues.push(oValue);
	});

	return aValues;
};

/**
 * Returns the current external value of the bound target which is formatted via a type or formatter function. 
 *
 * @return {object} the current value of the bound target
 *
 *@throws sap.ui.model.FormatException
 *
 * @public
 */
sap.ui.model.CompositeBinding.prototype.getExternalValue = function() {	
	var aValues = [],
		oValue;
	if (this.bRawValues) {
		// type of property bindings is ignored here because we call getValue().
		aValues = this.getValue();
	} else {
		// composite type is ignored here and the property binding types are used in getExternalValue()
		jQuery.each(this.aBindings, function(i, oBinding) {
			oValue = oBinding.getExternalValue();
			aValues.push(oValue);
		});
	}
	
	if (this.fnFormatter) {
		oValue = this.fnFormatter.apply(this, aValues);
	} else {
		if ( aValues.length > 1) {
			// default: multiple values are joined together if no formatter specified
			oValue = aValues.join(" ");
		} else {
			oValue = aValues[0];
		}
	}
	
	return oValue;
};


/**
 * Not supported for CompositeBinding as a composite binding contains an array of property bindings. 
 * An exception will be thrown. 
 *
 * @param {object} oValue the value to set for this binding
 * 
 * @throws sap.ui.base.Exception
 *
 * @public
 */
sap.ui.model.CompositeBinding.prototype.setExternalValue = function(oValue) {
	throw new sap.ui.base.Exception("Composite Binding does not support setExternalValue because it contains multiple property bindings!");
};

/**
 * Returns the property bindings contained in this composite binding.
 *
 * @return {array} the property bindings in this composite binding
 *
 * @public
 */
sap.ui.model.CompositeBinding.prototype.getBindings = function() {
	return this.aBindings;
};

//Eventing and related
/**
* Attach event-handler <code>fnFunction</code> to the '_change' event of this <code>sap.ui.model.Model</code>.<br/>
* @param {function} fnFunction The function to call, when the event occurs.
* @param {object} [oListener] object on which to call the given function.
* @protected
*/
sap.ui.model.CompositeBinding.prototype.attachChange = function(fnFunction, oListener) {
	
	jQuery.each(this.aBindings, function(i, oBinding){
		oBinding.attachChange(fnFunction, oListener);
	});
};

/**
* Detach event-handler <code>fnFunction</code> from the '_change' event of this <code>sap.ui.model.Model</code>.<br/>
* @param {function} fnFunction The function to call, when the event occurs.
* @param {object} [oListener] object on which to call the given function.
* @protected
*/
sap.ui.model.CompositeBinding.prototype.detachChange = function(fnFunction, oListener) {
	jQuery.each(this.aBindings, function(i, oBinding){
		oBinding.detachChange(fnFunction, oListener);
	});
};

/**
 * Determines if the property bindings in the composite binding should be updated by calling updateRequired on all property bindings with the specified model.
 * @param {object} oModel The model instance to compare against
 * @returns {boolean} true if this binding should be updated
 * @protected
 */
sap.ui.model.CompositeBinding.prototype.updateRequired = function(oModel) {
	var bUpdateRequired = false;
	jQuery.each(this.aBindings, function(i, oBinding){
		bUpdateRequired = bUpdateRequired || oBinding.updateRequired(oModel);
	});
	return bUpdateRequired;

};


}; // end of sap.ui.model.CompositeBinding


/**
 * Constructs and initializes a managed object with the given <code>sId</code> and settings.
 *
 * If the optional <code>mSettings</code> are given, they must be a simple object  
 * that defines values for properties, aggregations, associations or events keyed by their name.
 *
 * <b>Valid Names:</b>
 *
 * The property (key) names supported in the object literal are exactly the (case sensitive)
 * names documented in the JSDoc for the properties, aggregations, associations and events
 * of the managed object and its base classes. Note that for  0..n aggregations and associations this
 * usually is the plural name, whereas it is the singular name in case of 0..1 relations.
 *
 * If a key name is ambiguous for a specific managed object class (e.g. a property has the same
 * name as an event), then this method prefers property, aggregation, association and
 * event in that order. To resolve such ambiguities, the keys can be prefixed with
 * <code>aggregation:</code>, <code>association:</code> or <code>event:</code>.
 * In that case the keys must be quoted due to the ':'.
 *
 * Each subclass should document the set of supported names in its constructor documentation.
 *
 * <b>Valid Values:</b>
 *
 * <ul>
 * <li>for normal properties, the value has to be of the correct simple type (no type conversion occurs)
 * <li>for 0..1 aggregations, the value has to be an instance of the aggregated type
 * <li>for 0..n aggregations, the value has to be an array of instances of the aggregated type
 * <li>for 0..1 associations, an instance of the associated type or an id (string) is accepted
 * <li>0..n associations are not supported yet
 * <li>for events either a function (event handler) is accepted or an array of length 2
 *     where the first element is a function and the 2nd element is an object to invoke the method on.
 * </ul>
 *
 * @param {string} [sId] id for the new managed object; generated automatically if no non-empty id is given
 *      Note: this can be omitted, no matter whether <code>mSettings</code> will be given or not!
 * @param {object} [mSettings] optional map/JSON-object with initial property values, aggregated objects etc. for the new object
 *
 * @class Base Class for managed objects.
 * @extends sap.ui.base.EventProvider
 * @author SAP
 * @version 1.10.0
 * @public
 * @name sap.ui.base.ManagedObject
 */
sap.ui.base.EventProvider.extend("sap.ui.base.ManagedObject", {

	metadata : {
	  "abstract" : true,
	  publicMethods : [ "getId", "getMetadata", "getModel", "setModel", "hasModel", "bindProperty", "unbindProperty", "bindAggregation", "unbindAggregation" ],
	  library : "sap.ui.core", // UI Library that contains this class
	  properties : {
	  },
	  aggregations : {
	  },
	  associations : {},
	  events : {}
	},

	constructor : function(sId, mSettings) {

		sap.ui.base.EventProvider.apply(this); // no use to pass our arguments
		if (typeof(sId) != "string" && arguments.length>0) {
			// shift arguments in case sId was missing, but mSettings was given
			mSettings = sId;
			if (mSettings && mSettings.id) {
				sId = mSettings["id"];
			} else {
				sId = null;
			}
		}

		if (!sId) {
			sId = this.getMetadata().uid() || jQuery.sap.uid();
		} else {
			var preprocessor = sap.ui.base.ManagedObject._fnIdPreprocessor;
			sId = (preprocessor ? preprocessor.call(this, sId) : sId);
			var oType = sap.ui.base.DataType.getType("sap.ui.core.ID");
			if (!oType.isValid(sId)) {
				throw new Error("\"" + sId + "\" is not a valid ID.");
			}
		}
		this.sId = sId;

		// managed object interface
		// create an empty property bag that uses a map of defaultValues as its prototype
		this.mProperties = this.getMetadata().createPropertyBag();
		this.mAggregations = {};
		this.mAssociations = {};
		this.mMethods = {};

		// private properties
		this.oParent = null;

		this.aDelegates = [];
		this.aBeforeDelegates = [];
		this.iSuppressInvalidate = 0;
		this.oPropagatedProperties = {oModels:{}, oBindingContexts:{}};

		// data binding
		this.oModels = {};
		this.oBindingContexts = {};
		this.mBindingInfos = {};
		this.sBindingPath = null;
		this.mBindingParameters = null;
		this.mBoundElements = {};
		// TODO: generic concept for init hooks?
		if ( this._initCompositeSupport ) {
			this._initCompositeSupport(mSettings);
		}

		// Call init method here instead of specific Controls constructor.
		if (this.init) {
			this.init();
		}

		// apply the settings
		this.applySettings(mSettings);

		// registers the object in the Core
		if (this.register) this.register();

	}

}, /* Metadata constructor */ sap.ui.base.ManagedObjectMetadata);



/**
 * Creates a new ManagedObject from the given data.
 *
 * If vData is a managed object already, that object is returned.
 * If vData is an object (literal), then a new object is created with vData as settings.
 * The type of the object is either determined by a "Type" entry in the vData or
 * by a type information in the oKeyInfo object
 * @param {sap.ui.base.ManagedObject|object} vData the data to create the object from
 * @param {object} oKeyInfo
 * @public
 * @static
 */
sap.ui.base.ManagedObject.create = function(vData, oKeyInfo) {
	if ( !vData || vData instanceof sap.ui.base.ManagedObject || typeof vData !== "object" || vData instanceof String) {
		return vData;
	}

	function getClass(vType) {
		if ( typeof vType === "function" ) {
			return vType;
		} 
		if (typeof vType === "string" ) {
			return jQuery.sap.getObject(vType);
		}
	}

	var fnClass = getClass(vData.Type) || getClass(oKeyInfo && oKeyInfo.type);
	if ( typeof fnClass === "function" ) {
		return new fnClass(vData);
	}

	// we don't know how to create the ManagedObject from vData, so fail
	// extension points could be integrated here
	var message = "Don't know how to create a ManagedObject from " + vData + " (" + (typeof vData) + ")";
	jQuery.sap.log.fatal(message);
	throw new Error(message);
};

/**
 * A global preprocessor for the ID of a ManagedObject (used internally).
 * If set, this function will be called before the ID is applied to any ManagedObject.
 * If the original ID was empty, the hook will not be called (to be discussed).
 *
 * The expected signature is <code>function(sId)</code>, and <code>this</code> will
 * be the current ManagedObject.
 *
 * @return new ID of the ManagedObject
 * @type function
 * @private
 */
sap.ui.base.ManagedObject._fnIdPreprocessor = null;

/**
 * A global preprocessor for the settings of a ManagedObject (used internally).
 * If set, this function will be called before the settings are applied to any ManagedObject.
 * If the original settings are empty, the hook will not be called (to be discussed).
 *
 * The expected signature is <code>function(mSettings)</code>, and <code>this</code> will
 * be the current ManagedObject.
 *
 * @type function
 * @private
 */
sap.ui.base.ManagedObject._fnSettingsPreprocessor = null;

sap.ui.base.ManagedObject.runWithPreprocessors = function(fn, oPreprocessors) {
	jQuery.sap.assert(typeof fn === "function", "fn must be a function");
	jQuery.sap.assert(!oPreprocessors || typeof oPreprocessors === "object", "oPreprocessors must be an object");

	var oOldPreprocessors = { id : this._fnIdPreprocessor, settings : this._fnSettingsPreprocessor };
	oPreprocessors = oPreprocessors || {};

	this._fnIdPreprocessor = oPreprocessors.id; 
	this._fnSettingsPreprocessor = oPreprocessors.settings;

	try {
		var result = fn.call();
		this._fnIdPreprocessor = oOldPreprocessors.id; 
		this._fnSettingsPreprocessor = oOldPreprocessors.settings;
		return result;
	} catch (e) {
		this._fnIdPreprocessor = oOldPreprocessors.id; 
		this._fnSettingsPreprocessor = oOldPreprocessors.settings;
		throw e;
	}

};

/**
 * Sets all the properties, aggregations, associations and event handlers as given in
 * the object literal <code>mSettings</code>. If a property, aggregation, etc.
 * is not listed in <code>mSettings</code>, then its value is not changed by this method.
 *
 * For properties and 0..1 aggregations/associations, any given setting overwrites
 * the current value. For 0..n aggregations, the given values are appended; event
 * listeners are registered in addition to existing ones.
 *
 * For the possible keys and values in <code>mSettings</code> see the general
 * documentation in {@link sap.ui.base.ManagedObject} or the specific documentation
 * of the constructor of the concrete managed object class.
 *
 * @param {object} mSettings the settings to apply to this managed object
 * @return {sap.ui.base.ManagedObject} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.base.ManagedObject.prototype.applySettings = function(mSettings) {

	// PERFOPT: don't retrieve (expensive) JSONKeys if no settings are given
	if ( !mSettings || jQuery.isEmptyObject(mSettings) ) {
		return this;
	}

	var oMetadata = this.getMetadata(),
		mValidKeys = oMetadata.getJSONKeys(),
		makeControl = sap.ui.base.ManagedObject.create,
		preprocessor = sap.ui.base.ManagedObject._fnSettingsPreprocessor,
		sKey, oValue, oKeyInfo;

	// call the preprocessor if it has been defined
	preprocessor && preprocessor.call(this, mSettings); // TODO: decide whether to call for empty settings as well?
	
	// process models
	if ( mSettings.models ) {
		if ( typeof mSettings.models !== "object" ) {
			throw new Error("models must be a simple object");
		}
		if ( mSettings.models instanceof sap.ui.model.Model) {
			this.setModel(mSettings.models);
		} else {
			for(var sKey in mSettings.models ) {
				this.setModel(mSettings.models[sKey], sKey);
			}
		}
		delete mSettings.models;
	}
	//process BindingContext
	if ( mSettings.bindingContexts ) {
		if ( typeof mSettings.bindingContexts !== "object" ) {
			throw new Error("bindingContexts must be a simple object");
		}
		if ( mSettings.bindingContexts instanceof sap.ui.model.Context) {
			this.setBindingContext(mSettings.bindingContexts);
		} else {
			for(var sKey in mSettings.bindingContexts ) {
				this.setBindingContext(mSettings.bindingContexts[sKey], sKey);
			}
		}
		delete mSettings.bindingContexts;
	}
	// process all settings
	// process settings
	for(sKey in mSettings) {
		// get info object for the key
		if ( oKeyInfo = mValidKeys[sKey] ) {
			oValue = mSettings[sKey];
			switch(oKeyInfo._iKind) {
			case 0: // PROPERTY
				if (this.isBinding(oValue, oKeyInfo)) {
					var oBindingInfo = this.extractBindingInfo(oValue);
					this.bindProperty(sKey, oBindingInfo);
				} else {
					this[oKeyInfo._sMutator](oValue);
				}
				break;
			case 1: // SINGLE_AGGREGATION
				if ( oKeyInfo.altTypes && this.isBinding(oValue, oKeyInfo) ) {
					var oBindingInfo = this.extractBindingInfo(oValue);
					this.bindProperty(sKey, oBindingInfo);
				} else {
					this[oKeyInfo._sMutator](makeControl(oValue, oKeyInfo));
				}
				break;
			case 2: // MULTIPLE_AGGREGATION
				if (this.isBinding(oValue, oKeyInfo)) {
					var oBindingInfo = this.extractBindingInfo(oValue);
					this.bindAggregation(sKey, oBindingInfo);
				} else {
					if ( oValue && !jQuery.isArray(oValue) ) {
						oValue = [oValue];
					}
					if ( oValue ) {
						for(var i=0,l=oValue.length; i<l; i++) {
							this[oKeyInfo._sMutator](makeControl(oValue[i], oKeyInfo));
						}
					}
				}
				break;
			case 3: // SINGLE_ASSOCIATION
				this[oKeyInfo._sMutator](oValue);
				break;
			case 4: // MULTIPLE_ASSOCIATION
				if ( oValue && !jQuery.isArray(oValue) ) {
					oValue = [oValue];
				}
				if ( oValue ) {
					for(var i=0,l=oValue.length; i<l; i++) {
						this[oKeyInfo._sMutator](oValue[i]);
					}
				}
				break;
			case 5: // EVENT
				if ( typeof oValue == "function" ) {
					this[oKeyInfo._sMutator](oValue);
				}
				else {
					this[oKeyInfo._sMutator](oValue[0], oValue[1], oValue[2]);
				}
					//this[oKeyInfo._sMutator].apply(this, oValue); // could be replacement for line before
				break;
			default:
				break;
			}
		}
	}

	return this;
};

/**
 * Returns a simple string representation of this managed object.
 *
 * Mainly useful for tracing purposes.
 * @public
 * @return {string} a string description of this managed object
 */
sap.ui.base.ManagedObject.prototype.toString = function() {
	return "ManagedObject " + this.getMetadata().getName() + "#" + this.getId();
};

/**
 * Returns the object's Id.
 *
 * @return {string} the objects's Id.
 * @public
 */
sap.ui.base.ManagedObject.prototype.getId = function() {
	return this.sId;
};


/**
 * Sets a new value for the given property <code>sPropertyName</code> and marks
 * this object as changed. If the given <code>oValue</code> equals the
 * current value, nothing happens.
 *
 * @param {string}  sPropertyName name of the property to set
 * @param {any}     oValue value to set the property to
 * @param {boolean} [bSuppressInvalidate] if true, the managed is not marked as changed
 * @return {sap.ui.base.ManagedObject} Returns <code>this</code> to allow method chaining
 * TODO better name bSuppressInvalidate positive, e.g. "bStayValid"
 * @protected
 */
sap.ui.base.ManagedObject.prototype.setProperty = function(sPropertyName, oValue, bSuppressInvalidate) {

	// check for a value change
	var oOldValue = this.mProperties[sPropertyName];

	// value validation
	oValue = this.validateProperty(sPropertyName, oValue);

	if (jQuery.sap.equal(oOldValue, oValue)) {
		return this;
	} // no change

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	// change the property (and invalidate if the rendering should be updated)
	this.mProperties[sPropertyName] = oValue;
	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// check whether property is bound and update model in case of two way binding
	this.updateModelProperty(sPropertyName, oValue, oOldValue);

	// prototype for generic property change events
	// TODO: THINK ABOUT CONFIGURATION TO ENABLE THIS
	sap.ui.base.EventProvider.prototype.fireEvent.apply(this, ["_change", {
		"id": this.getId(),
		"name": sPropertyName,
		"oldValue": oOldValue,
		"newValue": oValue
	}]);

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

/**
 * Returns the value for the property with the given <code>sPropertyName</code>
 *
 * @param {string} sPropertyName the name of the property
 * @type any
 * @return the value of the property
 * @protected
 */
sap.ui.base.ManagedObject.prototype.getProperty = function(sPropertyName) {
	var oValue = this.mProperties[sPropertyName],
		oMetadata = this.getMetadata(),
		oProperty = oMetadata.getAllProperties()[sPropertyName],
		oType;

	if (!oProperty) {
		throw new Error("Property \"" + sPropertyName + "\" does not exist in " + this);
	}

	oType = sap.ui.base.DataType.getType(oProperty.type);

	// If property has an array type, clone the array to avoid modification of original data
	if (oType instanceof sap.ui.base.DataType && oType.isArrayType() && jQuery.isArray(oValue)) {
		oValue = oValue.slice(0);
	}
	
	// If proprerty is of type String instead of string, convert with valueOf()
	if (oValue instanceof String) {
		oValue = oValue.valueOf();
	}
	
	return oValue;
};

/**
 * Checks whether the given value is of the proper type for the given property name. In case null or undefined is
 * passed, the default value for this property is returned.
 *
 * @param {string} sPropertyName the name of the property
 * @param {any} oValue the value
 * @return {any} the passed value or the property's default value if null or undefined was passed
 * @throws Error if no property with the given name is found or the given value does not fit to the property type
 * @protected
 */
sap.ui.base.ManagedObject.prototype.validateProperty = function(sPropertyName, oValue) {
	var oMetadata = this.getMetadata(),
		oProperty = oMetadata.getAllProperties()[sPropertyName],
		oType;

	if (!oProperty) {
		throw new Error("Property \"" + sPropertyName + "\" does not exist in " + this);
	}

	oType = sap.ui.base.DataType.getType(oProperty.type);

	// If property has an array type, clone the array to avoid modification of original data
	if (oType instanceof sap.ui.base.DataType && oType.isArrayType() && jQuery.isArray(oValue)) {
		oValue = oValue.slice(0);
	}
	
	// In case null is passed as the value return the default value, either from the property or from the type
	if (oValue === null || oValue === undefined) {
		if (oProperty.defaultValue !== null) {
			return oProperty.defaultValue;
		} else {
			return oType.getDefaultValue();
		}
	}

	// Implicit casting for string only, other types are causing errors
	if (oType instanceof sap.ui.base.DataType) {
		if (oType.getName() == "string") {
			if (!(typeof oValue == "string" || oValue instanceof String)) {
				oValue = "" + oValue;
			}
		} else if (oType.getName() == "string[]") {
			for (var i = 0; i < oValue.length; i++) {
				if (!typeof oValue[i] == "string") {
					oValue[i] = "" + oValue[i];
				}
			}
		} else if (!oType.isValid(oValue)) {
			throw new Error("\"" + oValue + "\" is of type " + typeof oValue + ", expected " +
					oType.getName() + " for property \"" + sPropertyName + "\" of " + this);
		}
	} else if (!(oValue in oType)){ // Enumeration
		throw new Error("\"" + oValue + "\" is not a valid entry of the enumeration for property \"" + sPropertyName + "\" of " + this);
	}

	return oValue;
};

/**
 * Returns the origin info on the property value of the given property name
 *
 * @param {string} sPropertyName the name of the property
 * @return {object} a map of properties describing the origin of this property value or null
 * @public
 */
sap.ui.base.ManagedObject.prototype.getOriginInfo = function(sPropertyName) {
	var oValue = this.mProperties[sPropertyName];
	if (!(oValue instanceof String && oValue.originInfo)) {
		return null;
	}
	return oValue.originInfo;
};


// ######################################################################################################
// Associations
// ######################################################################################################

/**
 * Sets an association for the managed object
 *
 * @param {string}
 *            sAssociationName name of the association
 * @param {string | sap.ui.base.ManagedObject}
 *            sId the ID of the managed object that is set as an association, or the managed object itself or null
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the managed objects invalidate method is not called
 * @return {sap.ui.base.ManagedObject} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.base.ManagedObject.prototype.setAssociation = function(sAssociationName, sId, bSuppressInvalidate) {
	if (sId instanceof sap.ui.base.ManagedObject) {
		sId = sId.getId();
	} else if (sId != null && typeof sId !== "string") {
		jQuery.sap.assert(false, "setAssociation(): sId must be a string, an instance of sap.ui.base.ManagedObject or null");
		return this;
	}

	if (this.mAssociations[sAssociationName] === sId) {
		return this;
	} // no change

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	this.mAssociations[sAssociationName] = sId;

	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

/**
 * Returns an association of the managed object with a given sAssociationName
 *
 * @param {string} sAssociationName the name of the association
 * @param {object}
 *			  oDefaultForCreation the object that is used in case the current aggregation is empty (only null or empty array allowed)
 * @return {string | string[]} the ID of the associated managed object or an array of such IDs; may be null if the association has not been populated
 * @protected
 */
sap.ui.base.ManagedObject.prototype.getAssociation = function(sAssociationName, oDefaultForCreation) {
	var result = this.mAssociations[sAssociationName];

	if (!result) {
		result = this.mAssociations[sAssociationName] = oDefaultForCreation || null;
	} else {
		if (typeof result.length === 'number' && !(result.propertyIsEnumerable('length')) ) {
			// Return a copy of the array instead of the array itself as reference!!
			return result.slice();
		}
		// simple type or ManagedObject
		return result;
	}

	return result;
};

/**
 * Adds some entity with the ID <code>sId</code> to the association identified by <code>sAssociationName</code>.
 *
 * @param {string}
 *            sAssociationName the string identifying the association the object should be added to.
 * @param {string | sap.ui.base.ManagedObject}
 *            sId the ID of the managed object to add; if empty, nothing is added; if a <code>sap.ui.base.ManagedObject</code> is given, its ID is added
 * @param {boolean}
 *            [bSuppressInvalidate] if true, this managed object as well as the newly associated object are not marked as changed
 * @return {sap.ui.base.ManagedObject} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.base.ManagedObject.prototype.addAssociation = function(sAssociationName, sId, bSuppressInvalidate) {
	if (sId instanceof sap.ui.base.ManagedObject) {
		sId = sId.getId();
	} else if (typeof sId !== "string") {
	  // TODO what about empty string?
    jQuery.sap.assert(false, "addAssociation(): sId must be a string or an instance of sap.ui.base.ManagedObject");
		return this;
	}

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	var aIds = this.mAssociations[sAssociationName];
	if (!aIds) {
		aIds = this.mAssociations[sAssociationName] = [sId];
	} else {
		aIds.push(sId);
	}

	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

/**
 * Removes a ManagedObject from the association named <code>sAssociationName</code>.
 *
 * @param {string}
 *            sAssociationName the string identifying the association the ManagedObject should be removed from.
 * @param {int | string | sap.ui.base.ManagedObject}
 *            vObject the position or ID of the ManagedObject to remove or the ManagedObject itself; if <code>vObject</code> is invalid input,
 *            a negative value or a value greater or equal than the current size of the association, nothing is removed
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the managed object is not marked as changed
 * @return the ID of the removed ManagedObject or null
 * @protected
 */
sap.ui.base.ManagedObject.prototype.removeAssociation = function(sAssociationName, vObject, bSuppressInvalidate) {
	var aIds = this.mAssociations[sAssociationName];
	var sId = null;

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	if (typeof(vObject) == "object" && vObject.getId) { // object itself is given
		vObject = vObject.getId();
	}

	if (typeof(vObject) == "string") { // ID of the object is given or has just been retrieved
		for (var i = 0; i < aIds.length; i++) {
			if (aIds[i] == vObject) {
				vObject = i;
				break;
			}
		}
	}

	if (typeof(vObject) == "number") { // "object" is the index now
		if (vObject < 0 || vObject >= aIds.length) {
			jQuery.sap.log.warning("ManagedObject.removeAssociation called with invalid index: " + sAssociationName + ", " + vObject);
		} else {
			sId = aIds[vObject];
			aIds.splice(vObject, 1);
			if (!this.isInvalidateSuppressed()) {
				this.invalidate();
			}
		}
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return sId;
};

/**
 * Removes all the objects in the 0..n-association named <code>sAssociationName</code> (and returns them in an array).<br/>
 *
 * @param {string}
 *            sAssociationName the name of the association
 * @param {boolean}
 *            [bSuppressInvalidate] if true, this ManagedObject is not marked as changed
 * @type Array
 * @return an array with the IDs of the removed objects (might be empty)
 * @protected
 */
sap.ui.base.ManagedObject.prototype.removeAllAssociation = function(sAssociationName, bSuppressInvalidate){
	var aIds = this.mAssociations[sAssociationName];
	if (!aIds)	{
		return [];
	}

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	delete this.mAssociations[sAssociationName];
	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return aIds;
};

// ######################################################################################################
// End of Associations
// ######################################################################################################


// ######################################################################################################
// Aggregations
// ######################################################################################################

/**
 * Checks whether the given value is of the proper type for the given aggregation name. 
 *
 * @param {string} sAggregationName the name of the aggregation
 * @param {sap.ui.base.ManagedObject|any} oObject the aggregated object or a primitive value
 * @param {boolean} bMultiple whether the aggregation must have cardinality 0..n
 * @return {sap.ui.base.ManagedObject|any} the passed object
 * @throws Error if no aggregation with the given name is found or the given value does not fit to the aggregation type
 * @protected
 */
sap.ui.base.ManagedObject.prototype.validateAggregation = function(sAggregationName, oObject, bMultiple) {
	var oMetadata = this.getMetadata(),
		oAggregation = oMetadata.getAllAggregations()[sAggregationName],
		aAltTypes,
		oType,
		i,
		msg;

	// undeclared aggregation 
	if (!oAggregation) {
		if(sAggregationName && oMetadata._mHiddenAggregations && oMetadata._mHiddenAggregations[sAggregationName]){
			oAggregation = oMetadata._mHiddenAggregations[sAggregationName];
		}else{
			msg = "Aggregation \"" + sAggregationName + "\" does not exist in " + this;
			
			if ( /^sap\.(ui\.core|ui\.commons|ui\.table|ui\.ux3|m|makit|viz|uiext\.inbox)$/.test(oMetadata.getLibraryName() || "") ) {
				throw new Error(msg);
			} else {
				// TODO throw for any lib as soon as "hidden" aggregations are a public feature.
				// Otherwise, composite controls currently would have no legal way to react 
				jQuery.sap.assert(false, msg);
				return oObject;
			}
		}
	}

	if (oAggregation.multiple !== bMultiple ) {
		throw new Error("Aggregation '" + sAggregationName + "' of " + this + " used with wrong cardinality (declared as " + (oAggregation.multiple ? "0..n" : "0..1") + ")");
	}
	
	//Null is a valid value for 0..1 aggregations
	if(!oAggregation.multiple && !oObject){
		return oObject;
	}
	
	oType = jQuery.sap.getObject(oAggregation.type);
	// class types
	if ( typeof oType === "function" && oObject instanceof oType ) {
		return oObject;
	}
	// interfaces 
	if ( oObject && oObject.getMetadata && oObject.getMetadata().isInstanceOf(oAggregation.type) ) {
		return oObject;
	}
	// alternative types
	aAltTypes = oAggregation.altTypes;
	if ( aAltTypes && aAltTypes.length ) {
		// for primitive types, null or undefined is valid as well 
		if ( oObject == null ) {
			return oObject;
		}
		for (i=0; i<aAltTypes.length; i++) {
			oType = sap.ui.base.DataType.getType(aAltTypes[i]);
			if (oType instanceof sap.ui.base.DataType) {
				if (oType.isValid(oObject)) {
					return oObject;
				}
			} else if (oObject in oType) { // Enumeration
				return oObject;
			}
		}
	}

	// TODO make this stronger again (e.g. for FormattedText)
	msg = "\"" + oObject + "\" is not valid for aggregation \"" + sAggregationName + "\" of " + this;
	if ( sap.ui.base.DataType.isInterfaceType(oAggregation.type) ) {
		jQuery.sap.assert(false, msg);
		return oObject;
	} else {
	  throw new Error(msg);
	}
};

/**
 * Sets an aggregation for the managed object
 *
 * @param {string}
 *            sAggregationName name of the aggregation
 * @param {object}
 *            oObject the managed object that is set as an aggregation
 * @param {boolean}
 *            [bSuppressInvalidate] if true, this ManagedObject is not marked as changed
 * @return {sap.ui.base.ManagedObject} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.base.ManagedObject.prototype.setAggregation = function(sAggregationName, oObject, bSuppressInvalidate) {
	var oOldChild = this.mAggregations[sAggregationName];
	if (oOldChild === oObject) {
		return this;
	} // no change
	oObject = this.validateAggregation(sAggregationName, oObject, /* multiple */ false); 

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	if (oOldChild instanceof sap.ui.base.ManagedObject) { // remove old child
		oOldChild.setParent(null);
	}
	this.mAggregations[sAggregationName] = oObject;
	if (oObject instanceof sap.ui.base.ManagedObject) { // adopt new child
		oObject.setParent(this, sAggregationName, bSuppressInvalidate);
	} else {
		if (!this.isInvalidateSuppressed()) {
			this.invalidate();
		}
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

/**
 * Returns an aggregation of the managed object with a given sAggregationName
 *
 * @param {string}
 *            sAggregationName the name of the aggregation
 * @param {sap.ui.base.ManagedObject | Array}
 *			  oDefaultForCreation the object that is used in case the current aggregation is empty
 * @type sap.ui.base.ManagedObject|Array
 * @return the aggregation array in case of 0..n-aggregations or the managed object or null in case of 0..1-aggregations
 * @protected
 */
sap.ui.base.ManagedObject.prototype.getAggregation = function(sAggregationName, oDefaultForCreation) {
	var aChildren = this.mAggregations[sAggregationName];
	if (!aChildren) {
		aChildren = this.mAggregations[sAggregationName] = oDefaultForCreation || null;
	}
	if (aChildren) {
		if (typeof aChildren.length === 'number' && !(aChildren.propertyIsEnumerable('length')) ) {
			// Return a copy of the array instead of the array itself as reference!!
			return aChildren.slice();
		}
		// simple type or ManagedObject
		return aChildren;
	} else {
		return null;
	}
};

/**
 * Checks for the provided managed object <code>oObject</code> in the aggregation
 * named <code>sAggregationName</code> and returns its index if found, or -1
 * otherwise. Returns -2 if the given named aggregation is not a multiple one
 * (and does not contain the given child).
 *
 * @param {string}
 *            sAggregationName the name of the aggregation
 * @param {sap.ui.base.ManagedObject}
 *            oObject the ManagedObject whose index is looked for.
 * @return {int} the index of the provided managed object in the aggregation.
 * @protected
 */
sap.ui.base.ManagedObject.prototype.indexOfAggregation = function(sAggregationName, oObject) {
	var aChildren = this.mAggregations[sAggregationName];
	if (aChildren) {
		if (aChildren.length == undefined) {
			return -2;
		} // not a multiple aggregation

		for (var i = 0; i < aChildren.length; i++) {
			if (aChildren[i] == oObject) {
				return i;
			}
		}
	}
	return -1;
};

/**
 * Inserts managed object <code>oObject</code> to the aggregation named <code>sAggregationName</code> at
 * position <code>iIndex</code>.
 *
 * @param {string}
 *            sAggregationName the string identifying the aggregation the managed object <code>oObject</code>
 *            should be inserted into.
 * @param {sap.ui.base.ManagedObject}
 *            oObject the ManagedObject to add; if empty, nothing is inserted.
 * @param {int}
 *            iIndex the <code>0</code>-based index the managed object should be inserted at; for a negative
 *            value <code>iIndex</code>, <code>oObject</code> is inserted at position 0; for a value
 *            greater than the current size of the aggregation, <code>oObject</code> is inserted at
 *            the last position
 * @param {boolean}
 *            [bSuppressInvalidate] if true, this ManagedObject as well as the added child are not marked as changed
 * @return {sap.ui.base.ManagedObject} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.base.ManagedObject.prototype.insertAggregation = function(sAggregationName, oObject, iIndex, bSuppressInvalidate) {
	if (!oObject) {
		return this;
	}
	oObject = this.validateAggregation(sAggregationName, oObject, /* multiple */ true);

	var aChildren = this.mAggregations[sAggregationName] || (this.mAggregations[sAggregationName] = []);
	// force index into valid range 
	var i = iIndex < 0 ? 0 : (iIndex > aChildren.length ? aChildren.length : iIndex);
	if (i !== iIndex) {
		jQuery.sap.log.warning("ManagedObject.insertAggregation: index '" + iIndex + "' out of range [0," + aChildren.length + "], forced to " + i);
	}
	aChildren.splice(i, 0, oObject);
	oObject.setParent(this, sAggregationName, bSuppressInvalidate);

	return this;
};

/**
 * Adds some entity <code>oObject</code> to the aggregation identified by <code>sAggregationName</code>.
 *
 * @param {string}
 *            sAggregationName the string identifying the aggregation that <code>oObject</code> should be added to.
 * @param {sap.ui.base.ManagedObject}
 *            oObject the object to add; if empty, nothing is added
 * @param {boolean}
 *            [bSuppressInvalidate] if true, this ManagedObject as well as the added child are not marked as changed
 * @return {sap.ui.base.ManagedObject} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.base.ManagedObject.prototype.addAggregation = function(sAggregationName, oObject, bSuppressInvalidate) {
	if (!oObject) {
		return this;
	}
	oObject = this.validateAggregation(sAggregationName, oObject, /* multiple */ true);

	var aChildren = this.mAggregations[sAggregationName];
	if (!aChildren) {
		aChildren = this.mAggregations[sAggregationName] = [oObject];
	} else {
		aChildren.push(oObject);
	}
	oObject.setParent(this, sAggregationName, bSuppressInvalidate);
	return this;
};

/**
 * Removes an object from the aggregation named <code>sAggregationName</code>.
 *
 * @param {string}
 *            sAggregationName the string identifying the aggregation the ManagedObject should be removed from
 * @param {int | string | sap.ui.base.ManagedObject}
 *            vObject the position or ID of the ManagedObject to remove or the ManagedObject itself; if <code>vObject</code> is invalid,
 *            a negative value or a value greater or equal than the current size of the aggregation, nothing is removed
 * @param {boolean}
 *            [bSuppressInvalidate] if true, this ManagedObject is not marked as changed
 * @type sap.ui.base.ManagedObject
 * @return the removed object or null
 * @protected
 */
sap.ui.base.ManagedObject.prototype.removeAggregation = function(sAggregationName, vObject, bSuppressInvalidate) {
	var aChildren = this.mAggregations[sAggregationName];
	var oChildControl = null;

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	if (typeof(vObject) == "string") { // ID of the object is given
		vObject = sap.ui.getCore().byId(vObject);
	}

	if (typeof(vObject) == "object") { // the object itself is given or has just been retrieved
		for (var i = 0; i < aChildren.length; i++) {
			if (aChildren[i] == vObject) {
				vObject = i;
				break;
			}
		}
	}

	if (typeof(vObject) == "number") { // "vObject" is the index now
		if (vObject < 0 || vObject >= aChildren.length) {
			jQuery.sap.log.warning("ManagedObject.removeAggregation called with invalid index: " + sAggregationName + ", " + vObject);

		} else {
			oChildControl = aChildren[vObject];
			aChildren.splice(vObject, 1);
			oChildControl.setParent(null);
			if (!this.isInvalidateSuppressed()) {
				this.invalidate();
			}
		}
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return oChildControl;
};

/**
 * Removes all the controls in the 0..n-aggregation named <code>sAggregationName</code> (and returns them in an array).<br/>
 * Additionally unregisters them from the hosting UIArea.
 *
 * @param {string}
 *            sAggregationName the name of the aggregation
 * @param {boolean}
 *            [bSuppressInvalidate] if true, this ManagedObject is not marked as changed
 * @type Array
 * @return an array of the removed elements (might be empty)
 * @protected
 */
sap.ui.base.ManagedObject.prototype.removeAllAggregation = function(sAggregationName, bSuppressInvalidate){
	var aChildren = this.mAggregations[sAggregationName];
	if (!aChildren)	{
		return [];
	}

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	delete this.mAggregations[sAggregationName];
	for (var i = 0; i < aChildren.length; i++) {
		aChildren[i].setParent(null);
	}
	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return aChildren;
};

/**
 * Destroys (all) the managed object(s) in the aggregation named <code>sAggregationName</code> and afterwards empties the
 * aggregation.
 *
 * @param {string}
 *            sAggregationName the name of the aggregation
 * @param {boolean}
 *            [bSuppressInvalidate] if true, this ManagedObject is not marked as changed
 * @return {sap.ui.base.ManagedObject} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.base.ManagedObject.prototype.destroyAggregation = function(sAggregationName, bSuppressInvalidate){
	var aChildren = this.mAggregations[sAggregationName];
	if (!aChildren) {
		return this;
	}

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	delete this.mAggregations[sAggregationName];
	if (aChildren instanceof sap.ui.base.ManagedObject) {
		aChildren.destroy(bSuppressInvalidate);
	} else if (aChildren && jQuery.isArray(aChildren)) {
		for (var i = 0; i < aChildren.length; i++) {
			if (aChildren[i]) {
				aChildren[i].destroy(bSuppressInvalidate);
			}
		}
	}
	if (!this.isInvalidateSuppressed()) {
		this.invalidate();
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

// ######################################################################################################
// End of Aggregations
// ######################################################################################################


/**
 * This triggers rerendering of itself and its children.<br/> As <code>sap.ui.base.ManagedObject</code> "bubbles up" the
 * invalidate, changes to child-<code>Elements</code> will also result in rerendering of the whole sub tree.
 * @protected
 */
sap.ui.base.ManagedObject.prototype.invalidate = function() {
	if (this.oParent) {
		this.oParent.invalidate(this);
	}
};


/**
 * Returns whether rerendering is currently suppressed on this ManagedObject
 * @return boolean
 * @protected
 */
sap.ui.base.ManagedObject.prototype.isInvalidateSuppressed = function() {
	var bInvalidateSuppressed = this.iSuppressInvalidate > 0;
	if (this.oParent && this.oParent instanceof sap.ui.base.ManagedObject) {
		bInvalidateSuppressed = bInvalidateSuppressed || this.oParent.isInvalidateSuppressed();
	}
	return bInvalidateSuppressed;
};


/**
 * Removes the given child from this object's named aggregation.
 * @see sap.ui.core.UIArea#_removeChild
 * @see sap.ui.base.ManagedObject#setParent
 *
 * @param {sap.ui.base.ManagedObject}
 *            oChild the child object to be removed
 * @param {string}
 *            sAggregationName the name of this object's aggregation
 * @param {boolean}
 *            [bSuppressInvalidate] if true, this ManagedObject is not marked as changed
 * @protected
 */
sap.ui.base.ManagedObject.prototype._removeChild = function(oChild, sAggregationName, bSuppressInvalidate) {
	if (!sAggregationName) {
		// an aggregation name has to be specified!
		jQuery.sap.log.error("Cannot remove aggregated child without aggregation name.", null, this);
	} else {
		// set suppress invalidate flag
		if (bSuppressInvalidate) {
			this.iSuppressInvalidate++;
		}

		var iIndex = this.indexOfAggregation(sAggregationName, oChild);
		var oAggregationInfo = this.getMetadata().getJSONKeys()[sAggregationName];
		// Note: we assume that this is the given child's parent, i.e. -1 not expected!
		if (iIndex == -2) { // 0..1
			if(oAggregationInfo && this[oAggregationInfo._sMutator]) { // TODO properly deal with hidden aggregations
				this[oAggregationInfo._sMutator](null);
			}
			else {
				this.setAggregation(sAggregationName, null, bSuppressInvalidate);
			}
		} else if(iIndex > -1 ) { // 0..n
			if(oAggregationInfo && this[oAggregationInfo._sRemoveMutator]) { // TODO properly deal with hidden aggregations
				this[oAggregationInfo._sRemoveMutator](iIndex);
			}
			else {
				this.removeAggregation(sAggregationName, iIndex, bSuppressInvalidate);
			}
		} else {
			// already removed!?
			// this is the unexpected -1
			// TODO: What would be better? Explicit removeCompositeChild callback on subclass?
		}
		if (!this.isInvalidateSuppressed()) {
			this.invalidate();
		}

		// reset suppress invalidate flag
		if (bSuppressInvalidate) {
			this.iSuppressInvalidate--;
		}
	}
};

/**
 * Defines this object's new parent. If no new parent is given, the parent is
 * just unset and we assume that the old parent has removed this child from its
 * aggregation. But if a new parent is given, this child is first removed from
 * its old parent.
 *
 * @param {sap.ui.base.ManagedObject}
 *            oParent the object that becomes this objects's new parent
 * @param {string}
 *            sAggregationName the name of the parent objects's aggregation
 * @param {boolean}
 *            [bSuppressInvalidate] if true, this ManagedObject is not marked as changed. The old parent, however, is marked.
 * @return {sap.ui.base.ManagedObject}
 *            Returns <code>this</code> to allow method chaining
 * @private
 */
sap.ui.base.ManagedObject.prototype.setParent = function(oParent, sAggregationName, bSuppressInvalidate) {
	var that = this;
	
	if ( !oParent ) {
		this.oParent = null;
		this.sParentAggregationName = null;
		// Note: no need (and no way how) to invalidate
		return;
	}

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	var oOldParent = this.getParent();
	if (oOldParent) { // remove this object from its old parent
		// Note: bSuppressInvalidate  by intention is not propagated to the old parent.
		// It is not sure whether the (direct or indirect) caller of setParent
		// has enough knowledge about the old parent to automatically propagate this.
		// If needed, callers can first remove the object from the oldParent (specifying a 
		// suitable value for bSuppressInvalidate there) and only then call setParent.
		oOldParent._removeChild(this, this.sParentAggregationName);  
	}
	// adopt new parent
	this.oParent = oParent;
	this.sParentAggregationName = sAggregationName;
	
	//get propeties to propagate
	this.oPropagatedProperties.oBindingContexts = jQuery.extend({}, oParent.oPropagatedProperties.oBindingContexts, oParent.oBindingContexts);
	this.oPropagatedProperties.oModels = jQuery.extend({}, oParent.oPropagatedProperties.oModels, oParent.oModels);
	
	// update bindings
	if (this.hasModel()) {
		this.updateBindingContext(false, true, undefined, true);
		this.updateBindings(true,null,false); // TODO could be restricted to models that changed
		this.propagateProperties(true);
	}

	// only the parent knows where to render us, so we have to invalidate it
	if ( oParent && !this.isInvalidateSuppressed() ) {
		oParent.invalidate(this);
	}

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	return this;
};

/**
 * Returns the parent managed object or <code>null</code> if this object hasn't been added to a parent yet.
 *
 * @return {sap.ui.base.ManagedObject} The parent managed object or <code>null</code>
 * @public
 */
sap.ui.base.ManagedObject.prototype.getParent = function() {
	/* Be aware that internally this.oParent is used to reduce method calls. 
	 * Check for side effects when overriding this method */
	return this.oParent;
};


/**
 * Cleans up the resources associated with this object and all its aggregated children.
 *
 * After an object has been destroyed, it can no longer be used in!
 *
 * Applications should call this method if they don't need the object any longer.
 *
 * @param {boolean}
 *            [bSuppressInvalidate] if true, this ManagedObject is not marked as changed
 * @public
 */
sap.ui.base.ManagedObject.prototype.destroy = function(bSuppressInvalidate) {
	var that = this;

	// jQuery.sap.log.debug("destroying " + this);

	// set suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate++;
	}

	if (this.exit) {
		this.exit();
	}

	// TODO: generic concept for exit hooks?
	if ( this._exitCompositeSupport ) {
		this._exitCompositeSupport();
	}

	// ensure that also our children are destroyed!!
	for(var oAggr in this.mAggregations){
		this.destroyAggregation(oAggr, bSuppressInvalidate);
	}
	
	// Deregister, if available
	if (this.deregister) this.deregister();

	// remove this child from parent aggregation
	if (this.oParent && this.sParentAggregationName) {
		this.oParent._removeChild(this, this.sParentAggregationName, bSuppressInvalidate);
	}

	// Data Binding
	jQuery.each(this.mBindingInfos, function(sName, oBindingInfo) {
		if (oBindingInfo.factory) {
			that.unbindAggregation(sName);
		} else {
			that.unbindProperty(sName);
		}
	});

	// reset suppress invalidate flag
	if (bSuppressInvalidate) {
		this.iSuppressInvalidate--;
	}

	// finally make the object unusable
	this.setParent = function(){
		throw Error("The object with ID "+that.getId()+" was destroyed and cannot be used anymore.");
	};

	// make visible that it's been destroyed.
	this.bIsDestroyed = true;

};


// DataBinding
/**
 * Determines whether a given object contains binding information instead of a
 * value or aggregated controls. The method is used in applySettings for processing
 * the JSON notation of properties/aggregations in the constructor.
 *
 * @param {object} oValue the value
 * @param {object} oKeyInfo the metadata of the property
 *
 * @returns {boolean} whether the value contains binding information
 *
 * @private
 */
sap.ui.base.ManagedObject.prototype.isBinding = function(oValue, oKeyInfo) {
	if (oValue && typeof oValue == "object" && (oValue.path || oValue.parts) && oKeyInfo.type != "object") {
		return true;
	}
	if (typeof oValue == "string" && jQuery.sap.startsWith(oValue, "{") && jQuery.sap.endsWith(oValue, "}")) {
		return true;
	}
	return false;
};

/**
 * Extracts the binding info from the given value. There are two possible notations
 * for binding information in the JSON notation of the managed object constructor:
 * - property: "{path}"
 *   This is used for property binding and can only contain the path.
 * - property:{path:"path", template:oTemplate}
 *   This is used for aggregation binding, where a template is required or can
 *   be used for property binding when additional data is required (e.g. formatter).
 *
 * @param {object} oValue
 *
 * @returns {object} the binding info object, containing at least a path property
 *                   and, dependant of the binding type, additional properties
 *
 * @private
 */
sap.ui.base.ManagedObject.prototype.extractBindingInfo = function(oValue) {
	var oBindingInfo;
	// property:{path:"path", template:oTemplate}
	if (oValue && typeof oValue == "object") {
		oBindingInfo = oValue;
		// allow JSON syntax for templates
		if (oBindingInfo.template) {
			oBindingInfo.template = sap.ui.base.ManagedObject.create(oBindingInfo.template);
		}
	}
	// property:"{path}"
	if (typeof oValue == "string") {
		oBindingInfo = {};
		oBindingInfo.path = oValue.substr(1, oValue.length - 2);
	}
	return oBindingInfo;
};

/**
 * Returns the binding infos for the given property or aggregation. The binding info contains information about path, binding object, format options,
 * sorter, filter etc. for the property or aggregation.
 *
 * @param {string} sName the name of the property or aggregation
 *
 * @returns {object} the binding info object, containing at least a path property
 *                   and, dependant of the binding type, additional properties
 *
 * @protected
 */
sap.ui.base.ManagedObject.prototype.getBindingInfo = function(sName) {
	return this.mBindingInfos[sName];
};

/**
 * Bind the object to the referenced entity in the model, which is used as the binding context
 * to resolve bound properties or aggregations of the object itself and all of its children
 * relatively to the given path.
 * If a relative binding path is used, this will be applied whenever the parent context changes.
 * @param {string} sPath the binding path
 * @param {object} [mParameters] map of additional parameters for this binding
 *
 * @return {sap.ui.base.ManagedObject} reference to the instance itself
 * @public
 */
sap.ui.base.ManagedObject.prototype.bindElement = function(sPath, mParameters) {
	// if a model separator is found in the path, extract model name and path
	var boundElement = {}, 
		sModelName = undefined,
		iSeparatorPos = sPath.indexOf(">");
	
	boundElement.sBindingPath = sPath;
	boundElement.mBindingParameters = mParameters;
	if (iSeparatorPos > 0) {
		sModelName = sPath.substr(0, iSeparatorPos);
		boundElement.sBindingPath = sPath.substr(iSeparatorPos + 1);
	} 
	//this.sBindingPath = sPath;
	//this.mBindingParameters = mParameters;
	this.mBoundElements[sModelName] = boundElement;
	this.updateBindingContext(false, false, sModelName);
	return this;
};

/**
 * Deprecated, please use bindElement instead.
 * @deprecated
 * @param {string} sPath the binding path
 * @return {sap.ui.base.ManagedObject} reference to the instance itself
 * @public
 */
sap.ui.base.ManagedObject.prototype.bindContext = function(sPath) {
	this.bindElement(sPath);
	return this;
};

/**
 * Removes the defined binding context of this object, all bindings will now resolve
 * relative to the parent context again.
 *
 * @return {sap.ui.base.ManagedObject} reference to the instance itself
 * @public
 */
sap.ui.base.ManagedObject.prototype.unbindContext = function(sModelName) {
	return this.unbindElement(sModelName);
};

/**
 * Removes the defined binding context of this object, all bindings will now resolve
 * relative to the parent context again.
 *
 * @return {sap.ui.base.ManagedObject} reference to the instance itself
 * @public
 */
sap.ui.base.ManagedObject.prototype.unbindElement = function(sModelName) {
	this.mBoundElements[sModelName].sBindingPath = null;
	this.mBoundElements[sModelName].mBindingParameters = null;
	delete this.oBindingContexts[sModelName];
	this.updateBindingContext(false, false, sModelName);
	return this;
};

/**
 * Bind a property to the model.
 * The Setter for the given property will be called with the value retrieved
 * from the data model.
 * This is a generic method which can be used to bind any property to the
 * model. A managed object may flag properties in the metamodel with
 * bindable="bindable" to get typed bind methods for a property.
 *
 * @param {string} sName the name of the property
 * @param {object} oBindingInfo the binding information
 * @param {string} oBindingInfo.path the binding path
 * @param {string} [oBindingInfo.model] the model identifier
 * @param {function} [oBindingInfo.formatter] the formatter function or sap.ui.model.Type
 * @param {boolean} [oBindingInfo.useRawValues] determines if the parameters in the formatter functions should be passed as raw values or not. In this case
 * 					the specified type for the binding is not used and the values are not formatted. Note: use this flag only when using multiple bindings.
 * 					If you use only one binding and want raw values then simply don't specify a type for that binding. 
 * @param {sap.ui.model.Type} [oBindingInfo.type] the sap.ui.model.Type for this binding
 * @param {sap.ui.model.BindingMode} [oBindingInfo.mode=Default] the binding mode to be used for this property binding (e.g. one way)
 * @param {object} [oBindingInfo.parameters] a map of parameters which is passed to the binding
 *
 * @return {sap.ui.base.ManagedObject} reference to the instance itself
 * @public
 */
sap.ui.base.ManagedObject.prototype.bindProperty = function(sName, oBindingInfo) {
	var sPath,
		oFormat,
		sMode,
		sModelName,
		fnFormatter,
		oType,
		iSeparatorPos,
		bAvailable = true,
		that = this,
		oMetadata = this.getMetadata(),
		oProperty = oMetadata.getAllProperties()[sName],
		oKeyInfo = oMetadata.getJSONKeys()[sName];

	// check whether property or alternative type on aggregation exists
	if (!oProperty && !oKeyInfo.altTypes) {
		throw new Error("Property \"" + sName + "\" does not exist in " + this);
	}

	// old API compatbility (sName, sPath, oFormat, sMode)
	if (typeof oBindingInfo == "string") {
		sPath = arguments[1];
		oFormat = arguments[2];
		sMode = arguments[3];

		// find out whether formatter or type has been provided
		if (typeof oFormat == "function") {
			fnFormatter = oFormat;
		}
		else if (oFormat instanceof sap.ui.model.Type) {
			oType = oFormat;
		}
		oBindingInfo = {formatter: fnFormatter, parts : [ {path: sPath, type: oType, mode: sMode} ]};
	}
	
	// only one binding object with one binding specified
	if (!oBindingInfo.parts) {
		oBindingInfo.parts = [];
		oBindingInfo.parts[0] = {path: oBindingInfo.path, type: oBindingInfo.type, model: oBindingInfo.model, mode: oBindingInfo.mode};
		delete oBindingInfo.path;
		delete oBindingInfo.mode;
		delete oBindingInfo.model;
	}
	
	jQuery.each(oBindingInfo.parts, function(i, oPart) {
		if (typeof oPart == "string") {
			oPart = { path: oPart };
			oBindingInfo.parts[i] = oPart;
		}
		// if a model separator is found in the path, extract model name and path
		iSeparatorPos = oPart.path.indexOf(">");
		if (iSeparatorPos > 0) {
			oPart.model = oPart.path.substr(0, iSeparatorPos);
			oPart.path = oPart.path.substr(iSeparatorPos + 1);
		}
		// if we have multiple bindings the binding mode can be one way only
		if (oBindingInfo.parts.length > 1) {
			oPart.mode = sap.ui.model.BindingMode.OneWay;
		}
		
		if (!that.getModel(oPart.model)) {
			bAvailable = false;
		}
		
	});
	
	// if property is already bound, unbind it first
	if (this.isBound(sName)){
		this.unbindProperty(sName);
	}

	// store binding info to create the binding, as soon as the model is available, or when the model is changed
	this.mBindingInfos[sName] = oBindingInfo;

	// if the models are already available, create the binding
	if (bAvailable) {
		this._bindProperty(sName, oBindingInfo);
	}
	return this;
};

sap.ui.base.ManagedObject.prototype._bindProperty = function(sName, oBindingInfo) {
	var oModel,
	oContext,
	oBinding,
	oPropertyInfo = this.getMetadata().getJSONKeys()[sName], // TODO fix handling of hidden entitites?
	that = this,
	aBindings = [],
	fModelChangeHandler = function() {
		try {			
			var oValue = oBinding.getExternalValue();
			oBindingInfo.skipModelUpdate = true;
			that[oPropertyInfo._sMutator](oValue);
			oBindingInfo.skipModelUpdate = false;
		}catch (oException) {
			if (oException instanceof sap.ui.model.FormatException) {
					sap.ui.getCore().fireFormatError({element : that, property : sName, type : oBinding.getType(), newValue : oBinding.getValue(), oldValue : that.getProperty(sName), exception: oException});
			}else {
				throw oException;
			}
		}
	};

	// Only use context for bindings on the primary model
	oContext = this.getBindingContext(oBindingInfo.model);
	
	jQuery.each(oBindingInfo.parts, function(i, oPart) {
		// Only use context for bindings on the primary model
		oContext = that.getBindingContext(oPart.model);
		// Create binding object
		oModel = that.getModel(oPart.model);
		
		oBinding = oModel.bindProperty(oPart.path, oContext, oBindingInfo.parameters);
		oBinding.setType(oPart.type, oPropertyInfo.type);
		
		// TODO check if multiple bindings work with resource model 
		if (!oPart.mode || !oModel.isBindingModeSupported(oPart.mode)) {
			oPart.mode = oModel.getDefaultBindingMode();
		}
		
		aBindings.push(oBinding);
	});

	// check if we have a composite binding
	if (aBindings.length > 1){
		oBinding = new sap.ui.model.CompositeBinding(aBindings, oBindingInfo.useRawValues);
		oBinding.setType(oBindingInfo.type, oPropertyInfo.type);
	} else {
		oBinding = aBindings[0];
	}
	
	// Attach to the change event of the binding and initialize value
	// all composite bindings have already one way mode, so only check the first binding for its mode. 
	// Because if no composite binding is used there is only one binding.
	if (oBindingInfo.parts[0].mode != sap.ui.model.BindingMode.OneTime) {
		oBinding.attachChange(fModelChangeHandler);
	}
	
	// set only one formatter function if any
    // because the formatter gets the context of the element we have to set the context via proxy to ensure compatibility 
	// for formatter function which is now called by the property binding
	// proxy formatter here because "this" is the correct cloned object
	oBinding.setFormatter(jQuery.proxy(oBindingInfo.formatter, this));  
	
	// Set additional information on the binding info
	oBindingInfo.skipModelUpdate = false;
	oBindingInfo.binding = oBinding;
	oBindingInfo.modelChangeHandler = fModelChangeHandler;

	fModelChangeHandler();
};

/**
 * Unbind the property from the model
 *
 * @param {String} sName the name of the property
 * @return {sap.ui.base.ManagedObject} reference to the instance itself
 * @public
 */
sap.ui.base.ManagedObject.prototype.unbindProperty = function(sName){
	var oBindingInfo = this.mBindingInfos[sName];
	if(oBindingInfo) {
		if (oBindingInfo.binding) {
			oBindingInfo.binding.detachChange(oBindingInfo.modelChangeHandler);
		}
		delete this.mBindingInfos[sName];
	}
	return this;
};

/**
 * Update the property in the model if two way data binding mode is enabled
 *
 * @param sName the name of the property to update
 * @param oValue the new value to set for the property in the model
 * @private
 */
sap.ui.base.ManagedObject.prototype.updateModelProperty = function(sName, oValue, oOldValue){
	if (this.isBound(sName)){
		var oBindingInfo = this.mBindingInfos[sName],
			oBinding = oBindingInfo.binding;
		// only one property binding should work with two way mode...composite binding does not work with two way binding 
		if (oBindingInfo.parts[0].mode == sap.ui.model.BindingMode.TwoWay
				&& oBinding
				&& !oBindingInfo.skipModelUpdate) {
			try {
				oBinding.setExternalValue(oValue);
				sap.ui.getCore().fireValidationSuccess({element : this, property : sName, type : oBinding.getType(), newValue : oValue, oldValue : oOldValue});
			}
			catch (oException) {
				if (oException instanceof sap.ui.model.ParseException) {
					sap.ui.getCore().fireParseError({element : this, property : sName, type : oBinding.getType(), newValue : oValue, oldValue : oOldValue, exception: oException});
				}else if (oException instanceof sap.ui.model.ValidateException) {
					sap.ui.getCore().fireValidationError({element : this, property : sName, type : oBinding.getType(), newValue : oValue, oldValue : oOldValue, exception: oException});
				}
				else {
					throw oException;
				}
			}
		}
	}
};

/**
 * Bind an aggregation to the model.
 * The bound aggregation will use the given template, clone it for each item
 * which exists in the bound list and set the appropriate binding context.
 * This is a generic method which can be used to bind any aggregation to the
 * model. A managed object may flag aggregations in the metamodel with
 * bindable="bindable" to get typed bind methods for an aggregation.
 *
 * @param {string} sName the aggregation to bind
 * @param {object} oBindingInfo the binding info
 * @param {string} oBindingInfo.path the binding path
 * @param {sap.ui.base.ManagedObject} oBindingInfo.template the template
 * @param {function} oBindingInfo.factory the factory function
 * @param {sap.ui.model.Sorter} [oBindingInfo.oSorter] the initial sort order (optional)
 * @param {array} [oBindingInfo.filters] the predefined filters (sap.ui.model.Filter) for this aggregation (optional)
 * @param {object} [oBindingInfo.parameters] a map of parameters which is passed to the binding
 *
 * @return {sap.ui.base.ManagedObject} reference to the instance itself
 * @public
 */
sap.ui.base.ManagedObject.prototype.bindAggregation = function(sName, oBindingInfo) {
	var sPath,
		oTemplate,
		oSorter,
		aFilters,
		oMetadata = this.getMetadata(),
		oAggregation = oMetadata.getAllAggregations()[sName];

	// check whether aggregation exists
	if (!oAggregation) {
		throw new Error("Aggregation \"" + sName + "\" does not exist in " + this);
	}
	
	// Old API compatibility (sName, sPath, oTemplate, oSorter, aFilters)
	if (typeof oBindingInfo == "string") {
		sPath = arguments[1];
		oTemplate = arguments[2];
		oSorter = arguments[3];
		aFilters = arguments[4];
		oBindingInfo = {path: sPath, sorter: oSorter, filters: aFilters};
		// allow either to pass the template or the factory function as 3rd parameter
		if (oTemplate instanceof sap.ui.base.ManagedObject) {
			oBindingInfo.template = oTemplate;
		} else if (typeof oTemplate === "function") {
			oBindingInfo.factory = oTemplate;
		}
	}
	
	// if aggregation is already bound, unbind it first
	if (this.isBound(sName)){
		this.unbindAggregation(sName);
	}
	
	// check whether a template has been provided, which is required for proper processing of the binding
	if (!(oBindingInfo.template || oBindingInfo.factory)) {
		throw new Error("Missing template or factory function for aggregation " + sName + " of managed object id " + this.getId() + " !");
	}
	
	// if we have a template we will create a factory function
	if (oBindingInfo.template) {
		oBindingInfo.factory = function(sId) {
			return oBindingInfo.template.clone(sId);
		} 
	}
	
	// if a model separator is found in the path, extract model name and path
	var iSeparatorPos = oBindingInfo.path.indexOf(">");
	if (iSeparatorPos > 0) {
		oBindingInfo.model = oBindingInfo.path.substr(0, iSeparatorPos);
		oBindingInfo.path = oBindingInfo.path.substr(iSeparatorPos + 1);
	}
	
	// store binding info to create the binding, as soon as the model is available, or when the model is changed
	this.mBindingInfos[sName] = oBindingInfo;

	// if the model is already available create the binding
	if (this.getModel(oBindingInfo.model)) {
		this._bindAggregation(sName, oBindingInfo);
	}
	return this;
};

sap.ui.base.ManagedObject.prototype._bindAggregation = function(sName, oBindingInfo) {
	var that = this,
		oBinding,
		fModelChangeHandler = function(oEvent){
			var sUpdater = "update" + sName.substr(0,1).toUpperCase() + sName.substr(1);
			if (that[sUpdater]) {
				that[sUpdater]();
			} else {
				that.updateAggregation(sName);
			}
		};
		if (this.isTreeBinding(sName)) {
			oBinding = this.getModel(oBindingInfo.model).bindTree(oBindingInfo.path, this.getBindingContext(oBindingInfo.model), oBindingInfo.filters, oBindingInfo.parameters);		
		} else {
			oBinding = this.getModel(oBindingInfo.model).bindList(oBindingInfo.path, this.getBindingContext(oBindingInfo.model), oBindingInfo.sorter, oBindingInfo.filters, oBindingInfo.parameters);
		}

	oBindingInfo.binding = oBinding;
	oBindingInfo.modelChangeHandler = fModelChangeHandler;

	oBinding.attachChange(fModelChangeHandler);
	fModelChangeHandler();
};

/**
 * Unbind the aggregation from the model
 *
 * @param {String} sName the name of the aggregation
 * @return {sap.ui.base.ManagedObject} reference to the instance itself
 * @public
 */
sap.ui.base.ManagedObject.prototype.unbindAggregation = function(sName){
	var oBindingInfo = this.mBindingInfos[sName];
	if(oBindingInfo) {
		if (oBindingInfo.binding) {
			oBindingInfo.binding.detachChange(oBindingInfo.modelChangeHandler);
		}
		delete this.mBindingInfos[sName];
	}
	return this;
};

/**
 *  This method is used internally and should only be overridden by a tree managed object which utilizes the tree binding.
 *  In this case and if the aggregation is a tree node the overridden method should then return true.
 *  If true is returned the tree binding will be used instead of the list binding.
 *
 *  @param {string} sName the aggregation to bind (e.g. nodes for a tree managed object)
 *  @return {boolean} whether tree binding should be used or list binding. Default is false. Override method to change this behavior.
 *
 *  @protected
 */
sap.ui.base.ManagedObject.prototype.isTreeBinding = function(sName) {
	return false;
};

/**
 * Create or update local bindings.
 * 
 * Called when model or binding contexts have changed. Creates bindings when the model was not available 
 * at the time bindProperty or bindAggregation was called. Recreates the bindings when they exist already 
 * and when the model has changed.
 *
 * @param {boolean} bUpdateAll forces an update of all bindings, sModelName will be ignored
 * @param {string|undefined} sModelName name of a model whose bindings should be updated
 * @param {boolean} bRecreate whether to recreate the bindings 
 * 
 * TODO better understand and explain bRecreate flag
 * @private
 */
sap.ui.base.ManagedObject.prototype.updateBindings = function(bUpdateAll, sModelName, bRecreate) {
	var that = this,
		bUpdateRequired, bIsSameModelName, bIsSameModelInstance;
		
	// create property and aggregation bindings if they don't exist yet
	jQuery.each(this.mBindingInfos, function(sName, oBindingInfo) {
		bUpdateRequired = that._updateRequired(oBindingInfo);
		bIsSameModelInstance = oBindingInfo.binding && oBindingInfo.binding.updateRequired(that.getModel(sModelName));
				
		if (bUpdateAll || !oBindingInfo.binding || !bIsSameModelInstance) {
			if ( bRecreate && oBindingInfo.binding ) {
				oBindingInfo.binding.detachChange(oBindingInfo.modelChangeHandler);
				delete oBindingInfo.binding;
			}
			if (!oBindingInfo.binding) {
				if (bUpdateRequired) {
					if (oBindingInfo.factory) {
						that._bindAggregation(sName, oBindingInfo);
					} else {
						that._bindProperty(sName, oBindingInfo);
					}
				} 
			}
		}
	});
};

sap.ui.base.ManagedObject.prototype._updateRequired = function(oBindingInfo) {
	var bUpdateRequired = true,
		that = this;
	if (oBindingInfo.parts && oBindingInfo.parts.length > 1) {
		jQuery.each(oBindingInfo.parts, function(i, oPart) {
			bUpdateRequired = bUpdateRequired && that.getModel(oPart.model);
		});
	
	} else if (oBindingInfo.factory) { // List binding check
		bUpdateRequired = !!this.getModel(oBindingInfo.model); // Listbinding works only with default model
	} else {			// should be property binding now
		bUpdateRequired = !!this.getModel(oBindingInfo.parts[0].model); 
	}
	return bUpdateRequired;

};

/**
 * Generic method which is called, whenever an aggregation binding is changed.
 * This method deletes all elements in this aggregation and recreates them
 * according to the data model.
 * In case a managed object needs special handling for a aggregation binding, it can create
 * a typed update-method (e.g. "updateRows") which will be used instead of the
 * default behaviour.
 *
 * @private
 */
sap.ui.base.ManagedObject.prototype.updateAggregation = function(sName) {
	var oBindingInfo = this.mBindingInfos[sName],
		oBinding = oBindingInfo.binding,
		fnFactory = oBindingInfo.factory,
		oAggregationInfo = this.getMetadata().getJSONKeys()[sName],  // TODO fix handling of hidden aggregations
		oClone,
		that = this;
	this[oAggregationInfo._sDestructor]();
	if (this.isTreeBinding(sName)) {
		var iNodeIndex = 0,
			update = function(aContexts, fnFactory, oBinding, oParent){
			jQuery.each(aContexts, function(iIndex, oContext) {
				var sId = that.getId() + "-" + iNodeIndex++;
				oClone = fnFactory(sId, oContext);
				oClone.setBindingContext(oContext, oBindingInfo.model);
				oParent[oAggregationInfo._sMutator](oClone); // also sets the Parent
				update(oBinding.getNodeContexts(oContext), fnFactory, oBinding, oClone);
			});
		};
		update(oBinding.getRootContexts(), fnFactory, oBinding, this);
	} 
	else {
		jQuery.each(oBinding.getContexts(), function(iIndex, oContext) {
			var sId = that.getId() + "-" + iIndex;
			oClone = fnFactory(sId, oContext);
			oClone.setBindingContext(oContext, oBindingInfo.model);
			that[oAggregationInfo._sMutator](oClone);
		});
	}
};

/**
 * Find out whether a property or aggregation is bound
 *
 * @param {String} sName the name of the property or aggregation
 * @return {boolean} whether a binding exists for the given name
 * @public
 */
sap.ui.base.ManagedObject.prototype.isBound = function(sName){
	return (sName in this.mBindingInfos);
};

/**
 * Get the binding object for a specific aggregation/property
 *
 * @param {String} sName the name of the property or aggregation
 * @return {Binding} the binding for the given name
 * @public
 */
sap.ui.base.ManagedObject.prototype.getBinding = function(sName){
	return this.mBindingInfos[sName] && this.mBindingInfos[sName].binding;
};

/**
 * Get the binding path for a specific aggregation/property
 *
 * @param {String} sName the name of the property or aggregation
 * @return {String} the binding path for the given name
 * @protected
 */
sap.ui.base.ManagedObject.prototype.getBindingPath = function(sName){
	return this.mBindingInfos[sName] && this.mBindingInfos[sName].path;
};

/**
 * Set the binding context for this ManagedObject.
 *
 * @param {Object} oContext the new binding context for this object
 *
 * @return {sap.ui.base.ManagedObject} reference to the instance itself
 * @public
 */
sap.ui.base.ManagedObject.prototype.setBindingContext = function(oContext, sModelName){
	this.oBindingContexts[sModelName] = oContext;
	this.updateBindingContext(true, true, sModelName);
	this.propagateProperties(true);
	return this;
};

/**
 * Update the binding context in this object and all aggregated children
 * @private
 */
sap.ui.base.ManagedObject.prototype.updateBindingContext = function(bSkipLocal, bSkipChildren, sModelName, bUpdateAll){

	var oModel,
		oModelNames= {},
		oParentContext, 
		that = this;
	
	// find models that need an context update
	if (bUpdateAll) {
		for(sModelName in this.oModels) {
			if ( this.oModels.hasOwnProperty(sModelName) ){
				oModelNames[sModelName] = sModelName;
			}
		}
		for(sModelName in this.oPropagatedProperties.oModels) {
			if ( this.oPropagatedProperties.oModels.hasOwnProperty(sModelName) ){
				oModelNames[sModelName] = sModelName;
			}
		}
	} else {
		oModelNames[sModelName] = sModelName;
	}

	for(sModelName in oModelNames ) {
		if ( oModelNames.hasOwnProperty(sModelName) ){
			oModel = this.getModel(sModelName);

			if (this.mBoundElements[sModelName] && this.mBoundElements[sModelName].sBindingPath && !bSkipLocal) {
				if (this.oParent && oModel == this.oParent.getModel(sModelName)) {
					oParentContext= this.oParent.getBindingContext(sModelName); 
				}
				if (oModel) {
					oModel.createBindingContext(this.mBoundElements[sModelName].sBindingPath, oParentContext, this.mBoundElements[sModelName].mBindingParameters, function(oContext) {
						that.setBindingContext(oContext, sModelName);
						that.updateBindingContext(true, bSkipChildren, sModelName);
					});
				} else {
					this.oBindingContexts[sModelName] = undefined;
				}
				return;
			}

			var oContext = this.getBindingContext(sModelName);

			// update context in existing bindings, but only for the primary model
			jQuery.each(this.mBindingInfos, function(sName, oBindingInfo) {
				var oBinding = oBindingInfo.binding;
				if (oBinding && oBinding.updateRequired(oModel)) {
					oBinding.setContext(oContext);
				}
			});
			if (!bSkipChildren) {
				// also update context in all child elements
				jQuery.each(this.mAggregations, function(sName, oAggregation) {
					if (oAggregation instanceof sap.ui.base.ManagedObject) {
						oAggregation.oPropagatedProperties.oBindingContexts[sModelName] = oContext;
						oAggregation.updateBindingContext(false,false,sModelName);
					} else if (oAggregation instanceof Array) {
						for (var i = 0; i < oAggregation.length; i++) {
							oAggregation[i].oPropagatedProperties.oBindingContexts[sModelName] = oContext;
							oAggregation[i].updateBindingContext(false,false,sModelName);
						}
					}
				});
			}
		}
	}
};


/**
 * Get the binding context of this object
 * If the object does not have a binding context set on itself and has no own Model set, 
 * it will use the first binding context defined in its parent hierarchy.
 *
 * @return {Object} the binding context of this object
 * @public
 */
sap.ui.base.ManagedObject.prototype.getBindingContext = function(sModelName){
	var oModel = this.getModel(sModelName);
	
	if (this.oBindingContexts[sModelName]) {
		return this.oBindingContexts[sModelName];
	} else if (oModel && this.oParent && this.oParent.getModel(sModelName) && oModel != this.oParent.getModel(sModelName)) {
		return undefined;
	} else {
		return this.oPropagatedProperties.oBindingContexts[sModelName];
	}
};

/**
 * Set the model for databinding
 * @param {sap.ui.model.Model} oModel
 * @param {string} [sName]
 * @return {sap.ui.base.ManagedObject} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.base.ManagedObject.prototype.setModel = function(oModel, sName) {
	if (!oModel && this.oModels[sName]) {
		delete this.oModels[sName];
		// propagate Models to children
		this.propagateProperties(sName);
		// if the model instance for a name changes, all bindings for that model name have to be updated
		this.updateBindings(false, sName, true);
	} else if ( oModel !== this.oModels[sName] ) { 
		//TODO: handle null!
		this.oModels[sName] = oModel;
		// propagate Models to children
		this.propagateProperties(sName);
		// update binding context, for primary model only
		if (!sName){this.updateBindingContext(false, true, sName);}
		// if the model instance for a name changes, all bindings for that model name have to be updated
		this.updateBindings(false, sName, true);
	} else {
		// nothing to do
	} 
	return this;
};

/**
 * Propagate Properties (models and bindingContext) to aggregated objects.
 * @param {string|undefined|true} sName when <code>true</code>, all bindings are updated.
 *           Otherwise only those for the given model name (undefined == name of default model)
 * 
 * @private
 */
sap.ui.base.ManagedObject.prototype.propagateProperties = function(vName) {
	var oProperties = this._getPropertiesToPropagate(),
		bUpdateAll = vName === true, // update all bindings when no model name parameter has been specified
		sName = bUpdateAll ? undefined : vName;
	jQuery.each(this.mAggregations, function(sAggregationName, oAggregation) {
		if (oAggregation instanceof sap.ui.base.ManagedObject) {
			oAggregation.oPropagatedProperties = oProperties;
			oAggregation.updateBindings(bUpdateAll,sName,true);
			oAggregation.updateBindingContext(false, true, sName, bUpdateAll);
			oAggregation.propagateProperties(vName);
		} else if (oAggregation instanceof Array) {
			for (var i = 0; i < oAggregation.length; i++) {
				if (oAggregation[i] instanceof sap.ui.base.ManagedObject) {
					oAggregation[i].oPropagatedProperties = oProperties;
					oAggregation[i].updateBindings(bUpdateAll,sName,true);
					oAggregation[i].updateBindingContext(false, true, sName, bUpdateAll);
					oAggregation[i].propagateProperties(vName);
				}
			}
		}
	});
}

/**
 * Get properties for propagation
 * @return {object} oProperties
 * @private
 */
sap.ui.base.ManagedObject.prototype._getPropertiesToPropagate = function() {
	var oProperties,
		bHasOwnModels = !jQuery.isEmptyObject(this.oModels),
		bHasOwnContexts = !jQuery.isEmptyObject(this.oBindingContexts);

	if (this.oBindingContexts || bHasOwnModels) {
		//create new properties object
		oProperties = {};
		if (bHasOwnModels) {
			oProperties.oModels = {};
			jQuery.extend(oProperties.oModels,this.oPropagatedProperties.oModels);
			jQuery.each(this.oModels, function(sName, oModel) {
				oProperties.oModels[sName] = oModel;
			});
		}
		else {
			oProperties.oModels = this.oPropagatedProperties.oModels;
		}
		if (bHasOwnContexts) {
			oProperties.oBindingContexts = {};
			jQuery.extend(oProperties.oBindingContexts,this.oPropagatedProperties.oBindingContexts);
			jQuery.each(this.oBindingContexts, function(sName, oBindingContext) {
				oProperties.oBindingContexts[sName] = oBindingContext;
			});
		} else {
			oProperties.oBindingContexts = this.oPropagatedProperties.oBindingContexts;
		}
	} else {
		//propagate the existing container
		oProperties = this.oPropagatedProperties;
	}
	return oProperties;
};

/**
 * Get the model to be used for data bindings with the given model name.
 * If the object does not have a model set on itself, it will use the first 
 * model defined in its parent hierarchy.
 * 
 * The name can be omitted to reference the default model or it must be a non-empty string.
 * 
 * @param {string|null|undefined} [sName] name of the model to be retrieved
 * @return {sap.ui.model.Model} oModel
 * @public
 */
sap.ui.base.ManagedObject.prototype.getModel = function(sName) {
	return this.oModels[sName] || this.oPropagatedProperties.oModels[sName];
};

/**
 * Check if any Model is set to the ManagedObject or to one of its parents (including UIArea and Core)
 * @return {boolean} true or false
 * @public
 */
sap.ui.base.ManagedObject.prototype.hasModel = function() {
	return !(jQuery.isEmptyObject(this.oModels) && jQuery.isEmptyObject(this.oPropagatedProperties.oModels));
};

/**
 * Clones a tree of objects starting with the object on which clone is called first (root object).
 * 
 * The ids within the newly created clone tree are derived from the original ids by appending
 * the given <code>sIdSuffix</code> (if no suffix is given, one will be created; it will be 
 * unique across multiple clone calls).
 *  
 * The <code>oOptions</code> configuration object can have the following properties:
 * <ul>
 * <li>The boolean value <code>cloneChildren</code> specifies wether associations/aggregations will be cloned</li>
 * <li>The boolean value <code>cloneBindings</code> specifies if bindings will be cloned</li>
 * </ul>
 * 
 * For each cloned object the following settings are cloned based on the metadata of the object and the defined options:
 * <ul>
 * <li>all properties that are not bound. If cloneBinding is false even these properties will be cloned; 
 * the values are used by reference, they are not cloned</li>
 * <li>all aggregated objects that are not bound. If cloneBinding is false even the ones that are bound will be cloned;
 * they are all cloned recursively using the same <code>sIdSuffix</code></li>
 * <li>all associated controls; when an association points to an object inside the cloned object tree,
 *     then the cloned association will be modified to that it points to the clone of the target object.
 *     When the association points to a managed object outside of the cloned object tree, then its 
 *     target won't be changed.</li>  
 * <li>all models set via setModel(); used by reference </li>
 * <li>all property and aggregation bindings (if cloneBindings is true); the pure binding infos (path, model name) are 
 *     cloned, but all other information like template control or factory function, 
 *     data type or formatter function are copied by reference. The bindings themselves 
 *     are created anew as they are specific for the combination (object, property, model).
 *     As a result, any later changes to a binding of the original object are not reflected 
 *     in the clone, but changes to e.g the type or template etc. are.</li> 
 * </ul>
 *
 * Each clone is created by first collecting the above mentioned settings and then creating 
 * a new instance with the normal constructor function. As a result, any side effects of 
 * mutator methods (setProperty etc.) or init hooks are repeated during clone creation. 
 * There is no need to override <code>clone()</code> just to reproduce these internal settings!
 * 
 * Custom controls however can override <code>clone()</code> to implement additional clone steps. 
 * They usually will first call <code>clone()</code> on the super class and then modify the   
 * returned clone accordingly.  
 * 
 * Applications <b>must never provide</b> the second parameter <code>aLocaleIds</code>. 
 * It is determined automatically for the root object (and its non-existance also serves as 
 * an indicator for the root object). Specifying it will break the implementation of <code>clone()</code>. 
 * 
 * @param {String} [sIdSuffix] a suffix to be appended to the cloned object id
 * @param {Array} [aLocalIds] an array of local IDs within the cloned hierarchy (internally used)
 * @param {Object} [oOptions] configuration object 
 * @return {sap.ui.base.ManagedObject} reference to the newly created clone
 * @protected
 */
sap.ui.base.ManagedObject.prototype.clone = function(sIdSuffix, aLocalIds, oOptions) {
	var that = this,
		bCloneChildren = true, 
		bCloneBindings = true;
	
	if (oOptions) {
		bCloneChildren = !!oOptions.cloneChildren;
		bCloneBindings = !!oOptions.cloneBindings;
	}
	// if no id suffix has been provided use a generated UID
	if (!sIdSuffix) {
		sIdSuffix = sap.ui.base.ManagedObjectMetadata.uid("clone") || jQuery.sap.uid();
	}
	// if no local ID array has been passed, collect IDs of all aggregated objects to
	// be able to properly adapt associations, which are within the cloned object hierarchy
	if (!aLocalIds && bCloneChildren) {
		aLocalIds = jQuery.map(this.findAggregatedObjects(true), function(oObject) {return oObject.getId();});
	}

	var oMetadata = this.getMetadata(),
		oClass = oMetadata._oClass,
		sId = this.getId() + "-" + sIdSuffix,
		mSettings = {},
		mProps = this.mProperties,
		sKey,
		oClone;
	
	// Clone properties (only those with non-default value)
	for(sKey in mProps) {
		//do not clone properties if property is bound and bindings are cloned; Property is set on update
		if ( mProps.hasOwnProperty(sKey) && !(this.isBound(sKey) && bCloneBindings)){
			mSettings[sKey] = mProps[sKey];
		}
	}
	
	// Clone models		
	mSettings["models"] = this.oModels;		
	
	// Clone BindingContext
	mSettings["bindingContexts"] = this.oBindingContext;

	if(bCloneChildren) {
		// Clone aggregations
		jQuery.each(this.mAggregations, function(sName, oAggregation) {
			//do not clone aggregation if aggregation is bound and bindings are cloned; aggregation is filled on update
			if (oMetadata.hasAggregation(sName) && !(that.isBound(sName) && bCloneBindings)) {
				if (oAggregation instanceof sap.ui.base.ManagedObject) {
					mSettings[sName] = oAggregation.clone(sIdSuffix, aLocalIds);
				} else if (jQuery.isArray(oAggregation)) {
					mSettings[sName] = [];
					for (var i = 0; i < oAggregation.length; i++) {
						mSettings[sName].push(oAggregation[i].clone(sIdSuffix, aLocalIds));
					}
				} else {
					// must be an alt type
					mSettings[sName] = oAggregation;
				}
			}
		});

		// Clone associations
		jQuery.each(this.mAssociations, function(sName, oAssociation) {
			// Check every associated ID against the ID array, to make sure associations within
			// the template are properly converted to associations within the clone
			if (jQuery.isArray(oAssociation)) {
				oAssociation = oAssociation.slice(0);
				for (var i = 0; i < oAssociation.length; i++) {
					if (jQuery.inArray(oAssociation[i], aLocalIds) >= 0) {
						oAssociation[i] += "-" + sIdSuffix;
					}
				}
			} else if (jQuery.inArray(oAssociation, aLocalIds) >= 0) {
				oAssociation += "-" + sIdSuffix;
			}
			mSettings[sName] = oAssociation;
		});
	}
	// Create clone instance
	oClone = new oClass(sId, mSettings);
	
	// Clone events
	jQuery.each(this.mEventRegistry, function(sName, aListeners) {
		oClone.mEventRegistry[sName] = aListeners.slice();
	});
	
	// Clone bindings
	if (bCloneBindings) {
		jQuery.each(this.mBindingInfos, function(sName, oBindingInfo) {
			var oCloneBindingInfo = jQuery.extend({}, oBindingInfo);
			delete oCloneBindingInfo.binding; // remove the runtime binding info (otherwise the property will not be connected again!)
			if (oBindingInfo.factory) {
				oClone.bindAggregation(sName, oCloneBindingInfo);
			} else {
				oClone.bindProperty(sName, oCloneBindingInfo);
			}
		});
	}
	return oClone;
};

/**
 * Maps the given aggregation with name <code>sOldAggrName</code>
 * on aggregation <code>sNewAggrName</code> (When calling an accessor function
 * of the old aggregation the call is forwarded to the corresponding accessor
 * function of the new aggregation).
 *
 * This function should help to perform a smooth transition for users of a managed object
 * when an aggregation must be renamed.
 *
 * Both aggregations must have a mutiple cardinality (0..n) and must have the same
 * aggregated type!
 *
 * @param {object} oPrototype prototype of the ManagedObject class for which a mapping should be defined
 * @param {string} sOldAggrName Name of the old deprecated aggregation
 * @param {string} sNewAggrName Name of the new aggregation
 * @deprecated
 */
sap.ui.base.ManagedObject._mapAggregation = function(oPrototype, sOldAggrName, sNewAggrName){
	var mKeys = oPrototype.getMetadata().getJSONKeys(); // TODO fix handling of hidden entitites?
	var oOldAggrInfo = mKeys[sOldAggrName];
	var oNewAggrInfo = mKeys[sNewAggrName];

	//Check whether aggregations exist and are multiple.
	if(!oOldAggrInfo || !oNewAggrInfo || oOldAggrInfo._iKind != 2 || oNewAggrInfo._iKind != 2) {
		return;
	}

	var mFunc = {"insert" : true, "add" : true, "remove" : true, "removeAll" : false, "indexOf" : true, "destroy" : false, "get" : false};

	function method(sPrefix, sName) {
		return sPrefix + sName.substring(0,1).toUpperCase() + sName.substring(1);
	}

	function fAggrDelegator(sFuncName){
		return function() {
			return this[sFuncName].apply(this, arguments);
		};
	}

	for(var sPrefix in mFunc){
		var sOldFuncName = method(sPrefix, mFunc[sPrefix] ? oOldAggrInfo.singularName : oOldAggrInfo._sName);
		var sNewFuncName = method(sPrefix, mFunc[sPrefix] ? oNewAggrInfo.singularName : oNewAggrInfo._sName);
		oPrototype[sOldFuncName] = fAggrDelegator(sNewFuncName);
	}
};

/**
 * Searches and returns an array of child elements and controls which are
 * referenced within an aggregation or aggregations of child elements/controls.
 * This can be either done recursive or not.
 * <br>
 * <b>Take care: this operation might be expensive.</b>
 * @param {boolean}
 *          bRecursive true, if all nested children should be returned.
 * @return {sap.ui.base.ManagedObject[]} array of child elements and controls
 * @public
 */
sap.ui.base.ManagedObject.prototype.findAggregatedObjects = function(bRecursive) {

	var aAggregatedObjects = [];
	function fFindObjects(oObject) {
		for (var n in oObject.mAggregations) {
			var a = oObject.mAggregations[n];
			if (jQuery.isArray(a)) {
				for (var i = 0; i < a.length; i++) {
					aAggregatedObjects.push(a[i]);
					if (bRecursive) {
						fFindObjects(a[i]);
					}
				}
			} else if (a instanceof sap.ui.base.ManagedObject) {
				aAggregatedObjects.push(a);
				if (bRecursive) {
					fFindObjects(a);
				}
			}
		}
	}
	fFindObjects(this);
	return aAggregatedObjects;

};

}; // end of sap.ui.base.ManagedObject

if ( !jQuery.sap.isDeclared('sap.ui.core.ElementMetadata') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.core.ElementMetadata
jQuery.sap.declare("sap.ui.core.ElementMetadata");


/**
 * Creates a new metadata object for a UIElement subclass.
 *
 * @param {string} sClassName fully qualified name of the class that is described by this metadata object
 * @param {object} oStaticInfo static info to construct the metadata from
 *
 * @class
 * @author SAP
 * @version 1.10.0
 * @since 0.8.6
 */
sap.ui.core.ElementMetadata = function(sClassName, oClassInfo) {

	// call super constructor
	sap.ui.base.ManagedObjectMetadata.apply(this, arguments);
};

//chain the prototypes
sap.ui.core.ElementMetadata.prototype = jQuery.sap.newObject(sap.ui.base.ManagedObjectMetadata.prototype);

/**
 * Calculates a new id based on a prefix.
 *
 * @return {string} A (hopefully unique) control id
 * @public
 * @function
 */
sap.ui.core.ElementMetadata.uid = sap.ui.base.ManagedObjectMetadata.uid;

/**
 * By default, the element name is equal to the class name
 * @return {string} the qualified name of the UIElement class
 * @public
 */
sap.ui.core.ElementMetadata.prototype.getElementName = function() {
	return this._sClassName;
};

/**
 * Determines the class name of the renderer for the described control class.
 */
sap.ui.core.ElementMetadata.prototype.getRendererName = function() {
	return this._sRendererName;
};

/**
 * Retrieves the renderer for the described control class
 */
sap.ui.core.ElementMetadata.prototype.getRenderer = function() {

	// determine name via function for those legacy controls that override getRendererName()
	var sRendererName = this.getRendererName();

	if ( !sRendererName ) {
		return;
	}

	// check if renderer class exists already
	var fnRendererClass = jQuery.sap.getObject(sRendererName);
	if(fnRendererClass) {
		return fnRendererClass;
	}

	// if not, try to load a module with the same name
	jQuery.sap.require(sRendererName);
	return jQuery.sap.getObject(sRendererName);
};

sap.ui.core.ElementMetadata.prototype.applySettings = function(oClassInfo) {

	var oStaticInfo = oClassInfo.metadata;

	// remove renderer stuff before calling super.
	var vRenderer = oClassInfo.hasOwnProperty("renderer") ? (oClassInfo.renderer || "") : undefined;
	delete oClassInfo.renderer;

	sap.ui.base.ManagedObjectMetadata.prototype.applySettings.call(this, oClassInfo);

	this._sRendererName = this.getName() + "Renderer";

	if ( typeof vRenderer !== "undefined" ) {

		if ( typeof vRenderer === "string" ) {
			this._sRendererName = vRenderer || undefined;
			return;
		}
		if ( typeof vRenderer === "function" ) {
			vRenderer = { render : vRenderer };
		}

		var oParent = this.getParent();
		var oBaseRenderer;
		if ( oParent && oParent instanceof sap.ui.core.ElementMetadata ) {
			oBaseRenderer = oParent.getRenderer();
		}
		if ( !oBaseRenderer ) {
			jQuery.sap.require("sap.ui.core.Renderer");
			oBaseRenderer = sap.ui.core.Renderer;
		}
		var oRenderer = jQuery.sap.newObject(oBaseRenderer);
		jQuery.extend(oRenderer, vRenderer);
		jQuery.sap.setObject(this.getRendererName(), oRenderer);
	}
};
}; // end of sap.ui.core.ElementMetadata



/**
 * Constructs and initializes an UI Element with the given <code>sId</code> and settings.
 *
 * If the optional <code>mSettings</code> are given, they must be a JSON-like object (object literal)
 * that defines values for properties, aggregations, associations or events keyed by their name.
 *
 * <b>Valid Names:</b>
 *
 * The property (key) names supported in the object literal are exactly the (case sensitive)
 * names documented in the JSDoc for the properties, aggregations, associations and events
 * of the control and its base classes. Note that for  0..n aggregations and associations this
 * usually is the plural name, whereas it is the singular name in case of 0..1 relations.
 *
 * If a key name is ambiguous for a specific control class (e.g. a property has the same
 * name as an event), then this method prefers property, aggregation, association and
 * event in that order. To resolve such ambiguities, the keys can be prefixed with
 * <code>aggregation:</code>, <code>association:</code> or <code>event:</code>.
 * In that case the keys must be quoted due to the ':'.
 *
 * Each subclass should document the set of supported names in its constructor documentation.
 *
 * <b>Valid Values:</b>
 *
 * <ul>
 * <li>for normal properties, the value has to be of the correct simple type (no type conversion occurs)
 * <li>for 0..1 aggregations, the value has to be an instance of the aggregated control or element type
 * <li>for 0..n aggregations, the value has to be an array of instances of the aggregated type
 * <li>for 0..1 associations, an instance of the associated type or an id (string) is accepted
 * <li>0..n associations are not supported yet
 * <li>for events either a function (event handler) is accepted or an array of length 2
 *     where the first element is a function and the 2nd element is an object to invoke the method on.
 * </ul>
 *
 * @param {string} [sId] id for the new control; generated automatically if no non-empty id is given
 *      Note: this can be omitted, no matter whether <code>mSettings</code> will be given or not!
 * @param {object} [mSettings] optional map/JSON-object with initial property values, aggregated objects etc. for the new element
 *
 * @class Base Class for Elements.
 * @extends sap.ui.base.ManagedObject
 * @author SAP
 * @version 1.10.0
 * @public
 * @name sap.ui.core.Element
 */
sap.ui.base.ManagedObject.extend("sap.ui.core.Element", {

	metadata : {
	  "abstract" : true,
	  publicMethods : [ "getId", "getMetadata", "getTooltip_AsString", "getTooltip_Text", "getModel", "setModel", "hasModel", "bindProperty", "unbindProperty", "bindAggregation", "unbindAggregation", "prop", "getLayoutData", "setLayoutData" ],
	  library : "sap.ui.core",
	  properties : {
		// TODO can't yet declare id as a property: would show up in ControlTree and applySettings would allow to modify id
		// id : {name : "id", type : "string", group : "Identification", defaultValue : '', readOnly : true}
	  },
	  aggregations : {
		tooltip : {name : "tooltip", type : "sap.ui.core.TooltipBase", altTypes : ["string"], multiple : false},
		customData : {name : "customData", type : "sap.ui.core.CustomData", multiple : true, singularName : "customData"},
		layoutData : {name : "layoutData", type : "sap.ui.core.LayoutData", multiple : false, singularName : "layoutData"}
	  },
	  associations : {},
	  events : {}
	},

	constructor : function(sId, mSettings) {

		sap.ui.base.ManagedObject.apply(this, arguments);
	},

	renderer : null // Element has no renderer

}, /* Metadata constructor */ sap.ui.core.ElementMetadata);

/**
 * Creates a new subclass of class sap.ui.core.Element with name <code>sClassName</code>
 * and enriches it with the information contained in <code>oClassInfo</code>.
 *
 * <code>oClassInfo</code> might contain the following:
 * <ul>
 * <li><code>metadata:</code> an (optional) object literal containing meta information about the class.
 * The information in the object literal will be wrapped by an instance of ElementMetadata
 * and might contain the following information:
 * <ul>
 * <li>all values accepted for metadata as documented for the {@link sap.ui.base.Object.extend Object.extend} method</li>
 * <li>library: {string} (optional) name of the library that contains the element/control
 * <li>properties: a map of property info objects, mapped by the property name
 *     Each info object should be a simple object literal and may contain the following information
 *     <ul>
 *     <li>type {string} optional type of the property, defaults to type "string"
 *     <li>[defaultValue] {any} default value of the property. When omitted, defaults to the default value for the type
 *     <li>group {string} optional semantic group of the property. Defaults to "Misc"
 *     </ul>
 *     If the property info object is not an object literal, it is assumed to be a string and
 *     interpreted as the type of the property. All other informations use their default values.
 * <li>aggregations: a map of aggregation info objects, mapped by the aggregation name
 *     By convention, the name should be a singular name for aggregations of cardinality 0..1 and
 *     should be a plural name for aggregations of cardinality 0..n.
 *
 *     The info object should contain the following information
 *     <ul>
 *     <li>type {string} (optional) type of the aggregated controls/elements, defaults to sap.ui.core.Control
 *     <li>altTypes {string[]} (optional) alternative primitive types that the aggregation can have (like string etc.). Defaults to no alternative types.
 *     <li>multiple {boolean} (optional) information about the cardinality, defaults to true (multiple aggregation)
 *     <li>singularName {string} (optional) singular name for 0..n aggregations. If not specified, a singular name is guessed from the plural name.
 *     </ul>
 *     If the aggregation info object is not an object literal, it is assumed to be a string and
 *     interpreted as the type of the aggregation. All other informations use their default values.
 * <li>associations: a map of association info objects, mapped by the association name
 *     By convention, the name should be a singular name for aggregations of cardinality 0..1 and
 *     should be a plural name for aggregations of cardinality 0..n.
 *
 *     The info object should contain the following information
 *     <ul>
 *     <li>type {string} type of the associated controls/elements, defaults to sap.ui.core.Control
 *     <li>multiple {boolean} (optional) information about the cardinality, defaults to false (single aggregation)
 *     <li>singularName {string} (optional) singular name for 0..n aggregations. If not specified, a singular name is guessed from the plural name.
 *     </ul>
 *     If the association info object is not an object literal, it is assumed to be a string and
 *     interpreted as the type of the aggregation. All other informations then use their default values.
 * <li>events: a map of event info objects, mapped by the event name
 *     The info object can contain the following information
 *     <ul>
 *     <li><code>allowPreventDefault:</code> {boolean} whether the control allows to prevent its default behavior for this event (defaults to false) </li>
 *     </ul>
 * </ul>
 * For all properties, aggregations, associations and events, the usual access methods are created and added to the public facade.
 * They don't need to be listed in the publicMethods array.
 * </li>
 *
 * <li><code>constructor:</code> a function that serves as a constructor function for the new element class.
 * If no constructor function is given, the framework creates a default implementation that delegates all
 * its arguments to the constructor function of the base class.
 * <b>Note:</b> most of the time, subclasses of Element don't need to specify their own constructor function.
 * They should use the symmetric {@link #init} and {@link #exit} hooks instead.
 * </li>
 *
 * <li><code>renderer:</code> definition of a renderer. This can be any of the following
 * <ul>
 * <li>the class name of a renderer class (a string)</li>
 * <li>a render function with signature <code>function(oRenderManager, oControl)</code> that implements the rendering for the new class</li>
 * <li>an object literal that contains functions/properties that should be mixed into a new render class which is
 * created as a subclass of the renderer of the current class.</li>
 * </ul>
 * <b>Note:</b> usually only controls have a renderer. But to keep the control creation APIs simple and to honor future
 * extensions of the current policy, the definition of a renderer is supported for direct subclasses of Element as well.
 * </li>
 *
 * <li><i>any-other-name:</i> any other property in the <code>oClassInfo</code> is copied into the prototype
 * object of the newly created class. Callers can thereby add methods or properties to all instances of the
 * class. But be aware that the given values are shared between all instances of the class. Usually, it doesn't
 * make sense to use primitive values here other than to declare public constants.
 *
 * All methods added this way and whose name is not 'init' nor 'exit' nor does it start with an underscore ('_')
 * nor with the prefix 'on' are assumed to be public methods and are automatically added to the list of public facade methods.
 * </ul>
 *
 * The prototype object of the newly created class uses the same prototype as instances of the base class
 * (prototype chaining).
 *
 * A metadata object is always created, even if there is no <code>metadata</code> entry in the <code>oClassInfo</code>
 * object. A getter for the metadata is always attached to the prototype and to the class (constructor function)
 * itself.
 *
 * Last but not least, with the third argument <code>FNMetaImpl</code> the constructor of a metadata class
 * can be specified. Instances of that class will be used to represent metadata for the newly created class
 * and for any subclass created from it. Typically, only frameworks will use this parameter to enrich the
 * metadata for a new class hierarchy they introduce (as done by  {@link sap.ui.core.Element Element}).
 *
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] structured object with informations about the class
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.core.Element.extend
 * @function
 * @since 1.3.1
 */

/**
 * Creates metadata for an UI Element by extending the Object Metadata.
 *
 * In addition to the entries defined by {@link sap.ui.base.Object.defineClass}, the following
 * entries can be specified in the static info object:
 *
 * <ul>
 * <li>library: {string} name of the library that contains the element/control
 * <li>properties: a map of property info objects, mapped by the property name
 *     Info object should contain the following information
 *     <ul>
 *     <li>name {string} name of the property (redundant to map key)
 *     <li>type {string} type of the property
 *     <li>[defaultValue] {any} default value of the property. Can be omitted
 *     </ul>
 * <li>aggregations: a map of aggregation info objects, mapped by the aggregation name
 *     Info object should contain the following information
 *     <ul>
 *     <li>name {string} name of the aggregation, singular for 0..1, plural for 0..n
 *     <li>type {string} type of the aggregated controls/elements
 *     <li>multiple {boolean}
 *     <li>singularName {string} singular name for 0..n aggregations
 *     </ul>
 * <li>associations: a map of association info objects, mapped by the association name
 *     Info object should contain the following information
 *     <ul>
 *     <li>name {string} name of the association, singular for 0..1, plural for 0..n
 *     <li>type {string} type of the associated controls/elements
 *     <li>multiple {boolean}
 *     <li>singularName {string} singular name for 0..n associations
 *     </ul>
 * <li>events: map from event names to event names
 * </ul>
 *
 * @see sap.ui.core.Object.defineClass
 *
 * @param {string} sClassName name of the class to build the metadata for
 * @param {object} oStaticInfo static information used to build the metadata
 * @param {function} [fnMetaImpl] constructor to be used for the metadata
 * @return {object} the created metadata
 * @static
 * @public
 * @deprecated Since 1.3.1. Use the static <code>extend</code> method of the desired base class (e.g. {@link sap.ui.core.Element.extend})
 */
sap.ui.core.Element.defineClass = function(sClassName, oStaticInfo, fnMetaImpl) {
	// create and attach metadata but with an Element specific implementation
	return sap.ui.base.Object.defineClass(sClassName, oStaticInfo, fnMetaImpl || sap.ui.core.ElementMetadata);
};

/**
 * Handles the given browser event.
 * @private
 */
sap.ui.core.Element.prototype._handleEvent = function (oEvent) {
	var sHandlerName = "on" + oEvent.type;
	this._callEventHandles(this.aBeforeDelegates, sHandlerName, oEvent, true);
	this._callEventHandles([this], sHandlerName, oEvent);
	this._callEventHandles(this.aDelegates, sHandlerName, oEvent, true);
};

/**
 * Calls event handler of the given event handles with the given browser event.
 * @private
 */
sap.ui.core.Element.prototype._callEventHandles = function (aHandles, sHandlerName, oEvent, bDelegateHolder) {
	if (aHandles.length > 0) {
		for (var i = 0; i < aHandles.length; i++) {
			if (oEvent.isImmediateHandlerPropagationStopped()) {
				break;
			}
			var oHandle = bDelegateHolder ? aHandles[i].oDelegate : aHandles[i];
			var oThis = (bDelegateHolder && aHandles[i].vThis) ? aHandles[i].vThis : oHandle;
			if (oThis === true) { // special case, means the control should be the context
				oThis = this;
			}
			if (oHandle[sHandlerName]) {
				oHandle[sHandlerName].call(oThis, oEvent);
			}
		}
	}
};


// Element is granted "friend" access by Core for (de-)registration
/**
 * Registers this instance of sap.ui.core.Element with the Core.
 *
 * The implementation of this method is provided with "friend" access by Core.
 * @see sap.ui.core.Core.constructor
 *
 * @function
 * @name sap.ui.core.Element.prototype.register
 * @private
 */
//sap.ui.core.Element.prototype.register = function() {...}

/**
 * Deregisters this instance of sap.ui.core.Element from the Core.
 *
 * The implementation of this method is provided with "friend" access by Core.
 * @see sap.ui.core.Core.constructor
 *
 * @function
 * @name sap.ui.core.Element.prototype.deregister
 * @private
 */
//sap.ui.core.Element.prototype.deregister = function() {...}

/**
 * Initializes the element instance after creation.
 *
 * Applications must not call this hook method directly, it is called by the framework
 * while the constructor of an element is executed.
 *
 * Subclasses of Element should override this hook to implement any necessary initialization.
 *
 * @function
 * @name sap.ui.core.Element.prototype.init
 * @protected
 */
//sap.ui.core.Element.prototype.init = function() {};

/**
 * Cleans up the element instance before destruction.
 *
 * Applications must not call this hook method directly, it is called by the framework
 * when the element is {@link #destroy destroyed}.
 *
 * Subclasses of Element should override this hook to implement any necessary cleanup.
 *
 * @function
 * @name sap.ui.core.Element.prototype.exit
 * @protected
 */
//sap.ui.core.Element.prototype.exit = function() {};

/**
 * Creates a new Element from the given data.
 *
 * If vData is an element already, that element is returned.
 * If vData is an object (literal), then a new element is created with vData as settings.
 * The type of the element is either determined by a "Type" entry in the vData or
 * by a type information in the oKeyInfo object
 * @param {sap.ui.core.Element|object} vData the data to create the element from
 * @param {object} oKeyInfo
 * @public
 * @static
 */
sap.ui.core.Element.create = function(vData, oKeyInfo) {
	if ( !vData || vData instanceof sap.ui.core.Element || typeof vData !== "object" || vData instanceof String) {
		return vData;
	}

	function getClass(vType) {
		if ( typeof vType === "function" ) {
			return vType;
		} 
		if (typeof vType === "string" ) {
			return jQuery.sap.getObject(vType);
		}
	}

	var fnClass = getClass(vData.Type) || getClass(oKeyInfo && oKeyInfo.type);
	if ( typeof fnClass === "function" ) {
		return new fnClass(vData);
	}

	// we don't know how to create the Element from vData, so fail
	// extension points could be integrated here
	var message = "Don't know how to create an Element from " + vData + " (" + (typeof vData) + ")";
	jQuery.sap.log.fatal(message);
	throw new Error(message);
};


/**
 * Returns a simple string representation of this element.
 *
 * Mainly useful for tracing purposes.
 * @public
 * @return {string} a string descripition of this element
 */
sap.ui.core.Element.prototype.toString = function() {
	if ( this.getMetadata ) {
		return "Element " + this.getMetadata().getName() + "#" + this.sId;
	}
	else {
		return "Element {unknown class}#" + this.sId;
	}
};


/**
 * Returns the best suitable DOM node that represents this Element.
 * By default the DOM node with the same ID as this Element is returned.
 * Subclasses should override this method if the lookup via id is not sufficient.
 *
 * Note that such a DOM node does not necessarily exist in all cases.
 * Some elements or controls might not have a DOM representation at all (e.g.
 * a naive FlowLayout) while others might not have one due to their current
 * state (e.g. an initial, not yet rendered control).
 *
 * @return {DOMNode} The element's DOM reference or null
 * @protected
 */
sap.ui.core.Element.prototype.getDomRef = function() {
	return jQuery.sap.domById(this.getId());
};

/**
 * Returns the best suitable DOM node that represents this Element wrapped as jQuery object.
 * I.e. the element returned by {@link sap.ui.core.Element#getDomRef} is wrapped and returned.
 *
 * @return {jQuery} The jQuery wrapped element's DOM reference
 * @protected
 */

sap.ui.core.Element.prototype.$ = function() {
	return jQuery(this.getDomRef());
};

/**
 * Checks whether this element has an active parent.
 *
 * @type boolean
 * @return true if this element has an active parent
 * @private
 */
sap.ui.core.Element.prototype.isActive = function() {
	return this.oParent && this.oParent.isActive();
};

/**
 * This function either calls set[sPropertyName] or get[sPropertyName] with the specified property name
 * depending if an <code>oValue</code> is provided or not.
 *
 * @param {string}  sPropertyName name of the property to set
 * @param {any}     [oValue] value to set the property to
 * @return {any|sap.ui.core.Element} Returns <code>this</code> to allow method chaining in case of setter and the property value in case of getter
 * @public
 */
sap.ui.core.Element.prototype.prop = function(sPropertyName, oValue) {

	var oPropertyInfo = this.getMetadata().getJSONKeys()[sPropertyName];
	if (oPropertyInfo) {
		if (arguments.length == 1) {
			// getter
			return this[oPropertyInfo._sGetter]();
		} else {
			// setter
			this[oPropertyInfo._sMutator](oValue);
			return this;
		}
	}
};


/**
 * Getter for aggregation <code>customData</code>.<br/>
 *
 * @return {sap.ui.core.CustomData[]}
 * @function
 * @name sap.ui.core.Element.prototype.getCustomData
 * @public
 */

/**
 * Inserts a CustomData element into the aggregation named <code>customData</code>.
 *
 * @param {sap.ui.core.CustomData}
 *          oCustomData the customData to insert; if empty, nothing is inserted
 * @param {int}
 *             iIndex the <code>0</code>-based index the customData should be inserted at; for
 *             a negative value of <code>iIndex</code>, the customData is inserted at position 0; for a value
 *             greater than the current size of the aggregation, the customData is inserted at
 *             the last position
 * @return {sap.ui.core.Element} <code>this</code> to allow method chaining
 * @function
 * @name sap.ui.core.Element.prototype.insertCustomData
 * @public
 */

/**
 * Adds some customData element <code>oCustomData</code>
 * to the aggregation named <code>customData</code>.
 *
 * @param {sap.ui.core.CustomData}
 *            oCustomData the customData to add; if empty, nothing is inserted
 * @return {sap.ui.core.Element} <code>this</code> to allow method chaining
 * @function
 * @name sap.ui.core.Element.prototype.addCustomData
 * @public
 */

/**
 * Removes a CustomData element from the aggregation named <code>customData</code>.
 *
 * @param {int | string | sap.ui.core.CustomData} vCustomData the customData to remove or its index or id
 * @return {sap.ui.core.CustomData} the removed customData element or null
 * @function
 * @name sap.ui.core.Element.prototype.removeCustomData
 * @public
 */

/**
 * Removes all the data elements in the aggregation named <code>customData</code>.<br/>
 *
 * @return {sap.ui.core.CustomData[]} an array of the removed data elements (might be empty)
 * @function
 * @name sap.ui.core.Element.prototype.removeAllCustomData
 * @public
 */

/**
 * Checks for the provided <code>sap.ui.core.CustomData</code> in the aggregation named <code>customData</code>
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.core.CustomData}
 *            oCustomData the customData whose index is looked for.
 * @return {int} the index of the provided customData element in the aggregation if found, or -1 otherwise
 * @function
 * @name sap.ui.core.Element.prototype.indexOfCustomData
 * @public
 */

/**
 * Destroys all the customData elements in the aggregation
 * named <code>customData</code>.
 * @return {sap.ui.core.Element} <code>this</code> to allow method chaining
 * @function
 * @name sap.ui.core.Element.prototype.destroyCustomData
 * @public
 */


/// cyclic dependency
//jQuery.sap.require("sap.ui.core.TooltipBase"); /// cyclic dependency


/**
 * This triggers immediate rerendering of its parent and thus of itself and its children.<br/> As <code>sap.ui.core.Element</code> "bubbles up" the
 * rerender, changes to child-<code>Elements</code> will also result in immediate rerendering of the whole sub tree.
 * @protected
 */
sap.ui.core.Element.prototype.rerender = function() {
	if (this.oParent) {
		this.oParent.rerender();
	}
};


/**
 * Returns the UI area of this element, if any.
 *
 * @return {sap.ui.core.UIArea} The UI area of this element or null
 * @private
 */
sap.ui.core.Element.prototype.getUIArea = function() {
	return this.oParent ? this.oParent.getUIArea() : null;
};

/**
 * Cleans up the resources associated with this element and all its children.
 *
 * After an element has been destroyed, it can no longer be used in the UI!
 *
 * Applications should call this method if they don't need the element any longer.
 *
 * @param {boolean}
 *            [bSuppressInvalidate] if true, the UI element is not marked for redraw
 * @public
 */
sap.ui.core.Element.prototype.destroy = function(bSuppressInvalidate) {

	sap.ui.base.ManagedObject.prototype.destroy.call(this, bSuppressInvalidate);

	// remove this control from DOM, e.g. if there is no parent (e.g. Dialog or already removed control) or this.sParentAggregationName is not properly set
	this.$().remove();
};


/**
 * Fires the given event and notifies all listeners. Listeners must not change
 * the content of the event.
 *
 * @param {string} sEventId the event id
 * @param {object} mParameters the parameter map
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Element.prototype.fireEvent = function(sEventId, mParameters) {
	// TODO 'id' is somewhat redundant to getSource(), but it is commonly used - fade out with next major release?
	mParameters = mParameters || {};
	mParameters.id = mParameters.id || this.getId();
	// 'arguments' is necessary, as the EventProvider.fireEvent signature has more parameters
	return sap.ui.base.EventProvider.prototype.fireEvent.apply(this, arguments);
};


/**
 * Adds a delegate that listens to the events of this element.
 * 
 * Note that the default behavior (delegate attachments are not cloned when a control is cloned) is usually the desired behavior in control development 
 * where each control instance typically creates a delegate and adds it to itself. (As opposed to application development where the application may add 
 * one delegate to a template and then expects aggregation binding to add the same delegate to all cloned elements.)
 *
 * To avoid double registrations, all registrations of the given delegate are first removed and then the delegate is added.
 * 
 * @param {object} oDelegate the delegate object
 * @param {boolean} [bCallBefore] if true, the delegator event listeners are called before the event listeners of the element; default is "false". In order to also set bClone, this parameter must be given.
 * @param {object} [oThis] if given, this object will be the "this" context in the listener methods; default is the delegate object itself
 * @param {boolean} [bClone] if true, this delegate will also be attached to any clones of this element; default is "false"
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @private
 */
sap.ui.core.Element.prototype.addDelegate = function (oDelegate, bCallBefore, oThis, bClone) {
	this.removeDelegate(oDelegate);
	
	// shift parameters
	if (typeof bCallBefore === "object") {
		bClone = oThis;
		oThis = bCallBefore;
		bCallBefore = false;
	}
	
	if (typeof oThis === "boolean") {
		bClone = oThis;
		oThis = undefined;
	}

	(bCallBefore ? this.aBeforeDelegates : this.aDelegates).push({oDelegate:oDelegate, bClone: !!bClone, vThis: ((oThis === this) ? true : oThis)}); // special case: if this element is the given context, set a flag, so this also works after cloning (it should be the cloned element then, not the given one)
	return this;
};

/**
 * Removes the given delegate from this element.
 *
 * This method will remove all registrations of the given delegate, not only one.
 * If the delegate was marked to be cloned and this element has been cloned, the delegate will not be removed from any clones.
 * 
 * @param {object} oDelegate the delegate object
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @private
 */
sap.ui.core.Element.prototype.removeDelegate = function (oDelegate) {
	for (var i=0;i<this.aDelegates.length;i++) {
		if (this.aDelegates[i].oDelegate==oDelegate) {
			this.aDelegates.splice(i,1);
		}
	}
	for (var i=0;i<this.aBeforeDelegates.length;i++) {
		if (this.aBeforeDelegates[i].oDelegate==oDelegate) {
			this.aBeforeDelegates.splice(i,1);
		}
	}
	return this;
};


/**
 * Adds a delegate that listens to the events that are fired on this element (as opposed to events which are fired BY this element).
 * 
 * When this element is cloned, the same delegate will be added to all clones. This behavior is well-suited for applications which want to add delegates
 * that also work with templates in aggregation bindings.
 * For control development the internal "addDelegate" method which does not clone delegates by default may be more suitable, as typically each control instance takes care of its own delegates.
 *
 * To avoid double registrations, all registrations of the given delegate are first
 * removed and then the delegate is added.
 *
 * @param {object} oDelegate the delegate object
 * @param {object} [oThis] if given, this object will be the "this" context in the listener methods; default is the delegate object itself
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @since 1.9.0
 * @public
 */
sap.ui.core.Element.prototype.addEventDelegate = function (oDelegate, oThis) {
	return this.addDelegate(oDelegate, false, oThis, true);
};

/**
 * Removes the given delegate from this element.
 *
 * This method will remove all registrations of the given delegate, not only one.
 * 
 * @param {object} oDelegate the delegate object
 * @return {sap.ui.core.Element} Returns <code>this</code> to allow method chaining
 * @since 1.9.0
 * @public
 */
sap.ui.core.Element.prototype.removeEventDelegate = function (oDelegate) {
	return this.removeDelegate(oDelegate);
};

/**
 * Returns the dom reference that should get the focus
 * To be overwritten by the specific control method
 * @type DOMNode
 * @return Returns the dom reference that should get the focus
 */
sap.ui.core.Element.prototype.getFocusDomRef = function () {
	return this.getDomRef() || null;
};

/**
 * Sets the focus to the stored focus dom reference
 * @private
 */
sap.ui.core.Element.prototype.focus = function () {
	var oFocusDomRef = this.getFocusDomRef();

	if(oFocusDomRef) {
		try {
			oFocusDomRef.focus();
		} catch (ex) { // IE8 fails on focusing certain elements; IE9+10 and all other current browsers don't fail
			// the element does not exist or is not focusable; there is no information what to focus instead
			var id = oFocusDomRef.id ? " (id: " + oFocusDomRef.id + ")" : " ";
			jQuery.sap.log.warning("DOM element" + id + " in " + this.toString() + " which should be focused cannot be focused: " + ex.message);
		}
	}
};

/**
 * Returns an object representing the serialized focus information
 * To be overwritten by the specific control method
 * @type object
 * @return an object representing the serialized focus information
 * @protected
 */
sap.ui.core.Element.prototype.getFocusInfo = function () {
	return {id:this.getId()};
};

/**
 * Applies the focus info
 * To be overwritten by the specific control method
 * @param {object} oFocusInfo
 * @protected
 */
sap.ui.core.Element.prototype.applyFocusInfo = function (oFocusInfo) {
	this.focus();
	return this;
};


/**
 * Sets a new tooltip for this object. The tooltip can either be a simple string
 * (which in most cases will be rendered as the <code>title</code> attribute of this
 * Element) or an instance of {@link sap.ui.core.TooltipBase}.
 *
 * If a new tooltip is set, any previously set tooltip is deactivated.
 *
 * @param {string|sap.ui.core.TooltipBase} oTooltip.
 * @public
 */
sap.ui.core.Element.prototype.setTooltip = function(oTooltip) {

	var oOldTooltip = this.getTooltip();
	// if the old tooltip was a Tooltip object, remove it as a delegate
	if (oOldTooltip instanceof sap.ui.core.TooltipBase){
		this.removeDelegate(oOldTooltip);
	}
	// if the new tooltip is a Tooltip object, add it as a delegate
	if (oTooltip instanceof sap.ui.core.TooltipBase){
		oTooltip._currentControl = this;
		this.addDelegate(oTooltip);
	}
	this.setAggregation("tooltip", oTooltip);

	return this;
};

/**
 * Returns the tooltip for this element if any or an undefined value.
 * The tooltip can either be a simple string or a subclass of
 * {@link sap.ui.core.TooltipBase}.
 *
 * Callers that are only interested in tooltips of type string (e.g. to render
 * them as a <code>title</code> attribute), should call the convenience method
 * {@link #getTooltip_AsString} instead. If they want to get a tooltip text no
 * matter where it comes from (be it a string tooltip or the text from a TooltipBase
 * instance) then they could call {@link #getTooltip_Text} instead.
 *
 * @return {string|sap.ui.core.TooltipBase} The tooltip for this Element.
 * @public
 */
sap.ui.core.Element.prototype.getTooltip = function() {
	return this.getAggregation("tooltip");
};

sap.ui.core.Element.runWithPreprocessors = sap.ui.base.ManagedObject.runWithPreprocessors;

/**
 * Returns the tooltip for this element but only if it is a simple string.
 * Otherwise an undefined value is returned.
 *
 * @return {string} string tooltip or undefined
 * @public
 */
sap.ui.core.Element.prototype.getTooltip_AsString = function() {
	var oTooltip = this.getTooltip();
	if (typeof oTooltip === "string" || oTooltip instanceof String ) {
		return oTooltip;
	}
	return undefined;
};

/**
 * Returns the main text for the current tooltip or undefined if there is no such text.
 * If the tooltip is an object derived from sap.ui.core.Tooltip, then the text property
 * of that object is returned. Otherwise the object itself is returned (either a string
 * or undefined or null).
 *
 * @return {string} text of the current tooltip or undefined
 * @public
 */
sap.ui.core.Element.prototype.getTooltip_Text = function() {
	var oTooltip = this.getTooltip();
	if (oTooltip && typeof oTooltip.getText === "function" ) {
		return oTooltip.getText();
	}
	return oTooltip;
};

/**
 * Returns the runtime metadata for this UI element.
 *
 * When using the defineClass method, this function is automatically created and returns
 * a runtime representation of the design time metadata.
 *
 * @function
 * @name sap.ui.core.Element.prototype.getMetadata
 * @return {object} runtime metadata
 * @public
 */
// sap.ui.core.Element.prototype.getMetadata = sap.ui.base.Object.ABSTRACT_METHOD;

//data container

(function(){

	/**
	 * Returns the data object with the given key
	 */
	var getDataObject = function(element, key) {
		var aData = element.getAggregation("customData");
		if (aData) {
			for (var i = 0; i < aData.length; i++) {
				if (aData[i].getKey() == key) {
					return aData[i];
				}
			}
		}
		return null;
	};

	/**
	 * Contains the data modification logic
	 */
	var setData = function(element, key, value, writeToDom) {

		// DELETE
		if (value === null) { // delete this property
			var dataObject = getDataObject(element, key);
			if (!dataObject) {
				return;
			}

			var dataCount = element.getAggregation("customData").length;
			if (dataCount == 1) {
				element.destroyAggregation("customData", true); // destroy if there is no other data
			} else {
				element.removeAggregation("customData", dataObject, true);
				dataObject.destroy();
			}

			// ADD or CHANGE
		} else {
			var dataObject = getDataObject(element, key);
			if (dataObject) {
				dataObject.setValue(value);
				dataObject.setWriteToDom(writeToDom);
			} else {
				var dataObject = new sap.ui.core.CustomData({key:key,value:value, writeToDom:writeToDom});
				element.addAggregation("customData", dataObject, true);
			}
		}
	};

	/**
	 * Attaches custom data to an Element or retrieves attached data.
	 *
	 * Usage:
	 *    data("myKey", myData)
	 * attaches myData (which can be any JS data type, e.g. a number, a string, an object, or a function) to this element, under the given key "myKey". If the key already exists,the value will be updated.
	 *
	 *    data("myKey", myData, writeToDom)
	 * attaches myData to this element, under the given key "myKey" and (if writeToDom is true) writes key and value to the HTML. If the key already exists,the value will be updated. While oValue can be any JS data type to be attached, it must be a string to be also written to DOM. The key must also be a valid HTML attribute name (it must conform to sap.ui.core.ID and may contain no colon) and may not start with "sap-ui". When written to HTML, the key is prefixed with "data-".
	 *
	 *    data("myKey")
	 * retrieves whatever data has been attached to this Element (using the key "myKey") before
	 *
	 *    data("myKey", null)
	 * removes whatever data has been attached to this Element (using the key "myKey") before
	 *
	 *    data(null)
	 * removes all data
	 *
	 *    data()
	 * returns all data, as a map
	 *
	 * @public
	 */
	sap.ui.core.Element.prototype.data = function() {
		var argLength = arguments.length;

		if (argLength == 0) {                    // return ALL data as a map
			var aData = this.getAggregation("customData"),
				result = {};
			if (aData) {
				for (var i = 0; i < aData.length; i++) {
					result[aData[i].getKey()] = aData[i].getValue();
				}
			}
			return result;

		} else if (argLength == 1) {
			var arg0 = arguments[0];

			if (arg0 === null) {                  // delete ALL data
				this.destroyAggregation("customData", true); // delete whole map
				return this;

			} else if (typeof arg0 == "string") { // return requested data element
				var dataObject = getDataObject(this, arg0);
				return dataObject ? dataObject.getValue() : null;

			} else if (typeof arg0 == "object") { // should be a map - set multiple data elements
				for (var key in arg0) { // TODO: improve performance and avoid executing setData multiple times
					setData(this, key, arg0[key]);
				}
				return this;

			} else {
				// error, illegal argument
				throw new Error("When data() is called with one argument, this argument must be a string, an object or null, but is " + (typeof arg0) + ":" + arg0 + " (on UI Element with ID '" + this.getId() + "')");
			}

		} else if (argLength == 2) {            // set or remove one data element
			setData(this, arguments[0], arguments[1]);
			return this;

		} else if (argLength == 3) {            // set or remove one data element
			setData(this, arguments[0], arguments[1], arguments[2]);
			return this;

		} else {
			// error, illegal arguments
			throw new Error("data() may only be called with 0-3 arguments (on UI Element with ID '" + this.getId() + "')");
		}
	};

})();

/** Clone delegates
* @param {String} [sIdSuffix] a suffix to be appended to the cloned element id
* @param {Array} [aLocalIds] an array of local IDs within the cloned hierarchy (internally used)
* @return {sap.ui.base.ManagedObject} reference to the newly created clone
* @protected
*/
sap.ui.core.Element.prototype.clone = function(sIdSuffix, aLocalIds){

	var oClone = sap.ui.base.ManagedObject.prototype.clone.apply(this, arguments);
	// Clone delegates
	for ( var i = 0; i < this.aDelegates.length; i++) {
		if (this.aDelegates[i].bClone) {
			oClone.aDelegates.push(this.aDelegates[i]);
		}
	}
	for ( var i = 0; i < this.aBeforeDelegates.length; i++) {
		if (this.aBeforeDelegates[i].bClone) {
			oClone.aBeforeDelegates.push(this.aBeforeDelegates[i]);
		}
	}

	return oClone;
};

/**
* Searches and returns an array of child elements and controls which are
* referenced within an aggregation or aggregations of child elements/controls.
* This can be either done recursive or not.
* <br>
* <b>Take care: this operation might be expensive.</b>
* @param {boolean}
*          bRecursive true, if all nested children should be returned.
* @return {sap.ui.core.Element[]} array of child elements and controls
* @public
*/
sap.ui.core.Element.prototype.findElements = function(bRecursive) {
	var aControls = sap.ui.base.ManagedObject.prototype.findAggregatedObjects.call(this, bRecursive);
	return aControls;
};

/**
 * Sets the {@link sap.ui.core.LayoutData} defining the layout constraints 
 * for this control when it is used inside a layout.
 *
 * @function
 * @name sap.ui.core.Element.prototype.setLayoutData
 * @public
 */
sap.ui.core.Element.prototype.setLayoutData = function(oLayoutData) {
	this.setAggregation("layoutData", oLayoutData, true); // No invalidate because layout data changes does not affect the control / element itself
	var oLayout = this.getParent();
	if(oLayout){
		var oEvent = jQuery.Event("LayoutDataChange");
		oEvent.srcControl = this;
		oLayout._handleEvent(oEvent);
	}
	return this;
};

/**
 * Returns the {@link sap.ui.core.LayoutData} defining the layout constraints 
 * for this control when it is used inside a layout.
 *
 * @function
 * @name sap.ui.core.Element.prototype.getLayoutData
 * @public
 */

/**
 * Allows the parent of a control to enhance the aria information while rendering
 *
 * This function is called in RenderManager writeAccessibilityState for the parent
 * of the control if the function is implemented by the parent.
 *
 * @function
 * @name sap.ui.core.Element.prototype.enhanceAccessibilityState
 * @param {element} oElement the control/element for taht aria properties are rendered
 * @param {array} mAriaProps array of aria properties
 * @return {array} array of aria properties
 * @protected
 * @abstract
 */

}; // end of sap.ui.core.Element

//jQuery.sap.require("sap.ui.core.RenderManager"); // cyclic

/**
 * Creates and initializes a new control with the given <code>sId</code> and settings.
 *
 * The set of allowed entries in the <code>mSettings</code> object depends on the concrete
 * subclass and is described there. See {@link sap.ui.core.Element} for a general description of this
 * argument.
 *
 * @param {string} [sId] optional id for the new control; generated automatically if no non-empty id is given
 *      Note: this can be omitted, no matter whether <code>mSettings</code> will be given or not!
 * @param {object} [mSettings] optional map/JSON-object with initial settings for the new control
 * @public
 *
 * @class Base Class for Controls.
 * @extends sap.ui.core.Element
 * @abstract
 * @author Martin Schaus, Daniel Brinkmann
 * @version 1.10.0
 * @name sap.ui.core.Control
 */
sap.ui.core.Element.extend("sap.ui.core.Control", /* @lends sap.ui.core.Control */ {

	metadata : {
		"abstract" : true,
		publicMethods: ["placeAt", "attachBrowserEvent", "detachBrowserEvent"],
		library: "sap.ui.core",
		properties : {},
		aggregations : {},
		associations : {},
		events : {}
	},

	constructor : function(sId, mSettings) {

		// TODO initialization should happen in init
		// but many of the existing controls don't call super.init()
		// As a workaround I moved the initialization of bAllowTextSelection here
		// so that it doesn't overwrite settings in init() (e.g. ListBox)
		this.bAllowTextSelection = true;

		sap.ui.core.Element.apply(this,arguments);
		this.bOutput = this.getDomRef() != null; // whether this control has already produced output
	},

	renderer : null // Control has no renderer

});

/**
 * Creates a new subclass of class sap.ui.core.Control with name <code>sClassName</code> 
 * and enriches it with the information contained in <code>oClassInfo</code>.
 * 
 * <code>oClassInfo</code> might contain the same kind of informations as described in {@link sap.ui.core.Element.extend Element.extend}.
 *   
 * @param {string} sClassName name of the class to be created
 * @param {object} [oClassInfo] object literal with informations about the class  
 * @param {function} [FNMetaImpl] constructor function for the metadata object. If not given, it defaults to sap.ui.core.ElementMetadata.
 * @return {function} the created class / constructor function
 * @public
 * @static
 * @name sap.ui.core.Control.extend
 * @function
 */

/**
 * Overrides {@link sap.ui.core.Element#clone Element.clone} to clone additional 
 * internal state.
 * 
 * The additionally cloned information contains:
 * <ul>
 * <li>browser event handlers attached with {@link #attachBrowserEvent}
 * <li>text selection behavior
 * <li>style classes added with {@link #addStyleClass}
 * </ul>
 * 
 * @param {String} [sIdSuffix] a suffix to be appended to the cloned element id
 * @param {Array} [aLocalIds] an array of local IDs within the cloned hierarchy (internally used)
 * @return {sap.ui.core.Element} reference to the newly created clone
 * @protected
 */
sap.ui.core.Control.prototype.clone = function() {
	var oClone = sap.ui.core.Element.prototype.clone.apply(this, arguments);

	if ( this.aBindParameters ) {
		for(var i=0, l=this.aBindParameters.length; i<l; i++) {
			var aParams = this.aBindParameters[i];
			oClone.attachBrowserEvent(aParams.sEventType, aParams.fnHandler, aParams.oListener !== this ? aParams.oListener : undefined);
		}
	}
	oClone.bAllowTextSelection = this.bAllowTextSelection;
	return oClone;
};

// must appear after clone() method and metamodel definition
if ( !jQuery.sap.isDeclared('sap.ui.core.CustomStyleClassSupport') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides helper sap.ui.core.CustomStyleClassSupport
jQuery.sap.declare("sap.ui.core.CustomStyleClassSupport");

/**
 * If called on the prototype of a sap.ui.core.Element, the Element (and its prototype) is extended
 * to support custom style classes.
 *
 * WARNING: only to be used WITHIN a control implementation. An application cannot add style class support by calling this method!
 *
 * The methods "addStyleClass", "removeStyleClass", toggleStyleClass and "hasStyleClass" are added to the Element and the clone() method
 * is extended to also clone the custom classes.
 *
 * Usage example:
 * jQuery.sap.require("sap.ui.core.CustomStyleClassSupport");
 * sap.ui.core.CustomStyleClassSupport.apply(sap.ui.commons.layout.MatrixLayoutCell.prototype);
 *
 * Each renderer handling the given Element MUST then call
 * renderManager.writeClasses(oElement);
 * when writing the root tag of the Element. This makes sure the classes are written to the HTML.
 *
 * @public
 */
sap.ui.core.CustomStyleClassSupport = function () {
	// "this" is the prototype now when called with apply()

	// Ensure only Elements are enhanced
	if(!(this instanceof sap.ui.core.Element)) {
		return;
	}

	// enrich original clone function
	var fOriginalClone = this.clone;
	this.clone = function() {
		// call original clone function
		var oClone = fOriginalClone.apply(this, arguments);

		// add the style classes of "this" to the clone
		if (this.aCustomStyleClasses) {
			oClone.aCustomStyleClasses = this.aCustomStyleClasses.slice();
		}
		return oClone;
	};


	this.addStyleClass = function(sStyleClass, bSuppressRerendering) { // bSuppressRerendering is experimental and hence undocumented
		jQuery.sap.assert(sStyleClass && typeof sStyleClass === "string", "sStyleClass must be a string");

		if (!this.aCustomStyleClasses) {
			this.aCustomStyleClasses = [];
		}
		if (sStyleClass) {
			// ensure the "class" attribute is not closed
			if (sStyleClass.indexOf("\"") > -1) {
				return this;
			}
			if (sStyleClass.indexOf("'") > -1) {
				return this;
			} // TODO: maybe check for quotes in different charsets or encodings

			// multiple calls should not add the class multiple times
			for (var i = this.aCustomStyleClasses.length-1; i >= 0; i--) {
				if (this.aCustomStyleClasses[i] == sStyleClass) {
					return this;
				}
			}

			this.aCustomStyleClasses.push(sStyleClass);
			var oRoot = this.getDomRef();
			if (oRoot) { // non-rerendering shortcut
				jQuery(oRoot).addClass(sStyleClass);
			} else if (bSuppressRerendering === false) {
				this.invalidate();
			}
		}

		return this;
	};


	this.removeStyleClass = function(sStyleClass, bSuppressRerendering) { // bSuppressRerendering is experimental and hence undocumented
		jQuery.sap.assert(sStyleClass && typeof sStyleClass === "string", "sStyleClass must be a string");

		if (sStyleClass && this.aCustomStyleClasses) {
			for (var i = this.aCustomStyleClasses.length-1; i >= 0; i--) {
				if (this.aCustomStyleClasses[i] == sStyleClass) {
					this.aCustomStyleClasses.splice(i, 1);
					var oRoot = this.getDomRef();
					if (oRoot) { // non-rerendering shortcut
						jQuery(oRoot).removeClass(sStyleClass);
					} else if (bSuppressRerendering === false) {
						this.invalidate();
					}
				}
			}
		}

		return this;
	};


	this.toggleStyleClass = function(sStyleClass, bAdd) {
		jQuery.sap.assert(sStyleClass && typeof sStyleClass === "string", "sStyleClass must be a string");
		
		if (sStyleClass && typeof sStyleClass === "string") {
			if (bAdd === true) {
				this.addStyleClass(sStyleClass);
			} else if (bAdd === false) {
				this.removeStyleClass(sStyleClass);
			} else if (bAdd === undefined) {
				this.hasStyleClass(sStyleClass) ? this.removeStyleClass(sStyleClass) : this.addStyleClass(sStyleClass);
			} else {
				jQuery.sap.log.warning(this.toString() + "- toggleStyleClass(): bAdd should be a boolean or undefined, but is '" + bAdd + "'");
			}
		}
		
		return this; // we could (depending on bAdd) return either this or the boolean result of removeStyleClass, but at least in the bAdd===undefined case the caller wouldn't even know which return type to expect...
	};


	this.hasStyleClass = function(sStyleClass) {
		jQuery.sap.assert(sStyleClass && typeof sStyleClass === "string", "sStyleClass must be a string");

		if (sStyleClass && this.aCustomStyleClasses) {
			for (var i = this.aCustomStyleClasses.length-1; i >= 0; i--) {
				if (this.aCustomStyleClasses[i] == sStyleClass) {
					return true;
				}
			}
		}
		return false;
	};

	this.getMetadata().addPublicMethods(["addStyleClass", "removeStyleClass", "toggleStyleClass", "hasStyleClass"]);

};

// moved here to fix the cyclic dependency CustomStyleClassSupport, Element, Core, Control


}; // end of sap.ui.core.CustomStyleClassSupport

sap.ui.core.CustomStyleClassSupport.apply(sap.ui.core.Control.prototype);


/**
 * Checks whether the control is still active (part of the active DOM)
 *
 * @return {boolean} whether the control is still in the active DOM
 * @private
 */
sap.ui.core.Control.prototype.isActive = function() {
	return jQuery.sap.domById(this.sId) != null;
};

/**
 * Triggers rerendering of this element and its children.
 *
 * As <code>sap.ui.core.Element</code> "bubbles up" the invalidate, changes to children
 * potentially result in rerendering of the whole sub tree.
 * @protected
 */
sap.ui.core.Control.prototype.invalidate = function(oOrigin) {
	var oUIArea;
	if ( this.bOutput && (oUIArea = this.getUIArea()) ) {
		// if this control has been rendered before (bOutput)
		// and if it is contained in an UIArea (!!oUIArea)
		// then control re-rendering can be used (see UIArea.rerender() for details)
		//
		// The check for bOutput is necessary as the control
		// re-rendering needs to identify the previous rendering results.
		// Otherwise it wouldn't be able to replace them.
		oUIArea.addInvalidatedControl(this);
	} else {
		// else we bubble up the hierarchy
		var oParent = this.getParent();
		if (oParent && (
				this.bOutput /* && !this.getUIArea() */ ||
				/* !this.bOutput && */ !(this.getVisible && this.getVisible() === false))) {

			// Note: the two comments in the condition above show additional conditions
			//       that help to understand the logic. As they are always fulfilled,
			//       they have been omitted for better performance.
			//
			// If this control has a parent but either
			//  - has produced output before ('this.bOutput') but is not part of an UIArea (!this.getUIArea())
			//  - or if it didn't produce output (!this.bOutput') before and is/became visible
			// then invalidate the parent to request re-rendering
			//
			// The first commented condition is always true, otherwise the initial if condition
			// in this method would have been met. The second one must be true as well because of the
			// short evaluation logic of JavaScript. When bOutput is true the second half of the Or won't be processed.

			oParent.invalidate(this);
		}
	}
};

/**
 * Tries to replace its DOM reference by re-rendering.
 * @protected
 */
sap.ui.core.Control.prototype.rerender = function() {
	sap.ui.core.UIArea.rerenderControl(this);
};

/**
 * Defines whether the user can select text inside this control.
 * Defaults to <code>true</code> as long as this method has not been called.
 *
 * <b>Note:</b>This only works in IE and Safari; for Firefox the element's style must
 * be set to:
 * <pre>
 *   -moz-user-select: none;
 * </pre>
 * in order to prevent text selection.
 *
 * @param {boolean} whether to allow text selection or not
 * @return {sap.ui.core.Control} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Control.prototype.allowTextSelection = function(bAllow) {
	this.bAllowTextSelection = bAllow;
	return this;
};

/**
 * The string given as "sStyleClass" will be added to the "class" attribute of this control's root HTML element.
 *
 * This method is intended to be used to mark controls as being of a special type for which
 * special styling can be provided using CSS selectors that reference this style class name.
 *
 * <pre>
 * Example:
 *    myButton.addStyleClass("myRedTextButton"); // add a CSS class to one button instance
 *
 * ...and in CSS:
 *    .myRedTextButton {
 *       color: red;
 *    }
 * </pre>
 *
 * This will add the CSS class "myRedTextButton" to the Button HTML and the CSS code above will then
 * make the text in this particular button red.
 *
 * Only characters allowed inside HTML attributes are allowed.
 * Quotes are not allowed and this method will ignore any strings containing quotes.
 * Strings containing spaces are interpreted as ONE custom style class (even though CSS selectors interpret them
 * as different classes) and can only removed later by calling removeStyleClass() with exactly the
 * same (space-containing) string as parameter.
 * Multiple calls with the same sStyleClass will have no different effect than calling once.
 * If sStyleClass is null, the call is ignored.
 *
 * @name sap.ui.core.Control.prototype.addStyleClass
 * @function
 *
 * @param {string} sStyleClass the CSS class name to be added
 * @return {sap.ui.core.Control} Returns <code>this</code> to allow method chaining
 * @public
 */

/**
 * Removes the given string from the list of custom style classes that have been set previously.
 * Regular style classes like "sapUiBtn" cannot be removed.
 *
 * @name sap.ui.core.Control.prototype.removeStyleClass
 * @function
 *
 * @param {string} sStyleClass the style to be removed
 * @return {sap.ui.core.Control} Returns <code>this</code> to allow method chaining
 * @public
 */

/**
 * The string given as "sStyleClass" will be be either added to or removed from the "class" attribute of this control's root HTML element,
 * depending on the value of "bAdd": if bAdd is true, sStyleClass will be added.
 * If bAdd is not given, sStyleClass will be removed if it is currently present and will be added if not present.
 * If sStyleClass is null, the call is ignored.
 * 
 * See addStyleClass and removeStyleClass for further documentation.
 *
 * @name sap.ui.core.Control.prototype.toggleStyleClass
 * @function
 *
 * @param {string} sStyleClass the CSS class name to be added or removed
 * @param {boolean} bAdd whether sStyleClass should be added (or removed); when this parameter is not given, sStyleClass will be toggled (removed, if present, and added if not present) 
 * @return {sap.ui.core.Control} Returns <code>this</code> to allow method chaining
 * @public
 */

/**
 * Returns true if the given style class string is valid and if this control has this style class set
 * via a previous call to addStyleClass().
 *
 * @name sap.ui.core.Control.prototype.hasStyleClass
 * @function
 *
 * @param {string} sStyleClass the style to check for
 * @type boolean
 * @return whether the given style has been set before
 * @public
 */


/**
 * Allows binding handlers for any native browser event to the root HTML element of this Control. This internally handles
 * DOM element replacements caused by re-rendering.
 *
 * IMPORTANT:
 * This should be only used as FALLBACK when the Control events do not cover a specific use-case! Always try using
 * SAPUI5 control events, as e.g. accessibility-related functionality is then provided automatically.
 * E.g. when working with a sap.ui.commons.Button, always use the Button's "press" event, not the native "click" event, because
 * "press" is also guaranteed to be fired when certain keyboard activity is supposed to trigger the Button.
 *
 * In the event handler, "this" refers to the Control - not to the root DOM element like in jQuery. While the DOM element can
 * be used and modified, the general caveats for working with SAPUI5 control DOM elements apply. In particular the DOM element
 * may be destroyed and replaced by a new one at any time, so modifications that are required to have permanent effect may not
 * be done. E.g. use Control.addStyleClass() instead if the modification is of visual nature.
 *
 * Use detachBrowserEvent() to remove the event handler(s) again.
 *
 * @param {string} [sEventType] A string containing one or more JavaScript event types, such as "click" or "blur".
 * @param {function} [fnHandler] A function to execute each time the event is triggered.
 * @param {Object} [oListener] The object, that wants to be notified, when the event occurs
 * @return {sap.ui.core.Control} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Control.prototype.attachBrowserEvent = function(sEventType, fnHandler, oListener) {
	if (sEventType && (typeof(sEventType) === "string")) { // do nothing if the first parameter is empty or not a string
		if (fnHandler && typeof(fnHandler) === "function") {   // also do nothing if the second parameter is not a function
			// store the parameters for bind()
			if (!this.aBindParameters) {
				this.aBindParameters = [];
			}
			oListener = oListener || this;

			// FWE jQuery.proxy can't be used as it breaks our contract when used with same function but different listeners
			var fnProxy=function() { fnHandler.apply(oListener, arguments); };

			this.aBindParameters.push({
				sEventType: sEventType,
				fnHandler: fnHandler,
				oListener: oListener,
				fnProxy : fnProxy
			});

			// if control is rendered, directly call bind()
			this.$().bind(sEventType, fnProxy);
		}
	}

	return this;
};


/**
 * This method is used to remove event handlers which have been previously attached using sap.ui.core.Control.attachBrowserEvent().
 *
 * @param {string} [sEventType] A string containing one or more JavaScript event types, such as "click" or "blur".
 * @param {function} [fnHandler] The function that is to be no longer executed.
 * @public
 */
sap.ui.core.Control.prototype.detachBrowserEvent = function(sEventType, fnHandler, oListener) {
	if (sEventType && (typeof(sEventType) === "string")) { // do nothing if the first parameter is empty or not a string
		if (fnHandler && typeof(fnHandler) === "function") {   // also do nothing if the second parameter is not a function
			var $ = this.$(),i,oParamSet;
			oListener=oListener || this;

			// remove the bind parameters from the stored array
			if (this.aBindParameters) {
				for (i = this.aBindParameters.length - 1; i >= 0; i--) {
					oParamSet = this.aBindParameters[i];
					if ( oParamSet.sEventType === sEventType  && oParamSet.fnHandler === fnHandler  &&  oParamSet.oListener === oListener ) {
						this.aBindParameters.splice(i, 1);
						// if control is rendered, directly call unbind()
						$.unbind(sEventType, oParamSet.fnProxy);
					}
				}
			}

		}
	}

	return this;
};



/**
 * Returns a renderer for this control instance.
 *
 * It is retrieved using the RenderManager as done during rendering.
 *
 * @return {object} a Renderer suitable for this Control instance.
 * @protected
 */
sap.ui.core.Control.prototype.getRenderer = function () {
	//TODO introduce caching?
	return sap.ui.core.RenderManager.getRenderer(this);
};

/**
 * Puts <code>this</code> control into the specified container (<code>oRef</code>) at the given
 * position (<code>oPosition</code>).
 *
 * First it is checked whether <code>oRef</code> is a container element / control (has a
 * multiple aggregation with type <code>sap.ui.core.Control</code> and name 'content') or is an Id String
 * of such an container.
 * If this is not the case <code>oRef</code> can either be a Dom Reference or Id String of the UIArea
 * (if it does not yet exist implicitly a new UIArea is created),
 *
 * The <code>oPosition</code> can be one of the following:
 *
 * <ul>
 *  <li>"first": The control is added as the first element to the container.</li>
 *  <li>"last": The control is added as the last element to the container (default).</li>
 *  <li>"only": All existing children of the container are removed (not destroyed!) and the control is added as new child.</li>
 *  <li><i>index</i>: The control is added at the specified <i>index</i> to the container.</li>
 * </ul>
 * 
 * @param {String|DomRef|sap.ui.core.Control} oRef container into which the control should be put
 * @param {String|int} oPosition Describes the position where the control should be put into the container
 * @return {sap.ui.core.Control} Returns <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Control.prototype.placeAt = function(oRef, oPosition) {
	var oCore = sap.ui.getCore();
	if(oCore.isInitialized()){
		// core already initialized, do it now

		// 1st try to resolve the oRef as a Container control
		var oContainer = oRef;
		if(typeof oContainer === "string"){
			oContainer = oCore.byId(oRef);
		}
		// if no container control is found use the corresponding UIArea
		var bIsUIArea = false;
		if(!(oContainer instanceof sap.ui.core.Element)) {
			oContainer = oCore.createUIArea(oRef);
			bIsUIArea = true;
		}

		if(!oContainer) {
			return;
		}

		if(!bIsUIArea){
			var oContentAggInfo = oContainer.getMetadata().getAllAggregations()["content"];
			var bContainerSupportsPlaceAt = true;
			if(oContentAggInfo){
				if(!oContentAggInfo.multiple || oContentAggInfo.type != "sap.ui.core.Control"){
					bContainerSupportsPlaceAt = false;
				}
			}else{
				//Temporary workaround for sap.ui.commons.AbsoluteLayout to enable placeAt even when no content aggregation is available. TODO: Find a proper solution
				if(!oContainer.addContent || !oContainer.insertContent || !oContainer.removeAllContent) {
					bContainerSupportsPlaceAt = false;
				}
			}
			if(!bContainerSupportsPlaceAt) {
				jQuery.sap.log.warning("placeAt cannot be processed because container "+oContainer+" does not have an aggregation 'content'.");
				return;
			}
		}

		if(typeof oPosition === "number"){
			oContainer.insertContent(this, oPosition);
		}else{
			oPosition = oPosition || "last"; //"last" is default
			switch(oPosition){
				case "last":
					oContainer.addContent(this);
					break;
				case "first":
					oContainer.insertContent(this, 0);
					break;
				case "only":
					oContainer.removeAllContent();
					oContainer.addContent(this);
					break;
				default:
					jQuery.sap.log.warning("Position "+oPosition+" is not supported for function placeAt.");
			}
		}
	}else{
		// core not yet initialized, defer execution
		var that = this;
		oCore.attachInitEvent(function () {
			that.placeAt(oRef, oPosition);
		});
	}
	return this;
};

/*
 * Event handling
 */

/**
 * Cancels user text selection if text selection is disabled for this control.
 * See the {@link #allowTextSelection} method.
 * @private
 */
sap.ui.core.Control.prototype.onselectstart = function (oBrowserEvent) {
	if(!this.bAllowTextSelection) {
		oBrowserEvent.preventDefault();
		oBrowserEvent.stopPropagation();
	}
};

/*
 * Rendering
 */

/**
 * Function is called before the rendering of the control is started.
 *
 * Applications must not call this hook method directly, it is called by the framework.
 *
 * Subclasses of Control should override this hook to implement any necessary actions before the rendering.
 *
 * @function
 * @name sap.ui.core.Control.prototype.onBeforeRendering
 * @protected
 */
//sap.ui.core.Control.prototype.onBeforeRendering = function() {};

/**
 * Function is called when the rendering of the control is completed.
 *
 * Applications must not call this hook method directly, it is called by the framework.
 *
 * Subclasses of Control should override this hook to implement any necessary actions after the rendering.
 *
 * @function
 * @name sap.ui.core.Control.prototype.onAfterRendering
 * @protected
 */
//sap.ui.core.Control.prototype.onAfterRendering = function() {};

/**
 * Gets the ID used for the "labelFor" attribute of the label
 * By default its the control ID
 * @public
 */
sap.ui.core.Control.prototype.getIdForLabel = function () {
	return this.getId();
};


}; // end of sap.ui.core.Control

if ( !jQuery.sap.isDeclared('sap.ui.core.FocusHandler') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.core.FocusHandler
jQuery.sap.declare("sap.ui.core.FocusHandler");




(function(){

	/**
	 * Constructs an instance of a sap.ui.core.FocusHandler.
	 * Keeps track of the focused element.
	 *
	 * @class sap.ui.core.FocusHandler
	 * @param oRootRef e.g. document.body
	 */
	sap.ui.core.FocusHandler = function(oRootRef, oCore) {
		sap.ui.base.Object.apply(this);

		this.oCore = oCore;

		// keep track of element currently in focus
		this.oCurrent = null;
		// keep track of the element previously had the focus
		this.oLast = null;
		// buffer the focus/blur events for correct order
		this.aEventQueue = [];

		this.fEventHandler = jQuery.proxy(this.onEvent, this);
		this.fDestroyHandler = jQuery.proxy(this.destroy, this);

		// initialize event handling
		if(oRootRef.addEventListener && !jQuery.browser.msie){ //FF, Safari
			oRootRef.addEventListener("focus", this.fEventHandler, true);
			oRootRef.addEventListener("blur", this.fEventHandler, true);
		}else{ //IE
			jQuery(oRootRef).bind("activate", this.fEventHandler);
			jQuery(oRootRef).bind("deactivate", this.fEventHandler);
		}
		jQuery.sap.log.debug("FocusHandler setup on Root " + oRootRef.type + (oRootRef.id?": " + oRootRef.id:""), null, "sap.ui.core.FocusHandler");

		// TODO: Or should we be destroyed by the Core?
		jQuery(window).bind("unload", {"oRootRef": oRootRef}, this.fDestroyHandler);
	};

	sap.ui.core.FocusHandler.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);
	sap.ui.base.Object.defineClass("sap.ui.core.FocusHandler", {
		baseType : "sap.ui.base.Object"
	});

	/**
	 * Returns the Id of the control/element currently in focus.
	 * @return {string} the Id of the control/element currently in focus.
	 * @public
	 */
	sap.ui.core.FocusHandler.prototype.getCurrentFocusedControlId = function(){
		return this.oCurrent;
	};

	/**
	 * Destroy method of the Focus Handler.
	 * It unregisters the event handlers.
	 *
	 * @param {jQuery.Event} event the event that initiated the destruction of the FocusHandler
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.destroy = function(event) {
		var oRootRef = event.data.oRootRef;
		if(oRootRef){
			if(oRootRef.removeEventListener && !jQuery.browser.msie){ //FF, Safari
				oRootRef.removeEventListener("focus", this.fEventHandler, true);
				oRootRef.removeEventListener("blur", this.fEventHandler, true);
			}else{ //IE
				jQuery(oRootRef).unbind("activate", this.fEventHandler);
				jQuery(oRootRef).unbind("deactivate", this.fEventHandler);
			}
		}
		jQuery(window).unbind("unload", this.fDestroyHandler);
		this.oCore = null;
	};

	/**
	 * Handles the focus/blur events.
	 *
	 * @param oRootRef e.g. document.body
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.onEvent = function(oBrowserEvent){
		var oEvent = jQuery.event.fix(oBrowserEvent);

		jQuery.sap.log.debug("Event "+oEvent.type+" reached Focus Handler (target: "+oEvent.target+(oEvent.target ? oEvent.target.id : "")+")", null, "sap.ui.core.FocusHandler");

		var type = (oEvent.type == "focus" || oEvent.type == "focusin" || oEvent.type == "activate") ? "focus" : "blur";
		this.aEventQueue.push({type:type, controlId: getControlIdForDOM(oEvent.target)});
		if(this.aEventQueue.length == 1) {
			this.processEvent();
		}
	};

	/**
	 * Processes the focus/blur events in the event queue.
	 *
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.processEvent = function(){
		var oEvent = this.aEventQueue[0];
		if(!oEvent) {
			return;
		}
		if(oEvent.type == "focus"){
			this.onfocusEvent(oEvent.controlId);
		}else if(oEvent.type == "blur"){
			this.onblurEvent(oEvent.controlId);
		}
		this.aEventQueue.shift();
		if(this.aEventQueue.length > 0) {
			this.processEvent();
		}
	};

	/**
	 * Processes the focus event taken from the event queue.
	 *
	 * @param sControlId Id of the event related control
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.onfocusEvent = function(sControlId){
		this.oCurrent = sControlId;
		triggerFocusleave(this.oLast, sControlId, this.oCore);
		this.oLast = null;
	};

	/**
	 * Processes the blur event taken from the event queue.
	 *
	 * @param sControlId Id of the event related control
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.onblurEvent = function(sControlId){
		this.oLast = sControlId;
		this.oCurrent = null;
		jQuery.sap.delayedCall(0, this, "checkForLostFocus");
	};

	/**
	 * Checks for lost focus and provides events in case of losing the focus.
	 * Called in delayed manner from {@link sap.ui.core.FocusHandler#onblurEvent}.
	 *
	 * @private
	 */
	sap.ui.core.FocusHandler.prototype.checkForLostFocus = function(){
		if(this.oCurrent == null && this.oLast != null){
			triggerFocusleave(this.oLast, null, this.oCore);
		}
		this.oLast = null;
	};


	//***********************************************************
	// Utility / convenience
	//***********************************************************

	/**
	 * Returns the id of the control/element to which the given DOM
	 * reference belongs to or <code>null</code> if no such
	 * control/element exists.
	 *
	 * @param {DOMObject} oDOM the DOM reference
	 * @private
	 */
	var getControlIdForDOM = function(oDOM){
		var sId = jQuery(oDOM).closest("[data-sap-ui]").attr("id");
		if(sId) {
			return sId;
		}
		return null;
	};

	/**
	 * Calls the onsapfocusleave function on the control with id sControlId
	 * with the information about the given related control.
	 *
	 * @param {string} sControlId
	 * @param {string} sRelatedControlId
	 * @private
	 */
	var triggerFocusleave = function(sControlId, sRelatedControlId, oCore){
		var oControl = sControlId ? sap.ui.getCore().byId(sControlId) : null;
		if(oControl){
			var oRelatedControl = sRelatedControlId ? sap.ui.getCore().byId(sRelatedControlId) : null;
			var oEvent = jQuery.Event("sapfocusleave");
			oEvent.target = oControl.getDomRef();
			oEvent.relatedControlId = oRelatedControl ? oRelatedControl.getId() : null;
			oEvent.relatedControlFocusInfo = oRelatedControl ? oRelatedControl.getFocusInfo() : null;
			//TODO: Cleanup the popup! The following is shit
			var oControlUIArea = oControl.getUIArea();
			var oUiArea = null;
			if(oControlUIArea){
				oUiArea = oCore.getUIArea(oControlUIArea.getId());
			}else{
				var oPopupUIAreaDomRef = sap.ui.getCore().getStaticAreaRef();
				if(jQuery.sap.containsOrEquals(oPopupUIAreaDomRef, oEvent.target)){
					oUiArea = oCore.getUIArea(oPopupUIAreaDomRef.id);
				}
			}
			if(oUiArea) {
				oUiArea._handleEvent(oEvent);
			}
		}
	};

	/**
	 * Checks if the passed DOM reference is nested in the active DOM of the document
	 * @param {DOMNode} oDomRef The new active element
	 * @private
	 * @type boolean
	 * @returns whether the passed DOM reference is nested in the active DOM of the document
	 */
	/*function isInActiveDom(oDomRef) {
		jQuery.sap.assert(oDomRef != null);
		var oCurrDomRef = oDomRef;
		while(oCurrDomRef) {
			if(oCurrDomRef === document) return true;
			oCurrDomRef = oCurrDomRef.parentNode;
		}
		return false;
	};*/

}());
}; // end of sap.ui.core.FocusHandler

if ( !jQuery.sap.isDeclared('sap.ui.core.ResizeHandler') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.core.ResizeHandler
jQuery.sap.declare("sap.ui.core.ResizeHandler");




(function(){

	var oCoreRef = null;

	/**
	 * Constructs an instance of a sap.ui.core.ResizeHandler.
	 * Handles the resize event on registered DOM elements.
	 *
	 * Resize events on arbitrary DOM elements are not supported on Firefox and Safari.
	 * This class provides firing of resize events on Firefox by checking width
	 * and height of registered DOM elements and firing events accordingly.
	 *
	 * @class sap.ui.core.ResizeHandler
	 * @param oCore the core
	 */
	sap.ui.core.ResizeHandler = function(oCore) {
		sap.ui.base.Object.apply(this);

		oCoreRef = oCore;

		this.aResizeListeners = [];
		this.sInterval = null;

		this.iIdCounter = 0;

		this.fDestroyHandler = jQuery.proxy(this.destroy, this);

		jQuery(window).bind("unload", this.fDestroyHandler);
	};

	sap.ui.core.ResizeHandler.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);
	sap.ui.base.Object.defineClass("sap.ui.core.ResizeHandler", {
		baseType : "sap.ui.base.Object"
	});

	/**
	 * The interval which is used for checking the width/height of all attached elements.
	 * One check takes less than 1 MICROsecond (maybe even *much* less - the only confirmed fact is that 20000 checks
	 * summed up are still not measurable), so a 200 ms interval is perfectly fine.
	 * @private
	 */
	sap.ui.core.ResizeHandler.prototype.I_INTERVAL = 200;

	/**
	 * Destroy method of the Resize Handler.
	 * It unregisters the event handlers.
	 *
	 * @param {jQuery.Event} oEvent the event that initiated the destruction of the ResizeHandler
	 * @private
	 */
	sap.ui.core.ResizeHandler.prototype.destroy = function(oEvent) {
		jQuery(window).unbind("unload", this.fDestroyHandler);
		if(jQuery.browser.msie && (jQuery.browser.version == "7.0" || jQuery.browser.version == "8.0")){
			jQuery.each(this.aResizeListeners, function(index, oResizeListener){
				jQuery(oResizeListener.oDomRef).unbind("resize", oResizeListener.fHandler);
			});
		}
		oCoreRef = null;
		this.aResizeListeners = [];
		this.sInterval = null;
	};

	/**
	 * Attaches listener to resize event.
	 *
	 * @param {element} oDomRef the DOM reference
	 * @param {function} fHandler the event handler function
	 * @return {string} Registration-ID for later detaching.
	 * @private
	 */
	sap.ui.core.ResizeHandler.prototype.attachListener = function(oDomRef, fHandler){
		var iWidth = oDomRef.offsetWidth,
		iHeight = oDomRef.offsetHeight,
		sId = "rs-" + new Date().valueOf() + "-" + this.iIdCounter++;

		this.aResizeListeners.push({sId: sId, oDomRef: oDomRef, fHandler: fHandler, iWidth: iWidth, iHeight: iHeight});

		if(jQuery.browser.msie && (jQuery.browser.version == "7.0" || jQuery.browser.version == "8.0")){
			jQuery(oDomRef).bind("resize", fHandler);
		}else{
			if(!this.sInterval){
				this.sInterval = jQuery.sap.delayedCall(this.I_INTERVAL, this, "checkSizes");
			}
		}
		return sId;
	};

	/**
	 * Detaches listener from resize event.
	 *
	 * @param {string} Registration-ID returned from attachListener
	 * @private
	 */
	sap.ui.core.ResizeHandler.prototype.detachListener = function(sId){
		var that = this;
		jQuery.each(this.aResizeListeners, function(index, oResizeListener){
			if(oResizeListener.sId == sId){
				that.aResizeListeners.splice(index,1);
				if(jQuery.browser.msie && (jQuery.browser.version == "7.0" || jQuery.browser.version == "8.0")){
					jQuery(oResizeListener.oDomRef).unbind("resize", oResizeListener.fHandler);
				}
				return false; //break the loop
			};
		});

		// if list is empty now, stop interval
		if(this.aResizeListeners.length == 0){
			jQuery.sap.clearDelayedCall(this.sInterval);
			this.sInterval = null;
		}
	};

	/**
	 * Check sizes of resize elements
	 * @private
	 */
	sap.ui.core.ResizeHandler.prototype.checkSizes = function() {
		jQuery.each(this.aResizeListeners, function(index, oResizeListener){
			if(oResizeListener){
				var oDomRef = oResizeListener.oDomRef;
				if (oDomRef.offsetWidth != oResizeListener.iWidth ||
						oDomRef.offsetHeight != oResizeListener.iHeight) {
					oResizeListener.iWidth = oDomRef.offsetWidth;
					oResizeListener.iHeight = oDomRef.offsetHeight;
					var oEvent = jQuery.Event("resize");
					oEvent.target = oResizeListener.oDomRef;
					oEvent.currentTarget = oResizeListener.oDomRef;
					oResizeListener.fHandler(oEvent);
				}
			}
		});
		this.sInterval = jQuery.sap.delayedCall(this.I_INTERVAL, this, "checkSizes");
	};

	/**
	 * Registers the given handler for resize events on the given
	 * DOM reference.
	 *
	 * @param {element} oDomRef the DOM reference for which the given handler should be registered (beside the window)
	 * @param {function} fHandler the handler which should be called on a resize event
	 * @return {string} Registration ID which can be used for deregistering
	 * @public
	 */
	sap.ui.core.ResizeHandler.register = function(oDomRef, fHandler) {
		if(!oCoreRef || !oCoreRef.oResizeHandler) {
			return null;
		}
		return oCoreRef.oResizeHandler.attachListener(oDomRef, fHandler);
	};

	/**
	 * Deregisters the registered handler for resize events with the given ID.
	 *
	 * @param {string} Registration ID
	 * @public
	 */
	sap.ui.core.ResizeHandler.deregister = function(sId) {
		if(!oCoreRef || !oCoreRef.oResizeHandler) {
			return;
		}
		oCoreRef.oResizeHandler.detachListener(sId);
	};

}());
}; // end of sap.ui.core.ResizeHandler

if ( !jQuery.sap.isDeclared('sap.ui.core.RenderManager') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides the render manager sap.ui.core.RenderManager
jQuery.sap.declare("sap.ui.core.RenderManager");

if ( !jQuery.sap.isDeclared('jquery.sap.encoder') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides encoding functions for JavaScript.
jQuery.sap.declare("jquery.sap.encoder", false);

(function(){

	/*
	 * Encoding according to the Secure Programming Guide
	 * https://wiki.wdf.sap.corp/wiki/display/NWCUIAMSIM/XSS+Secure+Programming+Guide
	 */

	/**
	 * Create hex and pad to length
	 * @private
	 */
	function hex(iChar, iLength) {
		var sHex = iChar.toString(16);
		if (iLength) {
			while (iLength > sHex.length) {
				sHex = "0" + sHex;
			}
		}
		return sHex;
	}

	/**
	 * RegExp and escape function for HTML escaping
	 */
	var rHtml = /[\x00-\x2b\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\uffff]/g,
		rHtmlReplace = /[\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x9f]/,
		mHtmlLookup = {
			"<": "&lt;",
			">": "&gt;",
			"&": "&amp;",
			"\"": "&quot;"
		};

	var fHtml = function(sChar) {
		var sEncoded = mHtmlLookup[sChar];
		if (!sEncoded) {
			if (rHtmlReplace.test(sChar)) {
				sEncoded = "&#xfffd;";
			}
			else {
				sEncoded = "&#x" + hex(sChar.charCodeAt(0)) + ";";
			}
			mHtmlLookup[sChar] = sEncoded;
		}
		return sEncoded;
	};

	/**
	 * Encode the string for inclusion into HTML content/attribute
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for HTML contexts
	 */
	jQuery.sap.encodeHTML = function(sString) {
		return sString.replace(rHtml, fHtml);
	};

	/**
	 * Encode the string for inclusion into XML content/attribute
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for XML contexts
	 */
	jQuery.sap.encodeXML = function(sString) {
		return sString.replace(rHtml, fHtml);
	};

	/**
	 * Encode the string for inclusion into HTML content/attribute.
	 * Old name "escapeHTML" kept for backward compatibility
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @deprecated Has been renamed, use {@link jQuery.sap.encodeHTML} instead.
	 */
	jQuery.sap.escapeHTML = function(sString) {
		return sString.replace(rHtml, fHtml);
	};

	/**
	 * RegExp and escape function for JS escaping
	 */
	var rJS = /[\x00-\x2b\x2d\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\uffff]/g,
		mJSLookup = {};

	var fJS = function(sChar) {
		var sEncoded = mJSLookup[sChar];
		if (!sEncoded) {
			var iChar = sChar.charCodeAt(0);
			if (iChar < 256) {
				sEncoded = "\\x" + hex(iChar, 2);
			}
			else {
				sEncoded = "\\u" + hex(iChar, 4);
			}
			mJSLookup[sChar] = sEncoded;
		}
		return sEncoded;
	};

	/**
	 * Encode the string for inclusion into a JS string literal
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for a JavaScript contexts
	 */
	jQuery.sap.encodeJS = function(sString) {
		return sString.replace(rJS, fJS);
	};

	/**
	 * Encode the string for inclusion into a JS string literal.
	 * Old name "escapeJS" kept for backward compatibility
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @deprecated Since 1.3.0. Has been renamed, use {@link jQuery.sap.encodeJS} instead.
	 */
	jQuery.sap.escapeJS = function(sString) {
		return sString.replace(rJS, fJS);
	};

	/**
	 * RegExp and escape function for URL escaping
	 */
	var rURL = /[\x00-\x29\x2b\x2c\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\uffff]/g,
		mURLLookup = {};

	var fURL = function(sChar) {
		var sEncoded = mURLLookup[sChar];
		if (!sEncoded) {
			var iChar = sChar.charCodeAt(0);
			if (iChar < 128) {
				sEncoded = "%" + hex(iChar, 2);
			}
			else if (iChar < 2048) {
				sEncoded = "%" + hex((iChar >> 6) | 192, 2) +
						   "%" + hex((iChar & 63) | 128, 2);
			}
			else {
				sEncoded = "%" + hex((iChar >> 12) | 224, 2) +
						   "%" + hex(((iChar >> 6) & 63) | 128, 2) +
						   "%" + hex((iChar & 63) | 128, 2);
			}
			mURLLookup[sChar] = sEncoded;
		}
		return sEncoded;
	};

	/**
	 * Encode the string for inclusion into an URL parameter
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for a URL context
	 */
	jQuery.sap.encodeURL = function(sString) {
		return sString.replace(rURL, fURL);
	};

	/**
	 * RegExp and escape function for CSS escaping
	 */
	var rCSS = /[\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\uffff][0-9A-Fa-f]?/g;

	var fCSS = function(sChar) {
		var iChar = sChar.charCodeAt(0);
		if (sChar.length == 1) {
			return "\\" + hex(iChar);
		}
		else {
			return "\\" + hex(iChar) + " " + sChar.substr(1);
		}
	};

	/**
	 * Encode the string for inclusion into CSS string literals or identifiers
	 *
	 * @param {string} sString The string to be escaped
	 * @return The escaped string
	 * @type {string}
	 * @public
	 * @SecValidate {0|return|XSS} validates the given string for a CSS context
	 */
	jQuery.sap.encodeCSS = function(sString) {
		return sString.replace(rCSS, fCSS);
	};

	/**
	 * WhitelistEntry object
	 * @param {string} protocol The protocol of the URL
	 * @param {string} host The host of the URL
	 * @param {string} port The port of the URL
	 * @param {string} path the path of the URL
	 * @public
	 */
	function WhitelistEntry(protocol, host, port, path){
		if (protocol) {
			this.protocol = protocol.toUpperCase();
		}
		if (host) {
			this.host = host.toUpperCase();
		}
		this.port = port;
		this.path = path;
	}

	var aWhitelist = new Array();

	/**
	 * clears the whitelist for URL valiadtion
	 *
	 * @public
	 */
	jQuery.sap.clearUrlWhitelist = function() {

		aWhitelist.splice(0,aWhitelist.length);

	};

	/**
	 * Adds a whitelist entry for URL valiadtion
	 *
	 * @param {string} protocol The protocol of the URL
	 * @param {string} host The host of the URL
	 * @param {string} port The port of the URL
	 * @param {string} path the path of the URL
	 * @public
	 */
	jQuery.sap.addUrlWhitelist = function(protocol, host, port, path) {
		var oEntry = new WhitelistEntry(protocol, host, port, path);
		var iIndex = aWhitelist.length;
		aWhitelist[iIndex] = oEntry;
	};

	/**
	 * Removes a whitelist entry for URL valiadtion
	 *
	 * @param {int} iIndex index of entry
	 * @public
	 */
	jQuery.sap.removeUrlWhitelist = function(iIndex) {
		aWhitelist.splice(iIndex,1)
	};

	/**
	 * Gets the whitelist for URL valiadtion
	 *
	 * @return {string[]} whitelist
	 * @public
	 */
	jQuery.sap.getUrlWhitelist = function() {
		return aWhitelist.slice();
	};

	/**
	 * Validates an URL. Check if it's not a script or other security issue.
	 *
	 * @param {string} sUrl
	 * @return true if valid, false if not valid
	 * @public
	 */
	jQuery.sap.validateUrl = function(sUrl) {

		var result = /(?:([^:\/?#]+):)?(?:\/\/([^\/?#:]*)(?::([0-9]+))?)?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/.exec(sUrl);
		if (!result) {
			return result;
		}

		var sProtocol = result[1],
			sHost = result[2],
			sPort = result[3],
			sPath = result[4],
			sQuery = result[5],
			sHash = result[6];

		var rCheck = /[\x00-\x24\x26-\x29\x2b\x2c\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\uffff]/;

		// protocol
		if (sProtocol) {
			sProtocol = sProtocol.toUpperCase();
			if (aWhitelist.length <= 0) {
				// no whitelist -> check for default protocols
				if (!/^(https?|ftp)/i.test(sProtocol)) {
					return false;
				}
			}
		}

		// Host -> whitelist + character check (TBD)
		if (sHost) {
			sHost = sHost.toUpperCase();
		}

		// Path -> split for "/" and check if forbidden characters exist
		if (sPath) {
			var aComponents = sPath.split("/");
			for ( var i = 0; i < aComponents.length; i++) {
				var bCheck = rCheck.test(aComponents[i]);
				if (bCheck) {
					// forbidden character found
					return false;
				}
			}
		}

		// query -> Split on & and = and check if forbidden characters exist
		if (sQuery) {
			var aComponents = sQuery.split("&");
			for ( var i = 0; i < aComponents.length; i++) {
				var iPos = aComponents[i].search("=");
				if (iPos != -1) {
					var sPart1 = aComponents[i].substring(0,iPos);
					var sPart2 = aComponents[i].substring(iPos+1);
					var bCheck1 = rCheck.test(sPart1);
					var bCheck2 = rCheck.test(sPart2);
					if (bCheck1 || bCheck2) {
						// forbidden character found
						return false;
					}
				}
			}
		}

		// hash
		if (sHash) {
			if (rCheck.test(sHash)) {
				// forbidden character found
				return false;
			}
		}

		//filter whitelist
		if (aWhitelist.length > 0) {
			var bFound = false;
			for(var i=0; i<aWhitelist.length; i++){
				jQuery.sap.assert(aWhitelist[i] instanceof WhitelistEntry, "whitelist entry type wrong");
				if (!sProtocol || !aWhitelist[i].protocol || sProtocol == aWhitelist[i].protocol) {
					// protocol OK
					var bOk = false;
					if (sHost && aWhitelist[i].host && /^\*/.test(aWhitelist[i].host)) {
						// check for wildcard search at begin
						var sHostEscaped = aWhitelist[i].host.slice(1).replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
						var rFilter = RegExp(sHostEscaped + "$");
						if (rFilter.test(sHost)) {
							bOk = true;
						}
					}else if (!sHost || !aWhitelist[i].host || sHost == aWhitelist[i].host){
						bOk = true;
					}
					if (bOk){
						// host OK
						if (!aWhitelist[i].port || sPort == aWhitelist[i].port) {
							// port OK
							if (aWhitelist[i].path && /\*$/.test(aWhitelist[i].path)) {
								// check for wildcard search at end
								var sPathEscaped = aWhitelist[i].path.slice(0,-1).replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
								var rFilter = RegExp("^"+sPathEscaped);
								if (rFilter.test(sPath)) {
									bFound = true;
								}
							} else if (!aWhitelist[i].path || sPath == aWhitelist[i].path) {
								// path OK
								bFound = true;
							}
						}
					}
				}
				if (bFound) {
					break;
				}
			}
			if (!bFound) {
				return bFound;
			}
		}

		return true;
	};

	/**
	 * Strips unsafe tags and attributes from HTML.
	 * 
	 * @param {string} sHTML the HTML to be sanitized. 
	 * @param {object} [mOptions={}] options for the sanitizer
	 * @return {string} sanitized HTML
	 * @private
	 */
	jQuery.sap._sanitizeHTML = function(sHTML, mOptions) {
		return fnSanitizer(sHTML, mOptions || {
			uriRewriter: function(sUrl) {
				// by default we use the URL whitelist to check the URL's 
				if (jQuery.sap.validateUrl(sUrl)) {
					return sUrl;
				}
			} 
		});
	};
	
	/**
	 * Registers an application defined sanitizer to be used instead of the built-in one.
	 * 
	 * The given sanitizer function must have the same signature as 
	 * {@link jQuery.sap._sanitizeHTML}:
	 * 
	 * <pre>
	 *   function sanitizer(sHtml, mOptions);
	 * </pre>
	 * 
	 * The parameter <code>mOptions</code> will always be provided, but might be empty. 
	 * The set of understood options is defined by the sanitizer. If no specific 
	 * options are given, the sanitizer should run with the most secure settings.
	 * Sanitizers should ignore unknown settings. Known, but misconfigured settings should be 
	 * reported as error.
	 *  
	 * @param {function} fnSanitizer
	 * @private
	 */
	jQuery.sap._setHTMLSanitizer = function (fnSanitizer) {
		jQuery.sap.assert(typeof fnSanitizer === "function", "Sanitizer must be a function");
		fnSanitizer = fnSanitizer || defaultSanitizer;
	};

	function defaultSanitizer(sHTML, mOptions) {
		if ( !window.html || !window.html.sanitize ) {
			jQuery.sap.require("sap.ui.thirdparty.caja-html-sanitizer");
			jQuery.sap.assert(window.html && window.html.sanitize, "Sanitizer should have been loaded");
		}
		
		var oTagPolicy = mOptions.tagPolicy || window.html.makeTagPolicy(mOptions.uriRewriter, mOptions.tokenPolicy);
		return window.html.sanitizeWithPolicy(sHTML, oTagPolicy);
	}
	
	/**
	 * Globally configured sanitizer.
	 * @private
	 */
	var fnSanitizer = defaultSanitizer;
	
}());
}; // end of jquery.sap.encoder




/**
 * Creates an instance of the RenderManager.
 *
 * @class RenderManager that will take care for rendering Controls.
 *
 * The RenderManager will be available from the sap.ui.core.Core instance (available via <code>sap.ui.getCore()</code>).<br/>It
 * can be used to render Controls and Control-Trees.
 *
 * The convention for renderers belonging to some controls is the following:
 * <ul>
 * <li>for a Control e.g. <code>sap.ui.controls.InputField</code> there shall be </li>
 * <li>a renderer named <code>sap.ui.controls.InputFieldRenderer</code></li>
 * <ul>
 *
 * @see sap.ui.core.Core
 * @see sap.ui.getCore()
 *
 * @extends sap.ui.base.Object
 * @author Jens Pflueger
 * @version 1.10.0
 * @constructor
 * @public
 */
sap.ui.core.RenderManager = function() {
	this.aBuffer = [];
	this.aRenderedControls = [];
	this.aStyleStack = [{}];
};
sap.ui.core.RenderManager.prototype = jQuery.sap.newObject(sap.ui.base.Object.prototype);

(function() {

	var aCommonMethods = ["renderControl", "write", "writeEscaped", "translate", "writeAcceleratorKey", "writeControlData",
						  "writeElementData", "writeAttribute", "writeAttributeEscaped", "addClass", "writeClasses",
						  "addStyle", "writeStyles", "writeAccessibilityState",
						  "getConfiguration", "getHTML"];
	var aNonRendererMethods = ["render", "flush", "destroy"];

	sap.ui.base.Object.defineClass("sap.ui.core.RenderManager", {
		baseType : "sap.ui.base.Object",
		publicMethods : aCommonMethods.concat(aNonRendererMethods)
	});

	/**
	 * Returns the public interface of the RenderManager which can be used by Renderers.
	 *
	 * @return {sap.ui.base.Interface} the interface
	 * @private
	 */
	sap.ui.core.RenderManager.prototype.getRendererInterface = function() {
		// see sap.ui.base.Object.getInterface for reference
		var oInterface = new sap.ui.base.Interface(this, aCommonMethods);
		this.getRendererInterface = jQuery.sap.getter(oInterface);
		return oInterface;
	};

}());


/**
 * Cleans up the resources associated with this instance.
 * After the instance has been destroyed, it must not be used anymore.
 * Applications should call this function if they don't need the instance any longer.
 *
 * @public
 */
sap.ui.core.RenderManager.prototype.destroy = function() {
	this.aBuffer = [];
	this.aRenderedControls = [];
	this.aStyleStack = [{}];
};

/**
 * Returns the configuration object
 * Shortcut for <code>sap.ui.getCore().getConfiguration()</code>
 * @return {sap.ui.core.Configuration} the configuration object
 * @public
 */
sap.ui.core.RenderManager.prototype.getConfiguration = function() {
	return sap.ui.getCore().getConfiguration();
};

/**
 * Returns the renderer class for a given control instance
 *
 * @param {sap.ui.core.Control} oControl the control that should be rendered
 * @return the renderer class for a given control instance
 * @public
 */
sap.ui.core.RenderManager.prototype.getRenderer = function(oControl) {
	jQuery.sap.assert(oControl && oControl instanceof sap.ui.core.Control, "oControl must be a sap.ui.core.Control");
	return sap.ui.core.RenderManager.getRenderer(oControl);
};

/**
 * Turns the given control into its HTML representation and appends it to the
 * rendering buffer.
 *
 * If the given control is undefined or null, then nothing is rendered.
 *
 * @param {sap.ui.core.Control} oControl the control that should be rendered
 * @public
 */
sap.ui.core.RenderManager.prototype.renderControl = function(oControl) {
	jQuery.sap.assert(!oControl || oControl instanceof sap.ui.core.Control, "oControl must be a sap.ui.core.Control or empty");
	// don't render a NOTHING
	if (!oControl) {
		return;
	}

	// create stack to determine rendered parent
	if (!this.aRenderStack) {
		this.aRenderStack = new Array();
	}
	// stop the measurement of parent
	if (this.aRenderStack && this.aRenderStack.length > 0) {
		jQuery.sap.measure.pause(this.aRenderStack[0]+"---renderControl");
	}else if(oControl.getParent() && oControl.getParent().getMetadata().getName() == "sap.ui.core.UIArea"){
		jQuery.sap.measure.pause(oControl.getParent().getId()+"---rerender");
	}
	this.aRenderStack.unshift(oControl.getId());
	// start performance measurement
	jQuery.sap.measure.start(oControl.getId()+"---renderControl","Rendering of "+oControl.getMetadata().getName());

	//Remember the current buffer size to check later whether the control produced output
	var iBufferLength = this.aBuffer.length;

	var oControlStyles = {};
	if (oControl.aCustomStyleClasses && oControl.aCustomStyleClasses.length > 0) {
		oControlStyles.aCustomStyleClasses = oControl.aCustomStyleClasses; //cleared again in the writeClasses function
	}

	this.aStyleStack.push(oControlStyles);

	jQuery.sap.measure.pause(oControl.getId()+"---renderControl"); 
	// don't measure getRenderer because if Load needed its measured in Ajax call
	// but start measurement before is to see general rendering time including loading time
	var oRenderer = this.getRenderer(oControl);
	jQuery.sap.measure.resume(oControl.getId()+"---renderControl");

	// notify the control that it will be rendered soon (e.g. detached from DOM)
	this._bLocked = true;
	var oEvent = jQuery.Event("BeforeRendering");
	// store the element on the event (aligned with jQuery syntax)
	oEvent.srcControl = oControl;
	oControl._handleEvent(oEvent);
	this._bLocked = false;

	// unbind any generically bound browser event handlers
	var aBindings = oControl.aBindParameters;
	if (aBindings && aBindings.length > 0) { // if we have stored bind calls...
		var jDomRef = jQuery(oControl.getDomRef());
		if (jDomRef && jDomRef[0]) { // ...and we have a DomRef
			for (var i = 0; i < aBindings.length; i++) {
				var oParams = aBindings[i];
				jDomRef.unbind(oParams.sEventType, oParams.fnProxy);
			}
		}
	}

	//Render the control using the RenderManager interface
	oRenderer.render(this.getRendererInterface(), oControl);

	this.aStyleStack.pop();

	//Remember the rendered control
	this.aRenderedControls.push(oControl);

	//Check whether the control has produced HTML
	oControl.bOutput = this.aBuffer.length != iBufferLength;

	// end performance measurement
	jQuery.sap.measure.end(oControl.getId()+"---renderControl");
	this.aRenderStack.shift();
	// resume the measurement of parent
	if (this.aRenderStack && this.aRenderStack.length > 0) {
		jQuery.sap.measure.resume(this.aRenderStack[0]+"---renderControl");
	}else if(oControl.getParent() && oControl.getParent().getMetadata().getName() == "sap.ui.core.UIArea"){
		jQuery.sap.measure.resume(oControl.getParent().getId()+"---rerender");
	}
};

/**
 * Renders the given {@link sap.ui.core.Control} and finally returns
 * the content of the rendering buffer.
 * Ensures the buffer is restored to the state before calling this method.
 *
 * @param {sap.ui.core.Control}
 *            oControl the Control whose HTML should be returned.
 * @return {string} the resulting HTML of the provided control
 * @deprecated Since version 0.15.0. Use <code>flush()</code> instead render content outside the rendering phase.
 * @public
 */
sap.ui.core.RenderManager.prototype.getHTML = function(oControl) {
	jQuery.sap.assert(oControl && oControl instanceof sap.ui.core.Control, "oControl must be a sap.ui.core.Control");

	var tmp = this.aBuffer;
	var aResult = this.aBuffer = [];
	this.renderControl(oControl);
	this.aBuffer = tmp;
	return aResult.join("");
};

(function() {

	//Returns the information of the current focus
	var storeCurrentFocus = function(){
		var oCore = sap.ui.getCore();

		// Store current focus
		var sFocusedControlId = oCore.getCurrentFocusedControlId(),
			oFocusInfo = null,
			oFocusedDomRef = null;

		if(sFocusedControlId){
			var oFocusedControl = oCore.getElementById(sFocusedControlId);
			if(oFocusedControl){
				oFocusInfo = oFocusedControl.getFocusInfo();
				oFocusedDomRef = oFocusedControl.getFocusDomRef();
			}
		}

		return {focusedControlId: sFocusedControlId, focusInfo: oFocusInfo, focusDomRef: oFocusedDomRef};
	};

	//Does everthing needed after the rendering (restore focus, calling "onAfterRendering", initialize event binding)
	var finalizeRendering = function(oRM, aRenderedControls, oStoredFocusInfo){
		// Notify the behavior object that the controls will be attached to DOM
		for (var i = 0, size = aRenderedControls.length; i < size; i++) {
			var oControl = aRenderedControls[i];
			if (oControl.bOutput) {
				oRM._bLocked = true;
				var oEvent = jQuery.Event("AfterRendering");
				// store the element on the event (aligned with jQuery syntax)
				oEvent.srcControl = oControl;
				// start performance measurement
				jQuery.sap.measure.start(oControl.getId()+"---AfterRendering","AfterRendering of "+oControl.getMetadata().getName());
				oControl._handleEvent(oEvent);
				// end performance measurement
				jQuery.sap.measure.end(oControl.getId()+"---AfterRendering");
				oRM._bLocked = false;
			}
		}

		//finally restore focus
		try{
			if (oStoredFocusInfo && oStoredFocusInfo.focusedControlId) {
				var oFocusedControl = sap.ui.getCore().getElementById(oStoredFocusInfo.focusedControlId);
				if (oFocusedControl && oFocusedControl.getFocusDomRef() != oStoredFocusInfo.focusDomRef ) {
					oFocusedControl.applyFocusInfo(oStoredFocusInfo.focusInfo);
				}
			}
		}catch(e){
			jQuery.sap.log.warning("Problems while restore focus after rendering: " + e, null, oRM);
		}

		// Re-bind any generically bound browser event handlers (must happen after restoring focus to avoid focus event)
		for (var i = 0, size = aRenderedControls.length; i < size; i++) {
			var oControl = aRenderedControls[i],
				aBindings = oControl.aBindParameters;

			if (aBindings && aBindings.length > 0) { // if we have stored bind calls...
				var jDomRef = jQuery(oControl.getDomRef());
				if (jDomRef && jDomRef[0]) { // ...and we have a DomRef - TODO: this check should not be required right after rendering...
					for (var j = 0; j < aBindings.length; j++) {
						var oParams = aBindings[j];
						jDomRef.bind(oParams.sEventType, oParams.fnProxy);
					}
				}
			}
		}
	};

	/**
	 * Renders the content of the rendering buffer into the provided DOMNode.
	 *
	 * This function must not be called within control renderers.
	 *
	 * Usage:
	 * <pre>
	 * // Create a new instance of the RenderManager
	 * var rm = sap.ui.getCore().createRenderManager();
	 * // Use the writer API to fill the buffers
	 * rm.write(...);
	 * rm.renderControl(oControl);
	 * rm.write(...);
	 * ...
	 * // Finally flush the buffer into the provided DOM node (The current content is removed)
	 * rm.flush(oDomNode);
	 * // If the instance is not needed anymore, destroy it
	 * rm.destroy();
	 * </pre>
	 *
	 * @param {DOMNode} oTargetDomNode The node in the dom where the buffer should be flushed into.
	 * @param {boolean} bDoNotPreserve flag, whether to not preserve (true) the content or to preserve it (false).
	 * @param {boolean|int} vInsert flag, whether to append (true) or replace (false) the buffer of the target dom node or to insert at a certain position (int)
	 * @public
	 */
	sap.ui.core.RenderManager.prototype.flush = function(oTargetDomNode, bDoNotPreserve, vInsert) {
		jQuery.sap.assert((typeof oTargetDomNode === "object") && (oTargetDomNode.ownerDocument == document), "oTargetDomNode must be a DOM element");
		if(this.bRendererMode){
			jQuery.sap.log.info("Flush must not be called from control renderers. Call ignored.", null, this);
			return;
		}
		
		var RenderManager = sap.ui.core.RenderManager;

		// preserve HTML content before flushing HTML into target DOM node
		if (!bDoNotPreserve && (typeof vInsert !== "number") && !vInsert) { // expression mimics the conditions used below
			RenderManager.preserveContent(oTargetDomNode);
		}

		var oStoredFocusInfo = storeCurrentFocus();

		var vHTML = RenderManager.prepareHTML5(this.aBuffer.join("")); // Note: string might have been converted to a node list!

		if(this._fPutIntoDom){
			//Case when render function was called
			this._fPutIntoDom(oTargetDomNode, vHTML);
		}else{
			for(var i=0; i<this.aRenderedControls.length; i++){
				//TODO It would be enough to loop over the controls for which renderControl was initially called but for this
				//we have to manage an additional array. Rethink about later.
				var oldDomNode = this.aRenderedControls[i].getDomRef();
				if(oldDomNode && !RenderManager.isPreservedContent(oldDomNode)) {
					jQuery(oldDomNode).remove();
				}
			}
			if (typeof vInsert === "number") {
				if (vInsert <= 0) { // new HTML should be inserted at the beginning
					jQuery(oTargetDomNode).prepend(vHTML);
				} else { // new element should be inserted at a certain position > 0
					var $predecessor = jQuery(oTargetDomNode).children().eq(vInsert - 1); // find the element which should be directly before the new one
					if ($predecessor.length === 1) { 
						// element found - put the HTML in after this element
						$predecessor.after(vHTML);
					} else { 
						// element not found (this should not happen when properly used), append the new HTML
						jQuery(oTargetDomNode).append(vHTML);
					}
				}
			} else if (!vInsert) {
				jQuery(oTargetDomNode).html(vHTML); // Put the HTML into the given DOM Node
			} else {
				jQuery(oTargetDomNode).append(vHTML); // Append the HTML into the given DOM Node
			}
		}
		
		finalizeRendering(this, this.aRenderedControls, oStoredFocusInfo);

		this.aRenderedControls = [];
		this.aBuffer = [];
		this.aStyleStack = [{}];
	};

	/**
	 * Renders the given control to the provided DOMNode.
	 *
	 * If to control is already rendered in the provided DOMNode the DOM of the control is replaced. If the control
	 * is already rendered somewhere else the current DOM of the control is removed and the new DOM is appended
	 * to the provided DOMNode.
	 *
	 * This function must not be called within control renderers.
	 *
	 * @param {sap.ui.core.Control} oControl the Control that should be rendered.
	 * @param {DOMNode} oTargetDomNode The node in the dom where the result of the rendering should be inserted.
	 * @public
	 */
	sap.ui.core.RenderManager.prototype.render = function(oControl, oTargetDomNode) {
		jQuery.sap.assert(oControl && oControl instanceof sap.ui.core.Control, "oControl must be a control");
		jQuery.sap.assert(typeof oTargetDomNode === "object" && oTargetDomNode.ownerDocument == document, "oTargetDomNode must be a DOM element");
		if(this.bRendererMode){
			jQuery.sap.log.info("Render must not be called from control renderers. Call ignored.", null, this);
			return;
		}
		if(this._bLocked){
			jQuery.sap.log.error("Render must not be called within Before or After Rendering Phase. Call ignored.", null, this);
			return;
		}

		// Reset the buffer before rendering
		this.aBuffer = [];

		// Retrieve the markup (the rendering phase)
		this.renderControl(oControl);

		// FIXME: MULTIPLE ROOTS
		// The implementation of this method doesn't support multiple roots for a control.
		// Affects all places where 'oldDomNode' is used
		this._fPutIntoDom = function(oTarget, vHTML){

			if(oControl && oTargetDomNode){

				var oldDomNode = oControl.getDomRef();
				if ( sap.ui.core.RenderManager.isPreservedContent(oldDomNode) ) {
					// use placeholder instead
					oldDomNode = jQuery.sap.byId("sap-ui-dummy-" + oControl.getId())[0] || oldDomNode;
				}
				var bNewTarget = oldDomNode && oldDomNode.parentNode != oTargetDomNode;

				var fAppend = function(){
					var jTarget = jQuery(oTargetDomNode);
					if(oTargetDomNode.innerHTML == ""){
						jTarget.html(vHTML);
					}else{
						jTarget.append(vHTML);
					}
				};

				if(bNewTarget){ //Control was rendered already and is now moved to different location

					if(!sap.ui.core.RenderManager.isPreservedContent(oldDomNode)) {
						jQuery(oldDomNode).remove();
					}

					if(vHTML) {
						fAppend();
					}

				}else{ //Control either rendered initially or rerendered at the same location

					if(vHTML){
						if(oldDomNode){
							jQuery(oldDomNode).replaceWith(vHTML);
						}else{
							fAppend();
						}
					}else{
						jQuery(oldDomNode).remove();
					}

				}

			}

		};

		this.flush(oTargetDomNode, true);

		this._fPutIntoDom = null;
	};

}());


//#################################################################################################
// Static Methods
//#################################################################################################

/**
 * Returns the renderer class for a given control instance
 *
 * @param {sap.ui.core.Control}
 *            oControl the control that should be rendered
 * @type function
 * @return the renderer class for a given control instance
 * @static
 * @public
 */
sap.ui.core.RenderManager.getRenderer = function(oControl) {
	jQuery.sap.assert(oControl && oControl instanceof sap.ui.core.Control, "oControl must be a sap.ui.core.Control");

	return oControl.getMetadata().getRenderer();
};

/**
 * Makes the HTML5 tags known to older IE browsers; to be called once before rendering happens.
 *
 * Applies two workarounds
 * <ol>
 * <li>1. "SHIV": create each HTML5 tag once in the window document to make IE8 aware of it
 * <li>2. "INNERSHIV": IE8 fails when using innerHTML in conjunction with HTML5 tags for a DOM element __not__ part of the document.
 *        prepareHTML5 uses a dummy DOM element to convert the innerHTML to a set of DOM nodes first.
 * </ol>
 * @static
 * @private
 */
//Called once by the Core during initialization
sap.ui.core.RenderManager.initHTML5Support = function() {
	if(jQuery.browser.msie && (jQuery.browser.version === "8.0" || jQuery.browser.version === "7.0")){ // IE8 is recognized as "7.0"!!

		var aTags = [ "article", "aside", "audio", "canvas", "command", "datalist", "details",
				"figcaption", "figure", "footer", "header", "hgroup", "keygen", "mark", "meter", "nav",
				"output", "progress", "rp", "rt", "ruby", "section", "source", "summary", "template", "time", "video", "wbr" ];

		// 1. SHIV, create each HTML5 element once to make IE8 recognize it
		// see http://paulirish.com/2011/the-history-of-the-html5-shiv/ for an explanation
		for (var i = 0; i < aTags.length; i++) {
			document.createElement(aTags[i]);
		}

		// 2. INNERSHIV, converts string with HTML5 tags to DOM nodes before using them with jQuery
		// see http://jdbartlett.com/innershiv/ for an explanation of the matter
		var rhtmltags = new RegExp("<(" + aTags.join("|") + ")(\\s|>)", "i");
		var d = null;
		sap.ui.core.RenderManager.prepareHTML5 = function(sHTML) {
			if ( sHTML && sHTML.match(rhtmltags) ) {
				if(!d){
					d = document.createElement('div');
					d.style.display = 'none';
				}

				var e = d.cloneNode(true);
				document.body.appendChild(e);
				e.innerHTML = sHTML.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
				document.body.removeChild(e);

				return e.childNodes;
			}
			return sHTML;
		};

		jQuery.sap.log.info("IE8 HTML5 support activated");

	}else{

		jQuery.sap.log.info("no IE8 HTML5 support required");

		sap.ui.core.RenderManager.prepareHTML5 = function(sHTML) {
			return sHTML;
		};
	}
};


//#################################################################################################
// Methods for preserving HTML content
//#################################################################################################

(function() {

	var ID_PRESERVE_AREA = "sap-ui-preserve";
	var ATTR_PRESERVE_MARKER = "data-sap-ui-preserve";

	function getPreserveArea() {
		var $preserve = jQuery("#"+ID_PRESERVE_AREA);
		if ($preserve.length === 0){
			$preserve = jQuery("<DIV/>",{role:"application",id:ID_PRESERVE_AREA}).
				addClass("sapUiHidden").
				appendTo(document.body);
		}
		return $preserve;
	}

	/**
	 * Collects descendants of the given root node that need to be preserved before the root node
	 * is wiped out. The "to-be-preserved" nodes are moved to a special, hidden 'preserve' area.
	 *
	 * A node is declared "to-be-preserved" when it has the <code>data-sap-ui-preserve</code>
	 * attribute set. When the optional parameter <code>bPreserveNodesWithId</code> is set to true,
	 * then nodes with an id are preserved as well and their <code>data-sap-ui-preserve</code> attribute
	 * is set automatically. This option is used by UIAreas when they render for the first time and
	 * simplifies the handling of predefined HTML content in a web page.
	 *
	 * The "to-be-preserved" nodes are searched with a depth first search and moved to the 'preserve'
	 * area in the order that they are found. So for direct siblings the order should be stable.
	 *
	 * @param {DOMNode} oRootNode to search for "to-be-preserved" nodes
	 * @param {boolean} [bPreserveRoot=false] whether to preserve the root itself
	 * @param {boolean} [bPreserveNodesWithId=false] whether to preserve nodes with an id as well
	 * @public
	 * @static
	 */
	sap.ui.core.RenderManager.preserveContent = function(oRootNode, bPreserveRoot, bPreserveNodesWithId) {
		jQuery.sap.assert(typeof oRootNode === "object" && oRootNode.ownerDocument == document, "oRootNode must be a DOM element");

		sap.ui.getCore().getEventBus().publish("sap.ui","__preserveContent", { domNode : oRootNode});

		var $preserve = getPreserveArea();

		function check($candidates) {

			$candidates.each(function(i,candidate) {

				// don't process the preserve area or the static area
				if ( candidate.id === ID_PRESERVE_AREA || sap.ui.getCore().isStaticAreaRef(candidate)) {
					return;
				}

				var $candidate = jQuery(candidate);

				if ( $candidate.attr(ATTR_PRESERVE_MARKER) )  { // node is marked with the preserve marker
					// when the current node is the root node then we're doing a single control rerendering
					if ( candidate === oRootNode ) {
						var $placeholder = jQuery("<DIV/>", { id: "sap-ui-dummy-" + candidate.id}).addClass("sapUiHidden");
						$placeholder.insertBefore($candidate);
					}
					$preserve.append($candidate);
				} else if ( bPreserveNodesWithId && candidate.id ) {
					sap.ui.core.RenderManager.markPreservableContent($candidate, candidate.id);
					$preserve.append($candidate);
					return;
				}

				// don't dive into nested UIAreas. They are preserved together with any preserved parent (e.g. HTML control)
				if ( !$candidate.attr("data-sap-ui-area") ) {
					check($candidate.children());
				}
			});
		}

		jQuery.sap.measure.start(oRootNode.id+"---preserveContent","preserveContent for "+oRootNode.id);
		check(bPreserveRoot? jQuery(oRootNode) : jQuery(oRootNode).children());
		jQuery.sap.measure.end(oRootNode.id+"---preserveContent");
	};

	/**
	 * Searches "to-be-preserved" nodes for the given control id.
	 *
	 * @param {string} sId control id to search content for.
	 * @return {jQuery} a jQuery collection representing the found content
	 * @public
	 * @static
	 */
	sap.ui.core.RenderManager.findPreservedContent = function(sId) {
		jQuery.sap.assert(typeof sId === "string", "sId must be a string");
		var $preserve = getPreserveArea(),
			$content = $preserve.children("[" + ATTR_PRESERVE_MARKER + "='" + sId.replace(/(:|\.)/g,'\\$1') + "']");
		return $content;
	};

	/**
	 * Marks the given content as "to-be-preserved" for a control with the given id.
	 * When later on the content has been preserved, it can be found by giving the same id.
	 *
	 * @param {jQuery} $content a jQuery collection of DOM objects to be marked
	 * @param {string} sId id of the control to associate the content with
	 * @static
	 */
	sap.ui.core.RenderManager.markPreservableContent = function($content, sId) {
		$content.attr(ATTR_PRESERVE_MARKER, sId);
	};

	/**
	 * Checks whether the given DOM node is part of the 'preserve' area.
	 *
	 * @param {DOMNode} oDomNode
	 * @return {boolean} whether node is part of 'preserve' area
	 * @private
	 * @static
	 */
	sap.ui.core.RenderManager.isPreservedContent = function(oDomNode) {
		return ( oDomNode && oDomNode.getAttribute(ATTR_PRESERVE_MARKER) && oDomNode.parentNode && oDomNode.parentNode.id == ID_PRESERVE_AREA );
	};

	/**
	 * Returns the hidden area reference belonging to this window instance.
	 *
	 * @return {DOMNode}the hidden area reference belonging to this core instance.
	 * @public
	 * @static
	 */
	sap.ui.core.RenderManager.getPreserveAreaRef = function() {
		return getPreserveArea()[0];
	};

}());


//#################################################################################################
// Methods for 'Buffered writer' functionality... (all public)
// i.e. used methods in render-method of Renderers
//#################################################################################################

/**
 * Write the given texts to the buffer
 * @param {string|number ...} sText (can be a number too)
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 * @SecSink {*|XSS}
 */
sap.ui.core.RenderManager.prototype.write = function(/** string|number */ sText /* ... */) {
	jQuery.sap.assert(( typeof sText === "string") || ( typeof sText === "number"), "sText must be a string or number");
	this.aBuffer.push.apply(this.aBuffer, arguments);
	return this;
};

/**
 * Escape text for HTML and write it to the buffer
 * @param {string} sText
 * @param {boolean} bLineBreaks Whether to convert linebreaks into <br> tags
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeEscaped = function(/** string */ sText, bLineBreaks) {
	jQuery.sap.assert( typeof sText === "string", "sText must be a string");
	if (bLineBreaks) {
		var aLines = sText.split("\n");
		for (var i = 0; i < aLines.length; i++) {
			aLines[i] = jQuery.sap.encodeHTML(aLines[i]);
		}
		sText = aLines.join("<br>");
	} else {
		sText = jQuery.sap.encodeHTML(sText);
	}
	this.aBuffer.push(sText);
	return this;
};


/**
 * @deprecated Not implemented - DO NOT USE
 * @public
 */
sap.ui.core.RenderManager.prototype.translate = function(/** string */ sKey) {
	// TODO
};

/**
 * @deprecated Not implemented - DO NOT USE
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeAcceleratorKey = function() {
	/*
	if (bAlt && !bCtrl && !bArrowKey) {
		// Keyboard helper provides means for visualizing access keys.
		// keydown modifies some CSS rule for showing underlines
		// <span><u class="sapUiAccessKey">H</u>elp me</span>
		UCF_KeyboardHelper.showAccessKeys();
	}
	*/
	return this;
};

/**
 * Adds a style property to the style collection if the value is not empty or null
 * The style collection is flushed if it is written to the buffer using {@link #writeStyle}
 *
 * @param {string} sName name of the CSS property to write
 * @param {string|float} value value to write
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 * @SecSink {0 1|XSS} Styles are written to HTML without validation
 */
sap.ui.core.RenderManager.prototype.addStyle = function(sName, value) {
	jQuery.sap.assert(typeof sName === "string", "sName must be a string");
	if (value) {
		jQuery.sap.assert((typeof value === "string" || typeof value === "number"), "value must be a string or a float");
		var oStyle = this.aStyleStack[this.aStyleStack.length-1];
		if (!oStyle.aStyle) {
			oStyle.aStyle = [];
		}
		oStyle.aStyle.push(sName + ":" + value);
	}
	return this;
};

/**
 * Writes and flushes the style collection
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeStyles = function() {
	var oStyle = this.aStyleStack[this.aStyleStack.length-1];
	if (oStyle.aStyle) {
		this.write(" style=\"" +oStyle.aStyle.join(";") +"\" ");
	}
	oStyle.aStyle = null;
	return this;
};

/**
 * Adds a class to the class collection if the name is not empty or null.
 * The class collection is flushed if it is written to the buffer using {@link #writeClasses}
 *
 * @param {string} sName name of the class to be added; null values are ignored
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 * @SecSink {0|XSS} Classes are written to HTML without validation
 */
sap.ui.core.RenderManager.prototype.addClass = function(sName) {
	if (sName) {
		jQuery.sap.assert(typeof sName === "string", "sName must be a string");
		var oStyle = this.aStyleStack[this.aStyleStack.length-1];
		if (!oStyle.aClasses) {
			oStyle.aClasses = [];
		}
		oStyle.aClasses.push(sName);
	}
	return this;
};

/**
 * Writes and flushes the class collection (all CSS classes added by "addClass()" since the last flush).
 * Also writes the custom style classes added by the application with "addStyleClass(...)". Custom classes are
 * added by default from the currently rendered control. If an oElement is given, this Element's custom style
 * classes are added instead. If oElement === false, no custom style classes are added.
 *
 * @param {sap.ui.core.Element | boolean} [oElement] an Element from which to add custom style classes (instead of adding from the control itself)
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeClasses = function(oElement) {
	jQuery.sap.assert(!oElement || typeof oElement === "boolean" || oElement instanceof sap.ui.core.Element, "oElement must be empty, a boolean, or a sap.ui.core.Element");
	var oStyle = this.aStyleStack[this.aStyleStack.length-1];

	// Custom classes are added by default from the currently rendered control. If an oElement is given, this Element's custom style
	// classes are added instead. If oElement === false, no custom style classes are added.
	var aCustomClasses = oElement ? oElement.aCustomStyleClasses : ((oElement === false) ? [] : oStyle.aCustomStyleClasses);

	if (oStyle.aClasses || aCustomClasses) {
		var aClasses = [].concat(oStyle.aClasses || [], aCustomClasses || []);
		aClasses.sort();
		aClasses = jQuery.map(aClasses, function(n, i){
			return (i==0 || n != aClasses[i-1]) ? n : null;
		});
		this.write(" class=\"", aClasses.join(" "), "\" "); 
	}
	
	if (!oElement) {
		oStyle.aCustomStyleClasses = null;
	}
	oStyle.aClasses = null;
	return this;
};

/**
 * Writes the controls data into the HTML.
 * Control Data consists at least of the id of a control
 * @param {sap.ui.core.Control} oControl the control whose identifying information should be written to the buffer
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeControlData = function(oControl) {
	jQuery.sap.assert(oControl && oControl instanceof sap.ui.core.Control, "oControl must be a sap.ui.core.Control");
	this.writeElementData(oControl);
	return this;
};

/**
 * Writes the elements data into the HTML.
 * Element Data consists at least of the id of a element
 * @param {sap.ui.core.Element} oElement the element whose identifying information should be written to the buffer
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeElementData = function(oElement) {
	jQuery.sap.assert(oElement && oElement instanceof sap.ui.core.Element, "oElement must be a sap.ui.core.Element");
	var sId = oElement.getId();
	if(sId) {
		this.writeAttribute("id", sId).writeAttribute("data-sap-ui", sId);
	}
	var aData = oElement.getCustomData();
	var l = aData.length;
	for (var i = 0; i < l; i++) {
		var oData = aData[i];
		if (oData.getWriteToDom()) { // application wants this to be written to the DOM, but there are some conditions for this to work
			var key = oData.getKey();
			if (typeof oData.getValue() === "string") {
				if ((sap.ui.core.ID.isValid(key)) && (key.indexOf(":") == -1) && (key.indexOf("sap-ui") !== 0)) {
					this.writeAttributeEscaped("data-" + key, oData.getValue());
				} else { // error case
					jQuery.sap.log.error("CustomData with key " + key + " should be written to HTML of " + this + " but the key is not valid (must be a valid sap.ui.core.ID without any colon and may not start with 'sap-ui').");
				}
			} else { // error case: non-string value
				jQuery.sap.log.error("CustomData with key " + key + " should be written to HTML of " + this + " but the value is not a string.");
			}
		}
	}
	return this;
};

/**
 * Writes the attribute and its value into the HTML
 * @param {string} sName the name of the attribute
 * @param {string | number | boolean} value the value of the attribute
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 * @SecSink {0 1|XSS} Attributes are written to HTML without validation
 */
sap.ui.core.RenderManager.prototype.writeAttribute = function(sName, value) {
	jQuery.sap.assert(typeof sName === "string", "sName must be a string");
	jQuery.sap.assert(typeof value === "string" || typeof value === "number" || typeof value === "boolean", "value must be a string, number or boolean");
	this.write(" ", sName, "=\"", value, "\"");
	return this;
};

/**
 * Writes the attribute and its value into the HTML
 * @param sName the name of the attribute
 * @param sValue the value of the attribute
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 * @SecSink {0|XSS}
 */
sap.ui.core.RenderManager.prototype.writeAttributeEscaped = function(sName, sValue) {
	// writeAttribute asserts
	this.writeAttribute(sName, jQuery.sap.escapeHTML(sValue));
	return this;
};

/**
 * Writes the accessibility state (see WAI-ARIA specification) of the provided element into the HTML
 * based on the element's properties and associations.
 *
 * The ARIA properties are only written when the accessibility feature is activated in the UI5 configuration.
 *
 * The following properties/values to ARIA attribute mappings are done (if the element does have such properties):
 * <code>editable===false</code> => <code>aria-readonly="true"</code>
 * <code>enabled===false</code> => <code>aria-disabled="true"</code>
 * <code>visible===false</code> => <code>aria-hidden="true"</code>
 * <code>required===true</code> => <code>aria-required="true"</code>
 * <code>selected===true</code> => <code>aria-selected="true"</code>
 * <code>checked===true</code> => <code>aria-checked="true"</code>
 *
 * Additionally the association <code>ariaDescribedBy</code> and <code>ariaLabelledBy</code> are used to write
 * the id lists of the ARIA attributes <code>aria-describedby</code> and <code>aria-labelledby</code>.
 *
 * Note: This function is only a heuristic of a control property to ARIA attribute mapping. Control developers
 * have to check whether it fullfills their requirements. In case of problems (for example the RadioButton has a
 * <code>selected</code> property but must provide an <code>aria-checked</code> attribute) the auto-generated
 * result of this function can be influenced via the parameter <code>mProps</code> as described below.
 *
 * The parameter <code>mProps</code> can be used to either provide additional attributes which should be added and/or
 * to avoid the automatic generation of single ARIA attributes. The 'aria-' prefix will be prepended automatically to the keys
 * (Exception: Attribute 'role' does not get the prefix 'aria-').
 *
 * Examples:
 * <code>{hidden : true}</code> results in <code>aria-hidden="true"</code> independent of the precense or absence of
 * the visibility property.
 * <code>{hidden : null}</code> ensures that no <code>aria-hidden</code> attribute is written independent of the precense
 * or absence of the visibility property.
 * The function behaves in the same way for the associations <code>ariaDescribedBy</code> and <code>ariaLabelledBy</code>.
 * To append additional values to the auto-generated <code>aria-describedby</code> and <code>aria-labelledby</code> attributes
 * the following format can be used:
 * <code>{describedby : {value: "id1 id2", append: true}}</code> => <code>aria-describedby="ida idb id1 id2"</code> (assuming that "ida idb"
 * is the auto-generated part based on the association <code>ariaDescribedBy</code>).
 *
 * @param {sap.ui.core.Element}
 *            [oElement] the element whose accessibility state should be rendered
 * @param {Object}
 *            [mProps] a map of properties that should be added additionally or changed.
 * @return {sap.ui.core.RenderManager} this render manager instance to allow chaining
 * @public
 */
sap.ui.core.RenderManager.prototype.writeAccessibilityState = function(oElement, mProps) {
	if(!sap.ui.getCore().getConfiguration().getAccessibility()){
		return this;
	}

	if(arguments.length == 1 && !(oElement instanceof sap.ui.core.Element)) {
		mProps = oElement;
		oElement = null;
	}

	var mAriaProps = {};

	if(oElement != null) {
		var oMetadata = oElement.getMetadata();
		oMetadata._enrichChildInfos();

		function addACCForProp(sElemProp, sACCProp, oVal){
			var oProp = oMetadata.getAllProperties()[sElemProp];
			if(oProp && oElement[oProp._sGetter]() === oVal){
				mAriaProps[sACCProp] = "true";
			}
		}

		function addACCForAssoc(sElemAssoc, sACCProp){
			var oAssoc = oMetadata.getAllAssociations()[sElemAssoc];
			if(oAssoc && oAssoc.multiple){
				var aIds = oElement[oAssoc._sGetter]();
				if(aIds.length > 0){
					mAriaProps[sACCProp] = aIds.join(" ");
				}
			}
		}

		addACCForProp("editable", "readonly", false);
		addACCForProp("enabled", "disabled", false);
		addACCForProp("visible", "hidden", false);
		addACCForProp("required", "required", true);
		addACCForProp("selected", "selected", true);
		addACCForProp("checked", "checked", true);
		addACCForAssoc("ariaDescribedBy", "describedby");
		addACCForAssoc("ariaLabelledBy", "labelledby");
	}

	if(mProps){
		function checkValue(v){
			var type = typeof(v);
			return v === null || v === "" || type === "number" || type === "string" || type === "boolean";
		}
		
		var prop = {};
		var x, val, type, autoVal;
		
		for(x in mProps){
			val = mProps[x];
			if(checkValue(val)){
				prop[x] = val;
			}else if(typeof(val) === "object" && checkValue(val.value)){
				autoVal = "";
				if(val.append && (x === "describedby" || x === "labelledby")){
					autoVal = mAriaProps[x] ? mAriaProps[x]+" " : "";
				}
				prop[x] = autoVal + val.value;
			}
		}
		
		//The auto-generated values above can be overridden or reset (via null)
		jQuery.extend(mAriaProps, prop);
	}

	// allow parent (e.g. FormElement) to overwrite or enhance aria attributes
	if (oElement instanceof sap.ui.core.Element && oElement.getParent() && oElement.getParent().enhanceAccessibilityState) {
		oElement.getParent().enhanceAccessibilityState(oElement, mAriaProps);
	}

	for(var p in mAriaProps) {
		if(mAriaProps[p] != null && mAriaProps[p] !== ""){ //allow 0 and false but no null, undefined or empty string
			this.writeAttribute(p === "role" ? p : "aria-"+p, mAriaProps[p]);
		}
	}

	return this;
};

}; // end of sap.ui.core.RenderManager

if ( !jQuery.sap.isDeclared('sap.ui.core.UIArea') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.core.UIArea
jQuery.sap.declare("sap.ui.core.UIArea");
if ( !jQuery.sap.isDeclared('jquery.sap.ui') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// A bridge between the jQuery.sap plugin and the SAPUI5 Core
jQuery.sap.declare("jquery.sap.ui", false);

//jQuery.sap.require("sap.ui.core.Core"); // cyclic

// !!!!!!!!!!!!!!!!!!!!!!!!!!
// !!     EXPERIMENTAL     !!
// !!!!!!!!!!!!!!!!!!!!!!!!!!
(function() {

	// FIXME Too tough or just right?
	if(!jQuery.sap) {
		throw "Initialisation of jQuery.sap.ui failed. jQuery.sap plugin required!";
	}
	if(!window.sap || !window.sap.ui) {
		jQuery.sap.fatal("Initialisation of jQuery.sap.ui failed. Global SAP UI namespace required!");
	}

	//ensure not to initialize twice
	if(jQuery.sap.ui) {
		return;
	}

//	/**
//	 * Root Namespace for the jQuery UI-Layer plugin provided by SAP AG.
//	 *
//	 * @version 1.10.0
//	 * @namespace
//	 * @public
//	 */
//	jQuery.sap.ui = {};

	function fUIAreaFilter(idx){
		return sap.ui.getCore().getUIArea(this.id) != null;
	}
	function fgetUIArea(idx, odomref){
		return sap.ui.getCore().getUIArea(this.id);
	}
	function fgetUIAreaOfCtrl(oCtrl, idx){
		return oCtrl.getUIArea().getInterface();
	}

	/**
	 * @public
	 * @author SAP AG
	 */
	jQuery.fn.root = function(oRootControl) {
		var tmp;
		// handle 'setRoot'
		if(oRootControl) {
			sap.ui.getCore().setRoot(this.get(0), oRootControl);
			return this;
		}
		// and 'getRoot' behavior.
		var aControls = this.control();
		if (aControls.length > 0) {
			return jQuery.map(aControls, fgetUIAreaOfCtrl);
		}

		var aUIAreas = this.uiarea();

		if (aUIAreas.length > 0) {
			// we have UIAreas
			return aUIAreas;
		}

		// create UIAreas
		this.each(function(idx){
			sap.ui.getCore().createUIArea(this);
		});
		return this;
	};

	/**
	 * @public
	 */
	jQuery.fn.uiarea = function(iIdx) {
		// UIAreas need to have IDs... so reduce to those elements first
		var aUIAreas = this.slice("[id]").filter(fUIAreaFilter).map(fgetUIArea).get();
		return typeof(iIdx) === "number"?aUIAreas[iIdx]:aUIAreas;
	};

	/**
	 * Function identifying the closest SAPUI5 Control in the given jQuery context (provided via jQuery.map method).
	 * @private
	 */
	function fgetControl() {
		// as with jQuery 1.4.3 and 1.4.4 there is a big problem here, we increase checks here
		if(!this || !this.nodeType || this.nodeType === 9) {
			return null;
		} // in this case, we are on the HTML Document and cannot do anything
		// in IE8 'closest' might fail (e.g. when the element is not in the current document tree)
		// The following line would probably also work for the 'try-catch' below but induce performance penalty in EVERY call of this method.
		// if(jQuery(document.documentElement).has(this)) {
		try{
			var sId = jQuery(this).closest("[data-sap-ui]").attr("id");
			return sId ? sap.ui.getCore().byId(sId) : null;
		} catch(e){
			// probably IE8 case where element is not in current document tree... ==> there is no current control
			return null;
		}
	}

	/**
	 * Extension function to the jQuery.fn which identifies SAPUI5 controls in the given jQuery context.
	 *
	 * @param {integer} [idx] optional parameter to return the control instance at the given idx's position in the array.
	 * @methodOf jQuery.prototype
	 * @returns {sap.ui.core.Control[] | sap.ui.core.Control | null} depending on the given context and idx parameter an array of controls, an instance or null.
	 * @public
	 */
	jQuery.fn.control = function(idx) {
		var aControls = this.map(fgetControl);
		if(idx === undefined || isNaN(idx)) {
			return aControls.get();
		}
		else {
			return aControls.get(idx);
		}
	};


	/**
	 * EXPERIMENTAL!!
	 * Creates a new control of the given type and places it into the first DOM object of the jQuery collection.
	 * The type string is case sensitive.
	 *
	 * @param {string} sControlType the control type (fully qualified, like "sap.ui.dev.GoogleMap"; if no package is given, the package "sap.ui.commons" is assumed)
	 * @param {string} [sId] optional id for the new control; generated automatically if no non-empty id is given
	 * @param {object} [oConfiguration] optional map/JSON-object with initial values for the new control
	 * @returns {jQuery} the given jQuery object
	 * @private
	 */
	jQuery.fn.sapui = function(sControlType, sId, oConfiguration) {

		return this.each(function() { // TODO: hack for Steffen; (point is not clear, as this adds identical controls to many DOM elements...); remove soon

			var oControl = null;
			if (this) {
				// allow omitting the package prefix because this looks less Java-like...  sap.ui.commons is the default package
				if (sControlType.indexOf(".") == -1)  {
					sControlType = "sap.ui.commons." + sControlType;
				}

				// instantiate the control
				var fnClass = jQuery.sap.getObject(sControlType);
				if (fnClass) {

					// TODO: hack for Steffen; remove later
					if(typeof oConfiguration == 'object' && typeof oConfiguration.press == 'function') {
			  oConfiguration.press = jQuery.proxy(oConfiguration.press,this);
			}

					oControl = new (fnClass)(sId, oConfiguration); // sId might actually contain oConfiguration, the Element constructor will take care of this

					// placeAt first DomRef in collection
					oControl.placeAt(this);
					// TODO: avoid the direct call to applyChanges() in favor of a delayed version that potentially bundles several changes
					//sap.ui.getCore().applyChanges();
				}
			}

		});
	};

}());
}; // end of jquery.sap.ui




/**
 * @class An area in a page that hosts a tree of UI elements.
 *
 * Provides means for event-handling, rerendering, etc.
 *
 * @extends sap.ui.base.ManagedObject
 * @author SAP AG
 * @version 1.10.0
 * @param {sap.ui.Core} oCore internal API of the <core>Core</code> that manages this UIArea
 * @param {object} [oRootNode] reference to the Dom Node that should be 'hosting' the UI Area.
 * @public
 */
sap.ui.base.ManagedObject.extend("sap.ui.core.UIArea", {
	constructor: function(oCore, oRootNode) {
		if(arguments.length === 0) {
			return;
		}

		// Note: UIArea has a modifiable Id. This doesn't perfectly match the default behavior of ManagedObject
		// But UIArea overrides getId().
		sap.ui.base.ManagedObject.apply(this);

		//TODO we could get rid of oCore here, if we wanted to...
		this.oCore = oCore;
		this.bLocked = false;
		this.bInitial = true;
		this.aContentToRemove = [];
		
		this.bNeedsRerendering = false;
		if (oRootNode != null) {
			this.setRootNode(oRootNode);
			// Figure out whether UI Area is pre-rendered (server-side JS rendering)!
			this.bNeedsRerendering = this.bNeedsRerendering && !jQuery.sap.domById(oRootNode.id + "-Init");
		}
		this.mInvalidatedControls = {};

		if(!this.bNeedsRerendering) {
			this.oRenderControl = null;
		} else {
			// Core needs to be notified about an invalid UIArea
			this.oCore.addInvalidatedUIArea(this);
		}

	},
	metadata: {
		// ---- object ----
		publicMethods : ["setRootNode", "getRootNode", "setRootControl", "getRootControl", "lock","unlock", "isLocked", "getSavedContent"],
		aggregations : {
			"content" : {type : "sap.ui.core.Control", multiple : true, singularName : "content"}
		}
	}
});

/**
 * Returns whether rerendering is currently suppressed on this UIArea
 * @return boolean
 * @protected
 */
sap.ui.core.UIArea.prototype.isInvalidateSuppressed = function() {
	return this.iSuppressInvalidate > 0;
};

/**
 * Returns this <code>UIArea</code>'s id (as determined from provided RootNode).
 * @return {string} id of this UIArea
 * @public
 *
 * TODO what is this needed for? ID can change and getRootNode() is also there...
 * Is this part of "UI area is like an Element" contract?
 */
sap.ui.core.UIArea.prototype.getId = function() {
	return this.oRootNode ? this.oRootNode.id : null;
};

/**
 * Returns this UI area. Needed to stop recursive calls from an element to its parent.
 *
 * @return {sap.ui.core.UIArea} this
 * @protected
 */
sap.ui.core.UIArea.prototype.getUIArea = function() {
	return this;
};

/**
 * Allows setting the Root Node hosting this instance of <code>UIArea</code>.<br/> The Dom Ref must have an Id that
 * will be used as Id for this instance of <code>UIArea</code>.
 *
 * @param {object}
 *            oRootNode the hosting Dom Ref for this instance of <code>UIArea</code>.
 * @public
 */
sap.ui.core.UIArea.prototype.setRootNode = function(oRootNode) {
	if(this.oRootNode === oRootNode) {
		return;
	}

	// oRootNode must either be empty or must be a DOMElement and must not be root node of some other UIArea
	jQuery.sap.assert(!oRootNode || (oRootNode.nodeType === 1 && !jQuery(oRootNode).attr("data-sap-ui-area")), "UIArea root node must be a DOMElement");

	//TODO IS there something missing
	if(this.oRootNode) {
		this._ondetach();
	}

	this.oRootNode = oRootNode;
	if ( this.getContent().length > 0 ) {
	  this.invalidate();
	}

	if(this.oRootNode) {
		// prepare eventing
		this._onattach();
	}
};

/**
 * Returns the Root Node hosting this instance of <code>UIArea</code>.
 *
 * @return {DOMNode} the Root Node hosting this instance of <code>UIArea</code>.
 * @public
 */
sap.ui.core.UIArea.prototype.getRootNode = function() {
	return this.oRootNode;
};

/**
 * Sets the root control to be displayed in this UIArea.
 *
 * First, all old content controls (if any) will be detached from this UIArea (e.g. their parent
 * relationship to this UIArea will be cut off). Then the parent relationship for the new
 * content control (if not empty) will be set to this UIArea and finally, the UIArea will
 * be marked for re-rendering.
 *
 * The real re-rendering happens whenever the re-rendering is called. Either implicitly
 * at the end of any control event or by calling sap.ui.getCore().applyChanges().
 *
 * @param {sap.ui.base.Interface | sap.ui.core.Control}
 *            oRootControl the Control that should be the Root for this <code>UIArea</code>.
 * @public
 * @deprecated use functions <code>removeAllContent</code> and <code>addContent</code> instead
 */
sap.ui.core.UIArea.prototype.setRootControl = function(oRootControl) {
	this.removeAllContent();
	this.addContent(oRootControl);
};

/**
 * Returns the content control of this <code>UIArea</code> at the specified index.
 * If no index is given the first content control is returned.
 *
 * @param {int} idx index of the control in the content of this <code>UIArea</code>
 * @return {sap.ui.core.Control} the content control of this <code>UIArea</code> at the specified index.
 * @public
 * @deprecated use function <code>getContent</code> instead
 */
sap.ui.core.UIArea.prototype.getRootControl = function(idx) {
	var aContent = this.getContent();
	if(aContent.length > 0){
		if(idx >=0 && idx < aContent.length) {
			return aContent[idx];
		}
		return aContent[0];
	}
	return null;
};

sap.ui.core.UIArea.prototype._addRemovedContent = function(oDomRef) {
	if(this.oRootNode && oDomRef) {
		this.aContentToRemove.push(oDomRef);
	}
};

/**
 * Getter for aggregation <code>content</code>.<br/>
 *
 * @return {sap.ui.core.Control[]}
 * @public
 * @name sap.ui.core.UIArea.prototype.getContent
 */

/**
 * Inserts a content into the aggregation named <code>content</code>.
 *
 * @param {sap.ui.core.Control}
 *          oContent the content to insert; if empty, nothing is inserted
 * @param {int}
 *			iIndex the <code>0</code>-based index the content should be inserted at; for
 *             a negative value of <code>iIndex</code>, the content is inserted at position 0; for a value
 *             greater than the current size of the aggregation, the content is inserted at
 *             the last position
 * @return {sap.ui.core.UIArea} <code>this</code> to allow method chaining
 * @public
 * @name sap.ui.core.UIArea.prototype.insertContent
 */

/**
 * Adds some content <code>oContent</code>
 * to the aggregation named <code>content</code>.
 *
 * @param {sap.ui.core.Control}
 *            oContent the content to add; if empty, nothing is inserted
 * @return {sap.ui.core.UIArea} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.UIArea.prototype.addContent = function(oContent, _bSuppressInvalidate) {
	this.addAggregation("content", oContent, _bSuppressInvalidate);
	// TODO this remains here just to make the UX3 Shell work which doesn't invalidate properly
	if ( _bSuppressInvalidate !== true ) {
		this.invalidate();
	}
	return this;
};

/**
 * Removes an content from the aggregation named <code>content</code>.
 *
 * @param {int | string | sap.ui.core.Control} vContent the content to remove or its index or id
 * @return {sap.ui.core.Control} the removed element or null
 * @public
 */
sap.ui.core.UIArea.prototype.removeContent = function(vContent, _bSuppressInvalidate) {
	var oContent = this.removeAggregation("content", vContent, _bSuppressInvalidate);
	if ( !_bSuppressInvalidate ) {
		var oDomRef;
		if(oContent && oContent.getDomRef) {
			oDomRef = oContent.getDomRef();
		}
		this._addRemovedContent(oDomRef);
		//this.invalidate();
	}
	return oContent;
};

/**
 * Removes all the controls in the aggregation named <code>content</code>.<br/>
 * Additionally unregisters them from the hosting UIArea.
 * @return {sap.ui.core.Control[]} an array of the removed elements (might be empty)
 * @public
 */
sap.ui.core.UIArea.prototype.removeAllContent = function() {
	var aContent = this.removeAllAggregation("content");
	for(var idx=0; idx<aContent.length; idx++){
		var oDomRef;
		var oContent = aContent[idx];
		if(oContent && oContent.getDomRef) {
			oDomRef = oContent.getDomRef();
		}
		this._addRemovedContent(oDomRef);
	}
	//this.invalidate();
	return aContent;
};

/**
 * Checks for the provided <code>sap.ui.core.Control</code> in the aggregation named <code>content</code>
 * and returns its index if found or -1 otherwise.
 *
 * @param {sap.ui.core.Control}
 *            oContent the content whose index is looked for.
 * @return {int} the index of the provided control in the aggregation if found, or -1 otherwise
 * @public
 * @name sap.ui.core.UIArea.prototype.indexOfContent
 */

/**
 * Destroys all the content in the aggregation
 * named <code>content</code>.
 * @return {sap.ui.core.UIArea} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.UIArea.prototype.destroyContent = function() {
	var aContent = this.getContent();
	for(var idx=0; idx<aContent.length; idx++){
		var oDomRef;
		var oContent = aContent[idx];
		if(oContent && oContent.getDomRef) {
			oDomRef = oContent.getDomRef();
		}
		this._addRemovedContent(oDomRef);
	}
	this.destroyAggregation("content");
	//this.invalidate();
	return this;
};

/**
 * Locks this instance of UIArea.
 *
 * Rerendering and eventing will not be active as long as no
 * {@link #unlock} is called.
 *
 * @public
 */
sap.ui.core.UIArea.prototype.lock = function() {
	this.bLocked = true;
};

/**
 * Un-Locks this instance of UIArea.
 *
 * Rerendering and eventing will now be enabled again.
 *
 * @public
 */
sap.ui.core.UIArea.prototype.unlock = function() {
	if ( this.bLocked && this.bNeedsRerendering ) {
		// While being locked, we might have ignored a call to rerender()
		// Therefore notify the Core (again)
		this.oCore.addInvalidatedUIArea(this);
	}
	this.bLocked = false;
};

/**
 * Returns the locked state of the <code>sap.ui.core.UIArea</code>
 * @type boolean
 * @return locked state
 * @public
 */
sap.ui.core.UIArea.prototype.isLocked = function () {
	return this.bLocked;
};

/**
 * Provide getBindingContext, as UIArea can be parent of an element.
 * Always returns null.
 *
 * @protected
 */
sap.ui.core.UIArea.prototype.getBindingContext = function(){
	return null;
};

// ###########################################################################
// Convenience for methods
// e.g. Process Events for inner Controls
// or figure out whether control is part of this area.
// ###########################################################################

/**
 * Checks whether the control is still valid (is in the DOM)
 *
 * @return {boolean} True if the control is still in the active DOM
 * @protected
 */
sap.ui.core.UIArea.prototype.isActive = function() {
	return jQuery.sap.domById(this.getId()) != null;
};

/**
 * Will be used as end-point for invalidate-bubbling from controls up their hierarchy.<br/> Triggers re-rendering of
 * the UIAreas content.
 * @protected
 */
sap.ui.core.UIArea.prototype.invalidate = function() {
	this.addInvalidatedControl(this);
};

/**
 * Notifies the UIArea about an just invalidated control.
 *
 * The UIArea internally decides whether to re-render just the modified
 * controls or the complete content. It also informs the Core when it
 * becomes invalid the first time.
 *
 * TODO this.oRenderControl is either NULL or THIS. change to boolean?!
 * @protected
 */
sap.ui.core.UIArea.prototype.addInvalidatedControl = function(oControl){
	if (this.oRenderControl == this) {
		return;
	}

	// inform the Core, if we are getting invalid now
	if ( !this.bNeedsRerendering ) {
		this.oCore.addInvalidatedUIArea(this);
	}

	var sId = oControl.getId();
	//check whether the control is already invalidated
	if (/*jQuery.inArray(oControl, this.getContent()) || */oControl == this ) {
		this.oRenderControl = this; //everything in this UIArea
		this.bNeedsRerendering = true;
		return;
	}
	if (this.mInvalidatedControls[sId]) {
		return;
	}
	if (!this.oRenderControl) {
		//add it to the list of controls
		this.mInvalidatedControls[sId] = oControl;
		this.bNeedsRerendering = true;
	}
};

/**
 * TODO review and maybe refactor this complex algorithm
 * TODO documentation
 * TODO detach current "rerendering infos" before starting rerendering. Necessary to properly deal with concurrent modifications 
 * @param force {boolean} true, if the rerendering of the UI area should be forced
 * @return {boolean} whether a redraw was necessary or not
 * @private
 */
sap.ui.core.UIArea.prototype.rerender = function(force){
	if (force) {
		this.bNeedsRerendering = true;
	}
	if ( this.bLocked || !this.bNeedsRerendering ) {
		return false;
	}
	
	var that = this;

	// pause performance measurement for all UI Areas
	jQuery.sap.measure.pause("rerenderAllUIAreas");
	// start performance measurement
	jQuery.sap.measure.start(this.getId()+"---rerender","Rerendering of "+this.getMetadata().getName());

	if (this.oRenderControl == this) {
		if (this.oRootNode) {
			jQuery.sap.log.info("Rerendering of UI area: " + this.getId());

			// save old content
			sap.ui.core.RenderManager.preserveContent(this.oRootNode, /* bPreserveRoot */ false, /* bPreserveNodesWithId */ this.bInitial);
			this.bInitial = false;
			
			function cleanUpDom(aCtnt, bCtrls){
				var len = aCtnt.length;
				var oDomRef;
				for(var i=0; i<len; i++) {
					oDomRef = bCtrls ? aCtnt[i].getDomRef() : aCtnt[i];
					if ( oDomRef && !sap.ui.core.RenderManager.isPreservedContent(oDomRef) && that.oRootNode === oDomRef.parentNode) {
						jQuery(oDomRef).remove();
					}
				}
				return len;
			}

			//First remove the old Dom nodes and then render the controls again
			cleanUpDom(this.aContentToRemove);
			this.aContentToRemove = [];

			var aContent = this.getContent();
			var len = cleanUpDom(aContent, true);

			for(var i=0; i<len; i++){
				this.oCore.oRenderManager.render(aContent[i], this.oRootNode, true);
			}
		} else { // cannot re-render now; wait!
			// end performance measurement
			jQuery.sap.measure.end(this.getId()+"---rerender");
			// resume performance measurement for all UI Areas
			jQuery.sap.measure.resume("rerenderAllUIAreas");
			return false;
		}
	} else {
		function isAncestorInvalidated(oAncestor) {
			while ( oAncestor && oAncestor !== that ) {
				if ( that.mInvalidatedControls.hasOwnProperty(oAncestor.getId()) ) {
					return true;
				}
				oAncestor = oAncestor.getParent();
			}
			return false;
		}
		for (var n in this.mInvalidatedControls) { // TODO for in skips some names in IE8!
			var oControl = this.oCore.byId(n);
			// CSN 0000834961 2011: control may have been destroyed since invalidation happened
			if ( oControl && !isAncestorInvalidated(oControl.getParent()) ) {
				oControl.rerender();
			}
		}

	}

	this.oRenderControl = null;
	this.mInvalidatedControls = {};
	this.bNeedsRerendering = false;

	// end performance measurement
	jQuery.sap.measure.end(this.getId()+"---rerender");
	// resume performance measurement for all UI Areas
	jQuery.sap.measure.resume("rerenderAllUIAreas");
	return true;

};

/**
 * Rerenders the given control
 * @see sap.ui.core.Control.rerender()
 * @param oControl
 * @private
 */
sap.ui.core.UIArea.rerenderControl = function(oControl){
	var oDomRef = oControl ? oControl.getDomRef() : null;
	var oParentDomRef = oDomRef && oDomRef.parentNode; // remember parent here as preserveContent() might move the node!
	if(oParentDomRef){
		var uiArea = oControl.getUIArea();
		var rm = uiArea ? uiArea.oCore.oRenderManager : sap.ui.getCore().createRenderManager();
		jQuery.sap.log.info("Rerendering of control (using Core-RenderManager: "+(!!uiArea)+"): " + oControl.getId());
		sap.ui.core.RenderManager.preserveContent(oDomRef, /* bPreserveRoot */ true, /* bPreserveNodesWithId */ false);
		rm.render(oControl, oParentDomRef);
	} else {
		jQuery.sap.log.warning("Couldn't rerender '" + oControl.getId() + "', as its DOM location couldn't be determined");
	}
};

/**
 * Handles all incoming DOM events centrally and dispatches the event to the
 * registered event handlers.
 * @param {jQuery.Event} oEvent the jQuery event object
 * @private
 */
sap.ui.core.UIArea.prototype._handleEvent = function(/**event*/oEvent) {

	// execute the registered event handlers
	var oElement = null;

	// TODO: this should be the 'lowest' SAPUI5 Control of this very
	// UIArea instance's scope -> nesting scenario
	oElement = jQuery(oEvent.target).control(0);
	
	if(oElement === null){
		return;
	}
	
	//if event is already handled by inner UIArea (as we use the bubbling phase now), returns.
	//if capturing phase would be used, here means event is already handled by outer UIArea.
	if((oEvent.originalEvent || oEvent)._sapui_handledByUIArea){
		return;
	}

	// store the element on the event (aligned with jQuery syntax)
	oEvent.srcControl = oElement;

	// forward the control event:
	// if the control propagation has been stopped or the default should be
	// prevented then do not forward the control event.
	this.oCore._handleControlEvent(oEvent, this.getId());

	// if the UIArea or the Core is locked then we do not dispatch
	// any event to the control => but they will still be dispatched
	// as control event afterwards!
	if (this.bLocked || this.oCore.isLocked()) {
		return;
	}

	// retrieve the pseudo event types
	var aEventTypes = [];
	if(oEvent.getPseudoTypes){
		aEventTypes = oEvent.getPseudoTypes();
	}
	aEventTypes.push(oEvent.type);

	// dispatch the event to the controls (callback methods: onXXX)
	while (oElement && oElement instanceof sap.ui.core.Element && oElement.isActive() && !oEvent.isPropagationStopped()) {

		// for each event type call the callback method
		// if the execution should be stopped immediately
		// then no further callback method will be executed
		for (var i = 0, is = aEventTypes.length; i < is; i++) {
			var sType = aEventTypes[i];
			oEvent.type = sType;
			// ensure currenTarget is the DomRef of the handling Control
			oEvent.currentTarget = oElement.getDomRef();
			oElement._handleEvent(oEvent);
			if(oEvent.isImmediatePropagationStopped()) {
				break;
			}
		}

		// if the propagation is stopped do not bubble up further
		if(oEvent.isPropagationStopped()) {
			break;
		}

		// This is the (not that common) situation that the element was deleted in its own event handler.
		// i.e. the Element became 'inactive' (see Element#isActive())
		var oDomRef = oElement.getDomRef();
		if(!oDomRef) {
			break;
		}

		// bubble up to the parent
		oDomRef = oDomRef.parentNode;
		oElement = null;

		// ensure we do not bubble the control tree higher than our rootNode
		while (oDomRef && oDomRef !== this.getRootNode()) {
			if (oDomRef.id) {
				oElement = jQuery(oDomRef).control(0);
				if (oElement) {
					break;
				}
			}
			oDomRef = oDomRef.parentNode;
		}

	}

	// reset previously changed currentTarget
	oEvent.currentTarget = this.getRootNode();
	
	// mark on the event that it's already handled by this UIArea
	(oEvent.originalEvent || oEvent)._sapui_handledByUIArea = true;

	// TODO: rethink about logging levels!

	// logging: propagation stopped
	if (oEvent.isPropagationStopped()) {
		jQuery.sap.log.debug("'" + oEvent.type + "' propagation has been stopped");
	}

	// logging: prevent the logging of some events and for others do some
	//          info logging into the console
	var sName = oEvent.type;
	if (sName!="mousemove" && sName!="mouseover" && sName!="scroll" && sName!="mouseout") {
		var oElem = jQuery(oEvent.target).control(0);
		if(oElem) {
			jQuery.sap.log.debug("Event fired: '" + oEvent.type + "' on " + oElem, "", "sap.ui.core.UIArea");
		}
		else {
			jQuery.sap.log.debug("Event fired: '" + oEvent.type + "'", "", "sap.ui.core.UIArea");
		}
	}

};

/*
* The onattach function is called when the Element is attached to the DOM
* @private
*/
sap.ui.core.UIArea.prototype._onattach = function() {

// TODO optimizations for 'matching event list' could be done here.
//	// create the events string (space separated list of event names):
//	// the first time a control is attached - it will determine the required
//	// events and store this information in the controls metadata which is
//	// shared across the control instances.
//	if (!this.getMetadata().sEvents) {
//
//		// shorten the access to the array of events and pseudo events
//		var aEv = jQuery.sap.ControlEvents;
//		var oPsEv = jQuery.sap.PseudoEvents;
//
//		// create the data structures for the event handler registration
//		this.sEvents = "";
//		var aEvents = [];
//
//		// check for pseudo events and register them for their relevant types
//		for (var evt in oPsEv) {
//				for (j = 0, js = oPsEv[evt].aTypes.length; j < js; j++) {
//					var type = oPsEv[evt].aTypes[j];
//					if (jQuery.inArray(type, aEvents) == -1) {
//						aEvents.push(type);
//					}
//				}
//		}
//
//		// check for events and register them
//		for (var i = 0, is = aEv.length; i < is; i++) {
//			var type = aEv[i];
//				if (jQuery.inArray(type, aEvents) == -1) {
//					aEvents.push(type);
//				}
//		}
//
//		// keep the list of events for the jQuery bind/unbind method
//		this.sEvents = aEvents.join(" ");
//
//		// cache the event handlers registry map
//		this.getMetadata().sEvents = this.sEvents;
//
//	} else {
//		// use the cached map of event handlers
//		this.sEvents = this.getMetadata().sEvents;
//	}

	// check for existing root node
	var oDomRef = this.getRootNode();
	if (oDomRef == null) {
		return;
	}

	//	mark the DOM as UIArea and bind the required events
	jQuery(oDomRef).attr("data-sap-ui-area", oDomRef.id).bind(jQuery.sap.ControlEvents.join(" "), jQuery.proxy(this._handleEvent, this));

};

/**
* The ondetach function is called when the Element is detached out of the DOM
* @private
*/
sap.ui.core.UIArea.prototype._ondetach = function() {

	// check for existing root node
	var oDomRef = this.getRootNode();
	if (oDomRef == null) {
		return;
	}

	// remove UIArea marker and unregister all event handlers of the control
	jQuery(oDomRef).removeAttr("data-sap-ui-area").unbind();

	// TODO: when optimizing the events => take care to unbind only the
	//       required. additionally consider not to remove other event handlers.
//	var ojQRef = jQuery(oDomRef);
//	if (this.sEvents) {
//		ojQRef.unbind(this.sEvents, this._handleEvent);
//	}
//
//	var oFH = this.oCore.oFocusHandler;
//	ojQRef.unbind("focus",oFH.onfocusin);
//	ojQRef.unbind("blur", oFH.onfocusout);

};

/**
 * An UIArea can't be cloned and throws an error when trying to do so.
 */
sap.ui.core.UIArea.prototype.clone = function() {
	throw new Error("UIArea can't be cloned");
};


}; // end of sap.ui.core.UIArea

if ( !jQuery.sap.isDeclared('sap.ui.core.ThemeCheck') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.core.ThemeCheck
jQuery.sap.declare("sap.ui.core.ThemeCheck");




(function() {

/**
 * Creates a new ThemeCheck object.
 *
 * @class Helper class used by the UI5 Core to check whether the themes are applied correctly.
 *
 * In some browsers (e.g. Safari, Firefox) appling CSS files takes some time. So it could happen that e.g. in onAferRendering
 * not all themes are available. In these cases the check waits until the CSS is applied and fires an onThemeChanged event.
 *
 * @extends sap.ui.base.Object
 * @since 1.10.0
 * @author SAP AG
 * @constructor
 * @protected
 * @name sap.ui.core.ThemeCheck
 */
sap.ui.base.Object.extend("sap.ui.core.ThemeCheck", /** @lends sap.ui.core.ThemeCheck.prototype */ {

	constructor : function(oCore) {
		if(useThemeCheck()){
			loadThemeCheckCSS();
		}
		this._oCore = oCore;
	},
	
	clear : function(){
		sap.ui.core.ThemeCheck.initialized = false;
		jQuery.sap.byId("sap-ui-DummyCSSCheck-CSS").remove();
		jQuery.sap.byId("sap-ui-DummyCSSCheck").remove();
		if(this._sThemeCheckId){
			jQuery.sap.clearDelayedCall(this._sThemeCheckId);
			this._sThemeCheckId = null;
		}
	},
	
	getInterface : function() {
		return this;
	},
	
	fireThemeChangedEvent : function(bOnlyOnInitFail, bForceCheck) {
		var bUseCheck = useThemeCheck();
		if(bForceCheck || (!sap.ui.core.ThemeCheck.initialized && bUseCheck)){
			loadThemeCheckCSS();
		}
		if(bUseCheck || bForceCheck){
			if(!this._sThemeCheckId){
				var jDummy = jQuery("<div id=\"sap-ui-DummyCSSCheck\" class=\"sapUiCssCheck\" style=\"visibility:hidden;position:absolute;height:100px;width:100px;top:-150px;\"></div>");
				jQuery(document.body).append(jDummy);
				
				delayedCheckTheme.apply(this, [true]);
			}
		}
		
		if(!bOnlyOnInitFail && !this._sThemeCheckId){
			this._oCore.fireThemeChanged({theme: this._oCore.getConfiguration().getTheme()});
		}
	}

});

function loadThemeCheckCSS() {
	if (!sap.ui.core.ThemeCheck.initialized) {
		// for certain browsers CSS bug append CSS class at the end
		jQuery.sap.includeStyleSheet(jQuery.sap.getModulePath("sap.ui.core.", "/") + "ThemeCheck.css", "sap-ui-DummyCSSCheck-CSS");
		sap.ui.core.ThemeCheck.initialized = true;
	}
};

function useThemeCheck() {
	if(jQuery.browser.safari){
		var aVersion = jQuery.browser.version.split(".");
		if (parseInt(aVersion[0], 10) < 534 || (parseInt(aVersion[0], 10) == 534 && parseInt(aVersion[1],10) < 5)) {
			return true;
		}
	}else if(jQuery.browser.mozilla){
		return true;
	}
	return false;
};

function checkTheme() {
	var res = (jQuery.sap.domById("sap-ui-DummyCSSCheck").offsetHeight - jQuery.sap.domById("sap-ui-DummyCSSCheck").clientHeight) == 20;
	if(!res){
		jQuery.sap.log.warning("Theme not yet applied.");
	}else{
		jQuery.sap.byId("sap-ui-DummyCSSCheck").remove();
	}
	return res;
};

function delayedCheckTheme(bFirst) {
	if(!checkTheme()){
		this._sThemeCheckId = jQuery.sap.delayedCall(2, this, delayedCheckTheme);
	}else if(!bFirst){
		this._sThemeCheckId = null;
		this._oCore.fireThemeChanged({theme: this._oCore.getConfiguration().getTheme()});
	}
};

})();
}; // end of sap.ui.core.ThemeCheck

if ( !jQuery.sap.isDeclared('sap.ui.core.Component') ) {
/*
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides base class sap.ui.core.Component for all components
jQuery.sap.declare("sap.ui.core.Component");

if ( !jQuery.sap.isDeclared('sap.ui.core.ComponentMetadata') ) {
/*!
 * SAP UI development toolkit for HTML5 (SAPUI5)
 * 
 * (c) Copyright 2009-2013 SAP AG. All rights reserved
 */

// Provides class sap.ui.core.ComponentMetadata
jQuery.sap.declare("sap.ui.core.ComponentMetadata");


/**
 * Creates a new metadata object for a Component subclass.
 *
 * @param {string} sClassName fully qualified name of the class that is described by this metadata object
 * @param {object} oStaticInfo static info to construct the metadata from
 *
 * @experimental Since 1.9.2. The Component concept is still under construction, so some implementation details can be changed in future.
 * @class
 * @author SAP
 * @version 1.10.0
 * @since 1.9.2
 */
sap.ui.core.ComponentMetadata = function(sClassName, oClassInfo) {

	// call super constructor
	sap.ui.base.ManagedObjectMetadata.apply(this, arguments);
};

//chain the prototypes
sap.ui.core.ComponentMetadata.prototype = jQuery.sap.newObject(sap.ui.base.ManagedObjectMetadata.prototype);

sap.ui.core.ComponentMetadata.prototype.applySettings = function(oClassInfo) {

	var oStaticInfo = oClassInfo.metadata;

	sap.ui.base.ManagedObjectMetadata.prototype.applySettings.call(this, oClassInfo);

	this._mDependencies = oStaticInfo.dependencies || null;
};

/**
 * Returns the dependencies for the component
 */
sap.ui.core.ComponentMetadata.prototype.getDependencies = function() {

	return this._mDependencies;
};
}; // end of sap.ui.core.ComponentMetadata


/**
 * Creates and initializes a new component with the given <code>sId</code> and
 * settings.
 * 
 * The set of allowed entries in the <code>mSettings</code> object depends on
 * the concrete subclass and is described there. See {@link sap.ui.core.Component}
 * for a general description of this argument.
 * 
 * @param {string}
 *            [sId] optional id for the new control; generated automatically if
 *            no non-empty id is given Note: this can be omitted, no matter
 *            whether <code>mSettings</code> will be given or not!
 * @param {object}
 *            [mSettings] optional map/JSON-object with initial settings for the
 *            new component instance
 * @public
 * 
 * @class Base Class for Component.
 * @extends sap.ui.base.ManagedObject
 * @abstract
 * @author SAP
 * @version 1.10.0
 * @name sap.ui.core.Component
 * @experimental Since 1.9.2. The Component concept is still under construction, so some implementation details can be changed in future.
 */
sap.ui.base.ManagedObject.extend("sap.ui.core.Component", /** @lends sap.ui.core.Component */

{
	constructor : function(sId, mSettings) {

		sap.ui.base.ManagedObject.apply(this, arguments);

	},

	metadata : {
		version : "1.0",
		dependencies : {
			css : [],
			js : [],
			libs : [], //data-sap-ui-libs
			components : [], // to load in order to be able to use them. not over url, but name /relative to my comp
			ui5version : "1.8",
			modules : []
		},

		"abstract" : true,
		publicMethods : [ "wire", "setUIArea" ],
		library : "sap.ui.core",
		autoDestroy : false, // destroy component when view
		// should be destroyed
		initOnBeforeRender : true
	}

}, /* Metadata constructor */ sap.ui.core.ComponentMetadata);



/**
 * Initializes the Component instance after creation.
 *
 * Applications must not call this hook method directly, it is called by the
 * framework while the constructor of an Component is executed.
 *
 * Subclasses of Component should override this hook to implement any necessary
 * initialization.
 *
 * @function
 * @name sap.ui.core.Component.prototype.init
 * @protected
 */
sap.ui.core.Component.prototype.init = function() {
	this.loadDependencies();
	var that = this;
	sap.ui.base.ManagedObject.runWithPreprocessors(
		function() {
			that.oRootControl = that.getControl();
		},
		{
			id: function(sId) {
				return that.createId(sId);
			},
			settings: function(oSettings) {
				if (oSettings.component) {
					oSettings.component = that.createId(oSettings.component);
				}
				return oSettings;
			}
		}
	);
};


/**
 * returns an Element by its id in the context of the View
 *
 * @return Element by its id
 * @public
 */
sap.ui.core.Component.prototype.byId = function(sId) {
	return sap.ui.getCore().byId(this.createId(sId));
};

/**
 * creates an id for an Element prefixed with the view id
 *
 * @return prefixed id
 * @public
 */
sap.ui.core.Component.prototype.createId = function(sId) {
	return this.getId() + "--" + sId;
};


sap.ui.core.Component.prototype.loadDependencies = function() {

	var oDep = this.getMetadata().getDependencies();
	if (oDep){
		this.loadLibs(oDep);
		this.loadCss(oDep);
		this.loadComponents(oDep);
	}
};


sap.ui.core.Component.prototype.loadLibs = function (oDependencies) {
	var aLibs = oDependencies.libs;
	if (aLibs && aLibs.length > 0) {
		jQuery.each(aLibs, function(i, sLib) {
			jQuery.sap.log.info("Loading Library: " + sLib);
			sap.ui.getCore().loadLibrary(sLib);
		});
	}
};

sap.ui.core.Component.prototype.loadCss = function (oDependencies) {
	var aUrls = oDependencies.css;
	if (aUrls && aUrls.length > 0) {
		var sLibName = this.getMetadata().getLibraryName();
		jQuery.each(aUrls, function(i, sUrl) {
			var sCssUrl = sap.ui.resource(sLibName, sUrl);
			jQuery.sap.log.info("Loading CSS from: " + sCssUrl);
			jQuery.sap.includeStyleSheet(sCssUrl);
		});
	}
};

// Load child Components
sap.ui.core.Component.prototype.loadComponents = function (oDependencies) {
		var aComps = oDependencies.components;
		if (aComps){
			jQuery.each(aComps, function(i, sClassName){
				jQuery.sap.log.info(sClassName);
				jQuery.sap.require(sClassName);
		});
	}
};
/**
 * Cleans up the component instance before destruction.
 *
 * Applications must not call this hook method directly, it is called by the
 * framework when the element is {@link #destroy destroyed}.
 * 
 * Subclasses of Component should override this hook to implement any necessary
 * cleanup.
 *
 * @function
 * @name sap.ui.core.Component.prototype.exit
 * @protected
 */
sap.ui.core.Component.prototype.exit = function() {
};


/**
 * Set UI area
 */
sap.ui.core.Component.prototype.setUIArea = function(oUIArea) {
	oUIArea.setRootControl(this.oRootControl);
};


}; // end of sap.ui.core.Component


/**
 * @class Core Class of the SAP UI Library.
 *
 * This class boots the Core framework and makes it available for the Application
 * via the method <code>sap.ui.getCore()</code>.
 *
 * Example:<br/>
 * <pre>   var oCore = sap.ui.getCore();</pre><br/>
 *
 * It provides events where the Application can attach to.<br/>
 * Example:<br/>
 * <pre>
 * oCore.attachInitEvent(function () {
 *   //do the needful, do it lean
 * });
 * </pre><br/>
 *
 * It registers the Browser Eventing.
 *
 * @extends sap.ui.base.EventProvider
 * @final
 * @author Martin Schaus, Daniel Brinkmann
 * @version 1.10.0
 * @constructor
 * @public
 */
sap.ui.core.Core = function() {

	//make this class only available once
	if(sap.ui.getCore && sap.ui.getCore()) {
		return sap.ui.getCore();
	}

	var that=this,
		log = jQuery.sap.log,
		METHOD="sap.ui.core.Core";

	//inheritance to be able to fire internal events
	sap.ui.base.EventProvider.apply(this);

	/**
	 * Whether the core has been booted
	 * @private
	 */
	this.bBooted = false;

	/**
	 * Whether the core has been initialized
	 * @private
	 */
	this.bInitialized = false;

	/**
	 * Available plugins in the order of registration.
	 * @private
	 */
	this.aPlugins = [];

	/**
	 * Collection of loaded libraries, keyed by their name.
	 * @private
	 */
	this.mLibraries = {};

	/**
	 * Already loaded resource bundles keyed by library and locale.
	 * @private
	 * @see sap.ui.core.Core.getLibraryResourceBundle
	 */
	this.mResourceBundles = {};

	/**
	 * Currently created UIAreas keyed by their id.
	 * @private
	 * FIXME how can a UI area ever be removed?
	 */
	this.mUIAreas = {};

	/**
	 * Default model used for databinding
	 * @private
	 */
	this.oModels = {};
	
	/**
	 * The event bus (initialized lazily)
	 * @private
	 */
	this.oEventBus = null;

	/**
	 * Map of of created Elements keyed by their id.
	 *
	 * Each element registers itself in its constructor and deregisters itself in its
	 * destroy method.
	 *
	 * @private
	 * TODO get rid of this collection as it represents a candidate for memory leaks
	 */
	this.mElements = {};

	/**
	 * Map of of created Components keyed by their id.
	 *
	 * Each component registers itself in its constructor and deregisters itself in its
	 * destroy method.
	 *
	 * @private
	 * TODO get rid of this collection as it represents a candidate for memory leaks
	 */
	this.mComponents = {};

	/**
	 * Ordered collection of initEvent listeners
	 * Moved here (before boot()) so that the libraries can be registered for lazy load!!
	 * @private
	 */
	this.aInitListeners = [];

	/**
	 * Whether the legacy library has to be loaded.
	 * @private
	 */
	this.bInitLegacyLib = false;

	log.info("Creating Core",null,METHOD);

	/**
	 * Object holding the interpreted configuration
	 * Initialized from the global "sap-ui-config" object and from Url parameters
	 * @private
	 */
	this.oConfiguration = new sap.ui.core.Configuration();

	// grant Element "friend" access to Core for (de-)registration
	sap.ui.core.Element.prototype.register = function() {
		that.registerElement(this);
	};
	sap.ui.core.Element.prototype.deregister = function() {
		that.deregisterElement(this);
	};

	// grant Component "friend" access to Core for (de-)registration
	sap.ui.core.Component.prototype.register = function() {
		that.registerComponent(this);
	};
	sap.ui.core.Component.prototype.deregister = function() {
		that.deregisterComponent(this);
	};

	// handle modules
	var aModules = this.oConfiguration.modules;
	if ( this.oConfiguration.getDebug() ) {
		// add debug module if configured
		aModules.unshift("sap-ui-debug");
	}
	// enforce the core library as the first loaded module
	var i=jQuery.inArray("sap.ui.core.library", aModules);
	if ( i!=0 ) {
		if ( i>0 ) {
			aModules.splice(i,1);
		}
		aModules.unshift("sap.ui.core.library");
	}
	
	log.info("Declared modules: " + aModules, METHOD);

	var oCfgData = window["sap-ui-config"];
	if (oCfgData) {
		// read themeRoots configuration
		if (oCfgData.themeroots) {
			for (var themeName in oCfgData.themeroots) {
				var themeRoot = oCfgData.themeroots[themeName];
				if (typeof themeRoot === "string") {
					this.setThemeRoot(themeName, themeRoot);
				} else {
					for (var lib in themeRoot) {
						if (lib.length > 0) {
							this.setThemeRoot(themeName, [lib], themeRoot[lib]);
						} else {
							this.setThemeRoot(themeName, themeRoot[lib]);
						}
					}
				}
			}
		}
	}

	// set CSS class for the theme name
	this.sTheme = this.oConfiguration.getTheme();
	jQuery(document.documentElement).addClass("sapUiTheme-" + this.sTheme);
	log.info("Declared theme " + this.sTheme,null,METHOD);

	if (this.oConfiguration.getRTL()) {
		jQuery(document.documentElement).attr("dir", "rtl"); // webkit does not allow setting document.dir before the body exists
		log.info("RTL mode activated",null,METHOD);
	}

	function calcBrowserId() {

		var b = jQuery.browser,
			ua = navigator.userAgent,
			browserVersion = parseFloat(b.version);

		// jQuery checks for user agent strings. We differentiate between browsers
		if ( b.mozilla ) {
			if ( ua.match(/Firefox\/(\d+\.\d+)/) ) {
				browserVersion = parseFloat(RegExp.$1);
				b.fVersion = browserVersion;
				return "ff" + Math.floor(browserVersion);
			}
		} else if ( b.webkit ) {
			var oExpMobile = /Mobile/;
			if ( ua.match(/Chrome\/(\d+\.\d+).\d+/) ) {
				b.chrome = true;
				b.safari = false;
				browserVersion = parseFloat(RegExp.$1);
				b.fVersion = browserVersion;
				b.mobile = oExpMobile.test(ua);
				return "cr" + browserVersion;
			} else { // I do not know why but Safari might have an issue with ua.match(...); thus changing
				var oExp = /Version\/(\d+\.\d+).*Safari/;
				if(oExp.test(ua)) {
					b.safari = true;
					browserVersion = parseFloat(oExp.exec(ua)[1]);
					b.fVersion = browserVersion;
					b.mobile = oExpMobile.test(ua);
					return (b.mobile ? "msf" : "sf") + Math.floor(browserVersion);
				}
			}
		} else if ( b.msie ) {
			// recognize IE8 when running in compat mode (only then the documentMode property is there)
			if (document.documentMode) {
				if(document.documentMode === 7) {
					// OK, obviously we are IE and seem to be 7... but as documentMode is there this cannot be IE7!
					log.warning("Browser running in IE7 document mode.", null, METHOD);
					b.fVersion = 8.0;
					return "ie8"; // how do we solve this in higher versions? Where do we get this information from?
				}
				b.fVersion = parseFloat(document.documentMode);
				return "ie" + document.documentMode;
			} else {
				b.fVersion = browserVersion;
				return "ie" + browserVersion;
			}
		}

		// otherwise not recognized...
	}

	function getOS(userAgent){
		userAgent = userAgent || navigator.userAgent;
		var platform = /\(([a-zA-Z ]+);\s(?:[U]?[;]?)([\D]+)((?:[\d._]*))(?:.*[\)][^\d]*)([\d.]*)\s/;
		var result = userAgent.match(platform);
		if (result){
			var appleDevices = /iPhone|iPad|iPod/;
			var bbDevices = /PlayBook|BlackBerry/;
			if (result[0].match(appleDevices)){
				result[3] = result[3].replace(/_/g, ".");
				//result[1] contains info of devices
				return({"version": 'iOS'+result[3] , "css": "sap-ios"});
			} else if (result[2].match(/Android/)) {
				result[2] = result[2].replace(/\s/g, "");
				return({"version": result[2]+result[3] , "css": "sap-android"});
			} else if (result[0].match(bbDevices)) {
				return({"version": 'bb'+result[4] , "css": "sap-bb"});
			} else {
				// currently we only support iOS, Android, BlackBerry 6.0+ , everything else will be ignored, if more platforms should be supported, logic can be placed here
				return;
			} 
			
		} else if (userAgent.indexOf("(BB10;") > 0) { 
			// BlackBery 10 has a different structure...
			platform = /\sVersion\/([\d.]+)\s/;
			result = userAgent.match(platform);
			if (result){
				return {"version": 'bb'+result[1] , "css": "sap-bb"};
			} else {
				return {"version": 'bb10' , "css": "sap-bb"};
			}
			
		} else {
			// Windows phone has a different structure, so we need to check with another regExp.
			platform = /Windows Phone (?:OS )?([\d.]*)/;
			result = userAgent.match(platform);
			if (result){
				return({"version": "winPhone"+result[1] , "css": "sap-winphone"});
			} else {
				return;
			}
		}
	}

	//set the browser for css attribute selectors. do not move this to the onload function because sf and ie do not
	//use the classes
	var id = calcBrowserId();
	if ( id ) {
		jQuery("html").attr("data-sap-ui-browser", id);
		log.debug("Browser-Id: " + id, null, METHOD);
	}

	var os = getOS();
	if ( os ){
		jQuery("html").attr("data-sap-ui-os", os.version).addClass(os.css);
	}

	//if weinre id is set, load weinre target script
	if (this.oConfiguration.getWeinreId()) {
		log.info("Starting WEINRE Remote Web Inspector");
		document.write("<script src=\"");
		document.write(this.oConfiguration.getWeinreServer() + "/target/target-script-min.js#" + this.oConfiguration.getWeinreId());
		document.write("\"></script>");
	}

	// create accessor to the Core API early so that initLibrary and others can use it
	/**
	 * Retrieve the {@link sap.ui.core.Core SAPUI5 Core} instance for the current window.
	 * @returns the API of the current SAPUI5 Core instance.
	 * @public
	 * @function
	 */
	sap.ui.getCore = jQuery.sap.getter(this.getInterface());

	//Init the HTML5 support if necessary before initialize the RenderManager
	sap.ui.core.RenderManager.initHTML5Support();
	// create the RenderManager so it can be used already
	this.oRenderManager = new sap.ui.core.RenderManager();

	// sync point 1 synchronizes document ready and rest of UI5 boot
	var oSyncPoint1 = jQuery.sap.syncPoint("UI5 Document Ready", function(iOpenTasks, iFailures) {
		that.handleLoad();
	});
	var iDocumentReadyTask = oSyncPoint1.startTask("document.ready");
	var iCoreBootTask = oSyncPoint1.startTask("preload and boot");

	// task 1 is to wait for document.ready 
	jQuery(function() {
		log.trace("document is ready");
		oSyncPoint1.finishTask(iDocumentReadyTask);
	}); 
	
	// sync point 2 synchronizes all preload script loads and the end of the bootstrap script
	var oSyncPoint2 = jQuery.sap.syncPoint("UI5 Core Preloads and Bootstrap Script", function(iOpenTasks, iFailures) {
		log.trace("Core loaded: open=" + iOpenTasks + ", failures=" + iFailures);
		that._boot();
		oSyncPoint1.finishTask(iCoreBootTask);
	});

	// when a boot task is configured, add it to syncpoint2
	var fnCustomBootTask = this.oConfiguration["xx-bootTask"]; 
	if ( fnCustomBootTask ) {
    var iCustomBootTask = oSyncPoint2.startTask("custom boot task");
    fnCustomBootTask( function(bSuccess) { 
			oSyncPoint2.finishTask(iCustomBootTask, typeof bSuccess === "undefined" || bSuccess === true );
    });
	}
	
	// when the bootstrap script has finished, it calls sap.ui.getCore().boot() 
	var iBootstrapScriptTask = oSyncPoint2.startTask("bootstrap script");
	this.boot = function() {
		if (this.bBooted) {
			return;
		}
		this.bBooted = true;
		oSyncPoint2.finishTask(iBootstrapScriptTask);
	};
	
	var sPreloadMode = this.oConfiguration['preload'];
	// if debug sources are requested, then the preload feature must be deactivated
	if ( window["sap-ui-debug"] ) {
		sPreloadMode = "";
	}
	// when the preload mode is 'auto', it will be set to 'sync' for optimized sources
	if ( sPreloadMode === "auto" ) {
		sPreloadMode = (window["sap-ui-optimized"] && !this.oConfiguration['xx-loadAllMode']) ? "sync" : "";
	}
	if ( sPreloadMode === "sync" || sPreloadMode === "async" ) {
		var bAsyncPreload = sPreloadMode !== "sync";
		jQuery.each(aModules, function(i,sModule) {
			if ( sModule.match(/\.library$/) ) {
				jQuery.sap.preloadModules(sModule + "-preload", bAsyncPreload, oSyncPoint2);
			}
		});
	}

};

sap.ui.core.Core.prototype = jQuery.sap.newObject(sap.ui.base.EventProvider.prototype);
sap.ui.base.Object.defineClass("sap.ui.core.Core", {
		// ---- object ----
		baseType : "sap.ui.base.EventProvider",
		publicMethods : ["boot", "isInitialized","attachInitEvent","getRenderManager","createRenderManager",
						 "getConfiguration", "setRoot", "createUIArea", "getUIArea", "getUIDirty", "getElementById",
						 "getCurrentFocusedControlId", "getControl", "getComponent", "lock", "unlock","isLocked",
						 "attachEvent","detachEvent","applyChanges", "getEventBus",
						 "applyTheme","setThemeRoot","attachThemeChanged","detachThemeChanged","getStaticAreaRef",
						 "registerPlugin","unregisterPlugin","getLibraryResourceBundle", "byId",
						 "getLoadedLibraries", "attachControlEvent", "detachControlEvent", "loadLibrary", "initLibrary",
						 "includeLibraryTheme", "setModel", "getModel", "hasModel", "isMobile", "attachParseError", "detachParseError",
						 "attachValidationError", "detachValidationError", "attachFormatError", "detachFormatError", "attachValidationSuccess",
						 "detachValidationSuccess", "fireFormatError", "fireParseError", "fireValidationError", "fireValidationSuccess",
						 "isStaticAreaRef"]  //"loadComponent"];
	});
/**
 * Map of event names and ids, that are provided by this class
 * @private
 */
sap.ui.core.Core.M_EVENTS = {ControlEvent: "ControlEvent", UIUpdated: "UIUpdated", ThemeChanged: "ThemeChanged",
		ValidationError : "validationError", ParseError : "parseError", FormatError : "formatError", ValidationSuccess : "validationSuccess"};

/**
 * Boots the core and injects the necessary css and js files for the library.
 * Applications shouldn't call this method. It is automatically called by the bootstrap scripts (e.g. sap-ui-core.js)
 *
 * @private
 */
sap.ui.core.Core.prototype._boot = function() {

	//do not allow any event processing until the Core is booting
	this.lock();

	// initialize the application cachebuster mechanism if configured 
	if (this.oConfiguration.getAppCacheBuster()) {
		jQuery.sap.require("sap.ui.core.AppCacheBuster");
	}

	// load all modules now
	var that = this;
	jQuery.each(this.oConfiguration.modules, function(i,mod) {
		var m = mod.match(/^(.*)\.library$/);
		if ( m ) {
			that.loadLibrary(m[1]);
		} else {
			jQuery.sap.require(mod);
		}
	});

	//allow events again
	this.unlock();
};


/**
 * Applies the theme with the given name (by loading the respective style sheets, which does not disrupt the application).
 *
 * By default, the theme files are expected to be located at path relative to the respective control library ([libraryLocation]/themes/[themeName]).
 * Different locations can be configured by using the method setThemePath() or by using the second parameter "sThemeBaseUrl" of applyTheme().
 * Usage of this second parameter is a shorthand for setThemePath and internally calls setThemePath, so the theme location is then known.
 *
 * sThemeBaseUrl is a single URL to specify the default location of all theme files. This URL is the base folder below which the control library folders
 * are located. E.g. if the CSS files are not located relative to the root location of UI5, but instead they are at locations like
 *    http://my.server/myapp/resources/sap/ui/core/themes/my_theme/library.css
 * then the URL that needs to be given is:
 *    http://my.server/myapp/resources
 * All theme resources are then loaded from below this folder - except if for a certain library a different location has been registered.
 *
 * If the theme resources are not all either below this base location or  with their respective libraries, then setThemePath must be
 * used to configure individual locations.
 *
 * @param {string} sThemeName the name of the theme to be loaded
 * @param {string} [sThemeBaseUrl] the (optional) base location of the theme
 * @public
 */
sap.ui.core.Core.prototype.applyTheme = function(sThemeName, sThemeBaseUrl) {
	jQuery.sap.assert(typeof sThemeName === "string", "sThemeName must be a string");
	jQuery.sap.assert(typeof sThemeBaseUrl === "string" || typeof sThemeBaseUrl === "undefined", "sThemeBaseUrl must be a string or undefined");

	if (sThemeBaseUrl) {
		this.setThemeRoot(sThemeName, sThemeBaseUrl);
	}

	// only apply the theme if it is different from the active one
	if (sThemeName && this.sTheme != sThemeName) {
		var sCurrentTheme = this.sTheme,
			that = this;
		// select "our" stylesheets
		jQuery("link[id^=sap-ui-theme-]").each(function() {
			// modify style sheet URL to point to the new theme
			// be aware of custom css included with the colon (see includeLibraryTheme) // TODO: what is this??
			var sLibName = this.id.substr(13); // length of "sap-ui-theme-"
			var pos;
			if ((pos = sLibName.indexOf("-[")) > 0) { // assumes that "-[" does not occur as part of a library name
				sLibName = sLibName.substr(0, pos);
			}
			var sBaseUrl = that._getThemePath(sLibName, sThemeName);
			var fileName = this.href.substr(this.href.lastIndexOf("/") + 1);
			this.href = sBaseUrl + fileName;
		});
		this.sTheme = sThemeName;
		this.getConfiguration()._setTheme(sThemeName);
		
		this.oThemeCheck.clear();

		// modify the <html> tag's CSS class with the theme name
		jQuery(document.documentElement).removeClass("sapUiTheme-" + sCurrentTheme).addClass("sapUiTheme-" + sThemeName);

		// notify the listeners
		this.oThemeCheck.fireThemeChangedEvent(false, true);
	}
};


/**
 * Returns the URL of the folder in which the CSS file for the given theme and the given library is located .
 * The returned URL ends with a slash.
 *
 * @param sLibName
 * @param sThemeName
 * @private
 */
sap.ui.core.Core.prototype._getThemePath = function(sLibName, sThemeName) {
	if (this._mThemeRoots) {
		var path =  this._mThemeRoots[sThemeName + " " + sLibName] || this._mThemeRoots[sThemeName];
		// check whether for this combination (theme+lib) a URL is registered or for this theme a default location is registered
		if (path) {
			path = path + sLibName.replace(/\./g, "/") + "/themes/" + sThemeName + "/";
			jQuery.sap.registerModulePath(sLibName + ".themes." + sThemeName, path);
			return path;
		}
	}

	// use the library location as theme location
	return jQuery.sap.getModulePath(sLibName + ".themes." + sThemeName + "/", "/");
};


/**
 *
 *
 * @param sThemeName
 * @param aLibraryNames
 * @param sThemeBaseUrl
 */
sap.ui.core.Core.prototype.setThemeRoot = function(sThemeName, aLibraryNames, sThemeBaseUrl) {
	jQuery.sap.assert(typeof sThemeName === "string", "sThemeName must be a string");
	jQuery.sap.assert((jQuery.isArray(aLibraryNames) && typeof sThemeBaseUrl === "string") || (typeof aLibraryNames === "string" && sThemeBaseUrl === undefined), "either the second parameter must be a string (and the third is undefined), or it must be an array and the third parameter is a string");

	if (!this._mThemeRoots) {
		this._mThemeRoots = {};
	}

	// normalize parameters
	if (!sThemeBaseUrl) {
		sThemeBaseUrl = aLibraryNames;
		aLibraryNames = undefined;
	}
	sThemeBaseUrl = sThemeBaseUrl + (sThemeBaseUrl.slice(-1) == "/" ? "" : "/");

	if (aLibraryNames) {
		// registration of URL for several libraries
		for (var i = 0; i < aLibraryNames.length; i++) {
			var lib = aLibraryNames[i];
			this._mThemeRoots[sThemeName + " " + lib] = sThemeBaseUrl;
		}

	} else {
		// registration of theme default base URL
		this._mThemeRoots[sThemeName] = sThemeBaseUrl;
	}

};


/**
 * Initializes the Core after the initial page was loaded
 * @private
 */
sap.ui.core.Core.prototype.init = function() {

	if (this.bInitialized) {
		return;
	}

	var log = jQuery.sap.log,
		METHOD = "sap.ui.core.Core.init()";

	// ensure that the core is booted now (e.g. loadAllMode)
	this.boot();

	log.info("Initializing",null,METHOD);

	this.oFocusHandler = new sap.ui.core.FocusHandler(document.body, this);
	this.oResizeHandler = new sap.ui.core.ResizeHandler(this);
	this.oThemeCheck = new sap.ui.core.ThemeCheck(this);

	log.info("Initialized",null,METHOD);

	this.bInitialized = true;

	// start the plugins
	log.info("Starting Plugins",null,METHOD);
	this.startPlugins();
	log.info("Plugins started",null,METHOD);

	var oConfig = this.oConfiguration;
	// create any pre-configured UIAreas
//	if ( oConfig.areas && oConfig.areas.length > 0 ) {
	if ( oConfig.areas ) {
		// log.warning("deprecated config option '(data-sap-ui-)areas' used.");
		for (var i=0, l = oConfig.areas.length; i < l; i++) {
			this.createUIArea(oConfig.areas[i]);
		}
		oConfig.areas = undefined;
	}

	// execute a configured init hook
	if ( oConfig.onInit ) {
		if ( typeof oConfig.onInit === "function" ) {
			oConfig.onInit();
		} else {
			// DO NOT USE jQuery.globalEval as it executes async in FF!
			jQuery.sap.globalEval(oConfig.onInit);
		}
		oConfig.onInit = undefined;
	}

	// execute registered init event handlers
	if (this.aInitListeners.length > 0) {
		log.info("Fire Loaded Event",null,METHOD);
		jQuery.each(this.aInitListeners, function(i,f) { f(); }); // TODO is jQuery.each safe wrt. concurrent modifications?
		this.aInitListeners = [];
	}

	this._rerenderAllUIAreas(); // directly render without setTimeout, so rendering is guaranteed to be finished when init() ends
	
	this.oThemeCheck.fireThemeChangedEvent(true);
};

/**
 * Handles the load event of the browser to initialize the Core
 * @private
 */
sap.ui.core.Core.prototype.handleLoad = function () {

	//do not allow any event processing until the Core is initialized
	var bWasLocked = this.isLocked();
	if ( !bWasLocked ) {
		this.lock();
	}
	this.init();
	//allow event processing again
	if ( !bWasLocked ) {
		this.unlock();
	}

};

/**
 * Returns true if the core has already been initialized. This means that instances of RenderManager,
 * etc. do already exist and the init event has already been fired (and will not
 * be fired again).
 *
 * @return whether the core has already been initialized
 * @public
 */
sap.ui.core.Core.prototype.isInitialized = function () {
	return this.bInitialized;
};

/**
 * Attaches a given function to the initialized event of the core.
 * This event will only be fired once; you can check if it already has been fired by calling isInitialized().
 *
 * @param func the function to be called on event firing.
 * @public
 */
sap.ui.core.Core.prototype.attachInitEvent = function (func) {
	jQuery.sap.assert(typeof func === "function", "func must be a function");
	this.aInitListeners.push(func);
};

/**
 * Locks the Core. No browser events are dispatched to the controls.
 * Lock should be called before and after the dom is modified for rendering, roundtrips...
 * Exceptions might be the case for asynchronous UI behavior
 * @public
 */
sap.ui.core.Core.prototype.lock = function () {
	this.bLocked = true;
};

/**
 * Unlocks the Core. Browser events are dispatched to the controls after
 * this method is called.
 * @public
 */
sap.ui.core.Core.prototype.unlock = function () {
	this.bLocked = false;
};

/**
 * Returns the locked state of the <code>sap.ui.core.Core</code>
 * @type boolean
 * @return locked state
 * @public
 */
sap.ui.core.Core.prototype.isLocked = function () {
	return this.bLocked;
};

/**
 * Returns the Configuration instance of the current Core instance.
 *
 * @return {sap.ui.core.Configuration} the Configuration instance of the current Core instance.
 * @public
 */
sap.ui.core.Core.prototype.getConfiguration = function () {
	return this.oConfiguration;
};

/**
 * @public
 * @deprecated Since version 0.15.0. Replaced by <code>createRenderManager()</code>
 */
sap.ui.core.Core.prototype.getRenderManager = function() {
	return this.createRenderManager(); //this.oRenderManager;
};

/**
 * Returns a new instance of the RenderManager interface.
 *
 * @return {sap.ui.core.RenderManager} the new instance of the RenderManager interface.
 * @public
 */
sap.ui.core.Core.prototype.createRenderManager = function() {
	return (new sap.ui.core.RenderManager()).getInterface();
};

/**
 * Returns the Id of the control/element currently in focus.
 * @return {string} the Id of the control/element currently in focus.
 * @public
 */
sap.ui.core.Core.prototype.getCurrentFocusedControlId = function() {
	if(!this.isInitialized()){
		throw new Error("Core must be initialized");
	}
	return this.oFocusHandler.getCurrentFocusedControlId();
};

/**
 * Synchronously loads the given library and makes it available to the application.
 *
 * Loads the *.library module, which contains all preload modules (enums, types, content of a shared.js
 * if it exists). The library module will call initLibrary with additional metadata for the library.
 *
 * As a result, consuming applications can instantiate any control or element from that library
 * without having to write import statements for the controls or for the enums.
 *
 * When the optional parameter <code>sUrl</code> is given, then all request for resources of the
 * library will be redirected to the given Url. This is convenience for a call to
 * <pre>
 *   jQuery.sap.registerModulePath(sLibrary, sUrl);
 * </pre>
 *
 * When the given library has been loaded already, no further action will be taken.
 * Especially, a given Url will not be honored!
 *
 * @param {string} sLibrary name of the library to import
 * @param {string} [sUrl] URL to load the library from
 * @public
 */
sap.ui.core.Core.prototype.loadLibrary = function(sLibrary, sUrl) {
	jQuery.sap.assert(typeof sLibrary === "string", "sLibrary must be a string");
	jQuery.sap.assert(sUrl === undefined || typeof sUrl === "string", "sUrl must be a string or empty");

	// load libraries only once
	if ( !this.mLibraries[sLibrary] ) {

		var sModule = sLibrary + ".library",
			sAllInOneModule;

		// if a sUrl is given, redirect access to it
		if ( sUrl ) {
			jQuery.sap.registerModulePath(sLibrary, sUrl);
		}

		// optimization: in all-in-one mode we are loading all modules of the lib in a single file
		if ( this.oConfiguration['xx-loadAllMode'] && !jQuery.sap.isDeclared(sModule) ) {
			sAllInOneModule = sModule + "-all";
			jQuery.sap.log.debug("load all-in-one file " + sAllInOneModule);
			jQuery.sap.require(sAllInOneModule);
		}

		// require the library module (which in turn will call initLibrary())
		jQuery.sap.require(sModule);

		// check for legacy code
		if ( !this.mLibraries[sLibrary] ) {
			jQuery.sap.log.warning("library " + sLibrary + " didn't initialize itself");
			this.initLibrary(sLibrary); // TODO redundant to generated initLibrary call....
		}

	}

	return this.mLibraries[sLibrary];
};


//sap.ui.core.Core.prototype.loadComponent = function(sComponent, sUrl) {
//	jQuery.sap.assert(typeof sComponent === "string", "sComponent must be a string");
//	jQuery.sap.assert(sUrl === undefined || typeof sUrl === "string", "sUrl must be a string or empty");
//
//	// load libraries only once
//	if ( !this.mComponents[sComponent] ) {
//
//		// if a sUrl is given, redirect access to it
//		if ( sComponent ) {
//			var iIndex = sComponent.lastIndexOf(".");
//			var sPath = sComponent;
//			if (iIndex > 0) {
//				sPath = sComponent.substr(0,iIndex);
//			}
//			// register the path to the component
//			jQuery.sap.registerModulePath(sPath, sUrl);
//		}
//
//		// require the component
//		jQuery.sap.require(sComponent);
//		var oClass = jQuery.sap.getObject(sComponent);
//		jQuery.sap.log.info(oClass.getMetadata());
//	}
//
//	return this.mComponents[sComponent];
//};

/**
 * Initializes a library for an already loaded library module.
 *
 * This method is intended to be called only from a library.js (e.g. generated code).
 * It includes the library specific stylesheet into the current page, and creates
 * lazy import stubs for all controls and elements in the library.
 *
 * As a result, consuming applications don't have to write import statements for the controls or for the enums.
 *
 * Synchronously loads any libraries that the given library depends on.
 *
 * @param {string|object} vLibInfo name of or info object for the library to import
 * @public
 */
sap.ui.core.Core.prototype.initLibrary = function(vLibInfo) {
	jQuery.sap.assert(typeof vLibInfo === "string" || typeof vLibInfo === "object", "vLibInfo must be a string or object");

	var bLegacyMode = typeof vLibInfo === "string",
		oLibInfo = bLegacyMode ? { name : vLibInfo } : vLibInfo,
		sLibName = oLibInfo.name,
		log = jQuery.sap.log,
		METHOD =  "sap.ui.core.Core.initLibrary()";

	if ( bLegacyMode ) {
		log.warning("[Deprecated] library " + sLibName + " uses old fashioned initLibrary() call (rebuild with newest generator)");
	}

	if ( !sLibName || this.mLibraries[sLibName] ) {
		return;
	}

	log.debug("Analyzing Library " + sLibName, null, METHOD);

	// Create lib info object. Also used as a marker that the library is loading/has been loaded
	this.mLibraries[sLibName] = oLibInfo = jQuery.extend({
	  dependencies : [],
	  types : [],
	  interfaces : [],
	  controls: [],
	  elements : []
	}, oLibInfo);

	// this code could be moved to a separate "legacy support" module
	function readLibInfoFromProperties() {

		// read library properties
		var oProperties = jQuery.sap.properties({url : sap.ui.resource(sLibName, "library.properties")});

		// version info
		oLibInfo.version = oProperties.getProperty(sLibName + "[version]");

		// dependencies
		var sDepInfo = oProperties.getProperty(sLibName + "[dependencies]");
		log.debug("Required Libraries: " + sDepInfo, null, METHOD);
		oLibInfo.dependencies = (sDepInfo && sDepInfo.split(/[,;| ]/)) || [];

		// collect types, controls and elements
		var aKeys = oProperties.getKeys(),
		  rPattern = /(.+)\.(type|interface|control|element)$/,
		  aMatch;
		for(var i=0; i<aKeys.length; i++) {
			var sEntityPath = oProperties.getProperty(aKeys[i]);
			if ( aMatch = sEntityPath.match(rPattern) ) {
				oLibInfo[aMatch[2]+"s"].push(aKeys[i]);
			}
		}
	}

	// (legacy) if only a string was given, read the library.properties instead
	if ( bLegacyMode ) {
		readLibInfoFromProperties();
	}

	// resolve dependencies
	for(var i=0; i<oLibInfo.dependencies.length; i++) {
		var sDepLib = oLibInfo.dependencies[i];
		log.debug("resolve Dependencies to " + sDepLib, null, METHOD);
		if ( !this.mLibraries[sDepLib] ) {
			log.warning("Dependency from " + sLibName + " to " + sDepLib + " has not been resolved by library itself", null, METHOD);
			this.loadLibrary(sDepLib);
		}
	}

	// register interface types
	sap.ui.base.DataType.registerInterfaceTypes(oLibInfo.interfaces);
	
	// create lazy imports for all controls and elements
	var aElements = oLibInfo.controls.concat(oLibInfo.elements);
	for(var i=0; i<aElements.length; i++) {
		sap.ui.lazyRequire(aElements[i], "new extend getMetadata"); // TODO don't create an 'extend' stub for final classes
	}

	// include the library theme
	this.includeLibraryTheme(sLibName);

	// expose some legacy names
	oLibInfo.sName = oLibInfo.name;
	oLibInfo.aControls = oLibInfo.controls;

	// load and execute the library.js script
	if ( !jQuery.sap.isDeclared(sLibName + ".library") ) {
		// TODO redundant to generated require calls
		log.warning("Library Module " + sLibName + ".library" + " not loaded automatically", null, METHOD);
		jQuery.sap.require(sLibName + ".library");
	}

};

/**
 * Includes a library theme into the current page (if a variant is specified it
 * will include the variant library theme)
 * @param {string} sLibName the name of the UI library
 * @param {string} [sVariant] the variant to include (optional)
 * @public
 */
sap.ui.core.Core.prototype.includeLibraryTheme = function(sLibName, sVariant) {
	jQuery.sap.assert(typeof sLibName === "string", "sLibName must be a string");
	jQuery.sap.assert(sVariant === undefined || typeof sVariant === "string", "sVariant must be a string or undefined");

	/*
	 * by specifiying a library name containing a colon (":") you can specify
	 * the file name of the CSS file to include (ignoring RTL)
	 */

	// include the stylesheet for the library (except for "classic" and "legacy" lib)
	if ((sLibName != "sap.ui.legacy") && (sLibName != "sap.ui.classic")) {

		// no variant?
		if (!sVariant) {
			sVariant = "";
		}

		// determine RTL
		var sRtl = (this.oConfiguration.getRTL() ? "-RTL" : "");

		// create the library file name
		var sLibFileName,
			sLibId = sLibName + (sVariant.length > 0 ? "-[" + sVariant + "]" : sVariant);
		if (sLibName && sLibName.indexOf(":") == -1) {
			sLibFileName = "library" + sVariant + sRtl;
		} else {
			sLibFileName = sLibName.substring(sLibName.indexOf(":") + 1) + sVariant;
			sLibName = sLibName.substring(0, sLibName.indexOf(":"));
		}

		// log and include
		var cssPathAndName = this._getThemePath(sLibName, this.sTheme) + sLibFileName + ".css";
		jQuery.sap.log.info("Including " + cssPathAndName + " -  sap.ui.core.Core.includeLibraryTheme()");
		jQuery.sap.includeStyleSheet(cssPathAndName, "sap-ui-theme-" + sLibId);

	}

};

/**
 * Returns a map which contains the names of the loaded libraries as keys
 * and some additional information about each library as values.
 *
 * Note that the details of the 'values' in the returned map are not yet specified!
 * Their structure might change in future versions without notice. So applications
 * can only rely on the set of keys as well as the pure existance of a value.
 *
 * @return {map} map of library names / controls
 * @public
 */
sap.ui.core.Core.prototype.getLoadedLibraries = function() {
	return jQuery.extend({}, this.mLibraries); // TODO deep copy or real Library object?
};

/**
 * Implicitly creates a new <code>UIArea</code> (or reuses an exiting one) for the given DOM reference and
 * adds the given control reference to the UIAreas content (existing content will be removed).
 *
 * @param {String,DomRef} oDomRef a Dom Reference or Id String of the UIArea
 * @param {sap.ui.base.Interface | sap.ui.core.Control}
 *            oControl the Control that should be the added to the <code>UIArea</code>.
 * @public
 * @deprecated Use function <code>oControl.placeAt(oDomRef, "only")</code> of <code>sap.ui.core.Control</code> instead.
 */
sap.ui.core.Core.prototype.setRoot = function(oDomRef, oControl) {
	jQuery.sap.assert(typeof oDomRef === "string" || typeof oDomRef === "object", "oDomRef must be a string or object");
	jQuery.sap.assert(oControl instanceof sap.ui.base.Interface || oControl instanceof sap.ui.core.Control, "oControl must be a Control or Interface");

	if(oControl) {
		oControl.placeAt(oDomRef, "only");
	}
};

/**
 * Creates a new sap.ui.core.UIArea
 *
 * @param {String,DomRef} oDomRef a DOM reference or ID string of the UIArea
 * @return a new UIArea
 * @type sap.ui.core.UIArea
 *
 * @public
 * @deprecated Use <code>setRoot()</code> instead!
 */
sap.ui.core.Core.prototype.createUIArea = function(oDomRef) {
	var that = this;
	jQuery.sap.assert(typeof oDomRef === "string" || typeof oDomRef === "object", "oDomRef must be a string or object");

	if (!oDomRef) {
		throw new Error("oDomRef must not be null");
	}

	// oDomRef might be (and actually IS in most cases!) a string (the ID of a DOM element)
	if (typeof(oDomRef) === "string") {
		var id = oDomRef;
		oDomRef = jQuery.sap.domById(oDomRef);
		if (!oDomRef) {
			throw new Error("DOM element with ID '" + id + "' not found in page, but application tries to insert content.");
		}
	}

	// if the domref does not have an ID or empty ID => generate one
	if (!oDomRef.id || oDomRef.id.length == 0) {
		oDomRef.id = jQuery.sap.uid();
	}

	// create a new or fetch an existing UIArea
	var sId = oDomRef.id;
	if (!this.mUIAreas[sId]) {
		this.mUIAreas[sId] = new sap.ui.core.UIArea(this, oDomRef);
		// propagate Models to newly created UIArea
		jQuery.each(this.oModels, function (sName, oModel){
			that.mUIAreas[sId].oPropagatedProperties.oModels[sName] = oModel;
		});
		this.mUIAreas[sId].propagateProperties(true);
	} else {
		// this should solve the issue of 'recreation' of a UIArea
		// e.g. via setRoot with a new domRef
		this.mUIAreas[sId].setRootNode(oDomRef);
	}
	return this.mUIAreas[sId];
};
 
/**
 * Returns a UIArea if the given ID/Element belongs to one
 *
 * @public
 * @param {String,DomRef} o a DOM Reference or ID String of the UIArea
 * @return a UIArea with a given id or dom ref.
 * @type sap.ui.core.UIArea
 */ 
sap.ui.core.Core.prototype.getUIArea = function(o) {
	jQuery.sap.assert(typeof o === "string" || typeof o === "object", "o must be a string or object");

	var sId = "";
	if (typeof(o)=="string") {
		sId = o;
	}
	else {
		sId = o.id;
	}

	if (sId) {
		return this.mUIAreas[sId];
	}

	return null;
};

/**
 * Informs the core about an UIArea that just became invalid.
 *
 * The core might use this information to minimize the set of
 * re-rendered UIAreas. But for the time being it just registers
 * a timer to trigger a re-rendering after the current event
 * has been processed.
 *
 * @param oUIArea {sap.ui.core.UIArea} UIArea that just became invalid
 * @private
 */
sap.ui.core.Core.prototype.addInvalidatedUIArea = function(oUIArea) {
	this.rerenderAllUIAreas(); // TODO: document why immediately rerender all??
};

/**
 * Retrieves a resource bundle for the given library and locale.
 *
 * If only one argument is given, it is assumed to be the libraryName. The locale
 * then falls back to the current {@link sap.ui.core.Configuration.prototype.getLanguage session locale}.
 * If no argument is given, the library also falls back to a default: "sap.ui.core".
 *
 * @param {string} [sLibraryName=sap.ui.core] name of the library to retrieve the bundle for
 * @param {string} [sLocale] locale to retrieve the resource bundle for
 * @return {jQuery.sap.util.ResourceBundle} the best matching resource bundle for the given parameters or undefined
 * @public
 */
sap.ui.core.Core.prototype.getLibraryResourceBundle = function(sLibraryName, sLocale) {
	jQuery.sap.assert((sLibraryName === undefined && sLocale === undefined) || typeof sLibraryName === "string", "sLibraryName must be a string or there is no argument given at all");
	jQuery.sap.assert(sLocale === undefined || typeof sLocale === "string", "sLocale must be a string or omitted");

	// TODO move implementation together with similar stuff to a new class "UILibrary"?
	sLibraryName = sLibraryName || "sap.ui.core";
	sLocale = sLocale || this.getConfiguration().getLanguage();
	var sKey = sLibraryName + "/" + sLocale;
	if (!this.mResourceBundles[sKey]) {
		var sURL = sap.ui.resource(sLibraryName, 'messagebundle.properties');
		this.mResourceBundles[sKey] = jQuery.sap.resources({url : sURL, locale : sLocale});
	}
	return this.mResourceBundles[sKey];
};

sap.ui.core.Core.prototype.rerenderAllUIAreas = function() {
	if ( !this._sRerenderTimer ) {
		jQuery.sap.log.info("registering timer for delayed re-rendering");
		this._sRerenderTimer = jQuery.sap.delayedCall(0,this,"_rerenderAllUIAreas"); // decoupled for collecting several invalidations into one redraw
	}
};

sap.ui.core.Core.prototype._rerenderAllUIAreas = function() {

	// start performance measurement
	jQuery.sap.measure.start("rerenderAllUIAreas","Rerendering of all UIAreas");

	// clear the timer so that the next call to re-render will create a new timer
	if (this._sRerenderTimer) {
		jQuery.sap.clearDelayedCall(this._sRerenderTimer); // explicitly stop the timer, as this call might be synchronous while still a timer is running
		this._sRerenderTimer = undefined;
	}

	var bUIUpdated = false;
	// avoid 'concurrent modifications' as IE8 can't handle them
	var mUIAreas = this.mUIAreas;
	for (var sId in mUIAreas) {
		bUIUpdated = mUIAreas[sId].rerender() || bUIUpdated;
	}

	// TODO this only covers parts of the relevant changes, 
	// A full solution requires changes in UIArea.rerender, see TODO about rendering infos there
	jQuery.sap.assert(!this._sRerenderTimer, "invalidate() while rendering");

	// TODO: Provide information on what actually was re-rendered...
	if(bUIUpdated) {
		this.fireUIUpdated();
	}

	// end performance measurement
	jQuery.sap.measure.end("rerenderAllUIAreas");
};


/**
 * Returns "true" if the UI is marked as dirty and will be cleaned/re-rendered after a certain small timeout.
 *
 * @return {boolean} true if some UI part is marked as dirty and will be cleaned up/re-rendered
 * @public
 */
sap.ui.core.Core.prototype.getUIDirty = function() {
	return !!this._sRerenderTimer;
};

/**
 * @name sap.ui.core.Core.prototype.UIUpdated
 * @event
 * @param {string} a
 * @param {object} source
 * @private
 */

sap.ui.core.Core.prototype.attachUIUpdated = function(fFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.UIUpdated, fFunction, oListener);
};

sap.ui.core.Core.prototype.detachUIUpdated = function(fFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.UIUpdated, fFunction, oListener);
};

sap.ui.core.Core.prototype.fireUIUpdated = function(mParameters) {
	this.fireEvent(sap.ui.core.Core.M_EVENTS.UIUpdated, mParameters);
};

/**
 * @name sap.ui.core.Core.prototype.ThemeChanged
 * @event
 * @param {string} a
 * @param {object} source
 */

sap.ui.core.Core.prototype.attachThemeChanged = function(fFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.ThemeChanged, fFunction, oListener);
};

sap.ui.core.Core.prototype.detachThemeChanged = function(fFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.ThemeChanged, fFunction, oListener);
};

sap.ui.core.Core.prototype.fireThemeChanged = function(mParameters) {
	jQuery.sap.scrollbarSize(true);
	
	// special hook for resetting theming parameters before the controls get 
	// notified (lightweight coupling to static Parameters module)
	if (sap.ui.core.theming && sap.ui.core.theming.Parameters) {
		sap.ui.core.theming.Parameters.reset();
	}
	
	// notify all elements/controls via a pseudo browser event
	var sEventId = sap.ui.core.Core.M_EVENTS.ThemeChanged;
	var oEvent = jQuery.Event(sEventId);
	jQuery.each(this.mElements, function(sId, oElement) {
		oElement._handleEvent(oEvent);
	});
	
	// notify the listeners via a control event
	this.fireEvent(sEventId, mParameters);
};

/**
 * Enforces an immediate update of the visible UI (aka "rendering").
 *
 * In general, applications should avoid calling this method and
 * instead let the framework manage any necessary rendering.
 * @public
 */
sap.ui.core.Core.prototype.applyChanges = function() {
	this._rerenderAllUIAreas();
};

/**
 * Registers the given element. Must be called once during construction.
 * @param {sap.ui.core.Element} oElement
 * @private
 */
sap.ui.core.Core.prototype.registerElement = function(oElement) {
	var oldElement = this.byId(oElement.getId());
	if ( oldElement && oldElement !== oElement ) {
		// duplicate ID detected => fail or at least log a warning
		if (this.oConfiguration.getNoDuplicateIds()) {
			jQuery.sap.log.error("adding element with duplicate id '" + oElement.getId() + "'");
			throw new Error("Error: adding element with duplicate id '" + oElement.getId() + "'");
		} else {
			jQuery.sap.log.warning("adding element with duplicate id '" + oElement.getId() + "'");
		}
	}

	this.mElements[oElement.getId()] = oElement;
};

/**
 * Deregisters the given element. Must be called once during destruction.
 * @param {sap.ui.core.Element} oElement
 * @private
 */
sap.ui.core.Core.prototype.deregisterElement = function(oElement) {
	delete this.mElements[oElement.getId()];
};

/**
 * Registers the given component. Must be called once during construction.
 * @param {sap.ui.core.Component} oComponent
 * @private
 */
sap.ui.core.Core.prototype.registerComponent = function(oComponent) {
	var oldComponent = this.byId(oComponent.getId());
	if ( oldComponent && oldComponent !== oComponent ) {
		jQuery.sap.log.error("adding component with duplicate id '" + oComponent.getId() + "'");
		throw new Error("Error: adding component with duplicate id '" + oComponent.getId() + "'");
	}

	this.mComponents[oComponent.getId()] = oComponent;
};

/**
 * Deregisters the given Component. Must be called once during destruction.
 * @param {sap.ui.core.Component} oComponent
 * @private
 */
sap.ui.core.Core.prototype.deregisterComponent = function(oComponent) {
	delete this.mComponents[oComponent.getId()];
};


/**
 * Returns the registered element for the given id, if any.
 * @param {string} sId
 * @return {sap.ui.core.Element} the element for the given id
 * @public
 */
sap.ui.core.Core.prototype.byId = function(sId) {
	jQuery.sap.assert(sId == null || typeof sId === "string", "sId must be a string when defined");
	// allow null, as this occurs frequently and it is easier to check whether there is a control in the end than
	// first checking whether there is an ID and then checking for a control

	/*
	// test alternative implementation
	function findById(sId, mUIAreas) {
		function _find(oControl) {
			if ( !oControl )
				return undefined;
			if ( oControl.getId() === sId ) {
				return oControl;
			}
			for (var n in oControl.mAggregations) {
				var a = oControl.mAggregations[n];
				if ( jQuery.isArray(a) ) {
					for (var i=0; i<a.length; i++) {
						var r = _find(a[i]);
						if ( r ) return r;
					}
				} else if ( a instanceof sap.ui.core.Element ) {
					var r = _find(a[i]);
					if ( r ) return r;
				}
			}
			return undefined;
		}

		//var t0=new Date().getTime();
		var r=undefined;
		for (var n in mUIAreas) {
			r=_find(mUIAreas[n].getRootControl()); //TODO: Adapt to mUIAreas[n].getContent
			if ( r ) break;
		}
		//var t1=new Date().getTime();
		//t=t+(t1-t0);
		return r;
	}

	if ( findById(sId, this.mUIAreas) !== this.mElements[sId] ) {
		jQuery.sap.log.error("failed to resolve " + sId + " (" + this.mElements[sId] + ")");
	}
	*/
	return sId == null ? undefined : this.mElements[sId];
};

/**
 * Returns the registered element for the given ID, if any.
 * @param {string} sId
 * @return {sap.ui.core.Element} the element for the given id
 * @deprecated use <code>sap.ui.core.Core.byId</code> instead!
 * @function
 * @public
 */
sap.ui.core.Core.prototype.getControl = sap.ui.core.Core.prototype.byId;

/**
 * Returns the registered element for the given ID, if any.
 * @param {string} sId
 * @return {sap.ui.core.Element} the element for the given id
 * @deprecated use <code>sap.ui.core.Core.byId</code> instead!
 * @function
 * @public
 */
sap.ui.core.Core.prototype.getElementById = sap.ui.core.Core.prototype.byId;

/**
 * Returns the registered component for the given id, if any.
 * @param {string} sId
 * @return {sap.ui.core.Component} the component for the given id
 * @public
 */
sap.ui.core.Core.prototype.getComponent = function(sId) {
	jQuery.sap.assert(sId == null || typeof sId === "string", "sId must be a string when defined");
	return sId == null ? undefined : this.mComponents[sId];
};

/**
 * Returns the static, hidden area reference belonging to this core instance.<br/> It can be used e.g. for hiding
 * elements like Popups, Shadow, Blocklayer etc.<br/> If it is not yet available, creates one HTML element and attaches
 * it to the body.
 *
 * @return {DOMNode} the static, hidden area reference belonging to this core instance.
 * @public
 */
sap.ui.core.Core.prototype.getStaticAreaRef = function() {
	var sStaticId = "sap-ui-static";
	var oStatic = jQuery.sap.domById(sStaticId);
	if(!oStatic){
		var leftRight = this.getConfiguration().getRTL() ? "right" : "left";
		oStatic = jQuery("<DIV/>",{id:sStaticId})
					.css("visibility", "hidden")
					.css("height", "0")
					.css("width", "0")
					.css("overflow", "hidden")
					.css("float", leftRight)
					.prependTo(document.body)[0];

		// TODO Check whether this is sufficient
		this.createUIArea(oStatic).bInitial = false;
	}
	return oStatic;
};

/**
 * Used to find out whether a certain DOM element is the static area
 * 
 * @return {boolean} whether the given DomRef is the StaticAreaRef
 * @protected
 */
sap.ui.core.Core.prototype.isStaticAreaRef = function(oDomRef) {
	return oDomRef && (oDomRef.id === "sap-ui-static");
};

/**
 * Registers a listener for control events
 * @param {function} sFunction
 * @param {object} [oListener]
 * @public
 */
sap.ui.core.Core.prototype.attachControlEvent = function(fFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.ControlEvent, fFunction, oListener);
};

/**
 * Unregisters a listener for control events
 * @param {function} sFunction
 * @param {object} [oListener]
 * @public
 */
sap.ui.core.Core.prototype.detachControlEvent = function(fFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.ControlEvent, fFunction, oListener);
};

/**
 * Notifies the listeners that a event on a control occures
 * @param {map} mParameters { browserEvent: jQuery.EventObject }
 * @private
 */
sap.ui.core.Core.prototype.fireControlEvent = function(mParameters) {
	this.fireEvent(sap.ui.core.Core.M_EVENTS.ControlEvent, mParameters);
};

/**
 * Handles a control event and forwards it to the registered control event
 * listeners
 * @param {jQuery.EventObject} control event
 * @private
 */
sap.ui.core.Core.prototype._handleControlEvent = function(/**event*/oEvent, sUiAreaId) {
	// Create a copy of the event
	var oEventClone = jQuery.Event(oEvent.type);
	jQuery.extend(oEventClone, oEvent);
	oEventClone.originalEvent = undefined;

	this.fireControlEvent({"browserEvent": oEventClone, "uiArea": sUiAreaId});
};


/**
 * Registers a Plugin to the <code>sap.ui.core.Core</code>, which lifecycle
 * will be managed (start and stop).
 * <br/>
 * Plugin object need to implement two methods:
 * <ul>
 *   <li><code>startPlugin(oCore)</code>: will be invoked, when the Plugin
 *       should start (as parameter the reference to the Core will be provided</li>
 *   <li><code>stopPlugin()</code>: will be invoked, when the Plugin should stop</li>
 * </ul>
 *
 * @param {object} oPlugin reference to a Plugin object
 * @public
 */
sap.ui.core.Core.prototype.registerPlugin = function(oPlugin) {
	jQuery.sap.assert(typeof oPlugin === "object", "oPlugin must be an object");

	// check for a valid plugin
	if (!oPlugin) {
		return;
	}

	// check if the plugin is already registered
	// if yes, the exit this function
	for (var i = 0, l = this.aPlugins.length; i < l; i++) {
		if (this.aPlugins[i] === oPlugin) {
			return;
		}
	}

	// register the plugin (keep the plugin in the plugin array)
	this.aPlugins.push(oPlugin);

	// if the Core is initialized also start the plugin
	if (this.bInitialized && oPlugin && oPlugin.startPlugin) {
		oPlugin.startPlugin(this);
	}

};

/**
 * Unregisters a Plugin out of the <code>sap.ui.core.Core</code>
 *
 * @param {object} oPlugin reference to a Plugin object
 * @public
 */
sap.ui.core.Core.prototype.unregisterPlugin = function(oPlugin) {
	jQuery.sap.assert(typeof oPlugin === "object", "oPlugin must be an object");

	// check for a valid plugin
	if (!oPlugin) {
		return;
	}

	// check if the plugin is already registered
	var iPluginIndex = -1;
	for (var i = this.aPlugins.length; i--; i >= 0) {
		if (this.aPlugins[i] === oPlugin) {
			iPluginIndex = i;
			break;
		}
	}

	// plugin was not registered!
	if (iPluginIndex == -1) {
		return;
	}

	// stop the plugin
	if (this.bInitialized && oPlugin && oPlugin.stopPlugin) {
		oPlugin.stopPlugin(this);
	}

	// remove the plugin
	this.aPlugins.splice(iPluginIndex, 1);

};

/**
 * Internal method to start all registered plugins
 * @private
 */
sap.ui.core.Core.prototype.startPlugins = function() {
	for (var i = 0, l = this.aPlugins.length; i < l; i++) {
		var oPlugin = this.aPlugins[i];
		if (oPlugin && oPlugin.startPlugin) {
			oPlugin.startPlugin(this, /* onInit*/ true);
		}
	}
};

/**
 * Internal method to stop all registered plugins
 * @private
 */
sap.ui.core.Core.prototype.stopPlugins = function() {
	for (var i = 0, l = this.aPlugins.length; i < l; i++) {
		var oPlugin = this.aPlugins[i];
		if (oPlugin && oPlugin.stopPlugin) {
			oPlugin.stopPlugin(this);
		}
	}
};

/**
 * Set the model for databinding
 * @param {sap.ui.model.Model} oModel
 * @param {string} [sName]
 * @public
 */
sap.ui.core.Core.prototype.setModel = function(oModel, sName) {
	jQuery.sap.assert(typeof oModel === "object" || !oModel, "oModel must be an object or undefined");
	jQuery.sap.assert(sName === undefined || typeof sName === "string", "sName must be a string or omitted");
	if (!oModel && this.oModels[sName]) {
		delete this.oModels[sName];
		// propagate Models to all UI areas 
		jQuery.each(this.mUIAreas, function (i, oUIArea){
			delete oUIArea.oPropagatedProperties.oModels[undefined];
			oUIArea.propagateProperties(sName);
		});
	} else if (oModel !== this.oModels[sName] ) { 
		this.oModels[sName] = oModel;
		// propagate Models to all UI areas 
		jQuery.each(this.mUIAreas, function (i, oUIArea){
			oUIArea.oPropagatedProperties.oModels[sName] = oModel;
			oUIArea.propagateProperties(sName);
		});
	} else {
		// nothing to do
	}  
};

/**
 * Get the model for databinding
 * @param {string} [sName]
 * @return {sap.ui.model.Model} oModel
 * @public
 */
sap.ui.core.Core.prototype.getModel = function(sName) {
	jQuery.sap.assert(sName === undefined || typeof sName === "string", "sName must be a string or omitted");
	return this.oModels[sName];
};

/**
 * Check if a Model is set to the core
 * @return {boolean} true or false
 * @public
 */
sap.ui.core.Core.prototype.hasModel = function() {
	if (!jQuery.isEmptyObject(this.oModels)) {
		return true;
	} else {
		return false;
	}
};

/**
 * Returns the event bus.
 * @return {sap.ui.core.EventBus} the event bus
 * @since 1.8.0
 * @public
 */
sap.ui.core.Core.prototype.getEventBus = function() {
	if(!this.oEventBus){
		jQuery.sap.require("sap.ui.core.EventBus");
		this.oEventBus = new sap.ui.core.EventBus();
	}
	return this.oEventBus;
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'validationError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, this Model is used.
 *
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.attachValidationError = function(fnFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.ValidationError, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'validationError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.detachValidationError = function(fnFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.ValidationError, fnFunction, oListener);
	return this;
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'parseError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, this Model is used.
 *
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.attachParseError = function(fnFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.ParseError, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'parseError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.detachParseError = function(fnFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.ParseError, fnFunction, oListener);
	return this;
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'formatError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, this Model is used.
 *
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.attachFormatError = function(fnFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.FormatError, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'formatError' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.detachFormatError = function(fnFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.FormatError, fnFunction, oListener);
	return this;
};

/**
 * Attach event-handler <code>fnFunction</code> to the 'validationSuccess' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs. This function will be called on the
 *            oListener-instance (if present) or in a 'static way'.
 * @param {object}
 *            [oListener] Object on which to call the given function. If empty, this Model is used.
 *
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.attachValidationSuccess = function(fnFunction, oListener) {
	this.attachEvent(sap.ui.core.Core.M_EVENTS.ValidationSuccess, fnFunction, oListener);
	return this;
};

/**
 * Detach event-handler <code>fnFunction</code> from the 'validationSuccess' event of <code>sap.ui.core.Core</code>.<br/>
 *
 * The passed function and listener object must match the ones previously used for event registration.
 *
 * @param {function}
 *            fnFunction The function to call, when the event occurs.
 * @param {object}
 *            oListener Object on which the given function had to be called.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @public
 */
sap.ui.core.Core.prototype.detachValidationSuccess = function(fnFunction, oListener) {
	this.detachEvent(sap.ui.core.Core.M_EVENTS.ValidationSuccess, fnFunction, oListener);
	return this;
};


/**
 * Fire event parseError to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'element' of type <code>sap.ui.core.Element</code> </li>
 * <li>'property' of type <code>string</code> </li>
 * <li>'type' of type <code>string</code> </li>
 * <li>'newValue' of type <code>object</code> </li>
 * <li>'oldValue' of type <code>object</code> </li>
 * <li>'exception' of type <code>object</code> </li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Core.prototype.fireParseError = function(mArguments) {
	this.fireEvent(sap.ui.core.Core.M_EVENTS.ParseError, mArguments);
	return this;
};

/**
 * The 'parseError' event is fired when input parsing fails.
 *
 * @name sap.ui.core.Core#parseError
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {sap.ui.core.Element} oControlEvent.getParameters.element The Element where the parse error occurred
 * @param {string} oControlEvent.getParameters.property The property name of the element where the parse error occurred
 * @param {type} oControlEvent.getParameters.type The type of the property
 * @param {object} oControlEvent.getParameters.newValue The value of the property which was entered when the parse error occurred
 * @param {object} oControlEvent.getParameters.oldValue The value of the property which was present before a new value was entered (before the parse error)
 * @param {object} oControlEvent.getParameters.exception The exception object which occurred and has more information about the parse error
 * @public
 */

/**
 * Fire event validationError to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'element' of type <code>sap.ui.core.Element</code> </li>
 * <li>'property' of type <code>string</code> </li>
 * <li>'type' of type <code>string</code> </li>
 * <li>'newValue' of type <code>object</code> </li>
 * <li>'oldValue' of type <code>object</code> </li>
 * <li>'exception' of type <code>object</code> </li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Core.prototype.fireValidationError = function(mArguments) {
	this.fireEvent(sap.ui.core.Core.M_EVENTS.ValidationError, mArguments);
	return this;
};

/**
 * The 'validationError' event is fired when validation of the input fails.
 *
 * @name sap.ui.core.Core#validationError
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {sap.ui.core.Element} oControlEvent.getParameters.element The Element where the validation error occurred
 * @param {string} oControlEvent.getParameters.property The property name of the element where the validation error occurred
 * @param {type} oControlEvent.getParameters.type The type of the property
 * @param {object} oControlEvent.getParameters.newValue The value of the property which was entered when the validation error occurred
 * @param {object} oControlEvent.getParameters.oldValue The value of the property which was present before a new value was entered (before the validation error)
 * @param {object} oControlEvent.getParameters.exception The exception object which occurred and has more information about the validation error
 * @public
 */

/**
 * Fire event formatError to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'element' of type <code>sap.ui.core.Element</code> </li>
 * <li>'property' of type <code>string</code> </li>
 * <li>'type' of type <code>string</code> </li>
 * <li>'newValue' of type <code>object</code> </li>
 * <li>'oldValue' of type <code>object</code> </li>
 * <li>'exception' of type <code>object</code> </li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Core.prototype.fireFormatError = function(mArguments) {
	this.fireEvent(sap.ui.core.Core.M_EVENTS.FormatError, mArguments);
	return this;
};

/**
 * The 'formatError' event is fired when a value formatting fails. This can happen when a value stored in the model cannot be formatted to be displayed in an element property.
 *
 * @name sap.ui.core.Core#formatError
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {sap.ui.core.Element} oControlEvent.getParameters.element The Element where the format error occurred
 * @param {string} oControlEvent.getParameters.property The property name of the element where the format error occurred
 * @param {type} oControlEvent.getParameters.type The type of the property
 * @param {object} oControlEvent.getParameters.newValue The value of the property which was entered when the format error occurred
 * @param {object} oControlEvent.getParameters.oldValue The value of the property which was present before a new value was entered (before the format error)
 * @param {object} oControlEvent.getParameters.exception The exception object which occurred and has more information about the format error
 * @public
 */

/**
 * Fire event validationSuccess to attached listeners.
 *
 * Expects following event parameters:
 * <ul>
 * <li>'element' of type <code>sap.ui.core.Element</code> </li>
 * <li>'property' of type <code>string</code> </li>
 * <li>'type' of type <code>string</code> </li>
 * <li>'newValue' of type <code>object</code> </li>
 * <li>'oldValue' of type <code>object</code> </li>
 * </ul>
 *
 * @param {Map} [mArguments] the arguments to pass along with the event.
 * @return {sap.ui.core.Core} <code>this</code> to allow method chaining
 * @protected
 */
sap.ui.core.Core.prototype.fireValidationSuccess = function(mArguments) {
	this.fireEvent(sap.ui.core.Core.M_EVENTS.ValidationSuccess, mArguments);
	return this;
};

/**
 * The 'validationSuccess' event is fired when a value validation was successfully completed.
 *
 * @name sap.ui.core.Core#validationSuccess
 * @event
 * @param {sap.ui.base.Event} oControlEvent
 * @param {sap.ui.base.EventProvider} oControlEvent.getSource
 * @param {object} oControlEvent.getParameters

 * @param {sap.ui.core.Element} oControlEvent.getParameters.element The Element where the successful validation occurred
 * @param {string} oControlEvent.getParameters.property The property name of the element where the successfull validation occurred
 * @param {type} oControlEvent.getParameters.type The type of the property
 * @param {object} oControlEvent.getParameters.newValue The value of the property which was entered when the validation occurred
 * @param {object} oControlEvent.getParameters.oldValue The value of the property which was present before a new value was entered (before the validation)
 * @public
 */

/**
 * Check if the script is running on mobile
 * @return {boolean} true or false
 * @public
 */
sap.ui.core.Core.prototype.isMobile = function() {
	return !!window.orientation;
};

/**
 * @name sap.ui.core.CorePlugin
 * @interface Contract for plugins that want to extend the core runtime
 */

/**
 * Called by the Core after it has been initialized.
 * If a plugin is added to the core after its initialization, then
 * this method is called during registration of the plugin.
 *
 * Implementing this method is optional for a plugin.
 *
 * @name sap.ui.core.CorePlugin.prototype.startPlugin
 * @param {sap.ui.core.Core} oCore reference to the core
 * @param {boolean} bOnInit whether the hook is called during Core.init() or later
 * @function
 */

/**
 * Called by the Core when it is shutdown or when a plugin is
 * deregistered from the core.
 *
 * Implementing this method is optional for a plugin.
 *
 * @name sap.ui.core.CorePlugin.prototype.stopPlugin
 * @param {sap.ui.core.Core} oCore reference to the core
 * @function
 */


// TODO come up with more sophisticated solution.
// e.g. check for script tag, check for config... if not (yet) there, delay creation by e.g. 500ms or so.
if(!window.sap.ui.getCore){
	/**
	 * Create Core instance and make it available.
	 */
	(function(){
		new sap.ui.core.Core();
	}());
}

/**
 * Displays the control tree with the given root inside the area of the given
 * DOM reference (or inside the DOM node with the given ID) or in the given Control.
 *
 * Example:
 * <pre>
 *   &lt;div id="SAPUI5UiArea">&lt;/div>
 *   &lt;script type="text/javascript">
 *     var oRoot = new sap.ui.commons.Label();
 *     oRoot.setText("Hello world!");
 *     sap.ui.setRoot("SAPUI5UiArea", oRoot);
 *   &lt;/script>
 * </pre>
 * <p>
 *
 * This is a shortcut for <code>sap.ui.getCore().setRoot()</code>.
 *
 * Internally, if a string is given that does not identify an UIArea or a control
 * then implicitly a new <code>UIArea</code> is created for the given DOM reference
 * and the given control is added.
 *
 * @param {string|DOMRef|sap.ui.core.Control} oDomRef a Dom Reference or Id String of the UIArea
 * @param {sap.ui.base.Interface | sap.ui.core.Control}
 *            oControl the Control that should be added to the <code>UIArea</code>.
 * @public
 * @deprecated Use function <code>placeAt</code> of <code>sap.ui.core.Control</code> instead.
 */
sap.ui.setRoot = function(oDomRef, oControl) {
	jQuery.sap.assert(typeof oDomRef === "string" || typeof oDomRef === "object", "oDomRef must be a string or object");
	jQuery.sap.assert(oControl instanceof sap.ui.base.Interface || oControl instanceof sap.ui.core.Control, "oControl must be a Control or Interface");

	sap.ui.getCore().setRoot(oDomRef, oControl);
};

}; // end of sap.ui.core.Core

// as this module contains the Core, we ensure that the Core has been booted
sap.ui.getCore().boot && sap.ui.getCore().boot();

