sap.riv.module(
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
function Setup() {
    var versionSearchString;
    var searchString = function(data) {
        for(var i = 0; i < data.length; i++) {
            var dataString = data[i].string;
            var dataProp = data[i].prop;
            versionSearchString = data[i].versionSearch || data[i].identity;
            if(dataString) {
                if(dataString.indexOf(data[i].subString) != -1) {
                    return data[i].identity;
                }
            } else if(dataProp) {
                return data[i].identity;
            }
        }
    };
    var seps = [';', ' '];
    var searchVersion = function(dataString) {
        var index = dataString.indexOf(versionSearchString);
        if(index == -1)
            return;
        var versionStr = dataString.substring(index + versionSearchString.length + 1);
        var i = 0, l = seps.length, sepIndex = -1;
        while(sepIndex === -1 && i < l)
        sepIndex = versionStr.indexOf(seps[i++]);
        if(sepIndex !== -1)
            versionStr = versionStr.slice(0, sepIndex);
        return versionStr;
    };
    var dataBrowser = [{
        string : navigator.userAgent,
        subString : "Chrome",
        identity : "Chrome"
    }, {
        string : navigator.userAgent,
        subString : "OmniWeb",
        versionSearch : "OmniWeb/",
        identity : "OmniWeb"
    }, {
        string : navigator.userAgent,
        subString : "Safari",
        identity : "Safari",
        versionSearch : "Version"
    }, {
        string : navigator.userAgent,
        subString : "Apple",
        identity : "UIWebView",
        versionSearch : "AppleWebKit"
    }, {
        prop : window.opera,
        identity : "Opera",
        versionSearch : "Version"
    }, {
        string : navigator.vendor,
        subString : "iCab",
        identity : "iCab"
    }, {
        string : navigator.vendor,
        subString : "KDE",
        identity : "Konqueror"
    }, {
        string : navigator.userAgent,
        subString : "Firefox",
        identity : "Firefox"
    }, {
        string : navigator.vendor,
        subString : "Camino",
        identity : "Camino"
    }, {// for newer Netscapes (6+)
        string : navigator.userAgent,
        subString : "Netscape",
        identity : "Netscape"
    }, {
        string : navigator.userAgent,
        subString : "MSIE",
        identity : "Explorer",
        versionSearch : "MSIE"
    }, {
        string : navigator.userAgent,
        subString : "Gecko",
        identity : "Mozilla",
        versionSearch : "rv"
    }, {// for older Netscapes (4-)
        string : navigator.userAgent,
        subString : "Mozilla",
        identity : "Netscape",
        versionSearch : "Mozilla"
    }];

    var dataOS = [{
        string : navigator.platform,
        subString : "Win",
        identity : "Windows"
    }, {
        string : navigator.platform,
        subString : "Mac",
        identity : "Mac"
    }, {
        string : navigator.userAgent,
        subString : "iPhone",
        identity : "iPhone/iPod"
    }, {
        string : navigator.userAgent,
        subString : "iPad",
        identity : "iPad"
    }, {
        string : navigator.platform,
        subString : "Linux",
        identity : "Linux"
    }];

    var dataRenderEngine = [{
        string : navigator.userAgent,
        subString : "Presto",
        identity : "Presto"
    }, {
        string : navigator.userAgent,
        subString : "KHTML",
        identity : "KHTML"
    }, {
        string : navigator.userAgent,
        subString : "Gecko",
        identity : "Gecko"
    }, {
        string : navigator.userAgent,
        subString : "Trident",
        identity : "Trident"
    }];
    var _userAgent = searchString(dataBrowser) || "An unknown browser",
    _version = searchVersion(navigator.userAgent) || searchVersion(navigator.appVersion) || "an unknown version",
    _isIE = searchString(dataBrowser) === "Explorer",
    _isFirefox = searchString(dataBrowser) === 'Firefox',
    _isChrome = searchString(dataBrowser) === 'Chrome',
    _isSafari = searchString(dataBrowser) === 'Safari',
    _isUIWebView = searchString(dataBrowser) === 'UIWebView',
    _os = searchString(dataOS) || "an unknown OS",
    _renderEngine = searchString(dataRenderEngine) || "An unknown RenderEngine";
    var UADetector = {
        userAgent : function() {
            return _userAgent;
        },
        version : function() {
            return _version;
        },
        isIE : function(){
            return _isIE;   
        },
        isFirefox : function() {
            return _isFirefox;
        },
        isChrome : function() {
            return _isChrome;
        },
        isSafari : function() {
            return _isSafari;
        },
        isUIWebView : function() {
            return _isUIWebView;
        },
        os : function() {
            return _os;
        },
        renderEngine : function() {
            return _renderEngine;
        }
    };
    return (UADetector);
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
function Setup() {
	var class2type = {
		'[object Boolean]' : 'boolean',
		'[object Number]' : 'number',
		'[object String]' : 'string',
		'[object Function]' : 'function',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object RegExp]' : 'regexp',
		'[object Object]' : 'object'
	};

	var hasOwn = Object.prototype.hasOwnProperty;
	// Used for trimming whitespace
	var rdigit = /\d/;

	var type = function(obj) {
		return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
	};

	/**
	 * Type Utilities for common variable type related tasks
	 * 
	 * @name sap.riv.core.utils.TypeUtils
	 * @class
	 */
	var typeUtils = {

		/**
	     * Returns a boolean value indicating whether the parameter is of type function
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		// See test/unit/core.js for details concerning isFunction.
		// Since version 1.3, DOM methods and functions like alert
		// aren't supported. They return false on IE (#2968).
		isFunction : function(obj) {
			return type(obj) === "function";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is of type array
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isArray : Array.isArray || function(obj) {
			return type(obj) === "array";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is of type string
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isString : function(obj) {
			return type(obj) === "string";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a non-empty string
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isNonEmptyString : function(obj) {
			return this.isString(obj) && obj.length !== 0;
		},

		/**
	     * Returns a boolean value indicating whether the parameter is an empty string
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isEmptyString : function(obj) {
			return this.isString(obj) && obj.length === 0;
		},

		/**
	     * Returns a boolean value indicating whether the parameter is NaN
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isNaN : function(obj) {
			return obj === null || obj === undefined || !rdigit.test(obj) || isNaN(obj);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a number
	     *
	     * @param {object}
	     * @returns {boolean} Caution: isNumber(Infinity) returns false.
	     */
		isNumber : function(n) {
			return !this.isNaN(parseFloat(n)) && isFinite(n);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is defined
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isDefined : function(v) {
			return typeof (v) !== 'undefined';
		},

		/**
	     * Returns a boolean value indicating whether the parameter is undefined
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isUndefined : function(v) {
			return typeof (v) === 'undefined';
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a plain object
	     *
	     * @param {object}
	     * @returns {boolean}
	     * Caution: A plain object is an object that has no prototype method and
	     *  no parent class. Null, undefined, DOM nodes and window object are not considered as plain object.
	     */
		isPlainObject : function(obj) {
			// Must be an Object.
			// Because of IE, we also have to check the presence of the
			// constructor property.
			// Make sure that DOM nodes and window objects don't pass through,
			// as well
			if (!obj || type(obj) !== "object" || obj.nodeType
					|| (obj && typeof obj === "object" && "setInterval" in obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor && !hasOwn.call(obj, "constructor")
					&& !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own.

			var key;
			for (key in obj) {
			}

			return key === undefined || hasOwn.call(obj, key);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is an empty object
	     *
	     * @param {object}
	     * @returns {boolean}
	     * Caution: An empty is a plain object without any properties.
	     */
		isEmptyObject : function(obj) {
			for ( var name in obj) {
				return false;
			}
			return this.isPlainObject(obj);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is undefined or null
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isExist : function(o) {
			if ((typeof (o) === 'undefined') || (o === null)) {
				return false;
			}
			return true;
		}
	};

	return typeUtils;
});sap.riv.module(
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
}
],
function Setup(UADetector) {
    var OptMath = {
        PI : Math.PI,
        E : Math.E,
        LN10 : Math.LN10,
        LN2 : Math.LN2,
        LOG2E : Math.LOG2E,
        LOG10E : Math.LOG10E,
        SQRT1_2 : Math.SQRT1_2,
        SQRT2 : Math.SQRT2,

        abs : (function() {
            if(UADetector.isSafari() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)) {
                return function(n) {
                    return n < 0 ? -n : n;
                };
            } else {
                return Math.abs;
            }
        })(),

        acos : (function() {
            return Math.acos;
        })(),

        asin : (function() {
            return Math.asin;
        })(),

        atan : (function() {
            return Math.atan;
        })(),

        atan2 : (function() {
            return Math.atan2;
        })(),

        /**
         * Get the ceil of a number.
         *
         * @name sap.riv.core.Math#ceil
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the ceil of number
         */
        ceil : (function() {
            // if (UADetector.isFirefox()) {
            // return function(n) {
            // var i = n | 0;
            // return n <= 0 ? i : (i == n ? i : i + 1);
            // };
            // }
            // else if (UADetector.isChrome()) {
            // return function(n) {
            // return n <= 0 ? n | 0 : Math.ceil(n);
            // };
            // }
            // else {
            return Math.ceil;
            // }
        })(),

        cos : (function() {
            return Math.cos;
        })(),

        exp : (function() {
            return Math.exp;
        })(),

        /**
         * Get the floor of a number.
         *
         * @name sap.riv.core.Math#floor
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the floor of number
         */
        floor : (function() {
            // if(UADetector.isFirefox()) {
            // return function(n) {
            // var a = n | 0;
            // return n < 0 ? (a == n ? a : a - 1) : a;
            // };
            // } else
            return Math.floor;
        })(),

        log : (function() {
            return Math.log;
        })(),

        /**
         * Get the maximum number in an array.
         *
         * @name sap.riv.core.Math#max
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the maximum number in array
         */
        max : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.max;
            // } else
                // return function() {
                    // var max = arguments[0];
                    // var length = arguments.length;
                    // for(var i = 1; i < length; i++) {
                        // max = arguments[i] > max ? arguments[i] : max;
                    // }
                    // return max;
                // };
        })(),

        /**
         * Get the minimum number in an array.
         *
         * @name sap.riv.core.Math#min
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the minimum number in array
         */
        min : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.min;
			// }
			// else return function(){
		        // var min = arguments[0];
		        // var length = arguments.length;
				// for (var i=1; i<length; i++){
					// min = arguments[i] > min ? min : arguments[i];
				// }
				// return min;
            // };
        })(),

        pow : (function() {
            return Math.pow;
        })(),

        random : (function() {
            return Math.random;
        })(),

        /**
         * Get the round of a number.
         *
         * @name sap.riv.core.Math#round
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the round of number
         */
        round : (function() {
            return Math.round;
            //			if(UADetector.isFirefox() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)){
            //				return function(n) {
            //					return (n >= 0) ? (n + 0.5) | 0 : (n - 0.4999999999999999) | 0;
            //				};
            //			}
            //			else if(UADetector.isChrome()){
            //				return function(n) {
            //					return Math.floor(n + 0.5);
            //				};
            //			}
            //			else return Math.round;
        })(),

        sin : (function() {
            return Math.sin;
        })(),

        sqrt : (function() {
            return Math.sqrt;
        })(),

        tan : (function() {
            return Math.tan;
        })()
    };
    return OptMath;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.RIVExCanvasMgr',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(UADetector, Math) {
	if (UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
		// alias some functions to make (compiled) code shorter
		var m = Math;
		var mr = m.round;
		var ms = m.sin;
		var mc = m.cos;
		var abs = m.abs;
		var sqrt = m.sqrt;

		// this is used for sub pixel precision
		var Z = 10;
		var Z2 = Z / 2;

		var IE_VERSION = +navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];

		/**
		 * This funtion is assigned to the <canvas> elements as
		 * element.getContext().
		 * 
		 * @this {HTMLElement}
		 * @return {CanvasRenderingContext2D_}
		 */
		function getContext() {
			return this.context_ || (this.context_ = new CanvasRenderingContext2D_(this));
		}

		var slice = Array.prototype.slice;

		/**
		 * Binds a function to an object. The returned function will always use
		 * the passed in {@code obj} as {@code this}.
		 * 
		 * Example:
		 * 
		 * g = bind(f, obj, a, b) g(c, d) // will do f.call(obj, a, b, c, d)
		 * 
		 * @param {Function}
		 *            f The function to bind the object to
		 * @param {Object}
		 *            obj The object that should act as this when the function
		 *            is called
		 * @param {*}
		 *            var_args Rest arguments that will be used as the initial
		 *            arguments when the function is called
		 * @return {Function} A new function that has bound this
		 */
		function bind(f, obj, var_args) {
			var a = slice.call(arguments, 2);
			return function() {
				return f.apply(obj, a.concat(slice.call(arguments)));
			};
		}

		function encodeHtmlAttribute(s) {
			return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
		}

		function addNamespace(doc, prefix, urn) {
			if (!doc.namespaces[prefix]) {
				doc.namespaces.add(prefix, urn, '#default#VML');
			}
		}

		function addNamespacesAndStylesheet(doc) {
			addNamespace(doc, 'r_vml_', 'urn:schemas-microsoft-com:vml');
			addNamespace(doc, 'r_o_', 'urn:schemas-microsoft-com:office:office');

			// Setup default CSS. Only add one style sheet per document
			if (!doc.styleSheets['r_ex_canvas_']) {
				var ss = doc.createStyleSheet();
				ss.owningElement.id = 'r_ex_canvas_';
				ss.cssText = 'rivcanvas{display:inline-block;overflow:hidden;' +
				// default size is 300x150 in Gecko and Opera
				'text-align:left;width:300px;height:150px}';
			}
		}

		// Add namespaces and stylesheet at startup.
		addNamespacesAndStylesheet(document);

		var G_vmlCanvasManager_ = {
			init : function(opt_doc) {
				var doc = opt_doc || document;
				// Create a dummy element so that IE will allow canvas
				// elements to be
				// recognized.
				doc.createElement('rivcanvas');
				doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
			},

			init_ : function(doc) {
				// find all canvas elements
				var els = doc.getElementsByTagName('rivcanvas');
				for ( var i = 0; i < els.length; i++) {
					this.initElement(els[i]);
				}
			},

			/**
			 * Public initializes a canvas element so that it can be used as
			 * canvas element from now on. This is called automatically before
			 * the page is loaded but if you are creating elements using
			 * createElement you need to make sure this is called on the
			 * element.
			 * 
			 * @param {HTMLElement}
			 *            el The canvas element to initialize.
			 * @return {HTMLElement} the element that was created.
			 */
			initElement : function(el) {
				if (!el.getContext) {
					el.getContext = getContext;

					// Add namespaces and stylesheet to document of the
					// element.
					addNamespacesAndStylesheet(el.ownerDocument);

					// Remove fallback content. There is no way to hide text
					// nodes so we
					// just remove all childNodes. We could hide all
					// elements and remove
					// text nodes but who really cares about the fallback
					// content.
					el.innerHTML = '';

					// do not use inline function because that will leak
					// memory
					el.attachEvent('onpropertychange', onPropertyChange);
					el.attachEvent('onresize', onResize);

					var attrs = el.attributes;
					if (attrs.width && attrs.width.specified) {
						// TODO: use runtimeStyle and coordsize
						// el.getContext().setWidth_(attrs.width.nodeValue);
						el.style.width = attrs.width.nodeValue + 'px';
					} else {
						el.width = el.clientWidth;
					}
					if (attrs.height && attrs.height.specified) {
						// TODO: use runtimeStyle and coordsize
						// el.getContext().setHeight_(attrs.height.nodeValue);
						el.style.height = attrs.height.nodeValue + 'px';
					} else {
						el.height = el.clientHeight;
					}
					// el.getContext().setCoordsize_()
				}
				return el;
			}
		};

		function onPropertyChange(e) {
			var el = e.srcElement;

			switch (e.propertyName) {
			case 'width':
				el.getContext().clearRect();
				el.style.width = el.attributes.width.nodeValue + 'px';
				// In IE8 this does not trigger onresize.
				el.firstChild.style.width = el.width + 'px';
				break;
			case 'height':
				el.getContext().clearRect();
				el.style.height = el.attributes.height.nodeValue + 'px';
				el.firstChild.style.height = el.height + 'px';
				break;
			}
		}

		function onResize(e) {
			var el = e.srcElement;
			if (el.firstChild) {
				el.firstChild.style.width = el.clientWidth + 'px';
				el.firstChild.style.height = el.clientHeight + 'px';
			}
		}

		G_vmlCanvasManager_.init();

		// precompute "00" to "FF"
		var decToHex = [];
		for ( var i = 0; i < 16; i++) {
			for ( var j = 0; j < 16; j++) {
				decToHex[i * 16 + j] = i.toString(16) + j.toString(16);
			}
		}

		function createMatrixIdentity() {
			return [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
		}

		function matrixMultiply(m1, m2) {
			var result = createMatrixIdentity();

			for ( var x = 0; x < 3; x++) {
				for ( var y = 0; y < 3; y++) {
					var sum = 0;

					for ( var z = 0; z < 3; z++) {
						sum += m1[x][z] * m2[z][y];
					}

					result[x][y] = sum;
				}
			}
			return result;
		}

		function copyState(o1, o2) {
			o2.fillStyle = o1.fillStyle;
			o2.lineCap = o1.lineCap;
			o2.lineJoin = o1.lineJoin;
			o2.lineWidth = o1.lineWidth;
			o2.miterLimit = o1.miterLimit;
			o2.shadowBlur = o1.shadowBlur;
			o2.shadowColor = o1.shadowColor;
			o2.shadowOffsetX = o1.shadowOffsetX;
			o2.shadowOffsetY = o1.shadowOffsetY;
			o2.strokeStyle = o1.strokeStyle;
			o2.globalAlpha = o1.globalAlpha;
			o2.font = o1.font;
			o2.textAlign = o1.textAlign;
			o2.textBaseline = o1.textBaseline;
			o2.arcScaleX_ = o1.arcScaleX_;
			o2.arcScaleY_ = o1.arcScaleY_;
			o2.lineScale_ = o1.lineScale_;
		}

		var colorData = {
			aliceblue : '#F0F8FF',
			antiquewhite : '#FAEBD7',
			aquamarine : '#7FFFD4',
			azure : '#F0FFFF',
			beige : '#F5F5DC',
			bisque : '#FFE4C4',
			black : '#000000',
			blanchedalmond : '#FFEBCD',
			blueviolet : '#8A2BE2',
			brown : '#A52A2A',
			burlywood : '#DEB887',
			cadetblue : '#5F9EA0',
			chartreuse : '#7FFF00',
			chocolate : '#D2691E',
			coral : '#FF7F50',
			cornflowerblue : '#6495ED',
			cornsilk : '#FFF8DC',
			crimson : '#DC143C',
			cyan : '#00FFFF',
			darkblue : '#00008B',
			darkcyan : '#008B8B',
			darkgoldenrod : '#B8860B',
			darkgray : '#A9A9A9',
			darkgreen : '#006400',
			darkgrey : '#A9A9A9',
			darkkhaki : '#BDB76B',
			darkmagenta : '#8B008B',
			darkolivegreen : '#556B2F',
			darkorange : '#FF8C00',
			darkorchid : '#9932CC',
			darkred : '#8B0000',
			darksalmon : '#E9967A',
			darkseagreen : '#8FBC8F',
			darkslateblue : '#483D8B',
			darkslategray : '#2F4F4F',
			darkslategrey : '#2F4F4F',
			darkturquoise : '#00CED1',
			darkviolet : '#9400D3',
			deeppink : '#FF1493',
			deepskyblue : '#00BFFF',
			dimgray : '#696969',
			dimgrey : '#696969',
			dodgerblue : '#1E90FF',
			firebrick : '#B22222',
			floralwhite : '#FFFAF0',
			forestgreen : '#228B22',
			gainsboro : '#DCDCDC',
			ghostwhite : '#F8F8FF',
			gold : '#FFD700',
			goldenrod : '#DAA520',
			grey : '#808080',
			greenyellow : '#ADFF2F',
			honeydew : '#F0FFF0',
			hotpink : '#FF69B4',
			indianred : '#CD5C5C',
			indigo : '#4B0082',
			ivory : '#FFFFF0',
			khaki : '#F0E68C',
			lavender : '#E6E6FA',
			lavenderblush : '#FFF0F5',
			lawngreen : '#7CFC00',
			lemonchiffon : '#FFFACD',
			lightblue : '#ADD8E6',
			lightcoral : '#F08080',
			lightcyan : '#E0FFFF',
			lightgoldenrodyellow : '#FAFAD2',
			lightgreen : '#90EE90',
			lightgrey : '#D3D3D3',
			lightpink : '#FFB6C1',
			lightsalmon : '#FFA07A',
			lightseagreen : '#20B2AA',
			lightskyblue : '#87CEFA',
			lightslategray : '#778899',
			lightslategrey : '#778899',
			lightsteelblue : '#B0C4DE',
			lightyellow : '#FFFFE0',
			limegreen : '#32CD32',
			linen : '#FAF0E6',
			magenta : '#FF00FF',
			mediumaquamarine : '#66CDAA',
			mediumblue : '#0000CD',
			mediumorchid : '#BA55D3',
			mediumpurple : '#9370DB',
			mediumseagreen : '#3CB371',
			mediumslateblue : '#7B68EE',
			mediumspringgreen : '#00FA9A',
			mediumturquoise : '#48D1CC',
			mediumvioletred : '#C71585',
			midnightblue : '#191970',
			mintcream : '#F5FFFA',
			mistyrose : '#FFE4E1',
			moccasin : '#FFE4B5',
			navajowhite : '#FFDEAD',
			oldlace : '#FDF5E6',
			olivedrab : '#6B8E23',
			orange : '#FFA500',
			orangered : '#FF4500',
			orchid : '#DA70D6',
			palegoldenrod : '#EEE8AA',
			palegreen : '#98FB98',
			paleturquoise : '#AFEEEE',
			palevioletred : '#DB7093',
			papayawhip : '#FFEFD5',
			peachpuff : '#FFDAB9',
			peru : '#CD853F',
			pink : '#FFC0CB',
			plum : '#DDA0DD',
			powderblue : '#B0E0E6',
			rosybrown : '#BC8F8F',
			royalblue : '#4169E1',
			saddlebrown : '#8B4513',
			salmon : '#FA8072',
			sandybrown : '#F4A460',
			seagreen : '#2E8B57',
			seashell : '#FFF5EE',
			sienna : '#A0522D',
			skyblue : '#87CEEB',
			slateblue : '#6A5ACD',
			slategray : '#708090',
			slategrey : '#708090',
			snow : '#FFFAFA',
			springgreen : '#00FF7F',
			steelblue : '#4682B4',
			tan : '#D2B48C',
			thistle : '#D8BFD8',
			tomato : '#FF6347',
			turquoise : '#40E0D0',
			violet : '#EE82EE',
			wheat : '#F5DEB3',
			whitesmoke : '#F5F5F5',
			yellowgreen : '#9ACD32'
		};

		function getRgbHslContent(styleString) {
			var start = styleString.indexOf('(', 3);
			var end = styleString.indexOf(')', start + 1);
			var parts = styleString.substring(start + 1, end).split(',');
			// add alpha if needed
			if (parts.length != 4 || styleString.charAt(3) != 'a') {
				parts[3] = 1;
			}
			return parts;
		}

		function percent(s) {
			return parseFloat(s) / 100;
		}

		function clamp(v, min, max) {
			return Math.min(max, Math.max(min, v));
		}

		function hslToRgb(parts) {
			var r, g, b, h, s, l;
			h = parseFloat(parts[0]) / 360 % 360;
			if (h < 0)
				h++;
			s = clamp(percent(parts[1]), 0, 1);
			l = clamp(percent(parts[2]), 0, 1);
			if (s == 0) {
				r = g = b = l; // achromatic
			} else {
				var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
				var p = 2 * l - q;
				r = hueToRgb(p, q, h + 1 / 3);
				g = hueToRgb(p, q, h);
				b = hueToRgb(p, q, h - 1 / 3);
			}

			return '#' + decToHex[Math.floor(r * 255)] + decToHex[Math.floor(g * 255)] + decToHex[Math.floor(b * 255)];
		}

		function hueToRgb(m1, m2, h) {
			if (h < 0)
				h++;
			if (h > 1)
				h--;

			if (6 * h < 1)
				return m1 + (m2 - m1) * 6 * h;
			else if (2 * h < 1)
				return m2;
			else if (3 * h < 2)
				return m1 + (m2 - m1) * (2 / 3 - h) * 6;
			else
				return m1;
		}

		var processStyleCache = {};

		function processStyle(styleString) {
			if (styleString in processStyleCache) {
				return processStyleCache[styleString];
			}

			var str, alpha = 1;

			styleString = String(styleString);
			if (styleString.charAt(0) == '#') {
				str = styleString;
			} else if (/^rgb/.test(styleString)) {
				var parts = getRgbHslContent(styleString);
				var str = '#', n;
				for ( var i = 0; i < 3; i++) {
					if (parts[i].indexOf('%') != -1) {
						n = Math.floor(percent(parts[i]) * 255);
					} else {
						n = +parts[i];
					}
					str += decToHex[clamp(n, 0, 255)];
				}
				alpha = +parts[3];
			} else if (/^hsl/.test(styleString)) {
				var parts = getRgbHslContent(styleString);
				str = hslToRgb(parts);
				alpha = parts[3];
			} else {
				str = colorData[styleString] || styleString;
			}
			return processStyleCache[styleString] = {
				color : str,
				alpha : alpha
			};
		}

		var DEFAULT_STYLE = {
			style : 'normal',
			variant : 'normal',
			weight : 'normal',
			size : 10,
			family : 'sans-serif'
		};

		// Internal text style cache
		var fontStyleCache = {};

		function processFontStyle(styleString) {
			if (fontStyleCache[styleString]) {
				return fontStyleCache[styleString];
			}

			var el = document.createElement('div');
			var style = el.style;
			try {
				style.font = styleString;
			} catch (ex) {
				// Ignore failures to set to invalid font.
			}

			return fontStyleCache[styleString] = {
				style : style.fontStyle || DEFAULT_STYLE.style,
				variant : style.fontVariant || DEFAULT_STYLE.variant,
				weight : style.fontWeight || DEFAULT_STYLE.weight,
				size : style.fontSize || DEFAULT_STYLE.size,
				family : style.fontFamily || DEFAULT_STYLE.family
			};
		}

		function getComputedStyle(style, element) {
			var computedStyle = {};

			for ( var p in style) {
				computedStyle[p] = style[p];
			}

			// Compute the size
			var canvasFontSize = parseFloat(element.currentStyle.fontSize), fontSize = parseFloat(style.size);

			if (typeof style.size == 'number') {
				computedStyle.size = style.size;
			} else if (style.size.indexOf('px') != -1) {
				computedStyle.size = fontSize;
			} else if (style.size.indexOf('em') != -1) {
				computedStyle.size = canvasFontSize * fontSize;
			} else if (style.size.indexOf('%') != -1) {
				computedStyle.size = (canvasFontSize / 100) * fontSize;
			} else if (style.size.indexOf('pt') != -1) {
				computedStyle.size = fontSize / .75;
			} else {
				computedStyle.size = canvasFontSize;
			}

			// Different scaling between normal text and VML text. This was
			// found using
			// trial and error to get the same size as non VML text.
			computedStyle.size *= 0.981;

			return computedStyle;
		}

		function buildStyle(style) {
			return style.style + ' ' + style.variant + ' ' + style.weight + ' ' + style.size + 'px ' + style.family;
		}

		var lineCapMap = {
			'butt' : 'flat',
			'round' : 'round'
		};

		function processLineCap(lineCap) {
			return lineCapMap[lineCap] || 'square';
		}

		/**
		 * This class implements CanvasRenderingContext2D interface as described
		 * by the WHATWG.
		 * 
		 * @param {HTMLElement}
		 *            canvasElement The element that the 2D context should be
		 *            associated with
		 */
		function CanvasRenderingContext2D_(canvasElement) {
			this.m_ = createMatrixIdentity();

			this.mStack_ = [];
			this.aStack_ = [];
			this.currentPath_ = [];

			// Canvas context properties
			this.strokeStyle = '#000';
			this.fillStyle = '#000';

			this.lineWidth = 1;
			this.lineJoin = 'miter';
			this.lineCap = 'butt';
			this.miterLimit = Z * 1;
			this.globalAlpha = 1;
			this.font = '10px sans-serif';
			this.textAlign = 'left';
			this.textBaseline = 'alphabetic';
			this.canvas = canvasElement;

			var cssText = 'width:' + canvasElement.clientWidth + 'px;height:' + canvasElement.clientHeight
					+ 'px;overflow:hidden;position:absolute';
			var el = canvasElement.ownerDocument.createElement('div');
			el.style.cssText = cssText;
			canvasElement.appendChild(el);

			var overlayEl = el.cloneNode(false);
			// Use a non transparent background.
			overlayEl.style.backgroundColor = 'red';
			overlayEl.style.filter = 'alpha(opacity=0)';
			canvasElement.appendChild(overlayEl);

			this.element_ = el;
			this.arcScaleX_ = 1;
			this.arcScaleY_ = 1;
			this.lineScale_ = 1;
		}

		var contextPrototype = CanvasRenderingContext2D_.prototype;
		contextPrototype.clearRect = function() {
			if (this.textMeasureEl_) {
				this.textMeasureEl_.removeNode(true);
				this.textMeasureEl_ = null;
			}
			this.element_.innerHTML = '';
		};

		contextPrototype.beginPath = function() {
			// TODO: Branch current matrix so that save/restore has no
			// effect
			// as per safari docs.
			this.currentPath_ = [];
		};

		contextPrototype.moveTo = function(aX, aY) {
			var p = getCoords(this, aX, aY);
			this.currentPath_.push({
				type : 'moveTo',
				x : p.x,
				y : p.y
			});
			this.currentX_ = p.x;
			this.currentY_ = p.y;
		};

		contextPrototype.lineTo = function(aX, aY) {
			var p = getCoords(this, aX, aY);
			this.currentPath_.push({
				type : 'lineTo',
				x : p.x,
				y : p.y
			});

			this.currentX_ = p.x;
			this.currentY_ = p.y;
		};

		contextPrototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			var p = getCoords(this, aX, aY);
			var cp1 = getCoords(this, aCP1x, aCP1y);
			var cp2 = getCoords(this, aCP2x, aCP2y);
			bezierCurveTo(this, cp1, cp2, p);
		};

		// Helper function that takes the already fixed cordinates.
		function bezierCurveTo(self, cp1, cp2, p) {
			self.currentPath_.push({
				type : 'bezierCurveTo',
				cp1x : cp1.x,
				cp1y : cp1.y,
				cp2x : cp2.x,
				cp2y : cp2.y,
				x : p.x,
				y : p.y
			});
			self.currentX_ = p.x;
			self.currentY_ = p.y;
		}

		contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
			// the following is lifted almost directly from
			// http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

			var cp = getCoords(this, aCPx, aCPy);
			var p = getCoords(this, aX, aY);

			var cp1 = {
				x : this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
				y : this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
			};
			var cp2 = {
				x : cp1.x + (p.x - this.currentX_) / 3.0,
				y : cp1.y + (p.y - this.currentY_) / 3.0
			};

			bezierCurveTo(this, cp1, cp2, p);
		};

		contextPrototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			aRadius *= Z;
			var arcType = aClockwise ? 'at' : 'wa';

			var xStart = aX + mc(aStartAngle) * aRadius - Z2;
			var yStart = aY + ms(aStartAngle) * aRadius - Z2;

			var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
			var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

			// IE won't render arches drawn counter clockwise if xStart ==
			// xEnd.
			if (xStart == xEnd && !aClockwise) {
				xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use
				// something
				// that can be represented in binary
			}

			var p = getCoords(this, aX, aY);
			var pStart = getCoords(this, xStart, yStart);
			var pEnd = getCoords(this, xEnd, yEnd);

			this.currentPath_.push({
				type : arcType,
				x : p.x,
				y : p.y,
				radius : aRadius,
				xStart : pStart.x,
				yStart : pStart.y,
				xEnd : pEnd.x,
				yEnd : pEnd.y
			});

		};

		contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
			this.moveTo(aX, aY);
			this.lineTo(aX + aWidth, aY);
			this.lineTo(aX + aWidth, aY + aHeight);
			this.lineTo(aX, aY + aHeight);
			this.closePath();
		};

		contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
			var oldPath = this.currentPath_;
			this.beginPath();

			this.moveTo(aX, aY);
			this.lineTo(aX + aWidth, aY);
			this.lineTo(aX + aWidth, aY + aHeight);
			this.lineTo(aX, aY + aHeight);
			this.closePath();
			this.stroke();

			this.currentPath_ = oldPath;
		};

		contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
			var oldPath = this.currentPath_;
			this.beginPath();

			this.moveTo(aX, aY);
			this.lineTo(aX + aWidth, aY);
			this.lineTo(aX + aWidth, aY + aHeight);
			this.lineTo(aX, aY + aHeight);
			this.closePath();
			this.fill();

			this.currentPath_ = oldPath;
		};

		contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
			var gradient = new CanvasGradient_('gradient');
			gradient.x0_ = aX0;
			gradient.y0_ = aY0;
			gradient.x1_ = aX1;
			gradient.y1_ = aY1;
			return gradient;
		};

		contextPrototype.createRadialGradient = function(aX0, aY0, aR0, aX1, aY1, aR1) {
			var gradient = new CanvasGradient_('gradientradial');
			gradient.x0_ = aX0;
			gradient.y0_ = aY0;
			gradient.r0_ = aR0;
			gradient.x1_ = aX1;
			gradient.y1_ = aY1;
			gradient.r1_ = aR1;
			return gradient;
		};

		contextPrototype.drawImage = function(image, var_args) {
			var dx, dy, dw, dh, sx, sy, sw, sh;

			// to find the original width we overide the width and height
			var oldRuntimeWidth = image.runtimeStyle.width;
			var oldRuntimeHeight = image.runtimeStyle.height;
			image.runtimeStyle.width = 'auto';
			image.runtimeStyle.height = 'auto';

			// get the original size
			var w = image.width;
			var h = image.height;

			// and remove overides
			image.runtimeStyle.width = oldRuntimeWidth;
			image.runtimeStyle.height = oldRuntimeHeight;

			if (arguments.length == 3) {
				dx = arguments[1];
				dy = arguments[2];
				sx = sy = 0;
				sw = dw = w;
				sh = dh = h;
			} else if (arguments.length == 5) {
				dx = arguments[1];
				dy = arguments[2];
				dw = arguments[3];
				dh = arguments[4];
				sx = sy = 0;
				sw = w;
				sh = h;
			} else if (arguments.length == 9) {
				sx = arguments[1];
				sy = arguments[2];
				sw = arguments[3];
				sh = arguments[4];
				dx = arguments[5];
				dy = arguments[6];
				dw = arguments[7];
				dh = arguments[8];
			} else {
				throw Error('Invalid number of arguments');
			}

			var d = getCoords(this, dx, dy);

			var w2 = sw / 2;
			var h2 = sh / 2;

			var vmlStr = [];

			var W = 10;
			var H = 10;

			// For some reason that I've now forgotten, using divs didn't
			// work
			vmlStr.push(' <r_vml_:group', ' coordsize="', Z * W, ',', Z * H, '"', ' coordorigin="0,0"',
					' style="width:', W, 'px;height:', H, 'px;position:absolute;');

			// If filters are necessary (rotation exists), create them
			// filters are bog-slow, so only create them if abbsolutely
			// necessary
			// The following check doesn't account for skews (which don't
			// exist
			// in the canvas spec (yet) anyway.

			if (this.m_[0][0] != 1 || this.m_[0][1] || this.m_[1][1] != 1 || this.m_[1][0]) {
				var filter = [];

				// Note the 12/21 reversal
				filter.push('M11=', this.m_[0][0], ',', 'M12=', this.m_[1][0], ',', 'M21=', this.m_[0][1], ',', 'M22=',
						this.m_[1][1], ',', 'Dx=', mr(d.x / Z), ',', 'Dy=', mr(d.y / Z), '');

				// Bounding box calculation (need to minimize displayed area
				// so that
				// filters don't waste time on unused pixels.
				var max = d;
				var c2 = getCoords(this, dx + dw, dy);
				var c3 = getCoords(this, dx, dy + dh);
				var c4 = getCoords(this, dx + dw, dy + dh);

				max.x = m.max(max.x, c2.x, c3.x, c4.x);
				max.y = m.max(max.y, c2.y, c3.y, c4.y);

				vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),
						'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(', filter.join(''),
						", sizingmethod='clip');");

			} else {
				vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
			}

			vmlStr.push(' ">', '<r_vml_:image src="', image.src, '"', ' style="width:', Z * dw, 'px;', ' height:', Z
					* dh, 'px"', ' cropleft="', sx / w, '"', ' croptop="', sy / h, '"', ' cropright="', (w - sx - sw)
					/ w, '"', ' cropbottom="', (h - sy - sh) / h, '"', ' />', '</r_vml_:group>');

			this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));
		};

		contextPrototype.stroke = function(aFill) {
			var lineStr = [];
			var lineOpen = false;

			var W = 10;
			var H = 10;

			lineStr.push('<r_vml_:shape', ' filled="', !!aFill, '"', ' style="position:absolute;width:', W,
					'px;height:', H, 'px;"', ' coordorigin="0,0"', ' coordsize="', Z * W, ',', Z * H, '"',
					' stroked="', !aFill, '"', ' path="');

			var newSeq = false;
			var min = {
				x : null,
				y : null
			};
			var max = {
				x : null,
				y : null
			};

			for ( var i = 0; i < this.currentPath_.length; i++) {
				var p = this.currentPath_[i];
				var c;

				switch (p.type) {
				case 'moveTo':
					c = p;
					lineStr.push(' m ', mr(p.x), ',', mr(p.y));
					break;
				case 'lineTo':
					lineStr.push(' l ', mr(p.x), ',', mr(p.y));
					break;
				case 'close':
					lineStr.push(' x ');
					p = null;
					break;
				case 'bezierCurveTo':
					lineStr.push(' c ', mr(p.cp1x), ',', mr(p.cp1y), ',', mr(p.cp2x), ',', mr(p.cp2y), ',', mr(p.x),
							',', mr(p.y));
					break;
				case 'at':
				case 'wa':
					lineStr.push(' ', p.type, ' ', mr(p.x - this.arcScaleX_ * p.radius), ',', mr(p.y - this.arcScaleY_
							* p.radius), ' ', mr(p.x + this.arcScaleX_ * p.radius), ',', mr(p.y + this.arcScaleY_
							* p.radius), ' ', mr(p.xStart), ',', mr(p.yStart), ' ', mr(p.xEnd), ',', mr(p.yEnd));
					break;
				}

				// TODO: Following is broken for curves due to
				// move to proper paths.

				// Figure out dimensions so we can do gradient fills
				// properly
				if (p) {
					if (min.x == null || p.x < min.x) {
						min.x = p.x;
					}
					if (max.x == null || p.x > max.x) {
						max.x = p.x;
					}
					if (min.y == null || p.y < min.y) {
						min.y = p.y;
					}
					if (max.y == null || p.y > max.y) {
						max.y = p.y;
					}
				}
			}
			lineStr.push(' ">');

			if (!aFill) {
				appendStroke(this, lineStr);
			} else {
				appendFill(this, lineStr, min, max);
			}

			lineStr.push('</r_vml_:shape>');

			this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
		};

		function appendStroke(ctx, lineStr) {
			var a = processStyle(ctx.strokeStyle);
			var color = a.color;
			var opacity = a.alpha * ctx.globalAlpha;
			var lineWidth = ctx.lineScale_ * ctx.lineWidth;

			// VML cannot correctly render a line if the width is less than
			// 1px.
			// In that case, we dilute the color to make the line look
			// thinner.
			if (lineWidth < 1) {
				opacity *= lineWidth;
			}

			lineStr.push('<r_vml_:stroke', ' opacity="', opacity, '"', ' joinstyle="', ctx.lineJoin, '"',
					' miterlimit="', ctx.miterLimit, '"', ' endcap="', processLineCap(ctx.lineCap), '"', ' weight="',
					lineWidth, 'px"', ' color="', color, '" />');
		}

		function appendFill(ctx, lineStr, min, max) {
			var fillStyle = ctx.fillStyle;
			var arcScaleX = ctx.arcScaleX_;
			var arcScaleY = ctx.arcScaleY_;
			var width = max.x - min.x;
			var height = max.y - min.y;
			if (fillStyle instanceof CanvasGradient_) {
				// TODO: Gradients transformed with the transformation
				// matrix.
				var angle = 0;
				var focus = {
					x : 0,
					y : 0
				};

				// additional offset
				var shift = 0;
				// scale factor for offset
				var expansion = 1;

				if (fillStyle.type_ == 'gradient') {
					var x0 = fillStyle.x0_ / arcScaleX;
					var y0 = fillStyle.y0_ / arcScaleY;
					var x1 = fillStyle.x1_ / arcScaleX;
					var y1 = fillStyle.y1_ / arcScaleY;
					var p0 = getCoords(ctx, x0, y0);
					var p1 = getCoords(ctx, x1, y1);
					var dx = p1.x - p0.x;
					var dy = p1.y - p0.y;
					angle = Math.atan2(dx, dy) * 180 / Math.PI;

					// The angle should be a non-negative number.
					if (angle < 0) {
						angle += 360;
					}

					// Very small angles produce an unexpected result
					// because they are
					// converted to a scientific notation string.
					if (angle < 1e-6) {
						angle = 0;
					}
				} else {
					var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);
					focus = {
						x : (p0.x - min.x) / width,
						y : (p0.y - min.y) / height
					};

					width /= arcScaleX * Z;
					height /= arcScaleY * Z;
					var dimension = m.max(width, height);
					shift = 2 * fillStyle.r0_ / dimension;
					expansion = 2 * fillStyle.r1_ / dimension - shift;
				}

				// We need to sort the color stops in ascending order by
				// offset,
				// otherwise IE won't interpret it correctly.
				var stops = fillStyle.colors_;
				stops.sort(function(cs1, cs2) {
					return cs1.offset - cs2.offset;
				});

				var length = stops.length;
				var color1 = stops[0].color;
				var color2 = stops[length - 1].color;
				var opacity1 = stops[0].alpha * ctx.globalAlpha;
				var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;

				var colors = [];
				for ( var i = 0; i < length; i++) {
					var stop = stops[i];
					colors.push(stop.offset * expansion + shift + ' ' + stop.color);
				}

				// When colors attribute is used, the meanings of opacity
				// and o:opacity2
				// are reversed.
				lineStr.push('<r_vml_:fill type="', fillStyle.type_, '"', ' method="none" focus="100%"', ' color="',
						color1, '"', ' color2="', color2, '"', ' colors="', colors.join(','), '"', ' opacity="',
						opacity2, '"', ' r_o_:opacity2="', opacity1, '"', ' angle="', angle, '"', ' focusposition="',
						focus.x, ',', focus.y, '" />');
			} else if (fillStyle instanceof CanvasPattern_) {
				if (width && height) {
					var deltaLeft = -min.x;
					var deltaTop = -min.y;
					lineStr.push('<r_vml_:fill', ' position="', deltaLeft / width * arcScaleX * arcScaleX, ',',
							deltaTop / height * arcScaleY * arcScaleY, '"', ' type="tile"',
							// TODO: Figure out the correct size to fit the
							// scale.
							// ' size="', w, 'px ', h, 'px"',
							' src="', fillStyle.src_, '" />');
				}
			} else {
				var a = processStyle(ctx.fillStyle);
				var color = a.color;
				var opacity = a.alpha * ctx.globalAlpha;
				lineStr.push('<r_vml_:fill color="', color, '" opacity="', opacity, '" />');
			}
		}

		contextPrototype.fill = function() {
			this.stroke(true);
		};

		contextPrototype.closePath = function() {
			this.currentPath_.push({
				type : 'close'
			});
		};

		function getCoords(ctx, aX, aY) {
			var m = ctx.m_;
			return {
				x : Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
				y : Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
			};
		}
		;

		contextPrototype.save = function() {
			var o = {};
			copyState(this, o);
			this.aStack_.push(o);
			this.mStack_.push(this.m_);
			this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
		};

		contextPrototype.restore = function() {
			if (this.aStack_.length) {
				copyState(this.aStack_.pop(), this);
				this.m_ = this.mStack_.pop();
			}
		};

		function matrixIsFinite(m) {
			return isFinite(m[0][0]) && isFinite(m[0][1]) && isFinite(m[1][0]) && isFinite(m[1][1])
					&& isFinite(m[2][0]) && isFinite(m[2][1]);
		}

		function setM(ctx, m, updateLineScale) {
			if (!matrixIsFinite(m)) {
				return;
			}
			ctx.m_ = m;

			if (updateLineScale) {
				// Get the line scale.
				// Determinant of this.m_ means how much the area is
				// enlarged by the
				// transformation. So its square root can be used as a scale
				// factor
				// for width.
				var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
				ctx.lineScale_ = sqrt(abs(det));
			}
		}

		contextPrototype.translate = function(aX, aY) {
			var m1 = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ aX, aY, 1 ] ];

			setM(this, matrixMultiply(m1, this.m_), false);
		};

		contextPrototype.rotate = function(aRot) {
			var c = mc(aRot);
			var s = ms(aRot);

			var m1 = [ [ c, s, 0 ], [ -s, c, 0 ], [ 0, 0, 1 ] ];

			setM(this, matrixMultiply(m1, this.m_), false);
		};

		contextPrototype.scale = function(aX, aY) {
			this.arcScaleX_ *= aX;
			this.arcScaleY_ *= aY;
			var m1 = [ [ aX, 0, 0 ], [ 0, aY, 0 ], [ 0, 0, 1 ] ];

			setM(this, matrixMultiply(m1, this.m_), true);
		};

		contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
			var m1 = [ [ m11, m12, 0 ], [ m21, m22, 0 ], [ dx, dy, 1 ] ];

			setM(this, matrixMultiply(m1, this.m_), true);
		};

		contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
			var m = [ [ m11, m12, 0 ], [ m21, m22, 0 ], [ dx, dy, 1 ] ];

			setM(this, m, true);
		};

		/**
		 * The text drawing function. The maxWidth argument isn't taken in
		 * account, since no browser supports it yet.
		 */
		contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {
			var m = this.m_, delta = 1000, left = 0, right = delta, offset = {
				x : 0,
				y : 0
			}, lineStr = [];

			var fontStyle = getComputedStyle(processFontStyle(this.font), this.element_);

			var fontStyleString = buildStyle(fontStyle);

			var elementStyle = this.element_.currentStyle;
			var textAlign = this.textAlign.toLowerCase();
			switch (textAlign) {
			case 'left':
			case 'center':
			case 'right':
				break;
			case 'end':
				textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';
				break;
			case 'start':
				textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';
				break;
			default:
				textAlign = 'left';
			}

			// 1.75 is an arbitrary number, as there is no info about the
			// text baseline
			switch (this.textBaseline) {
			case 'hanging':
			case 'top':
				offset.y = fontStyle.size / 1.75;
				break;
			case 'middle':
				break;
			default:
			case null:
			case 'alphabetic':
			case 'ideographic':
			case 'bottom':
				offset.y = -fontStyle.size / 2.25;
				break;
			}

			switch (textAlign) {
			case 'right':
				left = delta;
				right = 0.05;
				break;
			case 'center':
				left = right = delta / 2;
				break;
			}

			var d = getCoords(this, x + offset.x, y + offset.y);

			lineStr.push('<r_vml_:line from="', -left, ' 0" to="', right, ' 0.05" ',
					' coordsize="100 100" coordorigin="0 0"', ' filled="', !stroke, '" stroked="', !!stroke,
					'" style="position:absolute;width:1px;height:1px;">');

			if (stroke) {
				appendStroke(this, lineStr);
			} else {
				// TODO: Fix the min and max params.
				appendFill(this, lineStr, {
					x : -left,
					y : 0
				}, {
					x : right,
					y : fontStyle.size
				});
			}

			var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' + m[0][1].toFixed(3) + ','
					+ m[1][1].toFixed(3) + ',0,0';

			var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);

			lineStr.push('<r_vml_:skew on="t" matrix="', skewM, '" ', ' offset="', skewOffset, '" origin="', left,
					' 0" />', '<r_vml_:path textpathok="true" />', '<r_vml_:textpath on="true" string="',
					encodeHtmlAttribute(text), '" style="v-text-align:', textAlign, ';font:',
					encodeHtmlAttribute(fontStyleString), '" /></r_vml_:line>');

			this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
		};

		contextPrototype.fillText = function(text, x, y, maxWidth) {
			this.drawText_(text, x, y, maxWidth, false);
		};

		contextPrototype.strokeText = function(text, x, y, maxWidth) {
			this.drawText_(text, x, y, maxWidth, true);
		};

		contextPrototype.measureText = function(text) {
			if (!this.textMeasureEl_) {
				var s = '<span style="position:absolute;' + 'top:-20000px;left:0;padding:0;margin:0;border:none;'
						+ 'white-space:pre;"></span>';
				this.element_.insertAdjacentHTML('beforeEnd', s);
				this.textMeasureEl_ = this.element_.lastChild;
			}
			var doc = this.element_.ownerDocument;
			this.textMeasureEl_.innerHTML = '';
			this.textMeasureEl_.style.font = this.font;
			// Don't use innerHTML or innerText because they allow
			// markup/whitespace.
			this.textMeasureEl_.appendChild(doc.createTextNode(text));
			return {
				width : this.textMeasureEl_.offsetWidth
			};
		};

		/** ****** STUBS ******* */
		contextPrototype.clip = function() {
			// TODO: Implement
		};

		contextPrototype.arcTo = function() {
			// TODO: Implement
		};

		contextPrototype.createPattern = function(image, repetition) {
			return new CanvasPattern_(image, repetition);
		};

		// Gradient / Pattern Stubs
		function CanvasGradient_(aType) {
			this.type_ = aType;
			this.x0_ = 0;
			this.y0_ = 0;
			this.r0_ = 0;
			this.x1_ = 0;
			this.y1_ = 0;
			this.r1_ = 0;
			this.colors_ = [];
		}

		CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
			aColor = processStyle(aColor);
			this.colors_.push({
				offset : aOffset,
				color : aColor.color,
				alpha : aColor.alpha
			});
		};

		function CanvasPattern_(image, repetition) {
			assertImageIsValid(image);
			switch (repetition) {
			case 'repeat':
			case null:
			case '':
				this.repetition_ = 'repeat';
				break;
			case 'repeat-x':
			case 'repeat-y':
			case 'no-repeat':
				this.repetition_ = repetition;
				break;
			default:
				throwException('SYNTAX_ERR');
			}

			this.src_ = image.src;
			this.width_ = image.width;
			this.height_ = image.height;
		}

		function throwException(s) {
			throw new DOMException_(s);
		}

		function assertImageIsValid(img) {
			if (!img || img.nodeType != 1 || img.tagName != 'IMG') {
				throwException('TYPE_MISMATCH_ERR');
			}
			if (img.readyState != 'complete') {
				throwException('INVALID_STATE_ERR');
			}
		}

		function DOMException_(s) {
			this.code = this[s];
			this.message = s + ': DOM Exception ' + this.code;
		}
		var p = DOMException_.prototype = new Error;
		p.INDEX_SIZE_ERR = 1;
		p.DOMSTRING_SIZE_ERR = 2;
		p.HIERARCHY_REQUEST_ERR = 3;
		p.WRONG_DOCUMENT_ERR = 4;
		p.INVALID_CHARACTER_ERR = 5;
		p.NO_DATA_ALLOWED_ERR = 6;
		p.NO_MODIFICATION_ALLOWED_ERR = 7;
		p.NOT_FOUND_ERR = 8;
		p.NOT_SUPPORTED_ERR = 9;
		p.INUSE_ATTRIBUTE_ERR = 10;
		p.INVALID_STATE_ERR = 11;
		p.SYNTAX_ERR = 12;
		p.INVALID_MODIFICATION_ERR = 13;
		p.NAMESPACE_ERR = 14;
		p.INVALID_ACCESS_ERR = 15;
		p.VALIDATION_ERR = 16;
		p.TYPE_MISMATCH_ERR = 17;

		// set up externs
		return G_vmlCanvasManager_;
	}
	return;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
}
],
function Setup(TypeUtils) {
	var msgparas = /\{(\d+)\}/g;

	var emptyFn = function() {
	};

	var funcUtils = {
		/**
		 * empty function
		 * 
		 * @name sap.riv.core.utils.FunctionUtils#noop
		 * @function
		 */
		noop : emptyFn,

		/**
		 * function throwing unsupported exception
		 * 
		 * @name sap.riv.core.utils.FunctionUtils#unsupported
		 * @function
		 */
		unsupported : function() {
			throw new Error('Unsupported function!');
		},

		/**
		 * function throwing unimplemented exception
		 * 
		 * @name sap.riv.core.utils.FunctionUtils#unimplemented
		 * @function
		 */
		unimplemented : function() {
			throw new Error('Unimplemented function!');
		},

		/**
		 * function throwing error
		 * 
		 * @name sap.riv.core.utils.FunctionUtils#error
		 * @param {String}
		 *            msg the error message
		 * @function
		 */
		error : function(msg) {
			var args = arguments;
			if (args[0]) {
				var msg = args[0].replace(msgparas, function(m, n) {
					return args[parseInt(n) + 1];
				});
				throw msg;
			} else {
				throw 'unknown error!';
			}
		},

		createCallChain : function() {
			var len = arguments.length;
			if (len > 1) {
				var callChain = [];
				for ( var i = 0; i < len; i++) {
					if (TypeUtils.isFunction(arguments[i])) {
						callChain.push(arguments[i]);
					} else {
						funcUtils.error('Could not create call chain for non-function object');
					}
				}
				return (function() {
					for ( var i = 0; i < len; i++) {
						callChain[i].apply(this, arguments);
					}
				});
			} else {
				return TypeUtils.isFunction(arguments[0]) ? arguments[0] : emptyFn;
			}
		}
	};

	return funcUtils;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.TransformHelper',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math) {
	var _matrixMultiplay = function(ma, mb) {
		var result = [];
		var m = mb.length, n = mb[0].length;
		for ( var r = 0, rowVec; r < m; r++) {
			rowVec = [];

			for ( var c = 0, e; c < n; c++) {
				e = 0;
				for ( var ci = 0; ci < n; ci++) {
					e += mb[r][ci] * ma[ci][c];
				}
				rowVec[c] = e;
			}
			result[r] = rowVec;
		}
		return result;
	};
	var identityMatrix = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
	/**
	 * Static Transform Utility
	 * 
	 * @name sap.riv.core.utils.TransformHelper
	 * @class
	 */
	var TransformHelper = {
		/**
		 * Get an identity matrix.
		 * 
		 * @return [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
		 */
		identityMatrix : function() {
			return identityMatrix;
		},
		/**
		 * The transform that rotates the given transform matrix by given angel
		 * 
		 * @param {Number}
		 *            angle Rotation angel in radians
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied rotation to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the rotated transform matrix
		 */
		makeRotateTM : function(angle, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay([ [ Math.cos(angle), -Math.sin(angle), 0 ],
					[ Math.sin(angle), Math.cos(angle), 0 ], [ 0, 0, 1 ] ], transform);
			return transM;
		},
		/**
		 * Calculate the inversion of the matrix by applying rotation
		 * 
		 * @param {Number}
		 *            angle Rotation angel in radians
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied rotation to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} The inversion of the rotated
		 *         transform matrix
		 */
		makeRotateInvertTM : function(angle, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay(transform, [ [ Math.cos(angle), Math.sin(angle), 0 ],
					[ -Math.sin(angle), Math.cos(angle), 0 ], [ 0, 0, 1 ] ]);
			return transM;
		},
		/**
		 * The transform that scales the given transform matrix by given factor
		 * 
		 * @param {Number}
		 *            x scale factor along the x axis
		 * @param {Number}
		 *            y scale factor along the y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied scaling to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the scaled transform matrix
		 */
		makeScaleTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay([ [ x, 0, 0 ], [ 0, y, 0 ], [ 0, 0, 1 ] ], transform);
			return transM;
		},
		/**
		 * Calculate the inversion of the matrix by applying scaling
		 * 
		 * @param {Number}
		 *            x scale factor along the x axis
		 * @param {Number}
		 *            y scale factor along the y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied scaling to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} The inversion of the scaling
		 *         transform matrix
		 */
		makeScaleInvertTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay(transform, [ [ 1 / x, 0, 0 ], [ 0, 1 / y, 0 ], [ 0, 0, 1 ] ]);
			return transM;
		},
		/**
		 * The transform that skew the given transform matrix by given factor
		 * 
		 * @param {Number}
		 *            x skew factor along the x axis
		 * @param {Number}
		 *            y skew factor along the y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied scaling to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the scaled transform matrix
		 */
		makeSkewTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay([ [ 1, x, 0 ], [ y, 1, 0 ], [ 0, 0, 1 ] ], transform);
			return transM;
		},
		/**
		 * Calculate the inversion of the matrix by applying skewing
		 * 
		 * @param {Number}
		 *            x skew factor along the x axis
		 * @param {Number}
		 *            y skew factor along the y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied skewing to the transform
		 *            to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} The inversion of the skewing
		 *         transform matrix
		 */
		makeInvertSkewTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var det = 1 - x * y;
			var m;
			if (det !== 0) {
				m = [ [ 1 / det, -x / det, 0 ], [ -y / det, 1 / det, 0 ], [ 0, 0, 1 ] ];
			} else {
				throw new Error('invalid affine transform matrix');
			}
			var transM = _matrixMultiplay(transform, m);
			return transM;
		},
		/**
		 * The transform that translate original of the given transform matrix
		 * by given point
		 * 
		 * @param {Number}
		 *            x the coordinate in x axis
		 * @param {Number}
		 *            y the coordinate in y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied translation to the
		 *            transform to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the translated transform matrix
		 */
		makeTranslateTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay([ [ 1, 0, x ], [ 0, 1, y ], [ 0, 0, 1 ] ], transform);
			return transM;
		},
		/**
		 * Calculate the inversion of the matrix by applying translation
		 * 
		 * @param {Number}
		 *            x the coordinate in x axis
		 * @param {Number}
		 *            y the coordinate in y axis
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied translation to the
		 *            transform to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} The inversion of the translated
		 *         transform matrix
		 */
		makeTranslateInvertTM : function(x, y, tsfm) {
			var transform = tsfm || identityMatrix;
			var transM = _matrixMultiplay(transform, [ [ 1, 0, -x ], [ 0, 1, -y ], [ 0, 0, 1 ] ]);
			return transM;
		},
		/**
		 * Apply the custom transform to the given transform matrix
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tm the transform to apply
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the result matrix
		 */
		makeCustomTM : function(tm, tsfm) {
			var transform = tsfm || identityMatrix;
			if (tm[0][0] * tm[1][1] != tm[1][0] * tm[0][1]) {
				var transM = _matrixMultiplay(tm, transform);
				return transM;
			} else {
				throw new Error('invalid affine transform matrix');
			}
		},
		/**
		 * Calculate the inversion of the transform matrix by applying custom
		 * transform
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tm the transform to apply
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tsfm the transform to be applied
		 * @return {[[a,c,e],[b,d,f],[0,0,1]]} the inversion of the result
		 *         matrix
		 */
		makeCustomInvertTM : function(tm, tsfm) {
			var transform = tsfm || identityMatrix;
			var a = tm[0][0], b = tm[1][0], c = tm[0][1], d = tm[1][1], e = tm[0][2], f = tm[1][2];
			var det = a * d - b * c;
			if (det != 0) {
				var transM = _matrixMultiplay(transform, [ [ d / det, -c / det, (c * f - e * d) / det ],
						[ -b / det, a / det, (e * b - a * f) / det ], [ 0, 0, 1 ] ]);
				return transM;
			} else {
				throw new Error('invalid affine transform matrix');
			}
		},
		/**
		 * Whether the two matrix is equal
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            atm one transform matrix
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            atm another transform matrix
		 * @return {Boolean}
		 */
		isEqualTransform : function(atm, btm) {
			return atm
					&& btm
					&& (atm[0][0] == btm[0][0] && atm[0][1] == btm[0][1] && atm[0][2] == btm[0][2]
							&& atm[1][0] == btm[1][0] && atm[1][1] == btm[1][1] && atm[1][2] == btm[1][2]
							&& atm[2][0] == btm[2][0] && atm[2][1] == btm[2][1] && atm[2][2] == btm[2][2]);
		},
		/**
		 * Whether the matrix is idendity matrix
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            atm the transform matrix to check
		 * @return {Boolean}
		 */
		isIdentityMatrix : function(atm) {
			return (atm[0][0] == 1 && atm[0][1] == 0 && atm[0][2] == 0 && atm[1][0] == 0 && atm[1][1] == 1
					&& atm[1][2] == 0 && atm[2][0] == 0 && atm[2][1] == 0 && atm[2][2] == 1);
		},
		/**
		 * Whether the matrix is a valid affine transform matrix
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tm the transform matrix to check
		 * @return {Boolean}
		 */
		isValidAffineTransform : function(tm) {
			if (TypeUtils.isArray(tm)) {
				return tm[0][0] * tm[1][1] != tm[1][0] * tm[0][1];
			}
			return false;
		},
		/**
		 * Calculate the new point by applying transformation
		 * 
		 * @param {Object}
		 *            point the point to be applied transformation
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##
		 * }
		 * </pre>
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tm the transform matrix to apply
		 * @return {Object} new point *
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##
		 * }
		 * </pre>
		 */
		pointApplyTransform : function(point, t) {
			var x = point.x, y = point.y;
			return {
				x : t[0][0] * x + t[0][1] * y + t[0][2],
				y : t[1][0] * x + t[1][1] * y + t[1][2]
			};
		},
		/**
		 * Calculate the new rectangle by applying transformation
		 * 
		 * @param {Object}
		 *            rect the rectangle to be applied transformation *
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            tm the transform matrix to apply
		 * @return {Object} new rectangle *
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 */
		rectApplyTransform : function(rect, t) {
			var x = rect.x, y = rect.y, w = rect.width, h = rect.height;
			var xy = {
				minx : Number.MAX_VALUE,
				maxx : Number.MIN_VALUE,
				miny : Number.MAX_VALUE,
				maxy : Number.MIN_VALUE
			};
			var corners = [
					[ t[0][0] * x + t[0][1] * y + t[0][2], t[1][0] * x + t[1][1] * y + t[1][2] ],
					[ t[0][0] * (x + w) + t[0][1] * y + t[0][2], t[1][0] * (x + w) + t[1][1] * y + t[1][2] ],
					[ t[0][0] * (x + w) + t[0][1] * (y + h) + t[0][2], t[1][0] * (x + w) + t[1][1] * (y + h) + t[1][2] ],
					[ t[0][0] * x + t[0][1] * (y + h) + t[0][2], t[1][0] * x + t[1][1] * (y + h) + t[1][2] ] ];
			for ( var i = 0, corner; i < 4; i++) {
				corner = corners[i];
				if (xy.minx > corner[0]) {
					xy.minx = corner[0];
				}
				if (xy.miny > corner[1]) {
					xy.miny = corner[1];
				}
				if (xy.maxx < corner[0]) {
					xy.maxx = corner[0];
				}
				if (xy.maxy < corner[1]) {
					xy.maxy = corner[1];
				}
			}
			return {
				x : xy.minx,
				y : xy.miny,
				width : xy.maxx - xy.minx,
				height : xy.maxy - xy.miny
			};
		},
		/**
		 * Decomposite a 2d transform matrix by translate, scale, skew, rotate
		 * primitive transform
		 * 
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            transform the transform matrix to decomposite
		 * @returns {Object} primitive transform
		 * 
		 * <pre>
		 * {
		 * 	tx : tx, //translate in x
		 * 	ty : ty, //translate in y
		 * 	sx : sx, //scale in x
		 * 	sy : sy, //scale in y
		 * 	skew : skew, //skew in xy
		 * 	rotate : rotate
		 * //rotation in radians
		 * }
		 * </pre>
		 */
		unmatrix : function(transform) {
			var a = transform[0][0], b = transform[1][0], c = transform[0][1], d = transform[1][1], tx = transform[0][2], ty = transform[1][2];
			var rotate, scaleX, scaleY, skew;
			if (a * d == b * c) {
				return false;
			} else {
				scaleX = Math.sqrt(a * a + b * b);
				a /= scaleX;
				b /= scaleX;
				skew = a * c + b * d;
				c -= a * skew;
				d -= b * skew;
				scaleY = Math.sqrt(c * c + d * d);
				c /= scaleY;
				d /= scaleY;
				skew /= scaleY;
				if (a * d - b * c < 0) {
					skew = -skew;
					scaleY = -scaleY;
				}
				rotate = Math.atan2(a, b);
			}
			return {

				tx : tx,
				ty : ty,
				sx : scaleX,
				sy : scaleY,
				skew : skew,
				rotate : rotate
			};
		}
	};
	return TransformHelper;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(TypeUtils, FuncUtils) {
	var emptyFn = function(){};
	var trimLeft = /^\s+/, trimRight = /\s+$/,
	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/, rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;

	var trim = trim ? function(text) {
		return text == null ? "" : trim.call(text);
	} :
	// Otherwise use our own trimming functionality
	function(text) {
		return text == null ? "" : text.toString().replace(trimLeft, "").replace(trimRight, "");
	};

	/**
	 * OO static utilities
	 * 
	 * @name sap.riv.core.utils
	 * @class
	 */
	var objUtils = {
		proxy : function(fn, proxy, thisObject) {
			if (arguments.length === 2) {
				if (typeof proxy === "string") {
					thisObject = fn;
					fn = thisObject[proxy];
					proxy = undefined;

				} else if (proxy && !TypeUtils.isFunction(proxy)) {
					thisObject = proxy;
					proxy = undefined;
				}
			}

			if (!proxy && fn) {
				proxy = function() {
					return fn.apply(thisObject || this, arguments);
				};
			}
			// So proxy can be declared as an argument
			return proxy;
		},

		// Copy from jQuery
		extend : function() {
			var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;

			// Handle a deep copy situation
			if (typeof target === "boolean") {
				deep = target;
				target = arguments[1] || {};
				// skip the boolean and the target
				i = 2;
			}

			// Handle case when target is a string or something (possible in
			// deep
			// copy)
			if (typeof target !== "object" && !TypeUtils.isFunction(target)) {
				target = {};
			}

			// extend jQuery itself if only one argument is passed
			if (length === i) {
				target = this;
				--i;
			}

			for (; i < length; i++) {
				// Only deal with non-null/undefined values
				if ((options = arguments[i]) != null) {
					// Extend the base object
					for (name in options) {
						src = target[name];
						copy = options[name];

						// Prevent never-ending loop
						if (target === copy) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (TypeUtils.isPlainObject(copy) || (copyIsArray = TypeUtils.isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && TypeUtils.isArray(src) ? src : [];

							} else {
								clone = src && TypeUtils.isPlainObject(src) ? src : {};
							}
							// Never move original objects, clone them
							target[name] = objUtils.extend(deep, clone, copy);
							// Don't bring in undefined values
						} else if (copy !== undefined) {
							target[name] = copy;
						}
					}
				}
			}
			// Return the modified object
			return target;
		},

		// args is for internal usage only
		each : function(object, callback, args) {
			var name, i = 0, length = object.length, isObj = length === undefined || TypeUtils.isFunction(object);

			if (args) {
				if (isObj) {
					for (name in object) {
						if (callback.apply(object[name], args) === false) {
							break;
						}
					}
				} else {
					for (; i < length;) {
						if (callback.apply(object[i++], args) === false) {
							break;
						}
					}
				}

				// A special, fast, case for the most common use of each
			} else {
				if (isObj) {
					for (name in object) {
						if (callback.call(object[name], name, object[name]) === false) {
							break;
						}
					}
				} else {
					for ( var value = object[0]; i < length && callback.call(value, i, value) !== false; value = object[++i]) {
					}
				}
			}
			return object;
		},

		parseJSON : function(data) {
			if (typeof data !== "string" || !data) {
				return null;
			}

			// Make sure leading/trailing whitespace is removed (IE can't handle
			// it)
			data = trim(data);

			// Make sure the incoming data is actual JSON
			// Logic borrowed from http://json.org/json2.js
			if (rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, ""))) {

				// Try to use the native JSON parser first
				return window && window.JSON && window.JSON.parse ? window.JSON.parse(data) : (new Function("return "
						+ data))();

			} else {
				TypeUtils.error("Invalid JSON: " + data);
			}
		},

		/**
		 * make the subclass derived from passed-in superclass, the superclass's
		 * constructor will be automatically called.
		 * 
		 * @name sap.riv.core.utils.derive
		 * @function
		 * @param {Function}
		 *            subcls constructor of subclass or baseclass to extend
		 * @param {Function}
		 *            supercls or overide constructor of superclass, or object
		 *            literals to overide
		 * @return {Function} the constructor of the derived class with some
		 *         additional field: 'clazz' points to current constructor,
		 *         superclazz points to superclass' constructor. superclass in
		 *         prototype points to superclass's prototype
		 */
		derive : function(subcls, supercls) {
			var ret;
			var retp;
			if (typeof subcls === 'function') {
				if (typeof supercls === 'function') {
					if (supercls.prototype.constructor == Object.prototype.constructor) {
						supercls.prototype.constructor = supercls;
					}
					emptyFn.prototype = supercls.prototype;
					var h = new emptyFn();
					var sbp = subcls.prototype;
					for (var p in sbp) {
						if (sbp.hasOwnProperty(p)) {
							h[p] = sbp[p];
						}
					}
					ret = FuncUtils.createCallChain(supercls, subcls);
					retp = ret.prototype = h;
					retp.constructor = ret;
					retp.superclass = supercls.prototype;
					retp.callParent = (function() {
						var stack = [];
						return function() {
							var funcName = arguments[0];
							if (!stack.length) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							} else if (stack[stack.length - 1].funcName !== funcName
									|| stack[stack.length - 1].thisObj !== this) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							}

							var skip = stack[stack.length - 1].level;
							var currentProto = this.superclass;
							while (skip--) {
								currentProto = currentProto.superclass;
							}
							stack[stack.length - 1].level++;
							var args = [];
							for ( var i = 1; i < arguments.length; i++) {
								args.push(arguments[i]);
							}
							currentProto[funcName].apply(stack[stack.length - 1].thisObj, args);
							stack[stack.length - 1].level--;
							if (!stack[stack.length - 1].level) {
								stack.pop();
							}
						};
					})();
					ret.superclazz = supercls;
					return ret;
				} else if (typeof supercls === 'object') {
					var basecls = subcls;
					var mixin = supercls;
					var bcp = basecls.prototype;

					emptyFn.prototype = bcp;
					var h = new emptyFn();
					ret = FuncUtils.createCallChain(basecls, mixin.constructor);
					retp = ret.prototype = h;
					for (p in mixin) {
						if (mixin.hasOwnProperty(p)) {
							retp[p] = mixin[p];
						}
					}
					retp.constructor = ret;
					retp.superclass = basecls.prototype;
					retp.callParent = (function() {
						var stack = [];
						return function() {
							var funcName = arguments[0];
							if (!stack.length) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							} else if (stack[stack.length - 1].funcName !== funcName
									|| stack[stack.length - 1].thisObj !== this) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							}

							var skip = stack[stack.length - 1].level;
							var currentProto = this.superclass;
							while (skip--) {
								currentProto = currentProto.superclass;
							}
							stack[stack.length - 1].level++;
							var args = [];
							for ( var i = 1; i < arguments.length; i++) {
								args.push(arguments[i]);
							}
							currentProto[funcName].apply(stack[stack.length - 1].thisObj, args);
							stack[stack.length - 1].level--;
							if (!stack[stack.length - 1].level) {
								stack.pop();
							}
						};
					})();
					ret.superclazz = basecls;
				}
			}
			return ret;
		}
	};
	return objUtils;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.Event',
  version : '1.0.0'
},
function Setup() {
	/**
	 * Event class for graphics
	 * 
	 * @name sap.riv.graphics.Event
	 * @constructor
	 */
	var Event = function(type, targetLayer, canBubbling) {
		this._type = type;
		this._targetLayer = this._currentLayer = targetLayer;
		this._canBubbling = canBubbling || false;
		this._timestamp = +new Date;
	};
	var Ep = Event.prototype;

	Ep._setCurrentLayer_ = function(currentLayer) {
		this._currentLayer = currentLayer;
	};
	/**
	 * Get the type of the event
	 * 
	 * @name sap.riv.graphics.Event#type
	 * @function
	 * @returns {String}
	 */
	Ep.type = function() {
		return this._type;
	};

	/**
	 * Get the timestamp of the event
	 * 
	 * @name sap.riv.graphics.Event#timestamp
	 * @function
	 * @returns {Integer}
	 */
	Ep.timestamp = function() {
		return this._timestamp;
	};
	/**
	 * Get the target layer the event is originated from
	 * 
	 * @name sap.riv.graphics.Event#targetLayer
	 * @function
	 * @returns {sap.riv.graphics.Layer}
	 */
	Ep.targetLayer = function() {
		return this._targetLayer;
	};
	/**
	 * Get the current target layer the event is currently going through it can
	 * be different with the target layer
	 * 
	 * @name sap.riv.graphics.Event#currentLayer
	 * @function
	 * @returns {sap.riv.graphics.Layer}
	 */
	Ep.currentLayer = function() {
		return this._currentLayer;
	};

	/**
	 * Whether the event is in the bubbling phase
	 * 
	 * @name sap.riv.graphics.Event#isInBubbling
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.isInBubbling = function() {
		return this._targetLayer.id() != this._currentLayer.id();
	};
	/**
	 * Whether the event should be bubbled
	 * 
	 * @name sap.riv.graphics.Event#shouldBubble
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.shouldBubble = function() {
		return this._canBubbling;
	};
	/**
	 * Stop the event propagation up through the layer hierarchy in the bubbling
	 * phase
	 * 
	 * @name sap.riv.graphics.Event#stopPropagation
	 * @function
	 * 
	 */
	Ep.stopPropagation = function() {
		this._canBubbling = false;
	};
	return Event;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.RIVExCanvasMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
}
],
function Setup(TypeUtils, FuncUtils, RIVExCanvasMgr, UADetector) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	var DrawingContextWrapper = function(canvas2DContext) {
		this._canvas2DContext = canvas2DContext;
	};

	var dp = DrawingContextWrapper.prototype;

	dp.save = function() {
		this._canvas2DContext.save();
	};

	dp.restore = function() {
		this._canvas2DContext.restore();
	};

	dp.scale = function(x, y) {
		this._canvas2DContext.scale(x, y);
	};
	dp.rotate = function(a) {
		this._canvas2DContext.rotate(a);
	};
	dp.translate = function(x, y) {
		this._canvas2DContext.translate(x, y);
	};
	dp.transform = function(a, b, c, d, e, f) {
		this._canvas2DContext.transform(a, b, c, d, e, f);
	};
	dp.setTransform = function(a, b, c, d, e, f) {
		this._canvas2DContext.setTransform(a, b, c, d, e, f);
	};
	dp.setAlpha = function(alpha) {
		this._canvas2DContext.globalAlpha = alpha;
	};
	dp.setCompositeOperation = function(composition) {
		this._canvas2DContext.globalCompositeOperation = composition;
	};
	dp.setStrokeStyle = function(style) {
		this._canvas2DContext.strokeStyle = style;
	};
	dp.setFillStyle = function(style) {
		this._canvas2DContext.fillStyle = style;
	};
	dp.setLineWidth = function(lineWidth) {
		this._canvas2DContext.lineWidth = lineWidth;
	};
	dp.setLineCap = (function() {
		if (UADetector.isFirefox() && parseFloat(UADetector.version()) < 4)
			// handle for Firefox 3.X which canvas context2d does not support
			// lineCap
			return FuncUtils.noop;
		else {
			return function(lineCap) {
				this._canvas2DContext.lineCap = lineCap;
			};
		}
	})();
	dp.setLineJoin = (function() {
		if (UADetector.isFirefox() && parseFloat(UADetector.version()) < 4)
			// handle for Firefox 3.X which canvas context2d does not support
			// lineJoin
			return FuncUtils.noop;
		else {
			return function(lineJoin) {
				this._canvas2DContext.lineJoin = lineJoin;
			};
		}
	})();
	dp.setMiterLimit = function(miterLimit) {
		this._canvas2DContext.miterLimit = miterLimit;
	};
	dp.setShadowStyle = function(offsetX, offsetY, blur, color) {
		this._canvas2DContext.shadowOffsetX = offsetX;
		this._canvas2DContext.shadowOffsetY = offsetY;
		this._canvas2DContext.shadowBlur = blur;
		this._canvas2DContext.shadowColor = color;
	};
	dp.clearRect = function(x, y, width, height) {
		this._canvas2DContext.clearRect(x, y, width, height);
	};
	dp.fillRect = function(x, y, width, height) {
		this._canvas2DContext.fillRect(x, y, width, height);
	};
	dp.strokeRect = function(x, y, width, height) {
		this._canvas2DContext.strokeRect(x, y, width, height);
	};
	dp.beginPath = function() {
		this._canvas2DContext.beginPath();
	};
	dp.closePath = function() {
		this._canvas2DContext.closePath();
	};
	dp.moveTo = function(x, y) {
		this._canvas2DContext.moveTo(x, y);
	};
	dp.lineTo = function(x, y) {
		this._canvas2DContext.lineTo(x, y);
	};
	dp.quadraticCurveTo = function(cpx, cpy, x, y) {
		this._canvas2DContext.quadraticCurveTo(cpx, cpy, x, y);
	};
	dp.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
		this._canvas2DContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
	};
	dp.arcTo = function(x1, y1, x2, y2, radius) {
		this._canvas2DContext.arcTo(x1, y1, x2, y2, radius);
	};
	dp.rect = function(x, y, width, height) {
		this._canvas2DContext.rect(x, y, width, height);
	};
	dp.arc = function(x, y, radius, startAngle, endAngle, antiClockwise) {
		this._canvas2DContext.arc(x, y, radius, startAngle, endAngle, antiClockwise);
	};
	dp.fill = function() {
		this._canvas2DContext.fill();
	};
	dp.stroke = function() {
		this._canvas2DContext.stroke();
	};
	dp.clip = function() {
		this._canvas2DContext.clip();
	};
	dp.setFont = function(font) {
		this._canvas2DContext.font = font;
	};
	dp.setTextAlign = function(textAlign) {
		this._canvas2DContext.textAlign = textAlign;
	};
	dp.setTextBaseline = function(textBaseline) {
		this._canvas2DContext.textBaseline = textBaseline;
	};
	dp.fillText = function(text, x, y, maxWidth) {
		if (maxWidth !== undefined) {
			this._canvas2DContext.fillText(text, x, y, maxWidth);
		} else {
			this._canvas2DContext.fillText(text, x, y);
		}
	};
	dp.strokeText = function(text, x, y, maxWidth) {
		// JY: FIREFOX doesn't accept undefined maxWidth as parameter
		if (TypeUtils.isDefined(maxWidth)) {
			this._canvas2DContext.strokeText(text, x, y, maxWidth);
		} else {
			this._canvas2DContext.strokeText(text, x, y);
		}
	};
	dp.measureText = function(text) {
		return this._canvas2DContext.measureText(text);
	};

	dp.drawImage = function(image, dx, dy) {
		if (image instanceof CanvasWraper) {
			this._canvas2DContext.drawImage(image._canvas, dx, dy);
		} else {
			this._canvas2DContext.drawImage(image, dx, dy);
		}
	};

	dp.createLinearGradient = function(x0, y0, x1, y1) {
		return this._canvas2DContext.createLinearGradient(x0, y0, x1, y1);
	};

	dp.createRadialGradient = function(x0, y0, r0, x1, y1, r1) {
		return this._canvas2DContext.createRadialGradient(x0, y0, r0, x1, y1, r1);
	};

	var CanvasWraper = function(canvas) {
		this._jqCanvas = canvas;
		this._canvas = canvas.get(0);
		this._drawingContext = new DrawingContextWrapper(this._canvas.getContext('2d'));
	};

	CanvasWraper.prototype.getContext = function(contextId) {
		return this._drawingContext;
	};

	CanvasWraper.prototype.toDataURL = function() {
		return this._canvas.toDataURL.apply(this._canvas, arguments);
	};

	CanvasWraper.prototype.width = function(width) {
		if (width !== undefined) {
			width = ~~(width + 0.5);
			this._jqCanvas.width(width);
			this._canvas.width = width;
			return this;
		} else {
			return this._canvas.width;
		}
	};

	CanvasWraper.prototype.height = function(height) {
		if (height != undefined) {
			height = ~~(height + 0.5);
			this._jqCanvas.height(height);
			this._canvas.height = height;
			return this;
		} else {
			return this._canvas.height;
		}
	};

	CanvasWraper.prototype.bind = function(type, callback) {
		this._jqCanvas.bind(type, callback);
	};

	var id = 0;
	var nextId = function() {
		return 'can:' + id++;
	};
	var rvmlmgr = RIVExCanvasMgr;
	var createCanvas = function(width, height, appendTo) {
		width = ~~(width + 0.5);
		height = ~~(height + 0.5);
		var canEl;
		if (window.__IS_IN_RHINO) {
			var canDom = document.createElement('canvas');
			if (!height || height <= 0) {
				height = 1;
			}
			if (!width || width <= 0) {
				width = 1;
			}
			canDom.height = height;
			canDom.width = width;
			canDom.id = nextId();
			canEl = $(canDom);
			if (appendTo) {
				canEl.appendTo(appendTo);
			}
		} else if (UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
			if (typeof FlashCanvas != "undefined") {
				var canDom = document.createElement('canvas');
				canEl = $(canDom).attr('id', nextId());
				if (appendTo) {
					canEl.appendTo(appendTo);
				} else {
					$('body').append(canDom);
				}
				FlashCanvas.initElement(canDom);
				canEl.attr('height', height).attr('width', width).width(width).height(height);
			} else {
				var canDom = document.createElement('rivcanvas');
				canEl = $(canDom).attr('id', nextId()).attr('height', height).attr('width', width).width(width).height(
						height);
				if (appendTo) {
					canEl.appendTo(appendTo);
				}
				rvmlmgr.initElement(canDom);
			}
		} else {
			canEl = $(document.createElement('canvas')).attr('id', nextId()).attr('height', height)
					.attr('width', width).width(width).height(height);
			if (appendTo) {
				canEl.appendTo(appendTo);
			}
		}
		return new CanvasWraper(canEl);
	};
	var hiddenCanvasCtx = undefined;
	var getHiddenCanvasCtx = function() {
		if (!hiddenCanvasCtx) {
			hiddenCanvasCtx = createCanvas(1, 1).getContext('2d');
		}
		return hiddenCanvasCtx;
	};
	/**
	 * Static Canvas Utility
	 * 
	 * @name sap.riv.graphics.CanvasHelper
	 * @class
	 */
	var CanvasHelper = {
		/**
		 * Create a new canvas element
		 * 
		 * @param {Number}
		 *            width width of the new canvas
		 * @param {Number}
		 *            height height of the new canvas
		 * @param {Element}
		 *            (appendTo) the container of the newly created canvas
		 */
		createCanvasElement : createCanvas,

		getCanvasElement : function(canvasEl) {
			return new CanvasWraper(canvasEl);
		},
		/**
		 * Create the color style based on the color setting
		 * 
		 * @param {Object}
		 *            style
		 * 
		 * <pre>
		 * {
		 * 	t : 'css', //Required. Indicate the type of the color is CSS color value.
		 * 	v : CSSCOLOR
		 * //Optional. eg. #C0C0C0. If missing, transparent black(#000000) will be used.
		 * }
		 * </pre>
		 * <pre>
		 * {
		 *      t: ['lg'|'rg'], //Required. lg stands for Linear Gradient, rg stands for Radial Gradient.
		 *      s: POINT, //Required. The start point of the linear gradient.
		 *      e: POINT, //Required. The end point of the linear gradient.
		 *      st: [{o: ##, v: CSSCOLOR }] //Required. The array of CSS color string at different offset along the gradient.
		 * }
		 * </pre>
		 * 
		 * @returns {String|CanvasGradient}
		 */
		createColorStyle : function(style) {
			var ret;
			if (!style) {
				return '#000000';
			}
			switch (style.t) {
			case 'css':
				ret = style.v;
				break;
			case 'lg':
				// TODO support referenced gradient
				var start = style.s;
				var end = style.e;
				var stops = style.st;
				ret = getHiddenCanvasCtx().createLinearGradient(start.x, start.y, end.x, end.y);
				for ( var i = 0, len = stops.length, stop; i < len; i++) {
					stop = stops[i];
					ret.addColorStop(stop.o, stop.v);
				}
				break;
			case 'rg':
				// TODO support referenced gradient
				var start = style.s.c;
				var startR = style.s.r;
				var end = style.e.c;
				var endR = style.e.r;
				var stops = style.st;
				ret = getHiddenCanvasCtx().createRadialGradient(start.x, start.y, startR, end.x, end.y, endR);
				for ( var i = 0, len = stops.length, stop; i < len; i++) {
					stop = stops[i];
					ret.addColorStop(stop.o, stop.v);
				}
				break;
			default:
				ret = style;
			}
			return ret;
		}
	};
	return CanvasHelper;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.Drawable',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TransformHelper',
  version : '1.0.0'
}
],
function Setup(ObjUtils, FuncUtils, TmHelper) {
	var shapeId = (function() {
		var id = 0;
		return function() {
			return 's:' + id++;
		};
	})();
	var identityMatrix = TmHelper.identityMatrix();
	/**
	 * The base class for any shape
	 * 
	 * @name sap.riv.graphics.Drawable
	 * @constructor
	 * @param {Object}
	 *            metadata
	 * @param {Object}
	 *            [metadata.tsfm] the transformation for the shape
	 * @param {Object}
	 *            [metadata.shdw] the shadow setting for the shape
	 * @param {Object}
	 *            [metadata.cpsn] the composite setting for the shape
	 */
	var drwbl = function(metadata) {
		this._isVisible = true;
		this._id = shapeId();
		this._shadowSetting = undefined;
		this._compositionSetting = undefined;
		this._tm = identityMatrix;
		this._itm = identityMatrix;
	};

	/**
	 * Get the unique id of the shape
	 * 
	 * @name sap.riv.graphics.Drawable#id
	 * @returns {String}
	 */
	drwbl.prototype.id = function() {
		return this._id;
	};
	/**
	 * Get or set the shape's visibility
	 * 
	 * @name sap.riv.graphics.Drawable#isVisible
	 * @param {Boolean}
	 *            isVisible
	 * @returns {Boolean|this} return the current visibility or this object to
	 *          allow function chaining
	 */
	drwbl.prototype.visible = function(isVisible) {
		if (isVisible !== undefined) {
			this._isVisible = isVisible;
			return this;
		}
		return this._isVisible;
	};

	/**
	 * An convenient method which combining the effect of translation and
	 * rotation
	 * 
	 * @name sap.riv.graphics.Drawable#rotateAt
	 * @param {Number}
	 *            x the x coordinate of the new origin.
	 * @param {Number}
	 *            y the y coordinate of the new origin.
	 * @param {Number}
	 *            angle the angle to rotate
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.rotateAt = function(x, y, angle) {
		this._tm = TmHelper.makeTranslateTM(x, y, this._tm);
		this._itm = TmHelper.makeTranslateInvertTM(x, y, this._itm);
		this._tm = TmHelper.makeRotateTM(angle, this._tm);
		this._itm = TmHelper.makeRotateInvertTM(angle, this._itm);
		return this;
	};

	/**
	 * Rotate the shape by an angle in radian around the origin of the
	 * coordinate system
	 * 
	 * @name sap.riv.graphics.Drawable#rotate
	 * @param {Number}
	 *            angle the angle to rotate
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.rotate = function(angle) {
		this._tm = TmHelper.makeRotateTM(angle, this._tm);
		this._itm = TmHelper.makeRotateInvertTM(angle, this._itm);
		return this;
	};
	/**
	 * Translate the origin of the coordinate system
	 * 
	 * @name sap.riv.graphics.Drawable#translate
	 * @param {Number}
	 *            x the x coordinate of the new origin.
	 * @param {Number}
	 *            y the y coordinate of the new origin.
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.translate = function(x, y) {
		this._tm = TmHelper.makeTranslateTM(x, y, this._tm);
		this._itm = TmHelper.makeTranslateInvertTM(x, y, this._itm);
		return this;
	};
	/**
	 * Scale the shape in x and y direction against the origin of the coordinate
	 * system
	 * 
	 * @name sap.riv.graphics.Drawable#scale
	 * @param {Number}
	 *            x the scale factor in x axis.
	 * @param {Number}
	 *            y the scale factor in y axis.
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.scale = function(x, y) {
		this._tm = TmHelper.makeScaleTM(x, y, this._tm);
		this._itm = TmHelper.makeScaleInvertTM(x, y, this._itm);
		return this;
	};

	/**
	 * Skew the shape in x and y direction against the origin of the coordinate
	 * system
	 * 
	 * @name sap.riv.graphics.Drawable#skew
	 * @param {Number}
	 *            x the skew factor in x axis.
	 * @param {Number}
	 *            y the skew factor in y axis.
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.skew = function(x, y) {
		this._tm = TmHelper.makeSkewTM(x, y, this._tm);
		this._itm = TmHelper.makeInvertSkewTM(x, y, this._itm);
		return this;
	};
	/**
	 * Transform the shape with custom transform matrix together with previous
	 * applied transform, the matrix should follow the format
	 * 
	 * <pre>
	 * [ a, c, e ][b, d, f][0, 0, 1]
	 * </pre>
	 * 
	 * @name sap.riv.graphics.Drawable#customTransform
	 * @param {Number}
	 *            a
	 * @param {Number}
	 *            b
	 * @param {Number}
	 *            c
	 * @param {Number}
	 *            d
	 * @param {Number}
	 *            e
	 * @param {Number}
	 *            f
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.customTransform = function(a, b, c, d, e, f) {
		var m = [ [ a, c, e ], [ b, d, f ], [ 0, 0, 1 ] ];
		this._tm = TmHelper.makeCustomTM(m, this._tm);
		this._itm = TmHelper.makeCustomInvertTM(m, this._itm);
		return this;
	};
	/**
	 * Transform the shape with custom transform matrix together, the matrix
	 * should follow the format
	 * 
	 * <pre>
	 * [ a, c, e ][b, d, f][0, 0, 1]
	 * </pre>
	 * 
	 * @name sap.riv.graphics.Drawable#setTransform
	 * @param {Number}
	 *            a
	 * @param {Number}
	 *            b
	 * @param {Number}
	 *            c
	 * @param {Number}
	 *            d
	 * @param {Number}
	 *            e
	 * @param {Number}
	 *            f
	 * @returns {this} this object to allow function chaining
	 */
	drwbl.prototype.setTransform = function(a, b, c, d, e, f) {
		this._tm = [ [ a, c, e ], [ b, d, f ], [ 0, 0, 1 ] ];
		this._itm = TmHelper.makeCustomInvertTM(this._tm, identityMatrix);
		return this;
	};

	/**
	 * Get or set the shadow, the setting should follow
	 * 
	 * <pre>
	 * {
	 *      offsetX: ##, //Number, offset in X axis
	 *      offsetY: ##, //Number, offset in Y axis
	 *      blur: ##, //Number, shadow blur
	 *      color: ##, //CSSColor, shadow color
	 * }
	 * </pre>
	 * 
	 * @name sap.riv.graphics.Drawable#shadow
	 * @param {Object|false}
	 *            shadow passing 'false' will remove existing shadow setting
	 * @returns {this|Object} when setting shadow the return will be this object
	 *          to allow chaining
	 */
	drwbl.prototype.shadow = function(shadow) {
		if (shadow !== undefined) {
			if (shadow !== false) {
				this._shadowSetting = {
					ox : shadow.offsetX,
					oy : shadow.offsetY,
					blur : shadow.blur,
					color : shadow.color
				};
			} else {
				this._shadowSetting = undefined;
			}
			return this;
		}
		if (this._shadowSetting) {
			return ObjUtils.extend({}, this._shadowSetting);
		}
	};
	/**
	 * Get or set the composition model, the setting should follow
	 * 
	 * <pre>
	 * {
	 *      alpha: ##, //Number, alpha when blending the color
	 *      operation: ##, //String, the blending type, default is source-over
	 * }
	 * </pre>
	 * 
	 * @name sap.riv.graphics.Drawable#compositionMode
	 * @param {Object|false}
	 *            composition passing 'false' will remove existing composition
	 *            setting
	 * @returns {this|Object} when setting composition the return will be this
	 *          object to allow chaining
	 */
	drwbl.prototype.compositionMode = function(composition) {
		if (composition !== undefined) {
			if (composition !== false) {
				this._compositionSetting = {
					alpha : composition.alpha,
					operation : composition.operation
				};
			} else {
				this._compositionSetting = undefined;
			}
			return this;
		}
		if (this._compositionSetting) {
			return ObjUtils.extend({}, this._compositionSetting);
		}
	};

	/**
	 * Whether the point is in the shape
	 * 
	 * @name sap.riv.graphics.Drawable#pointIn
	 * @param {Object}
	 *            point
	 * @returns {Boolean}
	 */
	drwbl.prototype.pointIn = function(point) {
		var itm = this._itm;
		var x = point.x;
		var y = point.y;
		return this.doPointInTest({
			x : itm[0][0] * x + itm[0][1] * y + itm[0][2],
			y : itm[1][0] * x + itm[1][1] * y + itm[1][2]
		});
	};

	/**
	 * Do point in shape testing, subclass should override with real
	 * implementation.
	 * 
	 * @name sap.riv.graphics.Drawable#doPointInTest
	 * @param {Object}
	 *            point the point to test.
	 * @return {Boolean}
	 */
	drwbl.prototype.doPointInTest = FuncUtils.unimplemented;

	drwbl.prototype.drawTo = function(drawingContext) {
		if (!this._isVisible) {
			return;
		}
		var dCtx = drawingContext;

		if (!TmHelper.isIdentityMatrix(this._tm)) {
			var t = this._tm;
			dCtx.transform(t[0][0], t[1][0], t[0][1], t[1][1], t[0][2], t[1][2]);
		}
		if (this._shadowSetting) {
			var shdw = this._shadowSetting;
			dCtx.setShadowStyle(shdw.ox, shdw.oy, shdw.blur, shdw.color);
		}
		if (this._compositionSetting) {
			var c = this._compositionSetting;
			dCtx.setAlpha(c.alpha || 1.0);
			dCtx.setCompositeOperation(c.operation || 'source-over');
		}
		this.doDraw(dCtx);
	};

	/**
	 * This method is intended to be overridden by subclass, to do actual
	 * drawing
	 * 
	 * @name sap.riv.graphics.Drawable#doDraw
	 * @param {DrawingContext}
	 *            the drawing context for drawing
	 */
	drwbl.prototype.doDraw = FuncUtils.noop;
	return drwbl;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.MouseEvent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Event',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Event) {
	/**
	 * This class defines Mouse Event on layers
	 * 
	 * @name sap.riv.graphics.MouseEvent
	 * @class
	 * @augments sap.riv.graphics.Event
	 */
	var MouseEvent = ObjUtils.derive(Event,
	/**
	 * @lends sap.riv.graphics.MouseEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, globalXY, pageXY) {
			this._relatedLayer = undefined;
			this._targetLocalXY = this._currentLocalXY = this._targetLayer.convertPointFromGlobal(globalXY);
			this._pageXY = {
				x : pageXY.x,
				y : pageXY.y
			};
		},

		_setRelatedLayer_ : function(relatedLayer) {
			this._relatedLayer = relatedLayer;
		},

		_setCurrentLocalXY_ : function(currentXY) {
			this._currentLocalXY = currentXY;
		},

		/**
		 * Get the related layer if any.
		 * 
		 * @name sap.riv.graphics.MouseEvent#relatedLayer
		 * @function
		 * @returns {sap.riv.graphics.Layer}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		relatedLayer : function() {
			return this._relatedLayer;
		},

		/**
		 * Get the mouse event XY in target layer's coordinates system
		 * 
		 * @name sap.riv.graphics.MouseEvent#targetLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		targetLocalXY : function() {
			return this._targetLocalXY;
		},
		/**
		 * Get the mouse event XY in current layer's coordinates system
		 * 
		 * @name sap.riv.graphics.MouseEvent#currentLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		currentLocalXY : function() {
			return this._currentLocalXY;
		},
		/**
		 * Get the page XY of the event
		 * 
		 * @name sap.riv.graphics.MouseEvent#pageXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		pageXY : function() {
			return this._pageXY;
		}
	});
	return MouseEvent;
});sap.riv.module(
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(FncUtils) {
    var noop = FncUtils.noop;
    // var noop = function() {
    // };
    Date.now = Date.now ||
    function() {
        return +new Date;
    };

    var dispatcherIdleCounter = 0;

    function callAppender(appender) {
        var logTime, logLevel, logCate, logMsg, appenderLevel;

        if(logBuffer[0].length > 0) {
            if(appender) {
                appenderLevel = appender.getLevel();
                for(var i = 0, bl = logBuffer[0].length; i < bl; i++) {
                    logTime = logBuffer[0][i];
                    logLevel = logBuffer[1][i];
                    logCate = logBuffer[2][i];
                    logMsg = logBuffer[3][i];
                    if(logBuffer[1][i] >= appenderLevel)
                        appender.doAppend(logTime, logLevel, logCate, logMsg);
                }
                return;
            }

            //call all appenders
            //var appender;
            var appenderLevelMap = {};
            for(var appenderKey in appenders) {
                appenderLevelMap[appenderKey] = appenders[appenderKey].getLevel();
            }
            while(logBuffer[0].length) {
                logTime = logBuffer[0].shift();
                logLevel = logBuffer[1].shift();
                logCate = logBuffer[2].shift();
                logMsg = logBuffer[3].shift();
                for(appenderKey in appenders) {
                    appender = appenders[appenderKey];
                    if(logLevel >= appenderLevelMap[appenderKey])
                        appender.doAppend(logTime, logLevel, logCate, logMsg);
                }
            }
            return;
        } else if(++dispatcherIdleCounter === 3)
            //pause on third time loop an empty Buffer
            pause();
    }

    function dispatcher() {
        callAppender();
        if(!paused)
            setTimeout(function() {
                dispatcher();
            }, 100);
    }

    var ConsoleAppender = function() {
        this.threshold = Logger.LEVEL.INFO;
        this.layout = new Logger.DefaultLayout();
        this.print = typeof console !== undefined ? function(msg) {
            console.log(msg);
        } : noop;
    };
    ConsoleAppender.prototype = {
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.print(this.layout.format(logTime, logLevel, logCate, logMsg));
        },
        setLayout : function(layout) {
            layout.format && (this.layout = layout);
        },
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        }
    };
    var DefaultLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    DefaultLayout.prototype.format = function(logTime, logLevel, logCate, logMsg) {
        return "[" + logTime + "]" + "[" + getLevelStr(logLevel) + "]" + "[" + (logCate || "main") + "]-" + logMsg;
    };
    var DivAppender = function(div) {
        if(!$) {
            throw "need jQuery";
        }
        this.threshold = Logger.LEVEL.INFO;
        this.divSl = $(div);
        this.layout = new HTMLLayout();
    };
    DivAppender.prototype = {
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        },
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.divSl.append(this.layout.format(logTime, logLevel, logCate, logMsg));
        }
    };
    var HTMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    HTMLLayout.prototype = {
        getStyle : function(logLevel) {
            var style;
            if(logLevel === Logger.LEVEL.ERROR) {
                style = 'color:red';
            } else if(logLevel === Logger.LEVEL.WARN) {
                style = 'color:orange';
            } else if(logLevel === Logger.LEVEL.DEBUG) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.TRACE) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.INFO) {
                style = 'color:grey';
            } else {
                style = 'color:yellow';
            }
            return style;
        },
        format : function(logTime, logLevel, logCate, logMsg) {
            return "<div style=\"" + this.getStyle(logLevel) + "\">[" + logTime + "]" + "[" + getLevelStr(logLevel) + "][" + (logCate || "main") + "]-" + logMsg + "</div>";
        }
    };
    var FifoBuffer = function() {
        this.array = new Array();
    };

    FifoBuffer.prototype = {

        /**
         * @param {Object} obj any object added to buffer
         */
        push : function(obj) {
            this.array[this.array.length] = obj;
            return this.array.length;
        },
        /**
         * @return first putted in Object
         */
        pull : function() {
            if(this.array.length > 0) {
                var firstItem = this.array[0];
                for(var i = 0; i < this.array.length - 1; i++) {
                    this.array[i] = this.array[i + 1];
                }
                this.array.length = this.array.length - 1;
                return firstItem;
            }
            return null;
        },
        length : function() {
            return this.array.length;
        }
    };
    var AjaxAppender = function(url) {
        this.loggingUrl = url;
        this.isInProgress = false;
        this.threshold = Logger.LEVEL.INFO;
        this.bufferSize = 1;
        this.timeout = 2000;
        this.loggingEventMap = new FifoBuffer();
        this.layout = new Logger.JSONLayout();
        this.httpRequest = null;
    };
    AjaxAppender.prototype = {
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        },
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            if(this.loggingEventMap.length() <= this.bufferSize || this.isInProgress === true) {
                this.loggingEventMap.push([logTime, logLevel, logCate, logMsg]);
            }

            if(this.loggingEventMap.length() >= this.bufferSize && this.isInProgress === false) {
                //if bufferSize is reached send the events and reset current bufferSize
                this.send();
            }
        },
        send : function() {
            if(this.loggingEventMap.length() > 0) {
                this.isInProgress = true;
                var a = [];
                var loggingEvent;
                for(var i = 0; i < this.loggingEventMap.length() && i < this.bufferSize; i++) {
                    loggingEvent = this.loggingEventMap.pull();
                    a.push(this.layout.format(loggingEvent[0], loggingEvent[1], loggingEvent[2], loggingEvent[3]));
                }

                var content = this.layout.getHeader();
                content += a.join(this.layout.getSeparator());
                content += this.layout.getFooter();

                var appender = this;
                if(this.httpRequest === null) {
                    this.httpRequest = this.getXmlHttpRequest();
                }
                this.httpRequest.onreadystatechange = function() {
                    appender.onReadyStateChanged.call(appender);
                };

                this.httpRequest.open("POST", this.loggingUrl, true);
                // set the request headers.
                //this.httpRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                this.httpRequest.setRequestHeader("Content-type", this.layout.getContentType());
                //REFERER will be the top-level
                // URI which may differ from the location of the error if
                // it occurs in an included .js file
                //this.httpRequest.setRequestHeader("REFERER", location.href);
                //this.httpRequest.setRequestHeader("Content-length", content.length);
                //this.httpRequest.setRequestHeader("Connection", "close");
                //console && console.log(content);
                this.httpRequest.send(content);
                appender = this;

                try {
                    setTimeout(function() {
                        appender.httpRequest.onreadystatechange = function() {
                            return;
                        };
                        appender.httpRequest.abort();
                        //this.httpRequest = null;
                        appender.isInProgress = false;

                        if(appender.loggingEventMap.length() > 0) {
                            appender.send();
                        }
                    }, this.timeout);
                } catch (e) {
                }
            }
        },
        onReadyStateChanged : function() {
            var req = this.httpRequest;
            if(this.httpRequest.readyState != 4) {
                return;
            }

            var success = (( typeof req.status === "undefined") || req.status === 0 || (req.status >= 200 && req.status < 300));

            if(success) {

                //ready sending data
                this.isInProgress = false;

            } else {
            }
        },
        getXmlHttpRequest : function() {

            var httpRequest = false;

            try {
                if(window.XMLHttpRequest) {// Mozilla, Safari, IE7...
                    httpRequest = new XMLHttpRequest();
                    if(httpRequest.overrideMimeType) {
                        httpRequest.overrideMimeType(this.layout.getContentType());
                    }
                } else if(window.ActiveXObject) {// IE
                    try {
                        httpRequest = new ActiveXObject("Msxml2.XMLHTTP");
                    } catch (e) {
                        httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
                    }
                }
            } catch (e) {
                httpRequest = false;
            }

            if(!httpRequest) {
                throw "browser don't support AJAX";
            }

            return httpRequest;
        }
    };
    var JSONLayout = function() {

    };
    JSONLayout.prototype = {
        /**
         * Implement this method to create your own layout format.
         * @param {Log4js.LoggingEvent} loggingEvent loggingEvent to format
         * @return formatted String
         * @type String
         */
        format : function(logTime, logLevel, logCate, logMsg) {

            var jsonString = "{\n \"LoggingEvent\": {\n";
            jsonString += "\t\"category\": \"" + (logCate || "main") + "\",\n";
            jsonString += "\t\"level\": \"" + getLevelStr(logLevel) + "\",\n";
            jsonString += "\t\"message\": \"" + logMsg + "\",\n";
            // jsonString += "\t\"referer\": \"" + referer + "\",\n";
            // jsonString += "\t\"useragent\": \"" + useragent + "\",\n";
            jsonString += "\t\"timestamp\": \"" + logTime + "\"\n";
            jsonString += "}\n}";

            return jsonString;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/json";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "{" + "\"ClientInfo\" : {\n" + "\t\"useragent\": \"" + useragent + "\",\n" + "\t\"referer\": \"" + referer + "\"\n},\n" + "\"VizLogger\": [\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "\n]}";
        },
        getSeparator : function() {
            return ",\n";
        }
    };

    /**
     * Get the XMLHttpRequest object independent of browser.
     * @private
     */
    var XMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    XMLLayout.prototype = {
        format : function(logTime, logLevel, logCate, logMsg) {

            var content = "<vizLogger:event category=\"";
            content += (logCate || "main") + "\" level=\"";
            content += getLevelStr(logLevel) + "\" timestamp=\"";
            content += logTime + "\">\n";
            content += "\t<vizLogger:message><![CDATA[" + this.escapeCdata(logMsg) + "]]></vizLogger:message>\n";
            content += "</vizLogger:event>";

            return content;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/xml";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "<vizLogger:eventSet useragent=\"" + useragent + "\" referer=\"" + referer.replace(/&/g, "&amp;") + "\">\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "</vizLogger:eventSet>\n";
        },
        getSeparator : function() {
            return "\n";
        },
        /**
         * Escape Cdata messages
         * @param str {String} message to escape
         * @return {String} the escaped message
         * @private
         */
        escapeCdata : function(str) {
            return str.replace(/\]\]>/, "]]>]]&gt;<![CDATA[");
        }
    };

    function getLevelStr(levelInt) {
        switch(levelInt) {
            case Logger.LEVEL.TRACE:
                return "TRACE";
            case Logger.LEVEL.DEBUG:
                return "DEBUG";
            case Logger.LEVEL.INFO:
                return "INFO";
            case Logger.LEVEL.WARN:
                return "WARN";
            case Logger.LEVEL.ERROR:
                return "ERROR";
        }
    }

    var enabled = false;
    var paused = false;
    var logBuffer = [[/*logTime*/], [/*level*/], [/*category*/], [/*message*/]];
    var MaxBufferSize = 2000;
    var doLog = function(level, category, message) {
        // if(enabled) {
        if(logBuffer[0].length === MaxBufferSize)
            callAppender();
        logBuffer[0].push(Date.now());
        logBuffer[1].push(level);
        logBuffer[2].push(category);
        logBuffer[3].push(message.toString());
        // }
    };
    var awakeThenLog = function(level, category, message) {
        resume();
        doLog(level, category, message);
    };
    var log = noop;
    var pause = function() {
        paused = true;
        log = awakeThenLog;
    };
    var resume = function() {
        paused = false;
        log = doLog;
        setTimeout(function() {
            dispatcher();
        }, 100);
    };
    // id for appender
    var id = 0;
    var nextId = function() {
        return id++;
    };
    var appenders = {};
    /*
     * singleton Logger
     *
     */
    var Logger = {
        LEVEL : {
            TRACE : 5000,
            DEBUG : 10000,
            INFO : 20000,
            WARN : 30000,
            ERROR : 40000,
            NO : Number.MAX_VALUE
        },
        isEnable : function() {
            return enabled;
        },
        enable : function() {
            log = doLog;
            enabled = true;
            setTimeout(function() {
                dispatcher();
            }, 100);
        },
        disable : function() {
            callAppender();
            log = noop;
            enabled = false;
        },
        toggleEnable : function() {
            enabled ? this.disable() : this.enable();
        },
        addAppender : function(/*[key,] appender*/) {
            var _nextId = nextId();
            var key, appender;
            if(arguments.length === 1) {
                key = _nextId;
                appender = arguments[0];
            } else if(arguments.length >= 2) {
                key = arguments[0];
                appender = arguments[1];
            }
            if( typeof appender === "object" && appender.doAppend) {
                if(appenders[key] !== undefined)
                    return;
                callAppender();
                appenders[key] = appender;
                return key;
            }

        },
        setAppenders : function(appenders) {
            appenders = [];
            for(var i = 0, l = appenders.length; i < l; i++) {
                var appender = appenders[i];
                if(appender.appenderKey)
                    this.addAppender(appender.appenderKey, appender.appender);
                else
                    this.addAppender(appender.appender);
            }
        },
        removeAppender : function(key) {
            if(appenders[key] === undefined)
                return false;
            //append immediately before remove
            callAppender(appenders[key]);
            return (
            delete appenders[key]);
        },
        getAppender : function(key) {
            return appenders[key];
        },
        ConsoleAppender : ConsoleAppender,
        DivAppender : DivAppender,
        AjaxAppender : AjaxAppender,
        //[time][level][category]-message [yyyy-MM-ddThh:mm:ss:ms][INFO][function1]-this is a piece of log.
        DefaultLayout : DefaultLayout,
        HTMLLayout : HTMLLayout,
        XMLLayout : XMLLayout,
        JSONLayout : JSONLayout,
        trace : function(message, category) {
            log(Logger.LEVEL.TRACE, category, message);
        },
        debug : function(message, category) {
            log(Logger.LEVEL.DEBUG, category, message);
        },
        info : function(message, category) {
            log(Logger.LEVEL.INFO, category, message);
        },
        warn : function(message, category) {
            log(Logger.LEVEL.WARN, category, message);
        },
        error : function(message, category) {
            log(Logger.LEVEL.ERROR, category, message);
        },
    };
    appenders["[default]"] = new Logger.ConsoleAppender();
    return Logger;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.ClosedShape',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Drawable',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, CanvasHelper, Drawable) {
	/**
	 * Abstract super class for all closed shapes to subclass. It defines border
	 * style, it cannot be drawn directly.
	 * 
	 * @name sap.riv.graphics.shape.ClosedShape
	 * @class
	 * @augments sap.riv.graphics.Drawable
	 */
	var ClosedShape = ObjectUtils.derive(Drawable, {
		constructor : function() {
			this._bdr = {
				width : 0,
				color : '#000000',
				lineJoin : 'miter',
				miterLimit : 10.0
			};
		},

		/**
		 * Get or set the border width of the closed shape, the border width
		 * should be greater or equal than zero. Setting zero means no border
		 * 
		 * @name sap.riv.graphics.shape.ClosedShape#borderWidth
		 * @function
		 * @param {Number}
		 *            borderWidth the border width
		 * @returns {this|Number}
		 */
		borderWidth : function(borderWidth) {
			if (borderWidth != undefined && borderWidth >= 0) {
				this._bdr.width = borderWidth;
				return this;
			}
			return this._bdr.width;
		},
		/**
		 * Get or set the border color of the closed shape, the default color is
		 * #000000, the color setting should be CSSColor serialized string or as
		 * follow to define gradient
		 * 
		 * <pre>
		 * {
		 *      t: 'lg'|'rg', //line gradient or radial gradient
		 *      s: { x:## , y:## }, //the start position of the gradient
		 *      e: { x:## , y:## }, //the end position of the gradient
		 *      st: [
		 *              {
		 *                  o: //the stop offset
		 *                  v: //the stop color
		 *              },...
		 *          ] //the color stops of the gradient
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.graphics.shape.ClosedShape#borderColor
		 * @function
		 * @param {CSSColor|Object}
		 *            borderColor the border color
		 * @returns {this|CSSColor|CanvasGradient}
		 */
		borderColor : function(borderColor) {
			if (borderColor != undefined) {
				this._bdr.color = CanvasHelper.createColorStyle(borderColor);
				return this;
			}
			return this._bdr.color;
		},
		/**
		 * Get or set the border join style of the closed shape, the default
		 * style is miter, the available styles are miter, bevel, round. For
		 * those shapes of which borders do not have pointed join, the setting
		 * will not take effect.
		 * 
		 * @name sap.riv.graphics.shape.ClosedShape#borderJoin
		 * @function
		 * @param {String}
		 *            borderJoinStyle the border join style
		 * @returns {this|String}
		 */
		borderJoin : function(borderJoinStyle) {
			if (borderJoinStyle !== undefined) {
				this._bdr.lineJoin = borderJoinStyle;
				return this;
			}
			return this._bdr.lineJoin;
		},
		/**
		 * Get or set the border miter limit of the closed shape. The value
		 * should be greater than zero.
		 * 
		 * @name sap.riv.graphics.shape.ClosedShape#borderMiterLimit
		 * @function
		 * @param {Number}
		 *            borderMLimit the border miter limit if the join style is
		 *            miter
		 * @returns {this|Number}
		 */
		borderMiterLimit : function(borderMLimit) {
			if (borderMLimit !== undefined && borderMLimit > 0) {
				this._bdr.miterLimit = borderMLimit;
				return this;
			}
			return this._bdr.miterLimit;
		},

		/**
		 * Draw the border around the shape, if the border width is greater than
		 * zero
		 * 
		 * @name sap.riv.graphics.shape.ClosedShape#drawBorder
		 * @function
		 * @param drawingContext
		 */
		drawBorder : function(drawingContext) {
			if (this._bdr.width > 0) {
				var b = this._bdr;
				drawingContext.save();
				drawingContext.setStrokeStyle(b.color);
				drawingContext.setLineWidth(b.width || 1.0);
				drawingContext.setLineJoin(b.lineJoin || '#miter');
				if (b.lineJoin === 'miter' && b.miterLimit) {
					drawingContext.setMiterLimit(b.miterLimit);
				}
				drawingContext.stroke();
				drawingContext.restore();
			}
		}
	});
	return ClosedShape;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.ClipRegion',
  version : '1.0.0'
},
function Setup() {
	var clipRegionId = (function() {
		var id = 0;
		return function() {
			return 'cr:' + id++;
		};
	})();
	var ClipRegion = function(regionDef) {
		this._id = clipRegionId();
		this._spths = [];
		switch (regionDef.type) {
		case 'rect':
			var x = regionDef.x, y = regionDef.y, w = regionDef.w, h = regionDef.h;
			var spth = [];
			spth.push({
				pd : 'orig',
				x : x,
				y : y
			});
			spth.push({
				pd : 'lnto',
				x : x + w,
				y : y
			});
			spth.push({
				pd : 'lnto',
				x : x + w,
				y : y + h
			});
			spth.push({
				pd : 'lnto',
				x : x,
				y : y + h
			});
			this._spths.push(spth);
			break;
		case 'path':
			this._spths = regionDef.spths;
			break;
		}
	};

	ClipRegion.prototype.id = function() {
		return this._id;
	};

	ClipRegion.prototype.clip = function(drawingContext) {
		var dCtx = drawingContext;
		dCtx.beginPath();
		for ( var si = 0, sp, sps = this._spths, slen = sps.length; si < slen; si++) {
			sp = sps[si];// sub-path
			for ( var di = 0, d, dlen = sp.length; di < dlen; di++) {
				d = sp[di];
				switch (d.pd) {
				case 'orig':
					dCtx.moveTo(d.x, d.y);
					break;
				case 'lnto':
					dCtx.lineTo(d.x, d.y);
					break;
				case 'spln':
					dCtx.quadraticCurveTo(d.cx, d.cy, d.x, d.y);
					break;
				case 'bcur':
					dCtx.bezierCurveTo(d.c1x, d.c1y, d.c2x, d.c2y, d.x, d.y);
					break;
				case 'arct':
					dCtx.arcTo(d.cx, d.cy, d.x, d.y, d.r);
					break;
				case 'arc':
					dCtx.arc(d.x, d.y, d.r, d.sa, d.ea, !d.cw);
					break;
				}
			}
			dCtx.closePath();
		}
		dCtx.clip();
	};
	return ClipRegion;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(FuncUtils) {
	/**
	 * Iterator for LinkedHashMap, to get an iterator for a linkedHashMap
	 * instance, use {@link sap.riv.core.utils.LinkedHashMap#getIterator}
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator
	 * @constructor
	 */
	var lhmItr = function(lhm, reverseOrder) {
		this._lhm = lhm;
		this._reverse = reverseOrder || false;
		this._count = lhm._length;
		this._cursor = this._reverse ? this._lhm._last : this._lhm._head;
		if (this._reverse) {
			this.hasMore = this._hasMoreInReverse;
		} else {
			this.hasMore = this._hasMoreInOrder;
		}
	};

	lhmItr.prototype._hasMoreInOrder = function() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._head;
			} else {
				this._cursor = this._cursor.next;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	};

	lhmItr.prototype._hasMoreInReverse = function() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._last;
			} else {
				this._cursor = this._cursor.prev;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	};
	/**
	 * Find if there is more item to iterate, calling this method will move the
	 * cursor forward to next item
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator#hasMore
	 * @function
	 * @returns {Boolean}
	 */
	lhmItr.prototype.hasMore = FuncUtils.noop;

	/**
	 * Get the entry at the current cursor, calling this method without calling
	 * hasMore method will return the same entry
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator#next
	 * @function
	 * @returns {Object} with key & value property indicating the entry's key
	 *          and value object
	 */
	lhmItr.prototype.next = function() {
		var ret = {
			key : this._cursor.key,
			value : this._cursor.value
		};
		return ret;
	};
	/**
	 * Get the value of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator#nextValue
	 * @function
	 * @returns {Object}
	 */
	lhmItr.prototype.nextValue = function() {
		return this._cursor.value;
	};
	/**
	 * Get the key of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator#nextKey
	 * @function
	 * @returns {String}
	 */
	lhmItr.prototype.nextKey = function() {
		return this._cursor.key;
	};
	/**
	 * Reset the iterator to initial state
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap.Iterator#reset
	 * @function
	 * @returns
	 */
	lhmItr.prototype.reset = function() {
		this._count = this._lhm._length;
	};
	/**
	 * Create an empty LinkedHashMap
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap
	 * @constructor
	 */
	var LinkedHashMap = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	var lhmp = LinkedHashMap.prototype;

	/**
	 * Add one entry, if the key for the entry is already existing, then the old
	 * value will be replaced.
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#add
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @returns {undefined|Object} undefined if key is new, otherwise will be
	 *          the replaced value
	 */
	lhmp.add = function(key, value) {
		var m = this._map;
		var ret = null;
		var node = {
			prev : null,
			key : key,
			value : value,
			next : null
		};
		if (!this._length) {
			this._head = this._last = node;
		}
		if (!m.hasOwnProperty(key)) {
			m[key] = node;
			this._length++;
			node.prev = this._last;
			this._last.next = node;
			this._last = node;
			this._last.next = this._head;
			this._head.prev = this._last;
		} else {
			ret = m[key].value;
			m[key].value = value;
		}
		return ret;
	};
	/**
	 * Add entries from an existing linked hash map, the duplicated entry will
	 * be replaced silently
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#addAll
	 * @function
	 * @param {sap.riv.core.utils.LinkedHashMap}
	 *            linkedHashMap another linkedHashMap to added
	 * @returns
	 */
	lhmp.addAll = function(linkedHashMap) {
		var itr = linkedHashMap.getIterator();
		var entry;
		while (itr.hasMore()) {
			entry = itr.next();
			this.add(entry.key, entry.value);
		}
	};
	/**
	 * Insert the entry before one entry, if the inserted entry exists or the
	 * entry to be inserted before doesn't exist, insertion will fail silently
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#insertBefore
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            beforeKey the key of the entry to be inserted before
	 * @returns {Object} the value inserted
	 */
	lhmp.insertBefore = function(key, value, beforeKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(beforeKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[beforeKey];
			if (anode !== this._head) {
				nnode.prev = anode.prev;
				anode.prev.next = nnode;
			} else {
				this._head = nnode;
				nnode.prev = this._last;
			}
			nnode.next = anode;
			anode.prev = nnode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Insert the entry after one entry, if the inserted entry exists or the
	 * entry to be inserted after doesn't exist, insertion will fail silently
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#insertAfter
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            afterKey the key of the entry to be inserted after
	 * @returns {Object} the value inserted
	 */
	lhmp.insertAfter = function(key, value, afterKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(afterKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[afterKey];
			if (anode !== this._last) {
				nnode.next = anode.next;
				anode.next.prev = nnode;
			} else {
				this._last = nnode;
				this._last.next = this._head;
			}
			anode.next = nnode;
			nnode.prev = anode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Replace the existing entry with new entry, including key in place
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#replace
	 * @function
	 * @param {String}
	 *            key the key for the entry to be replaced
	 * @param {withKey}
	 *            withKey the key for the entry to be added
	 * @param {Object}
	 *            andValue the value of the entry to be added
	 * @returns {Object} the value to be replaced
	 */
	lhmp.replace = function(key, withKey, andValue) {
		var m = this._map;
		if (!m.hasOwnProperty(withKey) && m.hasOwnProperty(key)) {
			var nnode = {
				prev : null,
				key : withKey,
				value : andValue,
				next : null
			};
			var rnode = m[key];
			nnode.prev = rnode.prev;
			nnode.next = rnode.next;
			rnode.prev.next = nnode;
			rnode.next.prev = nnode;
			if (this._head === rnode)
				this._head = nnode;
			if (this._last === rnode)
				this._last = nnode;
			m[withKey] = nnode;
			delete m[key];
			return rnode.value;
		}
	};
	/**
	 * Get the value for the key
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#get
	 * @function
	 * @param {String}
	 *            key the key for the entry to get
	 * 
	 * @returns {undefined|Object} the value for the key or undefined if key is
	 *          non-existing
	 */
	lhmp.get = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key)) {
			return m[key].value;
		}
		return null;
	};
	/**
	 * Get the first inserted entry
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#getFirstInsert
	 * @function
	 * 
	 * @returns {Object} the value first inserted
	 */
	lhmp.getFirstInsert = function() {
		return this._head ? this._head.value : null;
	};
	/**
	 * Get the last inserted entry
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#getLastInsert
	 * @function
	 * 
	 * @returns {Object} the value last inserted
	 */
	lhmp.getLastInsert = function() {
		return this._last ? this._last.value : null;
	};
	/**
	 * Move entry associated with key to the last of the link
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#moveToLast
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 * @returns
	 */
	lhmp.moveToLast = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._last.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.prev = this._last;
			node.next = this._last.next;
			this._last.next = node;
			this._last = node;
			this._head = node.next;
			this._head.prev = node;

		}
	};
	/**
	 * Move entry associated with key to the first of the link
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#moveToFirst
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 * @returns
	 */
	lhmp.moveToFirst = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._head.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.next = this._head;
			node.prev = this._head.prev;
			this._head.prev = node;
			this._head = node;
			this._last = node.prev;
			this._last.next = node;
		}
	};
	/**
	 * Check whether having the key
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#has
	 * @function
	 * @param {String}
	 *            key the key of the entry to check
	 * @returns {Boolean}
	 */
	lhmp.has = function(key) {
		var m = this._map;
		return m.hasOwnProperty(key);
	};
	/**
	 * Remove the entry associated with the key
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#remove
	 * @function
	 * @param {String}
	 *            key the key of the entry to remove
	 * @returns {undefined|Object} the removed item or undefined if key is
	 *          non-existing
	 */
	lhmp.remove = function(key) {
		var m = this._map;
		var ret;
		if (m.hasOwnProperty(key)) {
			var node = m[key];
			ret = node.value;
			if (node === this._head) {
				this._head = node.next;
			} else if (node === this._last) {
				this._last = node.prev;
			} else {
				node.prev.next = node.next;
				node.next.prev = node.prev;
			}
			delete m[key];
			this._length--;
			if (this._length === 0) {
				this._head = this._last = undefined;
			}
			return ret;
		}
	};
	/**
	 * Remove all entries added before
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#purgeAll
	 * @function
	 * 
	 * @returns
	 */
	lhmp.purgeAll = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	/**
	 * Whether the map is empty
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#isEmpty
	 * @function
	 * 
	 * @returns {Boolean}
	 */
	lhmp.isEmpty = function() {
		return this._length == 0;
	};
	/**
	 * Length of the map
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#length
	 * @function
	 * @returns {Integer}
	 */
	lhmp.length = function() {
		return this._length;
	};
	/**
	 * Get the iterator of the map
	 * 
	 * @name sap.riv.core.utils.LinkedHashMap#getIterator
	 * @function
	 * @param {Boolean}
	 *            reverseOrder whether iterate in reverse order
	 * @returns {sap.riv.core.utils.LinkedHashMap.Iterator}
	 */
	lhmp.getIterator = function(reverseOrder) {
		return new lhmItr(this, reverseOrder);
	};
	return LinkedHashMap;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.TouchEvent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Event',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Event) {
	/**
	 * Touch List class
	 * 
	 * @name sap.riv.graphics.TouchList
	 * @constructor
	 */
	var TouchList = function() {
		this.tA = [], this.tM = {};
	};
	var tlp = TouchList.prototype;
	tlp._addTouch_ = function(touch) {
		this.tA.push(touch);
		this.tM[touch.identifier()] = touch;
	};
	/**
	 * Return the length of the list
	 * 
	 * @name sap.riv.graphics.TouchList#length
	 * @function
	 * @returns {Number}
	 * 
	 */
	tlp.length = function() {
		return this.tA.length;
	};
	/**
	 * Get the touch at specified index
	 * 
	 * @name sap.riv.graphics.TouchList#item
	 * @function
	 * @param {Number}
	 *            index
	 * @returns {sap.riv.vizkit.Touch}
	 */
	tlp.item = function(index) {
		if (index >= 0 && (index < this.tA.length)) {
			return this.tA[index];
		}
	};
	/**
	 * Get the touch with specified identifier
	 * 
	 * @name sap.riv.graphics.TouchList#identifiedTouch
	 * @function
	 * @param {Number}
	 *            identifier
	 * @returns {sap.riv.vizkit.Touch}
	 */
	tlp.identifiedTouch = function(identifier) {
		if (identifier) {
			return this.tM[identifier];
		}
	};
	/**
	 * Touch class
	 * 
	 * @name sap.riv.graphics.Touch
	 * @constructor
	 */
	var Touch = function(identifier, targetLayer, globalXY, pageXY) {
		this._id = identifier;
		this._targetLayer = targetLayer;
		this._localXY = targetLayer.convertPointFromGlobal(globalXY);
		this._pageXY = pageXY;
	};
	/**
	 * Get the identifier of the touch
	 * 
	 * @name sap.riv.graphics.Touch#identifier
	 * @function
	 * @returns {Number}
	 */
	Touch.prototype.identifier = function() {
		return this._id;
	};

	/**
	 * Get the target Layer of the touch
	 * 
	 * @name sap.riv.graphics.Touch#targetLayer
	 * @function
	 * @returns {sap.riv.graphics.Layer}
	 */
	Touch.prototype.targetLayer = function() {
		return this._targetLayer;
	};

	/**
	 * Get the XY of the touch in target layer's coordinates system
	 * 
	 * @name sap.riv.graphics.Touch#localXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	Touch.prototype.localXY = function() {
		return {
			x : this._localXY.x,
			y : this._localXY.y
		};
	};

	/**
	 * Get the XY of the touch in document
	 * 
	 * @name sap.riv.graphics.Touch#pageXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	Touch.prototype.pageXY = function() {
		return {
			x : this._pageXY.x,
			y : this._pageXY.y
		};
	};

	/**
	 * This class defines Touch Event
	 * 
	 * @name sap.riv.graphics.TouchEvent
	 * @class
	 * @augmentssap.riv.graphics.Event
	 */
	var TouchEvent = ObjUtils.derive(Event,
	/**
	 * @lends sap.riv.graphics.TouchEvent
	 * 
	 */
	{
		constructor : function(type, targetLayer, canBubbling, touches, changedTouches, targetTouches) {
			this._relatedTarget = undefined;
			this._touches = touches;
			this._targetTouches = targetTouches;
			this._changedTouches = changedTouches;
		},

		/**
		 * Get the all touches on the screen.
		 * 
		 * @namesap.riv.graphics.TouchEvent#touches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		touches : function() {
			return this._touches;
		},
		/**
		 * Get the touches initiated from the same target
		 * 
		 * @namesap.riv.graphics.TouchEvent#targetTouches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		targetTouches : function() {
			return this._targetTouches;
		},
		/**
		 * Get the touches lead to the event
		 * 
		 * @namesap.riv.graphics.TouchEvent#changedTouches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		changedTouches : function() {
			return this._changedTouches;
		}
	});
	TouchEvent.createTouch = function(identifier, targetLayer, globalXY, pageXY) {
		return new Touch(identifier, targetLayer, globalXY, pageXY);
	};
	TouchEvent.createTouchList = function() {
		return new TouchList;
	};
	return TouchEvent;
});sap.riv.module(
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
}
],
function Setup(typeUtils) {
	/**
	 * To utilize observable object, You have to extend your object from it, and
	 * set the 'events' property as Array of event name to the constructor
	 * 
	 * @name sap.riv.core.utils.Observable
	 * @constructor
	 */
	var ob = function(option) {
		this._events = {};
		var cclazz = this.constructor;
		while (cclazz) {
			var events = cclazz.prototype.events, len;
			if (events) {
				len = events.length;
				while (len--) {
					this.addEvents(events[len]);
				}
			}
			cclazz = cclazz.superclazz;
		}
		if (option) {
			if (option.listeners) {
				this.addListeners(option.listeners);
				delete option.listeners;
			}
		}
	};

	var obp = ob.prototype;

	/**
	 * Add events that could be monitored
	 * 
	 * @name sap.riv.core.utils.Observable#addEvents
	 * @function
	 * @parameter {String|String|...} event1,event2,event3... variable length
	 *            arguments of String
	 */
	obp.addEvents = function(/* event1, event2,...,eventn */) {
		var es = this._events, a = arguments, len = arguments.length;
		while (len--) {
			if (typeof a[len] === 'string') {
				es[a[len]] = es[a[len]] || [];
			}
		}
	};
	/**
	 * Get the supported events
	 * 
	 * @name sap.riv.core.utils.Observable#getSupportedEvents
	 * @function
	 * @return {Array} an array of event names
	 */
	obp.getSupportedEvents = function() {
		var ret = [];
		for ( var e in this._events) {
			ret.push(e);
		}
		return ret;
	};
	/**
	 * Add event listeners
	 * 
	 * @name sap.riv.core.utils.Observable#addListeners
	 * @function
	 * @param {Object|[Object]}
	 *            o single event listener or array of event listener
	 * @param {String}
	 *            o.eventName the event to be monitored
	 * @param {Function}
	 *            o.listener the function to be called back when event is fired
	 * @param {Object}
	 *            [o.scope] the scope in which the listener will be executed
	 * @param {Object}
	 *            [o.optionalArgs] the additional arguments that will be passed
	 *            in the listener
	 */
	obp.addListeners = function(o) {
		var ls;
		if (typeUtils.isArray(o)) {
			ls = o;
		} else {
			ls = [ o ];
		}
		var len = ls.length, l, en;
		var es = this._events;
		while (len--) {
			l = ls[len];
			en = l.eventName;
			if (es.hasOwnProperty(en)) {
				var lList = es[en];
				if (!this.isListening(en, l.listener, l.scope)) {
					lList[lList.length] = {
						fn : l.listener,
						scp : l.scope,
						optArgs : l.optionalArgs
					};
				}
			}
		}
		return this;
	};

	/**
	 * Find the listener that registered before
	 * 
	 * @name sap.riv.core.utils.Observable#findListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * 
	 * 
	 * @returns {-1|Integer} returning -1 means not found otherwise return the
	 *          position order in which the listener to be invoked
	 */
	obp.findListener = function(eventName, fn, scope) {
		var es = this._events;
		if (!es.hasOwnProperty(eventName)) {
			return -1;
		}
		var lList = es[eventName], len = lList.length, lis;
		while (len--) {
			lis = lList[len];
			if (scope) {
				if (lis.fn == fn && lis.scp == scope) {
					return len;
				}
			} else {
				if (lis.fn == fn) {
					return len;
				}
			}
		}
		return -1;
	};
	/**
	 * Check whether the listener is listening on the event
	 * 
	 * @name sap.riv.core.utils.Observable#isListening
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * @returns {Boolean}
	 */
	obp.isListening = function(eventName, fn, scope) {
		return this.findListener(eventName, fn, scope) > -1;
	};

	/**
	 * Remove the previous registered listener listening on the given event
	 * 
	 * @name sap.riv.core.utils.Observable#removeListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * @returns {this} return the observable object itself
	 */
	obp.removeListener = function(eventName, fn, scope) {
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			var lList = es[eventName];
			var len = lList.length, idx;
			while (len--) {
				idx = this.findListener(eventName, fn, scope);
				if (idx > -1) {
					lList.splice(idx, 1);
					len = lList.length;
				}
			}
		}
		return this;
	};

	/**
	 * Remove all the listeners currently watching the event
	 * 
	 * @name sap.riv.core.utils.Observable#removeAllListeners
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {this} return the observable object itself
	 */
	obp.removeAllListeners = function(eventName) {
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			es[eventName] = [];
		}
		return this;
	};
	/**
	 * Check whether there is any listener watching the event
	 * 
	 * @name sap.riv.core.utils.Observable#hasListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {Boolean}
	 */
	obp.hasListener = function(eventName) {
		return this._events[eventName] && this._events[eventName].length > 0;
	};

	/**
	 * Purge all listeners registered on the observable object
	 * 
	 * @name sap.riv.core.utils.Observable#purgeListeners
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {Boolean}
	 */
	obp.purgeListeners = function() {
		var es = this._events;
		for ( var e in es) {
			es[e] = [];
		}
	};

	/**
	 * Fire a event, with optional details attached
	 * 
	 * @name sap.riv.core.utils.Observable#fireEvent
	 * @function
	 * @param {String}
	 *            eventName name of the event to be fired
	 * @param {Object}
	 *            details variable length arguments,var1, var2..varn, the
	 *            details to be passed in each listener call.
	 */
	obp.fireEvent = function(eventName /* details */) {
		var details = Array.prototype.slice.call(arguments, 1);
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			var lList = es[eventName], l;
			for ( var i = 0, len = lList.length; i < len; i++) {
				l = lList[i];
				if (l.optArgs) {
					details.push(l.optArgs);
				}
				l.fn.apply(l.scp || this || window, details);
			}
		}
	};

	/**
	 * Same as addListeners
	 * 
	 * @name sap.riv.core.utils.Observable#on
	 * @function
	 * @see sap.riv.core.utils.Observable#addListeners
	 */
	obp.on = obp.addListeners;
	/**
	 * Same as removeListener
	 * 
	 * @name sap.riv.core.utils.Observable#un
	 * @function
	 * @see sap.riv.core.utils.Observable#removeListener
	 */
	obp.un = obp.removeListener;
	return ob;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TransformHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.ClipRegion',
  version : '1.0.0'
}
],
function Setup(Observable, ObjUtils, LinkedHashMap, TmHelper, CanvasHelper, ClipRegion) {
	var id = 0;
	var nextId = function() {
		return id++;
	};
	var Layer = ObjUtils.derive(Observable,
	/**
	 * @lends sap.riv.graphics.Layer
	 * 
	 */
	{
		events : [ 'contentUpdate', 'focusin', 'focusout', 'focus', 'blur', 'mouseenter', 'mouseleave', 'mousemove',
				'mousedown', 'mouseup', 'click', 'dblclick', 'touchstart', 'touchmove', 'touchend', 'touchcancel' ],
		/**
		 * @constructs
		 * @param {Object}
		 *            options the options to initialize the layer
		 * 
		 * @param {String}
		 *            [options.bgColor] the background color of the layer
		 * 
		 * @param {Object}
		 *            [options.anchor] the anchor point of the layer, default is
		 * 
		 * <pre>
		 * {
		 * 	x : 0.5,
		 * 	y : 0.5
		 * }
		 * </pre>
		 * 
		 * @param {Object}
		 *            [options.position] the position of the layer, default is
		 * 
		 * <pre>
		 * {
		 * 	x : 0,
		 * 	y : 0
		 * }
		 * </pre>
		 * 
		 * @param {Object}
		 *            [options.size] the size of layer, default is
		 * 
		 * <pre>
		 * {
		 * 	w : 0,
		 * 	h : 0
		 * }
		 * </pre>
		 */
		constructor : function(options) {
			options = options || {};
			this._id = nextId();
			this._superLayer = undefined;

			// content clip region state
			this._currentClipRegion = undefined;

			this._clipRegions = {};
			this._shape2clip = {};
			this._clip2shapes = {};
			this._content = new LinkedHashMap();

			// event related
			this._listenOnLayer = {};

			this._subLayers = new LinkedHashMap();
			this._bgColor = options.bgColor || undefined;
			this._opacity = 1.0;
			this._hidden = false;
			this._clipToBounds = false;
			this._shouldRasterized = false;
			this._rasterized = false;
			this._bitmapCache = CanvasHelper.createCanvasElement(1, 1);
			this._bounds = {
				x : 0,
				y : 0,
				width : 0,
				height : 0
			};
			this._position = {
				x : 0,
				y : 0
			};
			this._anchorPoint = {
				x : 0.5,
				y : 0.5
			};
			this._transform = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
			this._calcMatrix = {
				m : undefined,
				i : undefined
			};
			this._init(options);
		},

		_init : function(options) {
			if (options.size && options.position) {
				this._position.x = options.position.x;
				this._position.y = options.position.y;
			}
			if (options.size) {
				this._bounds.width = options.size.w;
				this._bounds.height = options.size.h;
				this._updateBitmapCache();
			}
			if (options.anchor) {
				this._anchorPoint.x = options.anchor.x;
				this._anchorPoint.y = options.anchor.y;
			}
			this._updateCalcMatrix();
		},

		_updateCalcMatrix : function() {
			this._calcMatrix.m = TmHelper.makeTranslateTM(-this._anchorPoint.x * this._bounds.width,
					-this._anchorPoint.y * this._bounds.height, TmHelper.makeCustomTM(this._transform, TmHelper
							.makeTranslateTM(this._position.x, this._position.y)));
			this._calcMatrix.i = TmHelper.makeTranslateInvertTM(-this._anchorPoint.x * this._bounds.width,
					-this._anchorPoint.y * this._bounds.height, TmHelper.makeCustomInvertTM(this._transform, TmHelper
							.makeTranslateInvertTM(this._position.x, this._position.y)));
		},
		/**
		 * Get the id of the layer
		 * 
		 * @name sap.riv.graphics.Layer#id
		 * @function
		 * @returns {String} the unique id of the component
		 */
		id : function() {
			return this._id;
		},
		/**
		 * Get and set whether the layer should be rasterized for drawing
		 * performance boost
		 * 
		 * @name sap.riv.graphics.Layer#shouldRasterized
		 * @function
		 * @param {Boolean}
		 *            [should]
		 * @returns {this|Boolean}
		 */
		shouldRasterized : function(should) {
			if (should !== undefined) {
				this._shouldRasterized = should;
				this._rasterized = false;
				this._updateBitmapCache();
				return this;
			} else {
				return this._shouldRasterized;
			}
		},

		/**
		 * Get and set whether the layer should be hided
		 * 
		 * @name sap.riv.graphics.Layer#hidden
		 * @function
		 * @param {Boolean}
		 *            [hidden]
		 * @returns {this|Boolean}
		 */
		hidden : function(hidden) {
			if (hidden !== undefined) {
				if (this._hidden !== hidden) {
					this._hidden = hidden;
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return this._hidden;
			}
		},

		/**
		 * Get and set the opacity of the layer
		 * 
		 * @name sap.riv.graphics.Layer#opacity
		 * @function
		 * @param {Number}
		 *            [opacity]
		 * @returns {this|Number}
		 */
		opacity : function(opacity) {
			if (opacity !== undefined) {
				if (opacity >= 0 && opacity <= 1.0 && opacity != this._opacity) {
					this._opacity = opacity;
					this._rasterized = false;
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return this._opacity;
			}
		},

		/**
		 * Get and set the background color of the layer
		 * 
		 * @name sap.riv.graphics.Layer#backgroundColor
		 * @function
		 * @param {String|Boolean}
		 *            [bgColor] CSS color string, false means clear background
		 *            color
		 * @returns {this|String}
		 */
		backgroundColor : function(bgColor) {
			if (bgColor !== undefined) {
				if (bgColor === false) {
					this._bgColor = undefined;
				} else {
					if (this._bgColor !== bgColor) {
						this._bgColor = bgColor;
						this._rasterized = false;
						this.fireEvent('contentUpdate');
					}
				}
				return this;
			} else {
				return this._bgColor;
			}
		},

		/**
		 * Get and set the bounds of the layer
		 * 
		 * @name sap.riv.graphics.Layer#bounds
		 * @function
		 * @param {undefined|Object}
		 *            bounds the new bounds of the layer:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 * 
		 * @returns {this|Object }
		 */
		bounds : function(bounds) {
			if (bounds) {
				var ob = this._bounds, nb = bounds;
				if (ob.x !== nb.x || ob.y !== nb.y || ob.width !== nb.width || ob.height !== nb.height) {
					ob.x = nb.x;
					ob.y = nb.y;
					ob.width = nb.width;
					ob.height = nb.height;
					this._rasterized = false;
					this._updateCalcMatrix();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				var b = this._bounds;
				return {
					x : b.x,
					y : b.y,
					width : b.width,
					height : b.height
				};
			}
		},
		/**
		 * Get and set the size of the layer
		 * 
		 * @name sap.riv.graphics.Layer#size
		 * @function
		 * @param {undefined|Object}
		 *            size the new size of the layer:
		 * 
		 * <pre>
		 * {
		 *      width : ##,
		 *      height : ##,
		 * }
		 * </pre>
		 * 
		 * @returns {this|Object}
		 */
		size : function(size) {
			if (size) {
				var os = {
					width : this._bounds.width,
					height : this._bounds.height
				};
				if (os.width !== size.width || os.height !== size.height) {
					this._bounds.width = size.width;
					this._bounds.height = size.height;
					this._rasterized = false;
					this._updateCalcMatrix();
					this._updateBitmapCache();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return {
					width : this._bounds.width,
					height : this._bounds.height
				};
			}
		},
		/**
		 * Get and set the width of the layer
		 * 
		 * @name sap.riv.graphics.Layer#width
		 * @function
		 * @param {undefined|Number}
		 *            width the new width of the layer:
		 * 
		 * 
		 * @returns {this|Number}
		 */
		width : function(width) {
			if (width) {
				var ow = this._bounds.width;
				if (ow !== width) {
					this._bounds.width = width;
					this._rasterized = false;
					this._updateCalcMatrix();
					this._updateBitmapCache();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return this._bounds.width;
			}
		},
		/**
		 * Get and set the height of the layer
		 * 
		 * @name sap.riv.graphics.Layer#height
		 * @function
		 * @param {undefined|Number}
		 *            width the new height of the layer:
		 * 
		 * 
		 * @returns {this|Number}
		 */
		height : function(height) {
			if (height) {
				var oh = this._bounds.height;
				if (oh !== height) {
					this._bounds.height = height;
					this._rasterized = false;
					this._updateCalcMatrix();
					this._updateBitmapCache();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return this._bounds.height;
			}
		},

		/**
		 * Get and set the position of the layer
		 * 
		 * @name sap.riv.graphics.Layer#position
		 * @function
		 * @param {undefined|Object}
		 *            position the new position of the layer:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 * }
		 * </pre>
		 * 
		 * @returns {this|Object }
		 */
		position : function(position) {
			if (position) {
				var op = this._position, np = position;
				if (op.x !== np.x || op.y !== np.y) {
					op.x = np.x;
					op.y = np.y;
					this._updateCalcMatrix();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return {
					x : this._position.x,
					y : this._position.y
				};
			}
		},

		/**
		 * Get and set the anchor of the layer
		 * 
		 * @name sap.riv.graphics.Layer#anchorPoint
		 * @function
		 * @param {undefined|Object}
		 *            anchorPoint the new anchor of the layer:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 * }
		 * </pre>
		 * 
		 * @returns {this|Object }
		 */
		anchorPoint : function(anchorPoint) {
			if (anchorPoint) {
				var oap = this._anchorPoint, nap = anchorPoint;
				if (oap.x !== nap.x || oap.y !== nap.y) {
					oap.x = nap.x;
					oap.y = nap.y;
					this._updateCalcMatrix();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				var oap = this._anchorPoint;
				return {
					x : oap.x,
					y : oap.y
				};

			}
		},
		/**
		 * Get and set the frame of the layer
		 * 
		 * @name sap.riv.graphics.Layer#frame
		 * @function
		 * @param {undefined|Object}
		 *            rect the new frame of the layer:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 * 
		 * @returns {this|Object }
		 */
		frame : function(rect) {
			if (rect) {
				// TODO set the layer's geometry according to
				// frame
				this._bounds.width = rect.width;
				this._bounds.height = rect.height;
				this._position.x = rect.x + this._bounds.width * this._anchorPoint.x;
				this._position.y = rect.y + this._bounds.height * this._anchorPoint.y;
				this._rasterized = false;
				this._updateCalcMatrix();
				this._updateBitmapCache();
				this.fireEvent('contentUpdate');
				return this;
			} else {
				return TmHelper.rectApplyTransform({
					x : 0,
					y : 0,
					width : this._bounds.width,
					height : this._bounds.height
				}, this._calcMatrix.m);
			}
		},

		/**
		 * Get and set the transformation to the layer
		 * 
		 * @name sap.riv.graphics.Layer#affineTransform
		 * @function
		 * @param {[[a,c,e],[b,d,f],[0,0,1]]}
		 *            transform the new transformation to layer:
		 * 
		 * @returns {this|[[a,c,e],[b,d,f],[0,0,1]]}
		 */
		affineTransform : function(transform) {
			var t = this._transform;
			if (transform) {
				if (TmHelper.isValidAffineTransform(transform) || !TmHelper.isEqualTransform(t, transform)) {
					t[0][0] = transform[0][0];
					t[1][0] = transform[1][0];
					t[0][1] = transform[0][1];
					t[1][1] = transform[1][1];
					t[0][2] = transform[0][2];
					t[1][2] = transform[1][2];
					this._updateCalcMatrix();
					this.fireEvent('contentUpdate');
				}
				return this;
			} else {
				return [ [ t[0][0], t[0][1], t[0][2] ], [ t[1][0], t[1][1], t[1][2] ], [ 0, 0, 1 ] ];
			}
		},

		/**
		 * Get and set the transformation to the layer
		 * 
		 * @name sap.riv.graphics.Layer#affineTransform
		 * @function
		 * @param {Boolean}
		 *            transform the new transformation to layer
		 * 
		 * @returns {this|Boolean}
		 */
		clipToBounds : function(clipToBounds) {
			if (clipToBounds !== undefined) {
				if (this._clipToBounds != clipToBounds) {
					this._clipToBounds = clipToBounds;
					this.fireEvent('contentUpdate');
				} else {
					this._clipToBounds = clipToBounds;
				}
				return this;
			}
			return this._clipToBounds;
		},

		_setSuperLayer : function(superLayer) {
			this._superLayer = superLayer;
		},

		_removeSubLayer : function(subLayer) {
			if (subLayer && this._subLayers.has(subLayer.id())) {
				subLayer.removeAllListeners('contentUpdate');
				this._subLayers.remove(subLayer.id());
				this.fireEvent('contentUpdate');
			}
		},

		_updateBitmapCache : function() {
			if (this._shouldRasterized) {
				this._bitmapCache.width(this._bounds.width);
				this._bitmapCache.height(this._bounds.height);
			}
		},

		_getBitmapCache_ : function(reset) {
			if (reset) {
				this._updateBitmapCache();
			}
			return this._bitmapCache;
		},

		_rasterized_ : function(rasterized) {
			if (rasterized !== undefined) {
				this._rasterized = rasterized;
			} else {
				return this._rasterized;
			}
		},
		/**
		 * Does this layer have any shape content
		 * 
		 * @name sap.riv.graphics.Layer#hasContent
		 * @function
		 * 
		 * @returns {this|Boolean}
		 */
		hasContent : function() {
			return !this._content.isEmpty();
		},
		/**
		 * Add a shape onto the layer
		 * 
		 * @name sap.riv.graphics.Layer#addShape
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shapeObj the shape to be added
		 * @returns {sap.riv.graphics.Drawable} the concrete shape subclassing
		 *          {@link sap.riv.graphics.Drawable}
		 */
		addShape : function(shapeObj) {
			var shapeId = shapeObj.id();
			this._content.add(shapeId, shapeObj);
			this._rasterized = false;
			this.fireEvent('contentUpdate');
			return shapeObj;
		},
		/**
		 * Insert a shape into the layer after existing shape, so it will be
		 * drawn on top of it
		 * 
		 * @name sap.riv.graphics.Layer#insertShapeAfter
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            insertedShape the shape to be inserted
		 * @param {sap.riv.graphics.Drawable}
		 *            afterShape the existing shape on the layer inserted after
		 * @returns {sap.riv.graphics.Drawable} the concrete shape subclassing
		 *          {@link sap.riv.graphics.Drawable}
		 */
		insertShapeAfter : function(insertedShape, afterShape) {
			if (insertedShape && this._content.has(afterShape.id())) {
				var shapeId = insertedShape.id();
				this._content.insertAfter(shapeId, insertedShape, afterShape.id());
				this._rasterized = false;
				this.fireEvent('contentUpdate');
				return insertedShape;
			}
		},
		/**
		 * Insert a shape into the layer before existing shape, so it will be
		 * drawn on top of it
		 * 
		 * @name sap.riv.graphics.Layer#insertShapeBefore
		 * @function
		 * @param {String}
		 *            insertedShape the shape to be inserted
		 * @param {sap.riv.graphics.Drawable}
		 *            afterShape the existing shape on the layer inserted before
		 * @returns {sap.riv.graphics.Drawable} the concrete shape subclassing
		 *          {@link sap.riv.graphics.Drawable}
		 */
		insertShapeBefore : function(insertedShape, beforeShape) {
			if (insertedShape && this._content.has(beforeShape.id())) {
				var shapeId = insertedShape.id();
				this._content.insertBefore(shapeId, insertedShape, beforeShape.id());
				this._rasterized = false;
				this.fireEvent('contentUpdate');
				return insertedShape;
			}
		},

		/**
		 * Remove an existing shape from the layer
		 * 
		 * @name sap.riv.graphics.Layer#removeShape
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shape the shape to be removed
		 * 
		 */
		removeShape : function(shape) {
			if (shape) {
				var shapeId = shape.id();
				var removed = this._content.remove(shapeId);
				if (removed) {
					if (this._shape2clip.hasOwnProperty(shapeId)) {
						var clipId = this._shape2clip[shapeId];
						delete this._clip2shapes[clipId][shapeId];
						delete this._shape2clip[shapeId];
					}
					this._rasterized = false;
					this.fireEvent('contentUpdate');
				}
			}
		},
		/**
		 * Replace an existing shape with another shape, the replacing shape
		 * will have a different id other than the replaced shape
		 * 
		 * @name sap.riv.graphics.Layer#replaceShape
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shape the shape to be replaced
		 * @param {sap.riv.graphics.Drawable}
		 *            widthShapeType the shape to be added
		 * @return {sap.riv.graphics.Drawable} the replacing shape instance
		 */
		replaceShape : function(shape, withShape) {
			if (withShape && this._content.has(shape.id())) {
				var shapeId = withShape.id();
				this._content.replace(shape.id(), shapeId, withShape);
				if (this._shape2clip.hasOwnProperty(shape.id())) {
					var clipId = this._shape2clip[shape.id()];
					delete this._clip2shapes[clipId][shape.id()];
					this._clip2shapes[clipId][shapeId] = shapeId;
					delete this._shape2clip[shape.id()];
					this._shape2clip[shapeId] = clipId;
				}
				this._rasterized = false;
				this.fireEvent('contentUpdate');
				return withShape;
			}
		},

		/**
		 * Add clip region to the layer
		 * 
		 * @name sap.riv.graphics.Layer#addClipRegion
		 * @function
		 * @param {Object}
		 *            closedPath the clip region boundary definition
		 * @returns {String} the id of the clip region
		 * 
		 */
		addClipRegion : function(closedPath) {
			var newCr = new ClipRegion(closedPath);
			var id = newCr.id();
			this._clipRegions[id] = newCr;
			this._clip2shapes[id] = [];
			return id;
		},
		/**
		 * Assign the clip region to a shape
		 * 
		 * @name sap.riv.graphics.Layer#setClipRegion
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shape the shape to be applied clip
		 * @param {String}
		 *            clipRegionId the id of the clip region
		 * 
		 */
		setClipRegion : function(shape, clipRegionId) {
			if (this._clipRegions.hasOwnProperty(clipRegionId) && this._content.has(shape.id())) {
				if (this._shape2clip.hasOwnProperty(shape.id())) {
					var prevClipId = this._shape2clip[shape.id()];
					delete this._clip2shapes[prevClipId][shape.id()];
				}
				this._shape2clip[shape.id()] = clipRegionId;
				this._clip2shapes[clipRegionId][shape.id()] = shape.id();
				this._rasterized = false;
				this.fireEvent('contentUpdate');
			}
		},
		/**
		 * Remove the clip region from a shape
		 * 
		 * @name sap.riv.graphics.Layer#clearClipRegion
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shape the shape to clear clip setting
		 * 
		 */
		clearClipRegion : function(shape) {
			var shapeId = shape.id();
			if (this._shape2clip.hasOwnProperty(shapeId)) {
				var crid = this._shape2clip[shapeId];
				delete this._shape2clip[shapeId];
				delete this._clip2shapes[crid][shapeId];
				this._rasterized = false;
				this.fireEvent('contentUpdate');
			}
		},
		/**
		 * Remove the clip region from layer
		 * 
		 * @name sap.riv.graphics.Layer#removeClipRegion
		 * @function
		 * @param {String}
		 *            clipRegionId the id of the clip region
		 * 
		 */
		removeClipRegion : function(clipRegionId) {
			var clipRegs = this._clipRegions;
			if (clipRegs.hasOwnProperty(clipRegionId)) {
				var s2c = this._shape2clip;
				var c2s = this._clip2shapes;
				var needUpdate = false;
				for ( var i = 0, cshapes = c2s[clipRegionId], len = cshapes.length; i < len; i++) {
					delete s2c[cshapes[i]];
					needUpdate = true;
				}
				delete c2s[clipRegionId];
				delete clipRegs[clipRegionId];
				if (needUpdate) {
					this._rasterized = false;
					this.fireEvent('contentUpdate');
				}
			}
		},
		/**
		 * Clear the content of the layer
		 * 
		 * @name sap.riv.graphics.Layer#clearContent
		 * @function
		 */
		clearContent : function() {
			this._clipRegions = {};
			this._shape2clip = {};
			this._clip2shapes = {};
			this._content.purgeAll();
			this._rasterized = false;
			this.fireEvent('contentUpdate');
		},
		/**
		 * Get parent layer
		 * 
		 * @name sap.riv.graphics.Layer#superLayer
		 * @function
		 * @returns {sap.riv.graphics.Layer}
		 */
		superLayer : function() {
			return this._superLayer;
		},
		/**
		 * Get the iterator of the sublayers, you can specify the iteration
		 * order in insertion order or reversion of insertion order.
		 * 
		 * @name sap.riv.graphics.Layer#subLayersIterator
		 * @function
		 * @param {Boolean}
		 *            invert invert the iteration
		 * @returns {sap.riv.core.utils.LinkedHashMap.Iterator}
		 */
		subLayersIterator : function(invert) {
			return this._subLayers.getIterator(invert);
		},
		/**
		 * Add one layer as its sublayer
		 * 
		 * @name sap.riv.graphics.Layer#addSubLayer
		 * @function
		 * @param {sap.riv.graphics.Layer}
		 *            subLayer
		 */
		addSubLayer : function(subLayer) {
			if (subLayer) {
				if (!this._subLayers.has(subLayer.id())) {
					this._subLayers.add(subLayer.id(), subLayer);
					// TODO - add listener to propagate the
					// event
					subLayer.on({
						eventName : 'contentUpdate',
						listener : function(layer) {
							this.fireEvent('contentUpdate');
						},
						scope : this,
						optionalArgs : subLayer
					});
					subLayer._setSuperLayer(this);
					this.fireEvent('contentUpdate');
				}
			}
		},
		/**
		 * Remove self from its parent layer
		 * 
		 * @name sap.riv.graphics.Layer#removeFromSuperLayer
		 * @function
		 */
		removeFromSuperLayer : function() {
			if (this._superLayer) {
				this._superLayer._removeSubLayer(this);
				this._superLayer = undefined;
				this.fireEvent('contentUpdate');
			}
		},

		/**
		 * Replace given subLayer with another sublayer
		 * 
		 * @name sap.riv.graphics.Layer#replaceSubLayer
		 * @function
		 * @param {sap.riv.graphics.Layer}
		 *            subLayer sublayer to be replaced
		 * @param {sap.riv.graphics.Layer}
		 *            withSubLayer sublayer to replace the other
		 */
		replaceSubLayer : function(subLayer, withSubLayer) {
			if (subLayer.id() !== withSubLayer.id()) {
				this._subLayers.replace(subLayer.id(), withSubLayer.id(), withSubLayer);
				subLayer.removeAllListeners('contentUpdate');
				withSubLayer.on({
					eventName : 'contentUpdate',
					listener : function(layer) {
						this.fireEvent('contentUpdate');
					},
					scope : this,
					optionalArgs : subLayer
				});
				subLayer._setSuperLayer(undefined);
				withSubLayer._setSuperLayer(this);
				this.fireEvent('contentUpdate');
			}
		},

		/**
		 * Set a flag that indicates the current layer needs to be refresh
		 * display. This method is typically called after your finish editing
		 * the layer's content.
		 * 
		 * @name sap.riv.graphics.Layer#setNeedsDisplay
		 * @function
		 */
		setNeedsDisplay : function() {
			this._rasterized = false;
			this.fireEvent('contentUpdate');
		},

		drawContent : function(drawingContext) {
			drawingContext.save();
			drawingContext.beginPath();
			drawingContext.rect(0, 0, this._bounds.width, this._bounds.height);
			drawingContext.closePath();
			drawingContext.clip();
			// layer's content should never exceed the layer's
			// boundary
			if (this._bgColor !== undefined) {
				drawingContext.setFillStyle(this._bgColor);
				drawingContext.fillRect(0, 0, this._bounds.width, this._bounds.height);
			}
			drawingContext.translate(-this._bounds.x, -this._bounds.y);
			var itr = this._content.getIterator(), s, sid, p;
			var cr = this._clipRegions, s2c = this._shape2clip, clipId;
			while (itr.hasMore()) {
				p = itr.next();
				s = p.value;
				sid = p.key;
				if (s2c.hasOwnProperty(sid)) {
					if (this._currentClipRegion !== undefined) {
						drawingContext.restore();
					}
					clipId = s2c[sid];
					drawingContext.save();
					this._currentClipRegion = clipId;
					cr[clipId].clip(drawingContext);
				} else if (this._currentClipRegion !== undefined) {
					this._currentClipRegion = undefined;
					drawingContext.restore();
				}

				drawingContext.save();
				s.drawTo(drawingContext);
				drawingContext.restore();
			}
			if (this._currentClipRegion !== undefined) {
				this._currentClipRegion = undefined;
				drawingContext.restore();
			}
			drawingContext.restore();
			this._needsDisplay = false;
		},

		/**
		 * Test whether the given local point(point in local coordinate system)
		 * is in the given shape on the layer
		 * 
		 * @name sap.riv.graphics.Layer#shapeContainsPoint
		 * @function
		 * @param {sap.riv.graphics.Drawable}
		 *            shape the shape to be tested
		 * @param {Object}
		 *            localPoint the point to test
		 * @returns {Boolean}
		 */
		shapeContainsPoint : function(shape, localPoint) {
			if (shape && this._content.has(shape.id())) {
				return this._content.get(shape.id()).pointIn(localPoint);
			}
			return false;
		},

		/**
		 * Return the top most shape under the local point in the layer
		 * 
		 * @name sap.riv.graphics.Layer#hittedShape
		 * @function
		 * @param {Object}
		 *            localPoint the point to test
		 * @returns {sap.riv.graphics.Drawable}
		 */
		hittedShape : function(localPoint) {
			var itr = this._content.getIterator(true);
			while (itr.hasMore()) {
				if (itr.next().value.pointIn(localPoint)) {
					return itr.next().value;
				}
			}
		},
		/**
		 * Test whether the given local point(point in local coordinate system)
		 * is contained in the layer's boundary
		 * 
		 * @name sap.riv.graphics.Layer#containsPoint
		 * @function
		 * @param {Object}
		 *            localPoint the point to test
		 * @returns {Boolean}
		 */
		containsPoint : function(localPoint) {
			var bounds = this.bounds();
			return localPoint.x >= bounds.x && localPoint.x <= (bounds.x + bounds.width) && localPoint.y >= bounds.y
					&& localPoint.y <= (bounds.y + bounds.height);
		},
		/**
		 * Convert the point in super layer's coordinate system to local point
		 * 
		 * @name sap.riv.graphics.Layer#convertPointFromSuperLayer
		 * @function
		 * @param {Object}
		 *            pointInSuperLayer
		 * @returns {Object}
		 */
		convertPointFromSuperLayer : function(pointInSuperLayer) {
			var itm = this._calcMatrix.i;
			return {
				x : itm[0][0] * pointInSuperLayer.x + itm[0][1] * pointInSuperLayer.y + itm[0][2],
				y : itm[1][0] * pointInSuperLayer.x + itm[1][1] * pointInSuperLayer.y + itm[1][2]
			};
		},
		/**
		 * Convert the point in global coordinate system to local point
		 * 
		 * @name sap.riv.graphics.Layer#convertPointFromGlobal
		 * @function
		 * @param {Object}
		 *            globalPoint
		 * @returns {Object}
		 */
		convertPointFromGlobal : function(globalPoint) {
			var superLayerPath = [ this ];
			var currentLevel = this;
			var pointInProgress = globalPoint;
			while (currentLevel._superLayer) {
				superLayerPath.push(currentLevel._superLayer);
				currentLevel = currentLevel._superLayer;
			}
			while (superLayerPath.length) {
				currentLevel = superLayerPath.pop();
				pointInProgress = currentLevel.convertPointFromSuperLayer(pointInProgress);
			}
			return pointInProgress;
		},

		/**
		 * Convert the point in source layer's coordinate system to local
		 * coordinate system. Two layers should be in the one layer hierarchy.
		 * 
		 * @name sap.riv.graphics.Layer#convertPointFromLayer
		 * @function
		 * @param {POINT}
		 *            pointInSourceLayer
		 * @param {sap.riv.graphics.Layer}
		 *            sourceLayer
		 * @returns {POINT}
		 */
		convertPointFromLayer : function(pointInSourceLayer, sourceLayer) {
			return this.convertPointFromGlobal(sourceLayer.convertPointToGlobal(pointInSourceLayer));
		},
		/**
		 * Convert local point to point in super layer's coordinates system
		 * 
		 * @name sap.riv.graphics.Layer#convertPointToSuperLayer
		 * @function
		 * @param {Object}
		 *            pointInLocal
		 * @returns {Object}
		 */
		convertPointToSuperLayer : function(pointInLocal) {
			var tm = this._calcMatrix.m;
			return {
				x : tm[0][0] * pointInLocal.x + tm[0][1] * pointInLocal.y + tm[0][2],
				y : tm[1][0] * pointInLocal.x + tm[1][1] * pointInLocal.y + tm[1][2]
			};
		},

		/**
		 * Convert local point to point in global coordinates system
		 * 
		 * @name sap.riv.graphics.Layer#convertPointToGlobal
		 * @function
		 * @param {Object}
		 *            pointInLocal
		 * @returns {Object}
		 */
		convertPointToGlobal : function(pointInLocal) {
			var currentLevel = this;
			var pointInProgress = pointInLocal;
			while (currentLevel) {
				pointInProgress = currentLevel.convertPointToSuperLayer(pointInProgress);
				currentLevel = currentLevel._superLayer;
			}
			return pointInProgress;
		},
		/**
		 * Convert the point to target layer's coordinate system. Two layers
		 * should be in the one layer hierarchy.
		 * 
		 * @name sap.riv.graphics.Layer#convertPointToLayer
		 * @function
		 * @param {POINT}
		 *            pointInLocal
		 * @param {sap.riv.graphics.Layer}
		 *            targetLayer
		 * @returns {POINT}
		 */
		convertPointToLayer : function(pointInLocal, targetLayer) {
			return targetLayer.convertPointFromGlobal(this.convertPointToGlobal(pointInLocal));
		},

		/**
		 * Returns the farthest descendant layer in the hierarchy rooted at this
		 * layer, that contains the specified point.
		 * 
		 * @name sap.riv.graphics.Layer#hitTest
		 * @param {POINT}
		 *            localXY
		 * @returns {sap.riv.graphics.Layer}
		 */
		hitTest : function(localXY) {
			var pStack = [ {
				layer : this,
				pointInLocal : localXY,
				subLayerItr : this.subLayersIterator(true)
			} ];
			var levelInTest, localPoint, layer, subLayerItr;
			while (pStack.length) {
				levelInTest = pStack[pStack.length - 1];
				layer = levelInTest.layer;
				localPoint = levelInTest.pointInLocal;
				subLayerItr = levelInTest.subLayerItr;
				if (!layer.hidden()) {
					if (subLayerItr.hasMore()) {
						var subLayer = subLayerItr.next().value;
						pStack.push({
							layer : subLayer,
							pointInLocal : subLayer.convertPointFromSuperLayer(localPoint),
							subLayerItr : subLayer.subLayersIterator(true)
						});
						continue;
					} else if (layer.containsPoint(localPoint)) {
						// find the top layer which contains the
						// point and can
						// respond to event
						return layer;
					}
					pStack.pop();
				} else {
					pStack.pop();
				}
			}
		},

		_fireEvent_ : function(event) {
			this.fireEvent(event.type(), event);
			if (this._superLayer && event.shouldBubble()) {
				event._setCurrentLayer_(this._superLayer);
				this._superLayer._fireEvent_(event);
			}
		},

		_fireMouseEvent_ : function(event) {
			this.fireEvent(event.type(), event);
			if (this._superLayer && event.shouldBubble()) {
				event._setCurrentLayer_(this._superLayer);
				event._setCurrentLocalXY_(this.convertPointToSuperLayer(event.currentLocalXY()));
				this._superLayer._fireMouseEvent_(event);
			}
		},

		_fireTouchEvent_ : function(event) {
			this.fireEvent(event.type(), event);
			if (this._superLayer && event.shouldBubble()) {
				event._setCurrentLayer_(this._superLayer);
				this._superLayer._fireTouchEvent_(event);
			}
		}
	});
	return Layer;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.Canvas2DSurface',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Event',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.MouseEvent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.TouchEvent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Layer, Event, MouseEvent, TouchEvent, Math, LOG) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	var compositingTaskRunner = (function() {
		return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame
				|| window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.setTimeout;
	})();

	var compositor = function(dCtx, layer) {
		// Processing stack keep the current traversing state of each level
		var pStack = [ {
			processed : false,
			layer : layer,
			subLayerItr : layer.subLayersIterator()
		} ];
		var tStat, layer;// traverse state
		while (pStack.length) {
			tStat = pStack[pStack.length - 1];
			layer = tStat.layer;
			if (!layer.hidden()) {
				if (!tStat.processed) {
					if (layer.shouldRasterized()) {
						if (!layer._rasterized_()) {
							var cacheDCxt = layer._getBitmapCache_(true).getContext('2d');
							layer.drawContent(cacheDCxt);
							layer._rasterized_(true);
						}
						dCtx.save();
						// Process cLayer if haven't been processed yet.
						var layerPos = layer.position();
						var layerAnchorP = layer.anchorPoint();
						var layerAFTransfrom = layer.affineTransform();
						var layerBounds = layer.bounds();
						dCtx.translate(layerPos.x, layerPos.y);
						dCtx.transform(layerAFTransfrom[0][0], layerAFTransfrom[1][0], layerAFTransfrom[0][1],
								layerAFTransfrom[1][1], layerAFTransfrom[0][2], layerAFTransfrom[1][2]);
						dCtx.translate(-layerAnchorP.x * layerBounds.width, -layerAnchorP.y * layerBounds.height);
						dCtx.setAlpha(layer.opacity());
						dCtx.drawImage(layer._getBitmapCache_(), 0, 0);
					} else {
						dCtx.save();
						// Process cLayer if haven't been processed yet.
						var layerPos = layer.position();
						var layerAnchorP = layer.anchorPoint();
						var layerAFTransfrom = layer.affineTransform();
						var layerBounds = layer.bounds();
						dCtx.translate(layerPos.x, layerPos.y);
						dCtx.transform(layerAFTransfrom[0][0], layerAFTransfrom[1][0], layerAFTransfrom[0][1],
								layerAFTransfrom[1][1], layerAFTransfrom[0][2], layerAFTransfrom[1][2]);
						dCtx.translate(-layerAnchorP.x * layerBounds.width, -layerAnchorP.y * layerBounds.height);
						dCtx.setAlpha(layer.opacity());
						layer.drawContent(dCtx);
					}
					if (layer.clipToBounds()) {
						dCtx.beginPath();
						dCtx.rect(0, 0, layer.bounds().width, layer.bounds().height);
						dCtx.closePath();
						dCtx.clip();
					}
					tStat.processed = true;
				}
				if (tStat.subLayerItr.hasMore()) {
					var subLayer = tStat.subLayerItr.next().value;
					pStack.push({
						processed : false,
						layer : subLayer,
						subLayerItr : subLayer.subLayersIterator()
					});
				} else {
					dCtx.restore();
					pStack.pop();
				}
			} else {
				pStack.pop();
			}
		}
	};

	var compositingRequestList = [];

	var compositingTask = function() {
		var req, layer, drawingCtx;
		while (compositingRequestList.length) {
			req = compositingRequestList.shift();
			drawingCtx = req.drawingContext;
			layer = req.layer;
			//timer start
			//LOG.debug("layer["+layer.id()+"]rendering start.","perf");
			drawingCtx.clearRect(0, 0, layer.bounds().width, layer.bounds().height);
			compositor(drawingCtx, layer);
			//timer stop
			LOG.debug("layer["+layer.id()+"]rendering end.", "perf");
			req.onComplete();
		}
		queueRequest = queueRequestAndScheduleTask;
	};

	var queueRequestWithoutScheduleTask = function(compositingReq) {
		compositingRequestList.push(compositingReq);
	};

	var queueRequestAndScheduleTask = function(compositingReq) {
		compositingRequestList.push(compositingReq);
		compositingTaskRunner(compositingTask, 0);
		queueRequest = queueRequestWithoutScheduleTask;
	};

	var queueRequest = queueRequestAndScheduleTask;

	/**
	 * Each instance of this class is backed by a HTMLCanvasElement, and
	 * provides more easy to use graphic management and drawing capability
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface
	 * @constructor
	 * @param {Object}
	 *            options
	 * @param {HTMLCanvasElement}
	 *            options.canvasEl
	 * @param {String}
	 *            [options.bgColor] the background color of the canvas
	 */
	var Canvas2DSurface = function(options) {
		this._mainCanvasEl = options.canvasEl;
		this._drawingCtx = this._mainCanvasEl.getContext('2d');
		this._msTracking = [];
		this._touch2LayerTracking = {};
		this._layer2TouchTracking = {};
		this._rootLayer = new Layer({
		    id : "RootLayer",
			bgColor : options.bgColor,
			size : {
				w : this._mainCanvasEl.width(),
				h : this._mainCanvasEl.height()
			},
			anchor : {
				x : 0,
				y : 0
			},
			position : {
				x : 0,
				y : 0
			}
		});

		var inCompositing = false;

		var onCompositingComplete = function() {
			inCompositing = false;
		};

		var handleContentUpdate = function() {
			if (!inCompositing) {
				queueRequest({
					drawingContext : this._drawingCtx,
					layer : this._rootLayer,
					onComplete : onCompositingComplete
				});
				inCompositing = true;
			}
		};

		this._rootLayer.on({
			eventName : 'contentUpdate',
			listener : handleContentUpdate,
			scope : this
		});
		compositor(this._drawingCtx, this._rootLayer);
	};

	var cp = Canvas2DSurface.prototype;

	cp.dispatchComponentUIEvent = function(surfaceUIEvent) {
		var rootLayer = this._rootLayer;
		switch (surfaceUIEvent.type()) {
		case 'mousemove':
			var testPoint = surfaceUIEvent.targetLocalXY();
			var pageXY = surfaceUIEvent.pageXY();
			var hittedLayer = rootLayer.hitTest(testPoint);
			if (hittedLayer) {
				if (this._msTracking.length) {
					if (this._msTracking[this._msTracking.length - 1] !== hittedLayer) {
						var enteredLayers = [];
						var entered = hittedLayer;
						while (entered) {
							enteredLayers.push(entered);
							entered = entered.superLayer();
						}
						var inLayerCount = 0, checkFinished = false, minLen = Math.min(this._msTracking.length,
								enteredLayers.length);
						while (true) {
							var left = undefined;
							if (!checkFinished
									&& this._msTracking[inLayerCount] === enteredLayers[enteredLayers.length - 1
											- inLayerCount]) {
								inLayerCount++;
								checkFinished = inLayerCount === minLen;
							} else {
								while (this._msTracking.length > inLayerCount) {
									left = this._msTracking.pop();
									var mlEvt = new MouseEvent('mouseleave', left, false, testPoint, pageXY);
									mlEvt._setRelatedLayer_(hittedLayer);
									left._fireMouseEvent_(mlEvt);
								}
								while (inLayerCount < enteredLayers.length) {
									var entered = enteredLayers.shift();
									left = this._msTracking[enteredLayers.length - 1];
									this._msTracking[enteredLayers.length] = entered;
									var mlEvt = new MouseEvent('mouseenter', entered, false, testPoint, pageXY);
									mlEvt._setRelatedLayer_(left);
									entered._fireMouseEvent_(mlEvt);
								}
								break;
							}
						}
					}
				} else {
					var entered = hittedLayer;
					do {
						this._msTracking.push(entered);
						entered._fireMouseEvent_(new MouseEvent('mouseenter', entered, false, testPoint, pageXY));
						entered = entered.superLayer();
					} while (entered)
					this._msTracking.reverse();
				}
				hittedLayer._fireMouseEvent_(new MouseEvent('mousemove', hittedLayer, true, testPoint, pageXY));
			} else {
				while (this._msTracking.length) {
					var left = this._msTracking.pop();
					left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, testPoint, pageXY));
				}
			}
			break;
		case 'mouseleave':
			while (this._msTracking.length) {
				var left = this._msTracking.pop();
				left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, surfaceUIEvent.targetLocalXY(),
						surfaceUIEvent.pageXY()));
			}
			break;
		case 'mouseup':
			var testPoint = surfaceUIEvent.targetLocalXY();
			var hittedLayer = rootLayer.hitTest(testPoint);
			if (hittedLayer) {
				hittedLayer._fireMouseEvent_(new MouseEvent('mouseup', hittedLayer, true, testPoint, surfaceUIEvent
						.pageXY()));
			}
			break;
		case 'mousedown':
			var testPoint = surfaceUIEvent.targetLocalXY();
			var hittedLayer = rootLayer.hitTest(testPoint);
			if (hittedLayer) {
				hittedLayer._fireMouseEvent_(new MouseEvent('mousedown', hittedLayer, true, testPoint, surfaceUIEvent
						.pageXY()));
			}
			break;
		case 'dblclick':
			var testPoint = surfaceUIEvent.targetLocalXY();
			var hittedLayer = rootLayer.hitTest(testPoint);
			if (hittedLayer) {
				if (this._focusedLayer) {
					if (this._focusedLayer.id() !== hittedLayer.id()) {
						this._focusedLayer._fireEvent_(new Event('blur', this._focusedLayer, false));
						this._focusedLayer._fireEvent_(new Event('focusout', this._focusedLayer, true));
						this._focusedLayer = hittedLayer;
						this._focusedLayer._fireEvent_(new Event('focus', this._focusedLayer, false));
						this._focusedLayer._fireEvent_(new Event('focusin', this._focusedLayer, true));
					}
				} else {
					this._focusedLayer = hittedLayer;
					this._focusedLayer._fireEvent_(new Event('focus', this._focusedLayer, false));
					this._focusedLayer._fireEvent_(new Event('focusin', this._focusedLayer, true));
				}
				this._focusedLayer._fireMouseEvent_(new MouseEvent('dblclick', this._focusedLayer, true, testPoint,
						surfaceUIEvent.pageXY()));
			} else {
				if (this._focusedLayer) {
					this._focusedLayer._fireEvent_(new Event('blur', this._focusedLayer, false));
					this._focusedLayer._fireEvent_(new Event('focusout', this._focusedLayer, true));
					this._focusedLayer = undefined;
				}
			}
			break;
		case 'click':
			var testPoint = surfaceUIEvent.targetLocalXY();
			var hittedLayer = rootLayer.hitTest(testPoint);
			if (hittedLayer) {
				if (this._focusedLayer) {
					if (this._focusedLayer.id() !== hittedLayer.id()) {
						this._focusedLayer._fireEvent_(new Event('blur', this._focusedLayer, false));
						this._focusedLayer._fireEvent_(new Event('focusout', this._focusedLayer, true));
						this._focusedLayer = hittedLayer;
						this._focusedLayer._fireEvent_(new Event('focus', this._focusedLayer, false));
						this._focusedLayer._fireEvent_(new Event('focusin', this._focusedLayer, true));
					}
				} else {
					this._focusedLayer = hittedLayer;
					this._focusedLayer._fireEvent_(new Event('focus', this._focusedLayer, false));
					this._focusedLayer._fireEvent_(new Event('focusin', this._focusedLayer, true));
				}
				this._focusedLayer._fireMouseEvent_(new MouseEvent('click', this._focusedLayer, true, testPoint,
						surfaceUIEvent.pageXY()));
			} else {
				if (this._focusedLayer) {
					this._focusedLayer._fireEvent_(new Event('blur', this._focusedLayer, false));
					this._focusedLayer._fireEvent_(new Event('focusout', this._focusedLayer, true));
					this._focusedLayer = undefined;
				}
			}
			break;
		case 'touchstart':
			var t2l = this._touch2LayerTracking, l2t = this._layer2TouchTracking;
			// Touched Layers used to track how many layers are being touched
			var touchedLayers = {};
			// Consider touches in changedTouches list, since it contains those
			// touches that precisely lead to the triggering of the touchstart
			// event
			for ( var i = 0, touchOnComp, tT = surfaceUIEvent.changedTouches(), len = tT.length(); i < len; i++) {
				touchOnComp = tT.item(i);
				var identifier = touchOnComp.identifier();
				var testPoint = touchOnComp.localXY();
				var hittedLayer = rootLayer.hitTest(testPoint);
				if (hittedLayer) {
					var hittedLayerId = hittedLayer.id();
					// Tracking the new touch in two important structures
					t2l[identifier] = hittedLayer;
					if (!l2t.hasOwnProperty(hittedLayerId)) {
						l2t[hittedLayerId] = {
							layer : hittedLayer,
							touchIds : [ identifier ]
						};
					} else {
						l2t[hittedLayerId].touchIds.push(identifier);
					}

					if (!touchedLayers.hasOwnProperty(hittedLayerId)) {
						touchedLayers[hittedLayerId] = {
							layer : hittedLayer,
							touches : [ touchOnComp ]
						};
					} else {
						touchedLayers[hittedLayerId].touches.push(touchOnComp);
					}
				}
			}
			this._dispatchTouchEventToLayer(touchedLayers, surfaceUIEvent);
			break;
		case 'touchmove':
			var t2l = this._touch2LayerTracking;
			// Touched Layers used to track how many layers are being touched
			var touchedLayers = {};
			// Consider touches in changedTouches list, since it contains those
			// touches that precisely lead to the triggering of the touchmove
			// event
			for ( var i = 0, touchOnComp, tT = surfaceUIEvent.changedTouches(), len = tT.length(); i < len; i++) {
				touchOnComp = tT.item(i);
				var identifier = touchOnComp.identifier();
				if (t2l.hasOwnProperty(identifier)) {
					var hittedLayer = t2l[identifier];
					var hittedLayerId = hittedLayer.id();
					if (!touchedLayers.hasOwnProperty(hittedLayerId)) {
						touchedLayers[hittedLayerId] = {
							layer : hittedLayer,
							touches : [ touchOnComp ]
						};
					} else {
						touchedLayers[hittedLayerId].touches.push(touchOnComp);
					}
				}
			}
			this._dispatchTouchEventToLayer(touchedLayers, surfaceUIEvent);
			break;
		case 'touchend':
			var t2l = this._touch2LayerTracking, l2t = this._layer2TouchTracking;
			// Touched Layers used to track how many layers are being touched
			var touchedLayers = {};
			// Consider touches in changedTouches list, since it contains those
			// touches that precisely lead to the triggering of the touchend
			// event
			for ( var i = 0, touchOnComp, tT = surfaceUIEvent.changedTouches(), len = tT.length(); i < len; i++) {
				touchOnComp = tT.item(i);
				var identifier = touchOnComp.identifier();
				if (t2l.hasOwnProperty(identifier)) {
					var hittedLayer = t2l[identifier];
					var hittedLayerId = hittedLayer.id();
					if (!touchedLayers.hasOwnProperty(hittedLayerId)) {
						touchedLayers[hittedLayerId] = {
							layer : hittedLayer,
							touches : [ touchOnComp ]
						};
					} else {
						touchedLayers[hittedLayerId].touches.push(touchOnComp);
					}
					delete t2l[identifier];
					l2t[hittedLayerId].touchIds.splice(l2t[hittedLayerId].touchIds.indexOf(identifier), 1);
					if (!l2t[hittedLayerId].touchIds.length) {
						delete l2t[hittedLayerId];
					}
				}
			}
			this._dispatchTouchEventToLayer(touchedLayers, surfaceUIEvent);
			break;
		case 'touchcancel':
			var t2l = this._touch2LayerTracking, l2t = this._layer2TouchTracking;
			// Touched Layers used to track how many layers are being touched
			var touchedLayers = {};
			// Consider touches in changedTouches list, since it contains those
			// touches that precisely lead to the triggering of the touchcancel
			// event
			for ( var i = 0, touchOnComp, tT = surfaceUIEvent.changedTouches(), len = tT.length(); i < len; i++) {
				touchOnComp = tT.item(i);
				var identifier = touchOnComp.identifier();
				if (t2l.hasOwnProperty(identifier)) {
					var hittedLayer = t2l[identifier];
					var hittedLayerId = hittedLayer.id();
					if (!touchedLayers.hasOwnProperty(hittedLayerId)) {
						touchedLayers[hittedLayerId] = {
							layer : hittedLayer,
							touches : [ touchOnComp ]
						};
					} else {
						touchedLayers[hittedLayerId].touches.push(touchOnComp);
					}
					delete t2l[identifier];
					l2t[hittedLayerId].touchIds.splice(l2t[hittedLayerId].touchIds.indexOf(identifier), 1);
					if (!l2t[hittedLayerId].touchIds.length) {
						delete l2t[hittedLayerId];
					}
				}
			}
			this._dispatchTouchEventToLayer(touchedLayers, surfaceUIEvent);
			break;
		}
	};

	cp._dispatchTouchEventToLayer = function(touchedLayers, surfaceTouchEvent) {
		var t2l = this._touch2LayerTracking, l2t = this._layer2TouchTracking;
		for ( var layerId in touchedLayers) {
			// Analyze and build changedTouches of the touch start event
			var changedTouches = TouchEvent.createTouchList();
			var layer = touchedLayers[layerId].layer;
			for ( var i = 0, touchOnComp, cTs = touchedLayers[layerId].touches, len = cTs.length; i < len; i++) {
				touchOnComp = cTs[i];
				changedTouches._addTouch_(TouchEvent.createTouch(touchOnComp.identifier(), layer,
						touchOnComp.localXY(), touchOnComp.pageXY()));
			}

			// Analyze and build targetTouches of the touch start event
			var targetTouches = TouchEvent.createTouchList();
			if (l2t[layerId]) {
				var targetTouchIds = l2t[layerId].touchIds;
				for ( var i = 0, touchOnComp, allTs = surfaceTouchEvent.touches(), len = targetTouchIds.length; i < len; i++) {
					touchOnComp = allTs.identifiedTouch(targetTouchIds[i]);
					targetTouches._addTouch_(TouchEvent.createTouch(touchOnComp.identifier(), layer, touchOnComp
							.localXY(), touchOnComp.pageXY()));
				}
			}
			var touches = TouchEvent.createTouchList();
			for ( var i = 0, touchOnComp, layer, allTouches = surfaceTouchEvent.touches(), len = allTouches.length(); i < len; i++) {
				touchOnComp = allTouches.item(i);
				var identifier = touchOnComp.identifier();
				if (t2l[identifier]) {
					// Only remove the touch that don't originate from
					// current canvas2dsurface
					layer = t2l[identifier];
					touches._addTouch_(TouchEvent.createTouch(identifier, layer, touchOnComp.localXY(), touchOnComp
							.pageXY()));
				}
			}
			layer._fireTouchEvent_(new TouchEvent(surfaceTouchEvent.type(), layer, true, touches, changedTouches,
					targetTouches));
		}
	};

	/**
	 * Get and set the size of the Canvas2DSurface instance
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface#size
	 * @param {undefined|Object}
	 *            [size] the new size of the canvas
	 * @returns {this|Object}
	 */
	cp.size = function(size) {
		if (size !== undefined) {
			if (this._mainCanvasEl.width() != size.width) {
				this._mainCanvasEl.width(size.width);
				this._rootLayer.width(size.width);
			}
			if (this._mainCanvasEl.height() != size.height) {
				this._mainCanvasEl.height(size.height);
				this._rootLayer.height(size.height);
			}
			return this;
		} else {
			return {
				width : this._mainCanvasEl.width(),
				height : this._mainCanvasEl.height()
			};
		}
	};
	/**
	 * Get and set the width of the Canvas2DSurface instance
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface#width
	 * @param {undefined|Number}
	 *            [size] the new width of the canvas
	 * @returns {this|Number}
	 */
	cp.width = function(width) {
		if (width) {
			var ow = this._mainCanvasEl.width();
			if (ow != width) {
				this._mainCanvasEl.width(width);
				this._rootLayer.width(width);
			}
			return this;
		} else {
			return this._mainCanvasEl.width();
		}
	};
	/**
	 * Get and set the height of the Canvas2DSurface instance
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface#height
	 * @param {undefined|Number}
	 *            [size] the new height of the canvas
	 * @returns {this|Number}
	 */
	cp.height = function(height) {
		if (height) {
			var oh = this._mainCanvasEl.height();
			if (oh != height) {
				this._mainCanvasEl.height(height);
				this._rootLayer.height(height);
			}
			return this;
		} else {
			return this._mainCanvasEl.height();
		}
	},
	/**
	 * Get the root layer of the Canvas2DSurface instance
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface#getRootLayer
	 * @returns {sap.riv.graphics.Layer}
	 */
	cp.getRootLayer = function() {
		return this._rootLayer;
	};
	/**
	 * Get the background color of the Canvas2DSurface instance
	 * 
	 * @name sap.riv.graphics.Canvas2DSurface#backgroundColor
	 * @returns {String}
	 */
	cp.backgroundColor = function(bgColor) {
		if (bgColor) {
			this._rootLayer.backgroundColor(bgColor);
		} else {
			return this._rootLayer.backgroundColor();
		}
	};
	return Canvas2DSurface;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.ColorUtils',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math) {
    var getColorObjFromHSLA = function(h, s, l, a) {
            return colorUtils.fromHSLA(h / 360, s, l, a || 1.0);
    };
    var hue2rgb = function(p, q, t) {
        if(t < 0)
            t += 1;
        if(t > 1)
            t -= 1;
        if(t < 1 / 6)
            return p + (q - p) * 6 * t;
        if(t < 1 / 2)
            return q;
        if(t < 2 / 3)
            return p + (q - p) * (2 / 3 - t) * 6;
        return p;
    };
    var hsl2rgb = function(h, s, l) {
        var r, g, b;
        if(s == 0) {
            r = g = b = l;
            // achromatic
        } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    };
    var rgb2hsl = function(r, g, b) {r /= 255, g /= 255, b /= 255;
        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h = 0, s, l = (max + min) / 2;

        if(max == min) {
            h = s = 0;
            // achromatic
        } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return [h, s, l];
    };
    var parsePercentage = function(value) {
        return parseInt(value.substring(0, value.lastIndexOf('%'))) / 100;
    };
    var parseRGBValue = function(value) {
        if(value.lastIndexOf('%') > 0) {
            return Math.ceil(parseInt(value.substring(0, value.lastIndexOf('%'))) * 255 / 100);
        } else {
            return parseInt(value);
        }
    };
    var toHexString = function(decimal) {
        return decimal < 16 ? '0' + decimal.toString(16) : decimal.toString(16);
    };
    /**
     * Represent a color normalized from css color setting
     *
     * @name sap.riv.core.types.Color
     * @constructor
     */
    var colorUtils = {};

    /**
     * Factory method for creating a color object from valid CSS color string.
     *
     * @param cssColorString
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromCSSColor = function(cssColorString) {
        if(cssColorString.charAt(0) == '#') {
            return this.fromRGBHexString(cssColorString);
        } else if(cssColorString.substr(0, 4).toLowerCase() == 'rgba') {
            return this.fromRGBA(cssColorString);
        } else if(cssColorString.substr(0, 3).toLowerCase() == 'rgb') {
            return this.fromRGB(cssColorString);
        } else if(cssColorString.substr(0, 4).toLowerCase() == 'hsla') {
            return this.fromHSLA(cssColorString);
        } else if(cssColorString.substr(0, 3).toLowerCase() == 'hsl') {
            return this.fromHSL(cssColorString);
        }
    };
    /**
     * Factory method for creating a color object from either valid CSS rgb
     * string or seperated r,g,b components.
     *
     * @param {String|Number}
     *            rgb css rgb string or red component
     * @param {Number}
     *            [g] the green component
     * @param {Number}
     *            [b] the blue component
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromRGB = function(rgb) {
        var red = 0, green = 0, blue = 0;
        if(arguments.length == 1) {
            var comps = rgb.substring(4, rgb.lastIndexOf(')')).split(',');
            red = parseRGBValue(comps[0]);
            green = parseRGBValue(comps[1]);
            blue = parseRGBValue(comps[2]);
        } else if(arguments.length == 3) {
            red = arguments[0];
            green = arguments[1];
            blue = arguments[2];
        }
        return new colorObj(red, green, blue, 1.0);
    };
    /**
     * Factory method for creating a color object from either valid CSS rgba
     * string or seperated r,g,b,a components.
     *
     * @param {String|Number}
     *            rgb css rgb string or red component
     * @param {Number}
     *            [g] the green component
     * @param {Number}
     *            [b] the blue component
     * @param {Number}
     *            [a] the alpha component
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromRGBA = function(rgba) {
        var red = 0, green = 0, blue = 0, alpha = 0;
        if(arguments.length == 1) {
            var comps = rgba.substring(5, rgba.lastIndexOf(')')).split(',');
            red = parseRGBValue(comps[0]);
            green = parseRGBValue(comps[1]);
            blue = parseRGBValue(comps[2]);
            alpha = parseFloat(comps[3]);
        } else if(arguments.length == 4) {
            red = Math.ceil(arguments[0]);
            green = Math.ceil(arguments[1]);
            blue = Math.ceil(arguments[2]);
            alpha = Math.ceil(arguments[3]);
        }
        return new colorObj(red, green, blue, alpha);
    };
    /**
     * Factory method for creating a color object from either valid CSS
     * numbering color string.
     *
     * @param {String}
     *            hexString css color string like #FFFFFF
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromRGBHexString = function(hexString) {
        var red = 0, green = 0, blue = 0, alpha = 1.0;
        red = parseInt(hexString.substr(1, 2), 16);
        green = parseInt(hexString.substr(3, 2), 16);
        blue = parseInt(hexString.substr(5, 2), 16);
        return new colorObj(red, green, blue, alpha);
    };
    /**
     * Factory method for creating a color object from either valid CSS hsl
     * color string or hue, saturation, lightness component.
     *
     * @param {String|Number}
     *            hsl css hsl string or hue component
     * @param {Number}
     *            [s] saturation component
     * @param {Number}
     *            [l] lightness component
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromHSL = function(hsl) {
        if(arguments.length == 1) {
            var comps = hsl.substring(4, hsl.lastIndexOf(')')).split(',');
            var rgb = hsl2rgb((parseInt(comps[0]) % 360 + 360) % 360 / 360, parsePercentage(comps[1]), parsePercentage(comps[2]));
            return new colorObj(rgb[0], rgb[1], rgb[2], 1.0);
        } else if(arguments.length == 3) {
            rgb = hsl2rgb(arguments[0], arguments[1], arguments[2]);
            return new colorObj(rgb[0], rgb[1], rgb[2], 1.0);
        }
    };
    /**
     * Factory method for creating a color object from either valid CSS hsla
     * color string or hue, saturation, lightness, alpha component.
     *
     * @param {String|Number}
     *            hsl css hsl string or hue component
     * @param {Number}
     *            [s] saturation component
     * @param {Number}
     *            [l] lightness component
     * @param {Number}
     *            [a] alpha component
     * @returns {sap.riv.core.types.Color}
     */
    colorUtils.fromHSLA = function(hsla) {
        if(arguments.length == 1) {
            var comps = hsla.substring(5, hsla.lastIndexOf(')')).split(',');
            var rgb = hsl2rgb((parseInt(comps[0]) % 360 + 360) % 360 / 360, parsePercentage(comps[1]), parsePercentage(comps[2]));
            return new colorObj(rgb[0], rgb[1], rgb[2], parseFloat(comps[3]));
        } else if(arguments.length == 4) {
            rgb = hsl2rgb(arguments[0], arguments[1], arguments[2]);
            return new colorObj(rgb[0], rgb[1], rgb[2], arguments[3]);
        }
    };
    /*
     * This function is used to get a series of color according to a base color
     * @param [baseColorObj] used for base color @param [type] type of color
     * string returned. rgb, rgba, hsl or hsla @return [ColorSeries]: a
     * three-dimensional array of color string
     */
    colorUtils.getColorSeries = function(baseColorObj, type) {

        var baseHSLA = [baseColorObj.hue(), baseColorObj.saturation(), baseColorObj.lightness(), baseColorObj.alpha()]
        var ColorSeriesBaseObj = new Array();

        // decrease 15 degree on hue in circle
        ColorSeriesBaseObj[0] = getColorObjFromHSLA(360 - ((360 - baseHSLA[0]) + 15) % 360, baseHSLA[1], baseHSLA[2]);
        ColorSeriesBaseObj[1] = getColorObjFromHSLA(baseHSLA[0], baseHSLA[1], baseHSLA[2]);
        // increase 15 degree on hue in circle
        ColorSeriesBaseObj[2] = getColorObjFromHSLA((baseHSLA[0] + 15) % 360, baseHSLA[1], baseHSLA[2]);

        var ColorSeries = new Array();
        ColorSeries[0] = new Array();
        ColorSeries[1] = new Array();
        ColorSeries[2] = new Array();

        for(var i = 0; i < 3; i++) {

            for(var j = 0; j < 10; j++) {
                ColorSeries[i].unshift(getColorObjFromHSLA(ColorSeriesBaseObj[i].hue(), ColorSeriesBaseObj[i].saturation(), j / 10).toColorString(type));
            }
            for(var j = 1; j <= 4; j++) {
                // decrease 20 degree on hue every time in circle
                var newHue = (360 - ((360 - ColorSeriesBaseObj[i].hue()) + (20 * j)) % 360);
                ColorSeries[i].unshift(getColorObjFromHSLA(newHue, ColorSeriesBaseObj[i].saturation(), 0.9).toColorString(type));
            }
        }
        return ColorSeries;
    };

    colorUtils.changeOpacity = function(cssColor, opacity) {
        var color = colorUtils.fromCSSColor(cssColor);
        color.alpha(opacity);
        return color.toColorString('rgba');
    };
    /*
     * get colorSeries from css color
     */
    colorUtils.getColorSeriesFromCSS = function(cssColor) {

        var baseColorObj = colorUtils.fromCSSColor(cssColor);

        var colorSeries = this.getColorSeries(baseColorObj, "rgba")

        return colorSeries;
    };
    colorUtils.getColorSeriesForBar = function(cssColor, type) {
        type = type || "rgba";

        var baseColorObj = colorUtils.fromCSSColor(cssColor);
        var colorSeries = [];

        if(baseColorObj.lightness() <= 0.75) {
            colorSeries[0] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() + 0.25), baseColorObj.alpha()).toColorString(type);
            colorSeries[1] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() + 0.15), baseColorObj.alpha()).toColorString(type);
            colorSeries[2] = baseColorObj.toColorString(type);
            colorSeries[3] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() - 0.1) > 0 ? (baseColorObj.lightness() - 0.1) : 0, baseColorObj.alpha()).toColorString(type);
        } else {
            colorSeries[0] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() + 0.1) > 1 ? 1.0 : (baseColorObj.lightness() + 0.1), baseColorObj.alpha()).toColorString(type);
            colorSeries[1] = baseColorObj.toColorString(type);
            colorSeries[2] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() - 0.15), baseColorObj.alpha()).toColorString(type);
            colorSeries[3] = getColorObjFromHSLA(baseColorObj.hue(), baseColorObj.saturation(), (baseColorObj.lightness() - 0.25), baseColorObj.alpha()).toColorString(type);
        }
        return colorSeries;
    }
    var colorObj = function(r, g, b, a) {
        this._r = r;
        this._g = g;
        this._b = b;
        this._hsl = rgb2hsl(r, g, b);
        this._a = a;
    };
    /**
     * Get the hue component of this color object
     *
     * @name sap.riv.core.types.Color#hue
     * @function
     * @returns {Number} hue in degree
     */
    colorObj.prototype.hue = function() {
        return this._hsl[0] * 360;
    };
    /**
     * Get the saturation component of this color object
     *
     * @name sap.riv.core.types.Color#saturation
     * @function
     * @returns {Number} saturation between [0, 1]
     */
    colorObj.prototype.saturation = function() {
        return this._hsl[1];
    };
    /**
     * Get the lightness component of this color object
     *
     * @name sap.riv.core.types.Color#lightness
     * @function
     * @returns {Number} lightness between [0, 1]
     */
    colorObj.prototype.lightness = function() {
        return this._hsl[2];
    };
    /**
     * Get the red component of this color object
     *
     * @name sap.riv.core.types.Color#red
     * @function
     * @returns {Number} red between[0,255]
     */
    colorObj.prototype.red = function(red) {
        if(TypeUtils.isNumber(red)) {
            if(0 <= red && red <= 255) {
                this._red = red;
                this._hsl = rgb2hsl(this._r, this._g, this._b);
            }
            return this;
        }
        return this._r;
    };
    /**
     * Get or set the red component of this color object
     *
     * @name sap.riv.core.types.Color#green
     * @function
     * @returns {Number|this} green between[0,255]
     */
    colorObj.prototype.green = function(green) {
        if(TypeUtils.isNumber(green)) {
            if(0 <= green && green <= 255) {
                this._g = green;
                this._hsl = rgb2hsl(this._r, this._g, this._b);
            }
            return this;
        }
        return this._g;
    };
    /**
     * Get or set the blue component of this color object
     *
     * @name sap.riv.core.types.Color#blue
     * @function
     * @returns {Number} blue between[0,255]
     */
    colorObj.prototype.blue = function(blue) {
        if(TypeUtils.isNumber(blue)) {
            if(0 <= blue && blue <= 255) {
                this._b = blue;
                this._hsl = rgb2hsl(this._r, this._g, this._b);
            }
            return this;
        }
        return this._b;
    };
    /**
     * Get or set the alpha component of this color object
     *
     * @name sap.riv.core.types.Color#alpha
     * @function
     * @returns {Number|this} alpha between[0,1]
     */
    colorObj.prototype.alpha = function(alpha) {
        if(TypeUtils.isNumber(alpha)) {
            if(0 <= alpha && alpha <= 1) {
                this._a = alpha;
            }
            return this;
        }
        return this._a;
    };
    /**
     * Return the css color string representation of this color object
     *
     * @name sap.riv.core.types.Color#toColorString
     * @function
     * @param {String}
     *            [type] valid values are 'rgb','rgba','hsl','hsla'.
     * @returns {String}
     */
    colorObj.prototype.toColorString = function(type) {
        switch (type) {
            case 'rgb':
                return 'rgb(' + this._r + ',' + this._g + ',' + this._b + ')';
            case 'rgba':
                return 'rgba(' + this._r + ',' + this._g + ',' + this._b + ',' + (this._a || 1.0) + ')';
            case 'hsl':
                var hsl = rgb2hsl(this._r, this._g, this._b);
                return 'hsl(' + hsl[0] * 360 + ',' + hsl[1] * 100 + '%,' + hsl[2] * 100 + '%)';
            case 'hsla':
                var hsl = rgb2hsl(this._r, this._g, this._b);
                return 'hsla(' + hsl[0] * 360 + ',' + hsl[1] * 100 * 100 + '%,' + hsl[2] * 100 * 100 + '%,' + (this._a || 1.0) + ')';
            default:
                return '#' + toHexString(this._r) + toHexString(this._g) + toHexString(this._b);
        }
    };
    return colorUtils;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.FillableShape',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.ClosedShape',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, CanvasHelper, ClosedShape) {
	/**
	 * This class defines closed fillable shape which allows to fill the
	 * interior with color or gradient
	 * 
	 * @name sap.riv.graphics.shape.FillableShape
	 * @class
	 * @augments sap.riv.graphics.shape.ClosedShape
	 */
	var FillableShape = ObjectUtils.derive(ClosedShape, {
		constructor : function() {
			this._fill = undefined;
		},
		/**
		 * Get or set the filling color of the closed shape, the color setting
		 * should be CSSColor serialized string or as follow to define gradient
		 * 
		 * Linear Gradient:
		 * 
		 * <pre>
		 * {
		 *      t: 'lg', //line gradient
		 *      s: { x:## , y:## }, //the start position of the gradient
		 *      e: { x:## , y:## }, //the end position of the gradient
		 *      st: [
		 *              {
		 *                  o: //the stop offset
		 *                  v: //the stop color
		 *              },...
		 *          ] //the color stops of the gradient
		 * }
		 * </pre>
		 * 
		 * Radial Gradient:
		 * 
		 * <pre>
		 * {
		 *      t: 'rg', //radial gradient
		 *      s: { c : { x:## , y:## }, r : ## }, //the start position of the radial gradient, c stands for center of the circle, r stands for radius of the circle
		 *      e: { c : { x:## , y:## }, r : ## }, //the end position of the radial gradient, c stands for center of the circle, r stands for radius of the circle
		 *      st: [
		 *              {
		 *                  o: //the stop offset
		 *                  v: //the stop color
		 *              },...
		 *          ] //the color stops of the gradient
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.graphics.shape.FillableShape#fillingColor
		 * @function
		 * @param {CSSColor|Object}
		 *            color the filling color
		 * @returns {this|CSSColor|CanvasGradient}
		 */
		fillingColor : function(color) {
			if (color !== undefined) {
				if (color !== false) {
					this._fill = CanvasHelper.createColorStyle(color);
				} else {
					this._fill = undefined;
				}
				return this;
			}
			if (this._fill) {
				return this._fill;
			}
		},

		/**
		 * Filling the shape with color style, this method should be called
		 * inside of doDraw method.
		 * 
		 * @name sap.riv.graphics.shape.FillableShape#fillShape
		 * @function
		 * @param drawingContext
		 */
		fillShape : function(drawingContext) {
			if (this._fill) {
				drawingContext.save();
				drawingContext.setFillStyle(this._fill);
				drawingContext.fill();
				drawingContext.restore();
			}
		}
	});
	return FillableShape;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Observable) {
	var ThemeManager = new (ObjUtils.derive(Observable,
	/**
	 * A global theme manager
	 * 
	 * @lends sap.riv.vizkit.ThemeManager
	 */
	{
		events : [ 'defaultThemeChanged', 'themeSettingChanged' ],
		/**
		 * @constructs
		 * 
		 */
		constructor : function(options) {
			this._themeReg = {};
		},
		/**
		 * Get or set the global default theme
		 * 
		 * @name sap.riv.vizkit.ThemeManager#defaultTheme
		 * @function
		 * @param {String}
		 *            [theme] the name of the default theme.
		 * @return {String} the name of the current default theme
		 */
		defaultTheme : function(theme) {
			if (theme !== undefined) {
				if (this._defaultTheme !== theme && this.hasThemeInstalled(theme)) {
					var old = this._defaultTheme;
					this._defaultTheme = theme;
					this.fireEvent('defaultThemeChanged', old, theme);
				}
				return this;
			}
			return this._defaultTheme;
		},
		/**
		 * Check whether the theme has already been installed.
		 * 
		 * @name sap.riv.vizkit.ThemeManager#hasThemeInstalled
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @return {Boolean}
		 */
		hasThemeInstalled : function(theme) {
			return this._themeReg.hasOwnProperty(theme);
		},
		/**
		 * Install a new theme, if it's been already installed, nothing happens.
		 * 
		 * @name sap.riv.vizkit.ThemeManager#installTheme
		 * @function
		 * @param {String}
		 *            name the name of the new theme
		 * @param {Object}
		 *            settings the settings of the theme
		 */
		installTheme : function(name, settings) {
			if (!this._themeReg.hasOwnProperty(name)) {
				this._themeReg[name] = ObjUtils.extend({}, settings);
			}
		},
		/**
		 * Get the settings of given theme.
		 * 
		 * @name sap.riv.vizkit.ThemeManager#getThemeSettings
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @return {Object} the settings of the theme
		 */
		getThemeSettings : function(theme) {
			if (this._themeReg.hasOwnProperty(theme)) {
				return ObjUtils.extend({}, this._themeReg[theme]);
			}
		},
		/**
		 * Update a value of a given theme's property, will fire
		 * <b>themeSettingChanged</b> event if succeed.
		 * 
		 * @name sap.riv.vizkit.ThemeManager#updateThemeSetting
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @param {String}
		 *            key the key whose value to be updated.
		 * @param {String}
		 *            value the new value of the key
		 */
		updateThemeSetting : function(theme, key, value) {
			if (this._themeReg.hasOwnProperty(theme)) {
				var old = this._themeReg[theme][key];
				this._themeReg[theme][key] = value;
				this.fireEvent('themeSettingChanged', theme, key, old, value);
			}
		}
	}))();
	return ThemeManager;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Sector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.FillableShape',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, FillableShape, Math) {

	var preCalc = function(radius, startAngle, endAngle) {
		var sv = {
			x : radius * Math.cos(startAngle),
			y : radius * Math.sin(startAngle),
			z : 0
		}, ev = {
			x : radius * Math.cos(endAngle),
			y : radius * Math.sin(endAngle),
			z : 0
		};

		return {
			sr : radius * radius,
			sv : sv,
			ev : ev,
			z_of_sv_cross_ev : sv.x * ev.y - sv.y * ev.x
		};
	};

	/**
	 * This class defines Sector
	 * 
	 * @name sap.riv.graphics.shape.Sector
	 * @class
	 * @augments sap.riv.graphics.shape.FillableShape
	 */
	var Sector = ObjectUtils
			.derive(
					FillableShape,
					{
						constructor : function() {
							this._center = {
								x : 0,
								y : 0
							};
							this._radius = 0;
							this._startAngle = 0;
							this._endAngle = 0;
							this._clockwise = false;
						},

						/**
						 * Get or set center of the sector. The default is
						 * {0,0}.
						 * 
						 * @name sap.riv.graphics.shape.Sector#center
						 * @function
						 * @param {POINT}
						 *            center the x,y coordinates of the center
						 * @returns {this|POINT}
						 */
						center : function(center) {
							if (center !== undefined) {
								this._center.x = center.x;
								this._center.y = center.y;
								return this;
							}
							if (this._center) {
								return {
									x : this._center.x,
									y : this._center.y
								};
							}
						},
						/**
						 * Get or set radius of the sector. The default is 0.
						 * 
						 * @name sap.riv.graphics.shape.Sector#radius
						 * @function
						 * @param {Number}
						 *            radius the radius of the sector
						 * @returns {this|Number}
						 */
						radius : function(radius) {
							if (radius !== undefined) {
								if (radius > 0) {
									this._radius = radius;
									this._preCalcs = preCalc(this._radius, this._startAngle, this._endAngle);
								}
								return this;
							}
							return this._radius;
						},
						/**
						 * Get or set start angle of of the sector. The default
						 * is 0.
						 * 
						 * @name sap.riv.graphics.shape.Sector#startAngle
						 * @function
						 * @param {Number}
						 *            startAngle the start angle of the sector
						 * @returns {this|Number}
						 */
						startAngle : function(startAngle) {
							if (startAngle !== undefined) {
								this._startAngle = startAngle;
								this._preCalcs = preCalc(this._radius, this._startAngle, this._endAngle);
								return this;
							}
							return this._startAngle;
						},
						/**
						 * Get or set end angle of the sector. The default is 0.
						 * 
						 * @name sap.riv.graphics.shape.Sector#endAngle
						 * @function
						 * @param {Number}
						 *            endAngle the end angle of the sector
						 * @returns {this|Number}
						 */
						endAngle : function(endAngle) {
							if (endAngle !== undefined) {
								this._endAngle = endAngle;
								this._preCalcs = preCalc(this._radius, this._startAngle, this._endAngle);
								return this;
							}
							return this._endAngle;
						},
						/**
						 * Get or set clockwise of the sector. The default is
						 * false.
						 * 
						 * @name sap.riv.graphics.shape.Sector#clockwise
						 * @function
						 * @param {Boolean}
						 *            clockwise the clockwise of the sector
						 * @returns {this|Boolean}
						 */
						clockwise : function(clockwise) {
							if (clockwise !== undefined) {
								this._clockwise = clockwise;
								return this;
							}
							return this._clockwise;
						},

						doDraw : function(drawingContext) {
							var dCtx = drawingContext;
							var c = this._center;
							dCtx.beginPath();
							dCtx.moveTo(c.x, c.y);
							dCtx.arc(c.x, c.y, this._radius, this._startAngle, this._endAngle, !this._clockwise);
							dCtx.closePath();
							this.fillShape(dCtx);
							this.drawBorder(dCtx);
						},

						doPointInTest : function(point) {
							var sv = this._preCalcs.sv, ev = this._preCalcs.ev, sr = this._preCalcs.sr, z_of_sv_cross_ev = this._preCalcs.z_of_sv_cross_ev;
							var tv = {
								x : point.x - this._center.x,
								y : point.y - this._center.y,
								z : 0
							};
							var z_of_sv_cross_tv = sv.x * tv.y - sv.y * tv.x, z_of_tv_cross_ev = tv.x * ev.y - tv.y
									* ev.x;

							return (tv.x * tv.x + tv.y * tv.y) <= sr
									&& (this._clockwise ? (z_of_sv_cross_ev > 0 ? (z_of_sv_cross_tv > 0 && z_of_tv_cross_ev > 0)
											: !(z_of_sv_cross_tv < 0 && z_of_tv_cross_ev < 0))
											: (z_of_sv_cross_ev < 0 ? (z_of_sv_cross_tv < 0 && z_of_tv_cross_ev < 0)
													: !(z_of_sv_cross_tv > 0 && z_of_tv_cross_ev > 0)));
						}
					});
	return Sector;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
}
],
function Setup(TypeUtils) {
	var series = function(options) {

		this._xAxis = null;
		this._yAxis = null;
		this._data = [];
		this._seriesColor = '#000000';
		this._barMarkerSize = series.DEFAULTBARMARKERSIZE;
		this._lineMarkerSize = series.DEFAULTLINEMARKERSIZE;
		this._lineSize = series.DEFAULTLINESIZE;
		this._name = null;
		this._markerSymbol = series.CIRCLEMARKER;
		this._visible = true;
		this._parseOptions(options);
	};

	series.DEFAULTBARMARKERSIZE = undefined;// 17;
	series.DEFAULTLINEMARKERSIZE = 10;
	series.DEFAULTLINESIZE = 1;
	series.CIRCLEMARKER = 'circle';
	series.TRIANGLEMARKER = 'triangle';
	series.DIAMONDMARKER = 'diamond';
	series.PENTAGONMARKER = 'pentagon';

	/**
	 * 
	 * @param options{
	 *            color: '', markerSize: ''
	 *            markerSymbol:sap.riv.viz.shared.series.Series.CIRCLEMARKER }
	 */
	series.prototype._parseOptions = function(options) {
		if (TypeUtils.isExist(options.fillColor)) {
			this._seriesColor = options.fillColor;
		}

		if (TypeUtils.isExist(options.barMarkerSize)
				&& options.barMarkerSize > 0) {
			this._barMarkerSize = options.barMarkerSize;
		}

		if (TypeUtils.isExist(options.lineMarkerSize)
				&& options.lineMarkerSize > 0) {
			this._lineMarkerSize = options.lineMarkerSize;
		}

		if (TypeUtils.isExist(options.lineThickness)) {
			this._lineSize = options.lineThickness;
		}

		if (TypeUtils.isExist(options.lineColor)) {
			this._lineColor = options.lineColor;
		}

		if (TypeUtils.isExist(options.markerSymbol)) {
			var markerSymbol = options.markerSymbol;
			if (markerSymbol === series.CIRCLEMARKER
					|| markerSymbol === series.TRIANGLEMARKER
					|| markerSymbol === series.DIAMONDMARKER
					|| markerSymbol === series.PENTAGONMARKER) {
				this._markerSymbol = markerSymbol;
			}
		}

		if ( TypeUtils.isExist(options.visible) ) {
			this._visible = options.visible;
		}
	};

	series.prototype.isVisible = function() {
		return this._visible;
	};

	series.prototype.setVisible = function(visible) {
		this._visible = visible;
	};

	/**
	 * 
	 * @param data
	 *            Array
	 */
	series.prototype.setData = function(data) {
		this._data = data;
	};

	/**
	 * 
	 * @returns data Array
	 */
	series.prototype.getData = function() {
		return this._data;
	};

	/**
	 * 
	 * @param xAxis
	 *            sap.riv.viz.shared.axis.BasicAxisRenderer
	 */
	series.prototype.setXAxis = function(xAxis) {
		this._xAxis = xAxis;
	};

	/**
	 * 
	 * @param yAxis
	 *            sap.riv.viz.shared.axis.BasicAxisRenderer
	 */
	series.prototype.setYAxis = function(yAxis) {
		this._yAxis = yAxis;
	};

	/**
	 * 
	 * @returns xAxis sap.riv.viz.shared.axis.BasicAxisRenderer
	 */
	series.prototype.getXAxis = function() {
		return this._xAxis;
	};

	/**
	 * 
	 * @returns yAxis sap.riv.viz.shared.axis.BasicAxisRenderer
	 */
	series.prototype.getYAxis = function() {
		return this._yAxis;
	};

	/**
	 * 
	 * @param properties
	 *            Object
	 */
	series.prototype.updateProperties = function(properties) {
		if (TypeUtils.isExist(properties)) {
			this._parseOptions(properties);
			return this;
		}
	};

	/**
	 * @param name
	 */
	series.prototype.setName = function(name) {
		this._name = name;
	};

	/**
	 * @returns series name
	 */
	series.prototype.getName = function() {
		return this._name;
	};

	series.prototype.getDataRange = function() {
		var range = {
			max : Number.NEGATIVE_INFINITY,
			min : Number.POSITIVE_INFINITY
		};

		for ( var i = 0, len = this._data.length; i < len; i++) {
			if (this._data[i].value < range.min) {
				range.min = this._data[i].value;
			}
			if (this._data[i].value > range.max) {
				range.max = this._data[i].value;
			}
		}
		return range;
	};
	
	return series;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.multilayout.ColumnMultiLayout',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math) {
	var basicLayout = function(size, initProps) {
		this._size = {
			width : size.width,
			height : size.height
		};
		this._layoutChanged = false;
		this._itemLength = 0;
		this._columnLength = 2;
		this._layoutInfo = null;
		this._parseOptions(initProps);
	};

	basicLayout.prototype._parseOptions = function(options) {
		if (TypeUtils.isExist(options.itemLength)) {
			this._itemLength = options.itemLength;
		}
		if (TypeUtils.isExist(options.columnLength)) {
			this._columnLength = options.columnLength > 0 ? options.columnLength : 2;
		}
		// TODO actually we didn't check whether we have changed
		this._layoutChanged = true;
	};

	basicLayout.prototype.layoutChanged = function() {
		return this._layoutChanged;
	};

	basicLayout.prototype.updateSize = function(nsize) {
		if (this._size.width != nsize.width
				|| this._size.height != nsize.height) {
			this._size.width = nsize.width;
			this._size.height = nsize.height;
			this._layoutChanged = true;
		}
	};

	basicLayout.prototype.updateSettings = function(props) {
		this._parseOptions(props);
	};

	/**
	 * return layout info array, each indicate the sub item's size and position:
	 * [{x:,y:,width:,height:}]
	 * 
	 */
	basicLayout.prototype.getLayoutInfo = function() {
		if (this._layoutInfo != null && !this._layoutChanged) {
			return this._layoutInfo;
		} else {
			// calculate a new layoutInfo
			this._layoutInfo = [];
			var li = this._layoutInfo;

			if (this._itemLength > 0) {
				var numColumns = this._columnLength;
				var numRows = Math.ceil(this._itemLength / numColumns);
				// [jyang 3/16/2012]crisp line needs each layer be positioned at
				// an integer position
				var itemWidth = Math.floor(this._size.width / numColumns);
				var itemHeight = Math.floor(this._size.height / numRows);
				for ( var i = 0; i < numRows; i++) {
					for ( var j = 0; j < numColumns; j++) {
						li.push({
							x : j * itemWidth,
							y : i * itemHeight,
							width : itemWidth,
							height : itemHeight
						});
					}
				}
			}
			this._layoutChanged = false;
			return this._layoutInfo;
		}
	};

	return basicLayout;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Circle',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.FillableShape',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, FillableShape, Math) {
	/**
	 * This class defines Circle
	 * 
	 * @name sap.riv.graphics.shape.Circle
	 * @class
	 * @augments sap.riv.graphics.shape.FillableShape
	 */
	var Circle = ObjectUtils.derive(FillableShape, {
		constructor : function() {
			this._center = {
				x : 0,
				y : 0
			};
			this._radius = 0;
		},
		/**
		 * Get or set center of the sector The default is {0,0}.
		 * 
		 * @name sap.riv.graphics.Circle#center
		 * @function
		 * @param {POINT}
		 *            center the x,y coordinates of the center
		 * @returns {this|POINT}
		 */
		center : function(center) {
			if (center !== undefined) {
				this._center.x = center.x;
				this._center.y = center.y;
				return this;
			}
			if (this._center) {
				return {
					x : this._center.x,
					y : this._center.y
				};
			}
		},
		/**
		 * Get or set radius of the circle. The default is 0.
		 * 
		 * @name sap.riv.graphics.Circle#radius
		 * @function
		 * @param {Number}
		 *            radius the radius of the circle
		 * @returns {this|Number}
		 */
		radius : function(radius) {
			if (radius !== undefined) {
				if (radius > 0) {
					this._radius = radius;
				}
				return this;
			}
			return this._radius;
		},

		doDraw : function(drawingContext) {
			var dCtx = drawingContext;
			var c = this._center;
			dCtx.beginPath();
			dCtx.arc(c.x, c.y, this._radius, 0, 2 * Math.PI, false);
			dCtx.closePath();
			this.fillShape(dCtx);
			this.drawBorder(dCtx);
		},

		doPointInTest : function(point) {
			var c = this._center;
			var x = point.x - c.x;
			var y = point.y - c.y;
			return (x * x + y * y) <= this._radius * this._radius;
		}
	});
	return Circle;
});sap.riv.module(
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ColorUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TransformHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ColorUtils, FuncUtils, TypeUtils, LinkedHashMap, TransformHelper, Math) {
	var id = 0;
	var taskId = function() {
		return 'anim-' + id++;
	};
	var bezierCurveTiming = function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
		var ax = 0, bx = 0, cx = 0, ay = 0, by = 0, cy = 0;
		// `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
		var sampleCurveX = function(t) {
			return ((ax * t + bx) * t + cx) * t;
		};
		var sampleCurveY = function(t) {
			return ((ay * t + by) * t + cy) * t;
		};
		var sampleCurveDerivativeX = function(t) {
			return (3.0 * ax * t + 2.0 * bx) * t + cx;
		};
		// The epsilon value to pass given that the animation is going to run
		// over |dur| seconds. The longer the
		// animation, the more precision is needed in the timing function result
		// to avoid ugly discontinuities.
		var solveEpsilon = function(duration) {
			return 1.0 / (200.0 * duration);
		};
		var solve = function(x, epsilon) {
			return sampleCurveY(solveCurveX(x, epsilon));
		};
		// Given an x value, find a parametric value it came from.
		var solveCurveX = function(x, epsilon) {
			var t0, t1, t2, x2, d2, i;
			function fabs(n) {
				if (n >= 0) {
					return n;
				} else {
					return 0 - n;
				}
			}
			;
			// First try a few iterations of Newton's method -- normally very
			// fast.
			for (t2 = x, i = 0; i < 8; i++) {
				x2 = sampleCurveX(t2) - x;
				if (fabs(x2) < epsilon) {
					return t2;
				}
				d2 = sampleCurveDerivativeX(t2);
				if (fabs(d2) < 1e-6) {
					break;
				}
				t2 = t2 - x2 / d2;
			}
			// Fall back to the bisection method for reliability.
			t0 = 0.0;
			t1 = 1.0;
			t2 = x;
			if (t2 < t0) {
				return t0;
			}
			if (t2 > t1) {
				return t1;
			}
			while (t0 < t1) {
				x2 = sampleCurveX(t2);
				if (fabs(x2 - x) < epsilon) {
					return t2;
				}
				if (x > x2) {
					t0 = t2;
				} else {
					t1 = t2;
				}
				t2 = (t1 - t0) * 0.5 + t0;
			}
			return t2; // Failure.
		};
		// Calculate the polynomial coefficients, implicit first and last
		// control points are (0,0) and (1,1).
		cx = 3.0 * p1x;
		bx = 3.0 * (p2x - p1x) - cx;
		ax = 1.0 - cx - bx;
		cy = 3.0 * p1y;
		by = 3.0 * (p2y - p1y) - cy;
		ay = 1.0 - cy - by;
		// Convert from input time to parametric value in curve, then from that
		// to output time.
		return solve(t, solveEpsilon(duration));
	};

	var TimingFunctionFactory = (function() {
		var makeCustomTimingFunction = function(cp1x, cp1y, cp2x, cp2y) {
			return function(x) {
				return bezierCurveTiming(x, cp1x, cp1y, cp2x, cp2y, 100);
			};
		};
		var easings = {
			Linear : function(x) {
				return x;
			},
			EaseIn : function(x) {
				return bezierCurveTiming(x, 0.42, 0.0, 1.0, 1.0, 100);
			},
			EaseOut : function(x) {
				return bezierCurveTiming(x, 0.0, 0.0, 0.58, 1.0, 100);
			},
			EaseInEaseOut : function(x) {
				return bezierCurveTiming(x, 0.42, 0.0, 0.58, 1.0, 100);
			}
		};
		return {
			getTimingFunction : function(type) {
				if (easings.hasOwnProperty(type)) {
					return easings[type];
				} else if (TypeUtils.isArray(type) && type.length == 2) {
					return makeCustomTimingFunction(type[0].x, type[0].y, type[1].x, type[1].y);
				}
			}
		};
	})();

	var FloatLinearInterpolator = function(source, dest, easingFunc) {
		this._source = source;
		this._dest = dest;
		this._range = this._dest - this._source;
		this._easingFunc = easingFunc;
	};
	FloatLinearInterpolator.prototype.interpolateAt = function(pos) {
		return this._source + this._easingFunc(pos) * this._range;
	};
	var ColorLinearInterpolator = function(source, dest, _easingFunc) {
		// TODO consider the difference between interpolations of RGB & HSL
		this._source = ColorUtils.fromCSSColor(source);
		this._dest = ColorUtils.fromCSSColor(dest);
		this._redRange = this._dest.red() - this._source.red();
		this._greenRange = this._dest.green() - this._source.green();
		this._blueRange = this._dest.blue() - this._source.blue();
		this._alphaRange = this._dest.alpha() - this._source.alpha();
		this._easingFunc = _easingFunc;
	};
	ColorLinearInterpolator.prototype.interpolateAt = function(pos) {
		var factor = this._easingFunc(pos);
		var sr = this._source.red(), sg = this._source.green(), sb = this._source.blue(), sa = this._source.alpha();
		return ColorUtils.fromRGBA(sr + this._redRange * factor, sg + this._greenRange * factor, sb
				+ this._blueRange * factor, sa + this._alphaRange * factor);
	};
	var PointLinearInterpolator = function(source, dest, easingFunc) {
		this._source = source;
		this._dest = dest;
		this._range = [ dest[0] - source[0], dest[1] - source[1] ];
		this._easingFunc = easingFunc;
	};
	PointLinearInterpolator.prototype.interpolateAt = function(pos) {
		var factor = this._easingFunc(pos);
		return [ this._source[0] + this._range[0] * factor, this._source[1] + this._range[1] * factor ];
	};
	var RectLinearInterpolator = function(source, dest, easingFunc) {
		this._source = source;
		this._dest = dest;
		this._range = {
			x : dest.x - source.x,
			y : dest.y - source.y,
			w : dest.w - source.w,
			h : dest.h - source.h
		};
		this._easingFunc = easingFunc;
	};
	RectLinearInterpolator.prototype.interpolateAt = function(pos) {
		var factor = this._easingFunc(pos);
		return {
			x : this._source.x + this._range.x * factor,
			y : this._source.x + this._range.y * factor,
			w : this._source.x + this._range.w * factor,
			h : this._source.x + this._range.h * factor
		};
	};

	var TransformLinearInterpolator = function(source, dest, easingFunc) {
		this._source = TransformHelper.unmatrix(source);
		this._dest = TransformHelper.unmatrix(dest);
		this._range = {
			tx : this._dest.tx - this._source.tx,
			ty : this._dest.ty - this._source.ty,
			sx : this._dest.sx - this._dest.sx,
			sy : this._dest.sy - this._dest.sy,
			skew : this._dest.skew - this._source.skew,
			rotate : this._dest.rotate - this._source.rotate
		};
		this._easingFunc = easingFunc;
	};

	TransformLinearInterpolator.prototype.interpolateAt = function(pos) {
		var tmHelper = TransformHelper;
		var factor = this._easingFunc(pos);
		var tx = this._source.tx + this._range.tx * factor;
		var ty = this._source.ty + this._range.ty * factor;
		var sx = this._source.sx + this._range.sx * factor;
		var sy = this._source.sy + this._range.sy * factor;
		var skew = this._source.skew + this._source.skew * factor;
		var rotate = this._source.rotate + this._source.rotate * factor;
		return tmHelper.makeScaleTM(sx, sy, tmHelper.makeSkewTM(skew, skew, tmHelper.makeRotateTM(rotate, tmHelper
				.makeTranslateTM(tx, ty))));

	};

	var InterpolatorFactory = {
		getInterpolator : function(type, source, dest, easing) {
			switch (type) {
			case 'POINT':
				return new PointLinearInterpolator(source, dest, easing);
			case 'RECT':
				return new RectLinearInterpolator(source, dest, easing);
			case 'FLOAT':
				return new FloatLinearInterpolator(source, dest, easing);
			case 'COLOR':
				return new ColorLinearInterpolator(source, dest, easing);
			case 'TRANSFORM':
				throw new TransformLinearInterpolator(source, dest, easing);
			default:
				throw new Error('Unknown type for interpolation');
			}
		}
	};

	var JobState = {
		submitted : 0,
		running : 1,
		stopped : 2,
		paused : 3,
		cancelled : 4,
		aborted : 5
	};

	var AnimationJob = function(values, startWhen, endWhen, onStep, onComplete) {
		this._id = taskId();
		this._state = JobState.submitted;
		this._values = values;
		this._startWhen = startWhen;
		this._pauseWhen = 0;
		this._resumeWhen = 0;
		this._endWhen = endWhen;
		this._duration = endWhen - startWhen;
		this._onStep = onStep;
		this._onComplete = onComplete;
	};

	/**
	 * Singleton object for animating value(s) during a period of time
	 * 
	 * @name sap.riv.core.Animator
	 * @class
	 */
	var Animator = (function() {
		var _jobQueue = new LinkedHashMap();
		var _fps = 50;
		var _interval = 20;
		var _timer = false;
		var _processAnimStep = function(animJob, animTimePassed) {
			var interpolatePos = animTimePassed / animJob._duration;
			var stepValues = [];
			for ( var i = 0, value, values = animJob._values, len = values.length; i < len; i++) {
				value = values[i];
				stepValues.push(value.interpolator.interpolateAt(interpolatePos));
			}
			animJob._onStep(stepValues);
		};
		var _processingTask = function(animJob, nextState, currentTime) {
			switch (animJob._state) {
			case JobState.submitted:
				switch (nextState) {
				case JobState.running:
					if (currentTime >= animJob._startWhen) {
						animJob._state = JobState.running;
						var animTimePassed = Math.min(currentTime - animJob._startWhen - animJob._resumeWhen
								+ animJob._pauseWhen, animJob._duration);
						_processAnimStep(animJob, animTimePassed);
					}
					break;
				case JobState.stopped:
					animJob._state = JobState.stopped;
					_processAnimStep(animJob, animJob._duration);
					animJob._onComplete();
					break;
				case JobState.aborted:
					animJob._state = JobState.aborted;
					break;
				case JobState.cancelled:
					animJob._state = JobState.cancelled;
					break;
				}
				break;
			case JobState.running:
				switch (nextState) {
				case JobState.running:
					if (currentTime < animJob._endWhen + animJob._resumeWhen - animJob._pauseWhen) {
						var animTimePassed = currentTime - animJob._startWhen - animJob._resumeWhen
								+ animJob._pauseWhen;
						_processAnimStep(animJob, animTimePassed);
					} else {
						animJob._state = JobState.stopped;
						_processAnimStep(animJob, animJob._duration);
						animJob._onComplete();
					}
					break;
				case JobState.paused:
					animJob._state = JobState.Paused;
					animJob._pauseWhen = currentTime;
					break;
				case JobState.stopped:
					animJob._state = JobState.stopped;
					_processAnimStep(animJob, animJob._duration);
					animJob._onComplete();
					break;
				case JobState.aborted:
					animJob._state = JobState.aborted;
					break;
				case JobState.cancelled:
					animJob._state = JobState.cancelled;
					_processAnimStep(animJob, 0);
					break;
				}
				break;
			case JobState.paused:
				switch (nextState) {
				case JobState.running:
					animJob._resumeWhen = currentTime;
					animJob._state = JobState.running;
					break;
				case JobState.stopped:
					animJob._state = JobState.stopped;
					_processAnimStep(animJob, animJob._duration);
					animJob._onComplete();
					break;
				case JobState.aborted:
					animJob._state = JobState.aborted;
					break;
				case JobState.cancelled:
					animJob._state = JobState.cancelled;
					_processAnimStep(animJob, 0);
					break;
				}
				break;
			break;
		}
	}	;
		var _processor = function() {
			var _currentTime = (new Date()).getTime();
			var _jobItr = _jobQueue.getIterator();
			var _job;
			var _finJobs = [];
			while (_jobItr.hasMore()) {
				_job = _jobItr.nextValue();
				if (_job._state === JobState.submitted || _job._state === JobState.running) {
					_processingTask(_job, JobState.running, _currentTime);
				}
				if (_job._state === JobState.aborted || _job._state === JobState.cancelled
						|| _job._state === JobState.stopped) {
					_finJobs.push(_job._id);
				}
			}
			for ( var i = 0, len = _finJobs.length; i < len; i++) {
				_jobQueue.remove(_finJobs[i]);
			}
			if (!_jobQueue.isEmpty()) {
				_schedualProcessing();
			} else {
				_timer = false;
			}
		};
		var _schedualProcessing = function() {
			_timer = setTimeout(_processor, _interval);
		};
		return {
			/**
			 * Set or Get the frame ratio for the animator, default is 50fps.
			 * 
			 * @param [Integer]
			 *            fps the frame ratio, the valid range is (0, 100]
			 * @returns [Integer|this] the current frame ratio or this object to
			 *          allow chaining function call
			 */
			fps : function(fps) {
				if (fps !== undefined) {
					if (fps !== _fps && fps > 0 && fps <= 100) {
						_fps = fps;
						_interval = Math.ceil(1000 / fps);
					}
					return this;
				}
				return _fps;
			},
			/**
			 * Submit a value animation job, the job definition has the
			 * following variants
			 * 
			 * <pre>
			 * {
			 *     values : [
			 *                  {
			 *                      type : 'POINT' | 'RECT' | 'FLOAT' | 'TRANSFORM' | 'COLOR',
			 *                      from : POINT | RECT | FLOAT | TRANSFORM | COLOR,
			 *                      to : POINT | RECT | FLOAT | TRANSFORM | COLOR
			 *                  },
			 *                  ...
			 *              ], //The values to be animated.
			 *     duration : DURATION, //The duration setting for this animation, see duration setting for details.
			 *     easing : 'Linear' | 'EaseIn' | 'EaseOut' | 'EaseInOut' | [ POINT, POINT ], //The easing type of this animation, there are four built-in types. You can also pass an array of two points to define custom esing function.
			 *     onStep : Function, //This function will be called during animation with array of current interpolated values as its argument, the values will preserve the same order as the definition.
			 *     onComplete : Function, //This function will be called when complete normally or immediately(force to stop).
			 * } // Multiple Values Animation Definition
			 * </pre>
			 * 
			 * The <b>Duration</b> setting comes with 3 flavors as follows:
			 * 
			 * <pre>
			 * 1) Integer: The animation will start immediately and with the number in millisecond as duration.
			 * </pre>
			 * <pre>
			 * 2)
			 * {
			 *    startWhen : Integer, millisecond since epoch.
			 *    duration : Integer, the number in millisecond as duration.
			 * }
			 * </pre>
			 * <pre>
			 * 3)
			 * {
			 *    startWhen : Integer, millisecond since epoch.
			 *    endWhen : Integer, millisecond since epoch, must greater than startWhen
			 * }
			 * </pre>
			 * 
			 * @param {Object}
			 *            animation the animation job definition
			 * @return {String} id of the job, you can use the job id to
			 *         manipulate the on-going job. The job id will be
			 *         invalidated silently after the animation finishing.
			 */
			animate : function(animation) {
				var dur = animation.duration;
				var startWhen, endWhen;
				var animValues = [];
				var easingFunc = TimingFunctionFactory.getTimingFunction(animation.easing || 'Linear');
				for ( var i = 0, v, len = animation.values.length; i < len; i++) {
					v = animation.values[i];
					animValues.push({
						type : v.type,
						from : v.from,
						to : v.to,
						interpolator : InterpolatorFactory.getInterpolator(v.type, v.from, v.to, easingFunc)
					});
				}
				if (TypeUtils.isNumber(dur) && dur > 0) {
					startWhen = (new Date()).getTime();
					endWhen = startWhen + dur;
				} else {
					startWhen = dur.startWhen;
					if (dur.hasOwnProperty('duration')) {
						endWhen = startWhen + dur.duration;
					} else {
						endWhen = dur.endWhen;
					}
				}
				var animJob = new AnimationJob(animValues, startWhen, endWhen, animation.onStep
						|| FuncUtils.noop, animation.onComplete || FuncUtils.noop);
				_jobQueue.add(animJob._id, animJob);
				if (!_timer) {
					_schedualProcessing();
				}
				return animJob._id;
			},
			/**
			 * About a given job. If the job has been done, canceled or aborted,
			 * nothing will happen.
			 * 
			 * @param {String}
			 *            animId the id of the animation job
			 */
			abortAnimation : function(animId) {
				if (_jobQueue.has(animId)) {
					_processingTask(_jobQueue.get(animId), JobState.aborted, (new Date()).getTime());
				}
			},
			/**
			 * Pause a given job. If the job has been done, canceled or aborted,
			 * nothing will happen.
			 * 
			 * @param {String}
			 *            animId the id of the animation job
			 */
			pauseAnimation : function(animId) {
				if (_jobQueue.has(animId)) {
					_processingTask(_jobQueue.get(animId), JobState.paused, (new Date()).getTime());
				}
			},
			/**
			 * Resume a given job. If the job has been done, canceled or
			 * aborted, nothing will happen.
			 * 
			 * @param {String}
			 *            animId the id of the animation job
			 */
			resumeAnimation : function(animId) {
				if (_jobQueue.has(animId)) {
					_processingTask(_jobQueue.get(animId), JobState.running, (new Date()).getTime());
				}
			},
			/**
			 * Cancel a given job. If the job has been done, canceled or
			 * aborted, nothing will happen.
			 * 
			 * @param {String}
			 *            animId the id of the animation job
			 */
			cancelAnimation : function(animId) {
				if (_jobQueue.has(animId)) {
					_processingTask(_jobQueue.get(animId), JobState.cancelled, (new Date()).getTime());
				}
			},

			/**
			 * Abort the animator execution, all the running jobs will be
			 * aborted as well.
			 * 
			 */
			abortAll : function() {
				var _job,
					_jobItr = _jobQueue.getIterator();
				while (_jobItr.hasMore()) {
					_job = _jobItr.nextValue();
					_processingTask(_job, JobState.aborted, (new Date()).getTime());
				}
			},
			/**
			 * Pause the animator execution, all the running jobs will be paused
			 * as well.
			 * 
			 */
			pauseAll : function() {
				var _job,
				    _jobItr = _jobQueue.getIterator();
				while (_jobItr.hasMore()) {
					_job = _jobItr.nextValue();
					_processingTask(_job, JobState.paused, (new Date()).getTime());
				}
			},
			/**
			 * Resume the animator execution, all the paused jobs will be
			 * resumed as well.
			 * 
			 */
			resumeAll : function() {
				var _job,
				    _jobItr = _jobQueue.getIterator();
				while (_jobItr.hasMore()) {
					_job = _jobItr.nextValue();
					_processingTask(_job, JobState.running, (new Date()).getTime());
				}
			},
			/**
			 * Cancel the animator execution, all the running jobs will be
			 * cancelled as well.
			 * 
			 */
			cancelAll : function() {
				var _job,
				    _jobItr = _jobQueue.getIterator();
				while (_jobItr.hasMore()) {
					_job = _jobItr.nextValue();
					_processingTask(_job, JobState.cancelled, (new Date()).getTime());
				}
			}
		};
	})();
	return Animator;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.SeriesGroup',
  version : '1.0.0'
},
function Setup() {
	/**
	 * Represents a group of arbitrary number of chart series, usually wrapped
	 * in a chart instance.
	 */
	var seriesGroup = function() {
		/** Stores a number of plot series */
		this._seriesList = [];
	};

	seriesGroup.prototype = {
		/**
		 * Adds a plot series.
		 * 
		 * @param {Object}
		 *            [series] - Instance of the <code>Series</code> object
		 */
		addSeries : function(series) {
			this._seriesList.push(series);
		},

		/**
		 * Returns the list of plot series.
		 * 
		 * @returns {Array} Series list
		 */
		getSeriesList : function() {
			return this._seriesList;
		},

		updateProperties : function(props) {
			var seriesList = this._seriesList;
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				seriesList[i].updateProperties(props[i]);
			}
		}
	};

	return seriesGroup;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, LOG) {
    /**
     * Props Manager which accepts an initial propbag and encapsulate property
     * update logic, all supported property values are
     * String/Number/boolean/function
     * 
     * <pre>
     * e.g. initial propbag is:
     * {
     *      title: {
     *          main:{
     *              text:
     *              font:
     *              color:
     *          },
     *          sub:{
     *              text:
     *              font:
     *              color:
     *          }
     *      },
     *      measures:[
     *          {
     *              color: '',
     *              property_o:{
     *                  p_n: ''
     *              }
     *          },{
     *              color: '',
     *              property_o:{
     *                  p_n:
     *              }
     *          }
     *      ]
     * }
     * </pre>
     * 
     * to update it, we can pass: {title:{sub:{font:}}} to update font value of
     * property title/sub. for updating array values, see VISUAL-1205
     */
    var props =  function(descriptor) {
        this._descriptor = descriptor;
        this._local = {};
    };
    
    var propsPro = props.prototype;
    
    /**
     * 
     * @param propBag
     *            json object
     * 
     * If validation failed, an exception will be thrown. If some property is
     * defined in descriptor but not in user's property, default value should 
     * be used to replace user's.
     */
    propsPro.validate = function(propBag) {
        var result = {};
        var props = ObjUtils.extend(true, {}, propBag);
        for (var iname in this._descriptor) {
            if (this._descriptor.hasOwnProperty(iname)) {
                result[iname] = this.validateObject(props[iname], this._descriptor[iname]);
            }
        }
        return result;
    };

    /**
     * 
     * @param props
     *            chart properties object
     * @param propsDescriptor
     *            chart properties description
     * 
     * For all the inner properties, we should validate it and keep it
     * consistent with chart description contract. if not, throw a validation
     * exception
     */
    propsPro.validateObject = function(props, propsDescriptor) {
        var result;
        if(propsDescriptor.supportedValueType === 'Object') {
            result = {};
            if(!TypeUtils.isExist(props)) {
                props = {};
            }
            //validation the type of props, if it is not object, throw exception
            else if(typeof(props) != 'object'){
            	//throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
            }
            var supportedValues = propsDescriptor.supportedValues;
            for(var i = supportedValues.length; i--; ) {
                var iname = supportedValues[i].name;
                result[iname] = this.validateObject(props[iname], supportedValues[i]);
            }
        } else if(propsDescriptor.supportedValueType === 'ObjectArray'){
			result = [];
            if(!TypeUtils.isExist(props)) {
                props = [];
            }
           //validation the type of props, if it is not array, throw exception
            else if(!TypeUtils.isArray(props)){
            	//throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
            }
            var supportedValues = propsDescriptor.supportedValues;
            for(var i = props.length; i--; ) {
				result[i] = {};
                result[i] = this.validateObject(props[i], supportedValues[0]);
            }
		} else {
            result = this.validateItem(props, propsDescriptor);
        }
        return result;
    };
    
    propsPro.validateItem = function(props, propsDescriptor) {
        var type;
        // we should deal with the type that contain [], like
        // IntArray[4]
        // check the length and check the inner properties.
        if(propsDescriptor.supportedValueType.indexOf('[') != -1) {
            // get the length of this type. if the length is
            // not equal than the requirement, then failed to check
            // the propertie.
            var len = propsDescriptor.supportedValueType.substring(propsDescriptor.supportedValueType.indexOf('[') + 1, propsDescriptor.supportedValueType.indexOf(']'));
            //if(TypeUtils.isArray(props) && props.length !== parseInt(len))
            	//throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);

            if(propsDescriptor.supportedValueType.indexOf('IntArray') != -1) {
                // It is int array type
                type = 'IntArray';
            } else if(propsDescriptor.supportedValueType.indexOf('ColorArray') != -1) {
                // it is color array type.
                type = 'ColorArray';
            }

        } else {
            type = propsDescriptor.supportedValueType;
        }

        /*
        switch (type) {
            case 'Int':
                if(!this.validateInt(props, propsDescriptor))
                    throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                break;
            case 'PositiveInt':
                if(!this.validatePositiveInt(props, propsDescriptor))
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                break;
            case 'Number':
                if(!this.validateNumber(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'String':
                if(!this.validateString(props, propsDescriptor))
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                break;
            case 'Color':
                if(!this.validateColor(props, propsDescriptor))
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                break;
            case 'Boolean':
                if(!this.validateBoolean(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'Font':
                if(!this.validateFont(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'List':
                if(!this.validateList(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'StringArray':
                if(!this.validateStringArray(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'ObjectArray':
                if(!this.validateObjectArray(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'IntArray':
                if(!this.validateIntArray(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
                break;
            case 'ColorArray':
                if(!this.validateColorArray(props, propsDescriptor)) {
                	throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
                }
            case 'Function':
            	if(!this.validateFunction(props, propsDescriptor)){
            		throw new ClassCastException(props, propsDescriptor.name, propsDescriptor.supportedValueType);
            	}
            default:
                break;
        }
        */
        
        
        if (!TypeUtils.isExist(props)) {
            props = propsDescriptor.defaultValue;
        }
        return props;
    };


    
    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * special case: ignore the null and undefined value. we will create a
     * regular expression to test the property whether it is an Int. if not,
     * return false.
     */
    propsPro.validateInt = (function() {
    	var reg = new RegExp(/^-?\d+$/);
        return function(props, propsDescriptor) {
            if (!TypeUtils.isExist(props))
                return true;
            return (!TypeUtils.isString(props)&&TypeUtils.isNumber(props)&&reg.test(props))| props === Number.POSITIVE_INFINITY | props === Number.NEGATIVE_INFINITY;
        };
    })();

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not large than 0, return false;
     */
    propsPro.validatePositiveInt = (function() {
        var reg = new RegExp(/^(0|[1-9][0-9]*)$/);
        return function(props, propsDescriptor) {
            if (!TypeUtils.isExist(props))
                return true;
            return  (!TypeUtils.isString(props)&&TypeUtils.isNumber(props)&&reg.test(props))| props === Number.POSITIVE_INFINITY;
        };
    })();

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not less than 0, return false;
     */
    propsPro.validateNegativeInt = (function() {
        var reg = new RegExp(/^\-[1-9][0-9]*$/);
        return function(props, propsDescriptor) {
            if (!TypeUtils.isExist(props))
                return true;
            return  (!TypeUtils.isString(props)&&TypeUtils.isNumber(props)&&reg.test(props))|props === Number.NEGATIVE_INFINITY;
        };
    })();

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not a number, return false;
     */
    propsPro.validateNumber = function(props, propsDescriptor) {
        return !TypeUtils.isString(props)&&TypeUtils.isNumber(props);
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not a boolean, return false;
     */
    propsPro.validateBoolean = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        return props === true | props === false;
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not a string, return false;
     */
    propsPro.validateString = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        return TypeUtils.isString(props);
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * if the value of property is not a valid color string, return false;
     */
    propsPro.validateColor = (function() {
    	var hexReg = new RegExp(/(^#[0-9a-fA-F]{6}$)|(^#[0-9a-fA-F]{3}$)/);
        var rgbReg = new RegExp("^[rR][gG][Bb][\\s]*[\(]([\\s]*(2[0-4][0-9]|25[0-5]|[01]?[0-9][0-9]?)[\\s]*,){2}[\\s]*(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)[\\s]*[\)]{1}$");
        var rgbaReg = new RegExp("^[rR][gG][Bb][Aa][\\s]*[\(]([\\s]*(2[0-4][0-9]|25[0-5]|[01]?[0-9][0-9]?)[\\s]*,){3}[\\s]*(1|0.[0-9]*)[\\s]*[\)]{1}$");
        return function(props, propsDescriptor) {
            if (!TypeUtils.isExist(props))
                return true;
            return hexReg.test(props)|rgbReg.test(props)|rgbaReg.test(props);
        };
    })();

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @return true|false
     * 
     * Font style only two format: 
     *  1. fontWeight + fontSize + fontFamily
     *  2. fontSize + fontFamily
     */
    propsPro.validateFont = (function() {
        var fontWeighRreg = new RegExp('^bold$|^normal$|^bolder$|^lighter$|^100$|^200$|^300$|^400$|^500$|^600$|^700$|^800$|^900$');
        var fontSizeReg = new RegExp('^\\d{1,9}\\d(px|pt|em)?$');
        return function(props, propsDescriptor) {
            if (!TypeUtils.isExist(props))
                return true;
            //trim the props value, as we may get the size 3 like ' 16px Arial'.
            //props = props.replace(/^\s+|\s+$/g,"");
            props = props.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); //The regular expression is more faster than the above one.
            var infs = props.split(' ');
            //If the font size is large than 3, means it do not meet the format of font style
            if(infs.length < 2){
                return false;
            }else if(infs.length >= 2){
            	if(fontSizeReg.test(infs[0])){
            		//FontStyle format: fontSize + fontFamily
            		
            		//Ian To be implement, as in font style, it may like this 14px Arial, Helvetica, it has three element, the the last two is font family,
                    //now only check the combination value of last two is whether or not string.
                	var fontFamily;
                	for(var i=1, len = infs.length; i<len; i++){
                		fontFamily += infs[i];
                	}
                	
                	return this.validateString(fontFamily);
            	}else{
            		 //Ian To be implement, as in font style, it may like this bold 14px Arial, Helvetica, it has four element, the the last two is font family,
                    //now only check the combination value of last two is whether or not string.
                	var fontFamily;
                	for(var i=2, len = infs.length; i<len; i++){
                		fontFamily += infs[i];
                	}
                    return fontWeighRreg.test(infs[0]) && fontSizeReg.test(infs[1]) && this.validateString(fontFamily);
            	}
            }
        };
    })();

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * we will check the props. If it is in supported list, return true, else return false;
     */
    propsPro.validateList = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        var supportedValues = propsDescriptor.supportedValues;
        for ( var i = supportedValues.length; i--;) {
            if (supportedValues[i] === props)
                return true;
        }
        return false;
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * we will check the inner values of array, it all the values in array is string, return true, else return false;
     */
    propsPro.validateStringArray = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        for ( var i = props.length; i--;) {
            if (!this.validateString(props[i], null))
                return false;
        }
        return true;
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * validate the inner properties in object.
     */
    propsPro.validateObjectArray = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        for ( var i = props.length; i--;) {
            if (!this.validateObject(props[i], propsDescriptor))
                return false;
        }
        return true;
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * we will check the properties in array. If all value is int, return true, else return false;
     */
    propsPro.validateIntArray = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        for ( var i = props.length; i--;) {
            if (!this.validateInt(props[i], null))
                return false;
        }
        return true;
    };

    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * we will check the values in array, if all meet the format of color, return true, else return false;
     */
    propsPro.validateColorArray = function(props, propsDescriptor) {
        if (!TypeUtils.isExist(props))
            return true;
        for ( var i = props.length; i--;) {
            if (!this.validateColor(props[i], null))
                return false;
        }
        return true;
    };
    
    /**
     * 
     * @param props
     * @param propsDescriptor
     * @returns {Boolean}
     * 
     * if the props is undefined and Fcuntion, return true. Otherwise, return false.
     */
    propsPro.validateFunction = function(props, propsDescriptor){
    	  if (!TypeUtils.isExist(props))
              return true;
    	  return TypeUtils.isFunction(props);
    };
    
    propsPro.properties = function(propBag) {
        if (propBag) {
            propBag = ObjUtils.extend(true, this._local, propBag);
            this._local = this.validate(propBag);
        }
        return ObjUtils.extend(true, {}, this._local);
    };

    /**
     * TODO add unit test: var p = new
     * sap.riv.viz.shared.misc.PropsMgr({title:{main:{color:'#11ddff','text':'default
     * title'},sub:{color:'#aaddff','text':'default sub'}},
     * measures:[{color:'#2233dd',render:{type:'bar',
     * width:5}},{color:'#112233', render:{type:'line', width:4}}]});
     * p.properties({title:{main:{text:'changed title'}}});
     * p.properties({title:{main:{text:'changed title'},sub:{color:'changed
     * color', text:'changed sub title'}}});
     * p.properties({title:{main:{text:'changed title 111'}},
     * measures:[{color:'changed color', render:{type:'changed type'}}]});
     */
    return props;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Line',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Drawable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, CanvasHelper, Drawable, Math) {
	/**
	 * This class defines Line
	 * 
	 * @name sap.riv.graphics.shape.Line
	 * @class
	 * @augments sap.riv.graphics.Drawable
	 */
	var Line = ObjectUtils.derive(Drawable, {
		constructor : function(metadata) {
			this._start = {
				x : 0,
				y : 0
			};
			this._end = {
				x : 0,
				y : 0
			};
			this._width = 1.0;
			this._capStyle = 'butt';
			this._color = '#000000';
		},

		_calcForHitTest : function(startPoint, endPoint, width) {
			this._preCalc = {
				A : (endPoint.y - startPoint.y),
				B : (startPoint.x - endPoint.x),
				C : startPoint.y * endPoint.x - startPoint.x * endPoint.y,
				D : Math.sqrt((endPoint.y - startPoint.y) * (endPoint.y - startPoint.y) + (startPoint.x - endPoint.x)
						* (startPoint.x - endPoint.x)),
				delta : width > 2.0 ? width / 2.0 : 1.0
			};
		},

		/**
		 * Get or set the start position of the line segment, The default start
		 * position is {0,0}.
		 * 
		 * @name sap.riv.graphics.shape.Line#from
		 * @function
		 * @param {POINT}
		 *            startPosition the x,y coordinates of the start position
		 * @returns {this|POINT}
		 */
		from : function(startPosition) {
			if (startPosition !== undefined) {
				this._start.x = startPosition.x;
				this._start.y = startPosition.y;
				this._calcForHitTest(startPosition, this._end, this._width);
				return this;
			}
			return {
				x : this._start.x,
				y : this._start.y
			};
		},
		/**
		 * Get or set the end position of the line segment, The default end
		 * position is {0,0}.
		 * 
		 * @name sap.riv.graphics.shape.Line#to
		 * @function
		 * @param {POINT}
		 *            endPosition the x,y coordinates of the end position
		 * @returns {this|POINT}
		 */
		to : function(endPosition) {
			if (endPosition !== undefined) {
				this._end.x = endPosition.x;
				this._end.y = endPosition.y;
				this._calcForHitTest(this._start, endPosition, this._width);
				return this;
			}
			return {
				x : this._end.x,
				y : this._end.y
			};
		},

		/**
		 * Get or set the color of the line segment, the default color is
		 * #000000, the color setting should be CSSColor serialized string or as
		 * follow to define gradient
		 * 
		 * <pre>
		 * {
		 *      t: 'lg'|'rg', //line gradient or radial gradient
		 *      s: { x:## , y:## }, //the start position of the gradient
		 *      e: { x:## , y:## }, //the end position of the gradient
		 *      st: [
		 *              {
		 *                  o: //the stop offset
		 *                  v: //the stop color
		 *              },...
		 *          ] //the color stops of the gradient
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.graphics.shape.Line#color
		 * @function
		 * @param {CSSColor|Object}
		 *            lineColor the line segment color setting
		 * @returns {this|CSSColor|CanvasGradient}
		 */
		color : function(lineColor) {
			if (lineColor != undefined) {
				this._color = CanvasHelper.createColorStyle(lineColor);
				return this;
			}
			return this._color;
		},

		/**
		 * Get or set the width of the line segment, the width should be greater
		 * or equal than 1.0. The default width is 1.0
		 * 
		 * @name sap.riv.graphics.shape.Line#width
		 * @function
		 * @param {Number}
		 *            lineWidth the width of the line segment
		 * @returns {this|Number}
		 */
		width : function(lineWidth) {
			if (lineWidth != undefined) {
				if (lineWidth >= 1.0) {
					this._width = lineWidth;
					this._calcForHitTest(this._start, this._end, lineWidth);
				}
				return this;
			}
			return this._width;
		},

		/**
		 * Get or set the cap style of the line segment, the default style is
		 * butt, the available styles are butt, square, round.
		 * 
		 * @name sap.riv.graphics.shape.Line#cap
		 * @function
		 * @param {String}
		 *            capStyle the line segment cap style
		 * @returns {this|String}
		 */
		cap : function(capStyle) {
			if (capStyle != undefined) {
				this._capStyle = capStyle;
				return this;
			}
			return this._capStyle;
		},

		/**
		 * Draws the line to canvas.
		 * Caution: If the layer to which the line is added starts at a coordination 
		 * whose x and y are both integers, SDK will perform crisp line optimization 
		 * when line width is an odd number.
		 * 
		 * @name sap.riv.graphics.shape.Line#doDraw
		 * @param {DrawingContext}
		 *            the drawing context for drawing
		 */
		doDraw : function(drawingContext) {
			// Add crisp line optimization
        	var xEquals = (this._start.x === this._end.x);
        	var yEquals = (this._start.y === this._end.y);
        	
        	// If the line to draw is horizontally or vertically straight
        	if(xEquals || yEquals){ 
        		if(xEquals){
        			this._start.x = this._end.x = Math.floor(this._start.x);
        			
        			if(this._width%2 === 1){
        				this._start.x = this._end.x = this._start.x+0.5;
        			}
        			
        			this._start.y = Math.round(this._start.y);
        			this._end.y = Math.round(this._end.y);
        		} 
        		
        		if(yEquals){
        			this._start.y = this._end.y = Math.floor(this._start.y);
        			
        			if(this._width%2 === 1){
        				this._start.y = this._end.y = this._start.y+0.5;
        			}
        			
        			this._start.x = Math.round(this._start.x);
        			this._end.x = Math.round(this._end.x);
        		}
        	}
        	
			var dCtx = drawingContext;
			dCtx.setLineWidth(this._width);
			dCtx.setLineCap(this._capStyle);
			dCtx.setStrokeStyle(this._color);
			dCtx.beginPath();
			dCtx.moveTo(this._start.x, this._start.y);
			dCtx.lineTo(this._end.x, this._end.y);
			dCtx.stroke();
		},

		doPointInTest : function(point) {
			var pc = this._preCalc;
			var x = point.x;
			var y = point.y;
			var s = this._start;
			var e = this._end;
			if (s.x == e.x) {
				// perpendicular line
				return (Math.abs(x - s.x) < pc.delta) && ((s.y < y && y < e.y) || (s.y > y && y > e.y));
			}
			return ((s.x < x && x < e.x) || (s.x > x && x > e.x))
					&& Math.abs((pc.A * x + pc.B * y + pc.C) / pc.D) < pc.delta;
		}
	});
	return Line;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.PositionCalculator',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math) {
	var pCalculator = function() {
	};

	// --------------------------------------------------------------------------
	// static Methods
	// --------------------------------------------------------------------------

	/**
	 * The position calculation function that should be used in most cases. It
	 * determines the position based on the bounds of the axis, the actual data,
	 * the size of the axis, the line scaling, and whether the value should be a
	 * percentage.
	 * 
	 * @param currentData
	 *            a particular value whose position should be determined
	 * @param minValue
	 *            the minimum value of the target axis
	 * @param maxValue
	 *            the maximum value of the target axis
	 * @param distance
	 *            the length of the target axis
	 * @param scaling
	 *            the line scaling of the target axis (linear, logarithmic,
	 *            etc.)
	 * @param percentage
	 *            a flag for whether the value will be a percentage or not
	 * @return the position in pixels on the axis in which the item should
	 *         appear
	 */
	pCalculator.calculateStandardPosition = function(currentData, minValue,
			maxValue, distance, scaling, percentage) {

		var position = 0;
		if (scaling == 'linear') {
			var multiplier = pCalculator.generateLinearMultiplier(minValue,
					maxValue, distance);
			position = pCalculator.calculateLinearPosition(currentData,
					multiplier, minValue);
		} else {
			var multiplier = pCalculator.generateLogarithmicMultiplier(
					minValue, maxValue, distance);
			if (percentage)
				currentData *= 100;
			if (currentData <= 0)
				currentData = 1;

			position = pCalculator.calculateLogarithmicPosition(currentData,
					multiplier, minValue);
		}

		return pCalculator.validatePosition(position, distance, true);
	};

	/**
	 * Generates a conversion multiplier between values and actual pixel
	 * positions on a linear scale.
	 * 
	 * @param minValue
	 *            the minimum value of the target axis
	 * @param maxValue
	 *            the maximum value of the target axis
	 * @param distance
	 *            the length of the target axis
	 * @return a value to use for converting between data values and pixel
	 *         positions
	 */
	pCalculator.generateLinearMultiplier = function(minValue, maxValue,
			distance) {
		return distance / (maxValue - minValue);
	};

	/**
	 * Using a multiplier, determines the position of a data value based on the
	 * minimum value of the target axis on a linear scale.
	 * 
	 * @param value
	 *            the value whose position should be determined
	 * @param multiplier
	 *            the Number used to convert from the value to a position
	 * @param minValue
	 *            the minimum value of the target axis
	 * @return the position of the data value
	 */
	pCalculator.calculateLinearPosition = function(value, multiplier, minValue) {
		return multiplier * (value - minValue);
	};

	/**
	 * The inverse of <code>calculateLinearPosition</code>
	 * 
	 * @param position
	 *            the position whose value should be calculated
	 * @param multiplier
	 *            the Number used to convert from the value to a position
	 * @param minValue
	 *            the minimum value of the target axis
	 * 
	 * @return the data value of the position
	 * 
	 * @see calculateLinearPosition
	 */
	pCalculator.calculateLinearValue = function(position, multiplier, minValue) {
		return (position / multiplier) + minValue;
	};

	/**
	 * Generates a conversion multiplier between values and actual pixel
	 * positions on a logarithmic scale.
	 * 
	 * @param minValue
	 *            the minimum value of the target axis
	 * @param maxValue
	 *            the maximum value of the target axis
	 * @param distance
	 *            the length of the target axis
	 * @return a value to use for converting between data values and pixel
	 *         positions
	 */
	pCalculator.generateLogarithmicMultiplier = function(minValue, maxValue,
			distance) {
		if (minValue <= 0) {
			minValue = 1;
			if (maxValue <= minValue)
				maxValue = 2;
		}

		var minLog = Math.log(minValue);
		var maxLog = Math.log(maxValue);

		return distance / (maxLog - minLog);
	};

	/**
	 * Using a multiplier, determines the position of a data value based on the
	 * minimum value of the target axis on a logarithmic scale.
	 * 
	 * @param value
	 *            the value whose position should be determined
	 * @param multiplier
	 *            the Number used to convert from the value to a position
	 * @param minValue
	 *            the minimum value of the target axis
	 * @return the position of the data value
	 */
	pCalculator.calculateLogarithmicPosition = function(value, multiplier,
			minValue) {
		if (value == 0 || minValue == 0)
			return 0;
		return multiplier * (Math.log(value) - Math.log(minValue));
	};

	/**
	 * Checks if the position is invalid (NaN) or outside of the bounds and sets
	 * it to zero or the maximum distance.
	 * 
	 * @param position
	 *            the desired position
	 * @param distance
	 *            the length of the target axis
	 * @param invalidToZero
	 *            if invalid, go to zero. otherwise, go to distance
	 * @return a valid position in the range of the axis
	 */
	pCalculator.validatePosition = function(position, distance, invalidToZero) {

		if (position < 0)
			position = 0;
		else if (position > distance)
			position = distance;
		if (TypeUtils.isNaN(position)) {
			if (invalidToZero)
				position = 0;
			else
				position = distance;
		}
		return position;
	};

	return pCalculator;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.DrawableRect',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.ClosedShape',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(FunctionUtils, ObjectUtils, ClosedShape, Math) {
	/**
	 * Abstract super class for all rect-bounded shape.
	 * 
	 * @name sap.riv.graphics.shape.DrawableRect
	 * @class
	 * @augments sap.riv.graphics.shape.ClosedShape
	 */
	var DrawableRect = ObjectUtils.derive(ClosedShape, {
		constructor : function() {
			this._anchor = 'tl';
			this._width = 0;
			this._height = 0;
			this._cornerRadius = 0;
			this._vtx = [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ];// tl,tr,br,bl
		},

		_calcVertices : function(anchor, position) {
			var p = position;
			var vtx = this._vtx;
			var width = this._width;
			var height = this._height;
			switch (anchor) {
			case 'tl':
				vtx[0][0] = p[0];
				vtx[0][1] = p[1];
				vtx[1][0] = p[0] + width;
				vtx[1][1] = p[1];
				vtx[2][0] = p[0] + width;
				vtx[2][1] = p[1] + height;
				vtx[3][0] = p[0];
				vtx[3][1] = p[1] + height;
				break;
			case 'tc':
				vtx[0][0] = p[0] - width / 2;
				vtx[0][1] = p[1];
				vtx[1][0] = p[0] + width / 2;
				vtx[1][1] = p[1];
				vtx[2][0] = p[0] + width / 2;
				vtx[2][1] = p[1] + height;
				vtx[3][0] = p[0] - width / 2;
				vtx[3][1] = p[1] + height;
				break;
			case 'tr':
				vtx[0][0] = p[0] - width;
				vtx[0][1] = p[1];
				vtx[1][0] = p[0];
				vtx[1][1] = p[1];
				vtx[2][0] = p[0];
				vtx[2][1] = p[1] + height;
				vtx[3][0] = p[0] - width;
				vtx[3][1] = p[1] + height;
				break;
			case 'rc':
				vtx[0][0] = p[0] - width;
				vtx[0][1] = p[1] - height / 2;
				vtx[1][0] = p[0];
				vtx[1][1] = p[1] - height / 2;
				vtx[2][0] = p[0];
				vtx[2][1] = p[1] + height / 2;
				vtx[3][0] = p[0] - width;
				vtx[3][1] = p[1] + height / 2;
				break;
			case 'br':
				vtx[0][0] = p[0] - width;
				vtx[0][1] = p[1] - height;
				vtx[1][0] = p[0];
				vtx[1][1] = p[1] - height;
				vtx[2][0] = p[0];
				vtx[2][1] = p[1];
				vtx[3][0] = p[0] - width;
				vtx[3][1] = p[1];
				break;
			case 'bc':
				vtx[0][0] = p[0] - width / 2;
				vtx[0][1] = p[1] - height;
				vtx[1][0] = p[0] + width / 2;
				vtx[1][1] = p[1] - height;
				vtx[2][0] = p[0] + width / 2;
				vtx[2][1] = p[1];
				vtx[3][0] = p[0] - width / 2;
				vtx[3][1] = p[1];
				break;
			case 'bl':
				vtx[0][0] = p[0];
				vtx[0][1] = p[1] - height;
				vtx[1][0] = p[0] + width;
				vtx[1][1] = p[1] - height;
				vtx[2][0] = p[0] + width;
				vtx[2][1] = p[1];
				vtx[3][0] = p[0];
				vtx[3][1] = p[1];
				break;
			case 'lc':
				vtx[0][0] = p[0];
				vtx[0][1] = p[1] - height / 2;
				vtx[1][0] = p[0] + width;
				vtx[1][1] = p[1] - height / 2;
				vtx[2][0] = p[0] + width;
				vtx[2][1] = p[1] + height / 2;
				vtx[3][0] = p[0];
				vtx[3][1] = p[1] + height / 2;
				break;
			case 'c':
				vtx[0][0] = p[0] - width / 2;
				vtx[0][1] = p[1] - height / 2;
				vtx[1][0] = p[0] + width / 2;
				vtx[1][1] = p[1] - height / 2;
				vtx[2][0] = p[0] + width / 2;
				vtx[2][1] = p[1] + height / 2;
				vtx[3][0] = p[0] - width / 2;
				vtx[3][1] = p[1] + height / 2;
				break;
			}
		},

		_adjustVertices : function() {
			var vtx = this._vtx;
			var w = vtx[1][0] - vtx[0][0];
			var h = vtx[3][1] - vtx[0][1];
			switch (this._anchor) {
			case 'tl':
				this._calcVertices('tl', vtx[0]);
				break;
			case 'tc':
				this._calcVertices('tc', [ vtx[0][0] + w / 2, vtx[0][1] ]);
				break;
			case 'tr':
				this._calcVertices('tr', vtx[1]);
				break;
			case 'rc':
				this._calcVertices('rc', [ vtx[1][0], vtx[1][1] + h / 2 ]);
				break;
			case 'br':
				this._calcVertices('br', vtx[2]);
				break;
			case 'bc':
				this._calcVertices('bc', [ vtx[2][0] - w / 2, vtx[2][1] ]);
				break;
			case 'bl':
				this._calcVertices('bl', vtx[3]);
				break;
			case 'lc':
				this._calcVertices('lc', [ vtx[3][0], vtx[3][1] - h / 2 ]);
				break;
			case 'c':
				this._calcVertices('c', [ vtx[0][0] + w / 2, vtx[0][1] + h / 2 ]);
				break;
			}
			this._cornerRadius = Math.min(this._width / 2, this._height / 2, this._cornerRadius);
		},

		/**
		 * Get or set the width of the rectangle area, the width should be
		 * greater zero.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#width
		 * @function
		 * @param {Number}
		 *            width the rectangle bound width
		 * @returns {this|Number}
		 */
		width : function(width) {
			if (width !== undefined) {
				if (width > 0) {
					this._width = width;
					this._adjustVertices();
				}
				return this;
			}
			return this._width;
		},
		/**
		 * Get or set the height of the rectangle area, the height should be
		 * greater zero.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#height
		 * @function
		 * @param {Number}
		 *            height the rectangle bound height
		 * @returns {this|Number}
		 */
		height : function(height) {
			if (height !== undefined) {
				if (height > 0) {
					this._height = height;
					this._adjustVertices();
				}
				return this;
			}
			return this._height;
		},
		/**
		 * Get or set the top left corner position, and set the anchor to top
		 * left.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#topLeft
		 * @function
		 * @param {[x,y]}
		 *            tl top left corner coordinates
		 * @returns {this|[x,y]}
		 */
		topLeft : function(tl) {
			if (tl !== undefined) {
				this._anchor = 'tl';
				this._calcVertices('tl', tl);
				return this;
			}
			return {
				x : this._vtx[0][0],
				y : this._vtx[0][1]
			};
		},
		/**
		 * Get or set the top center corner position, and set the anchor to top
		 * center.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#topCenter
		 * @function
		 * @param {[x,y]}
		 *            tc top center corner coordinates
		 * @returns {this|[x,y]}
		 */
		topCenter : function(tc) {
			if (tc !== undefined) {
				this._anchor = 'tc';
				this._calcVertices('tc', tc);
				return this;
			}
			return {
				x : this._vtx[0][0] + this._width / 2,
				y : this._vtx[0][1]
			};
		},
		/**
		 * Get or set the top right corner position, and set the anchor to top
		 * right.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#topRight
		 * @function
		 * @param {[x,y]}
		 *            tr top right corner coordinates
		 * @returns {this|[x,y]}
		 */
		topRight : function(tr) {
			if (tr !== undefined) {
				this._anchor = 'tr';
				this._calcVertices('tr', tr);
				return this;
			}
			return {
				x : this._vtx[1][0],
				y : this._vtx[1][1]
			};
		},
		/**
		 * Get or set the right center corner position, and set the anchor to
		 * right center.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#rightCenter
		 * @function
		 * @param {[x,y]}
		 *            rc rignt center corner coordinates
		 * @returns {this|[x,y]}
		 */
		rightCenter : function(rc) {
			if (rc !== undefined) {
				this._anchor = 'rc';
				this._calcVertices('rc', rc);
				return this;
			}
			return {
				x : this._vtx[1][0],
				y : this._vtx[1][1] + this._height / 2
			};
		},
		/**
		 * Get or set the bottom right corner position, and set the anchor to
		 * bottom right.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#bottomRight
		 * @function
		 * @param {[x,y]}
		 *            br bottom right corner coordinates
		 * @returns {this|[x,y]}
		 */
		bottomRight : function(br) {
			if (br !== undefined) {
				this._anchor = 'br';
				this._calcVertices('br', br);
				return this;
			}
			return {
				x : this._vtx[2][0],
				y : this._vtx[2][1]
			};
		},
		/**
		 * Get or set the bottom center corner position, and set the anchor to
		 * bottom center.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#bottomCenter
		 * @function
		 * @param {[x,y]}
		 *            bc bottom center corner coordinates
		 * @returns {this|[x,y]}
		 */
		bottomCenter : function(bc) {
			if (bc !== undefined) {
				this._anchor = 'bc';
				this._calcVertices('bc', bc);
				return this;
			}
			return {
				x : this._vtx[2][0] - this._width / 2,
				y : this._vtx[2][1]
			};
		},
		/**
		 * Get or set the bottom left corner position, and set the anchor to
		 * bottom left.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#bottomLeft
		 * @function
		 * @param {[x,y]}
		 *            bl bottom left corner coordinates
		 * @returns {this|[x,y]}
		 */
		bottomLeft : function(bl) {
			if (bl !== undefined) {
				this._anchor = 'bl';
				this._calcVertices('bl', bl);
				return this;
			}
			return {
				x : this._vtx[3][0],
				y : this._vtx[3][1]
			};
		},
		/**
		 * Get or set the left center corner position, and set the anchor to
		 * left center.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#leftCenter
		 * @function
		 * @param {[x,y]}
		 *            lc left center corner coordinates
		 * @returns {this|[x,y]}
		 */
		leftCenter : function(lc) {
			if (lc !== undefined) {
				this._anchor = 'lc';
				this._calcVertices('lc', lc);
				return this;
			}
			return {
				x : this._vtx[3][0],
				y : this._vtx[3][1] - this._height / 2
			};
		},
		/**
		 * Get or set the center position, and set the anchor to center.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#center
		 * @function
		 * @param {[x,y]}
		 *            c center coordinates
		 * @returns {this|[x,y]}
		 */
		center : function(c) {
			if (c !== undefined) {
				this._anchor = 'c';
				this._calcVertices('c', c);
				return this;
			}
			return {
				x : this._vtx[0][0] + this._width / 2,
				y : this._vtx[0][1] + this._height / 2
			};
		},
		/**
		 * Get or set the corner radius. Value should be greater or equals to
		 * zero. Zero means no rounded corner.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#cornerRadius
		 * @function
		 * @param {Number}
		 *            radius the corner radius
		 * @returns {this|Number}
		 */
		cornerRadius : function(radius) {
			if (radius !== undefined) {
				if (radius >= 0) {
					var minwh = Math.min(this._width / 2, this._height / 2);
					this._cornerRadius = radius > minwh ? minwh : radius;
				}
				return this;
			}
			return this._cornerRadius;
		},

		_antialiasForMin : function(s, t) {
			if (window.__IS_IN_RHINO == true) {
				return parseInt(t);
			}
			var tr = Math.round(t);
			var sr = Math.round(s);
			tr = tr + sr / 2;// ensure not exceeding the margin
			// for iOS only, line doesn't show up in 0.5 for width = 1
			if (tr == 0.5 && sr == 1)
				tr = 1.5;
			return tr;
		},
		
		_antialiasForMax : function(s, t) {
			if (window.__IS_IN_RHINO == true) {
				return parseInt(t);
			}
			var tr = Math.round(t);
			var sr = Math.round(s);
			tr = tr - sr / 2;// ensure not exceeding the margin
			// for iOS only, line doesn't show up in 0.5 for width = 1
			if (tr == 0.5 && sr == 1)
				tr = 1.5;
			return tr;
		},

		doDraw : function(drawingContext) {
			var vtx = this._vtx;
			var minx = vtx[0][0], midx = (vtx[0][0] + vtx[1][0]) / 2, maxx = vtx[1][0];
			var miny = vtx[0][1], midy = (vtx[0][1] + vtx[3][1]) / 2, maxy = vtx[3][1];
			// Antialiasing
			if (this.borderWidth() > 0) {
				var bdw = this.borderWidth();
				minx = this._antialiasForMin(bdw, minx);
				maxx = this._antialiasForMax(bdw, maxx);
				miny = this._antialiasForMin(bdw, miny);
				maxy = this._antialiasForMax(bdw, maxy);
			}
			else {
				minx = Math.round(minx);
				maxx = Math.round(maxx);
				miny = Math.round(miny);
				maxy = Math.round(maxy);
			}
			
			var dCtx = drawingContext;
			dCtx.save();
			dCtx.beginPath();
			if (this._cornerRadius > 0) {
				var radius = this._cornerRadius;
				dCtx.moveTo(minx, midy);
				dCtx.arcTo(minx, miny, midx, miny, radius);
				dCtx.arcTo(maxx, miny, maxx, midy, radius);
				dCtx.arcTo(maxx, maxy, midx, maxy, radius);
				dCtx.arcTo(minx, maxy, minx, midy, radius);
			} else {
				dCtx.moveTo(minx, miny);
				dCtx.lineTo(maxx, miny);
				dCtx.lineTo(maxx, maxy);
				dCtx.lineTo(minx, maxy);
			}
			dCtx.closePath();
			// Move the origin to the top-left corner of the rectangle
			dCtx.translate(minx, miny);
			this.drawInRect(dCtx);
			this.drawBorder(dCtx);
			dCtx.restore();
		},

		/**
		 * This method is intended to be overriden by subclass.
		 * 
		 * @name sap.riv.graphics.shape.DrawableRect#drawInRect
		 * @function
		 * @param {DrawingContext}
		 *            drawingContext the current drawing context
		 */
		drawInRect : FunctionUtils.unimplemented,

		doPointInTest : function(point) {
			var x = point.x;
			var y = point.y;
			var vtx = this._vtx;
			return vtx[0][0] <= x && x <= vtx[2][0] && vtx[0][1] <= y && y <= vtx[2][1];
		}
	});
	return DrawableRect;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.RIVExCanvasMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(UADetector, RIVExCanvasMgr, Math) {
    var rvmlmgr = RIVExCanvasMgr;
    var hiddenCanvasCtx = undefined;
    var getHiddenCanvasCtx = function() {
        if(hiddenCanvasCtx) {
            return hiddenCanvasCtx;
        }
        var canDom;
        var body = document.body;
        if(window.__IS_IN_RHINO) {
            canDom = document.createElement('canvas');
			//Sun xuetao 2010/4/27  on ui5 check these two varibles are global,  and the code could not be exec, comment out.
            //canDom.height = height;
            //canDom.width = width;
            body.appendChild(canDom);
        } else if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
            if( typeof FlashCanvas != "undefined") {
                canDom = document.createElement('canvas');
                body.appendChild(canDom);
                FlashCanvas.initElement(canDom);
                canDom.setAttribute('height', 1);
                canDom.setAttribute('width', 1);
                canDom.style.width = '1px';
                canDom.style.height = '1px';
                canDom.style.display = 'none';
            } else {
                canDom = document.createElement('rivcanvas');
                canDom.setAttribute('height', 1);
                canDom.setAttribute('width', 1);
                canDom.style.width = '1px';
                canDom.style.height = '1px';
                body.appendChild(canDom);
                rvmlmgr.initElement(canDom);
            }
        } else {
            canDom = document.createElement('canvas');
            canDom.setAttribute('height', 1);
            canDom.setAttribute('width', 1);
            canDom.style.width = '1px';
            canDom.style.height = '1px';
            canDom.style.display = 'none';
            body.appendChild(canDom);
        }
        hiddenCanvasCtx = canDom.getContext('2d');
        return hiddenCanvasCtx;
    };
    var p = /(\d+)(px|em|pt|%)/i;
    var fsp = /(x{1,2}-)?(small|medium|large)/i;
    var w = /\d+\b|bold|[\s\t]normal/i;
    var sizeMap ={
        "x-small" : 9,
        "xx-small" : 10,
        "small" : 13,
        "medium" : 16,
        "large" : 18,
        "x-large" : 24,
        "xx-large" : 32
    };
    /**
     * Text Ruler
     *
     * @name sap.riv.core.utils.TextRuler
     * @class
     */
    var TextRuler = {
        /**
         * Measure the text width in given font setting
         *
         * @function
         * @param {String}
         *            font the css font string
         * @param {String}
         *            text the text to be measured
         * @returns {Number} the actual width of the text in px
         */
        measureWidth : window.measureWidth ||
        function(font, text) {
            var canvasCtx = getHiddenCanvasCtx();
            canvasCtx.save();
            canvasCtx.font = font;
            var width = canvasCtx.measureText(String(text)).width + 2;
            canvasCtx.restore();
            return width;
        },

        /**
         * Measure the text height in given font setting approximately, the
         * supported units of font-size setting could be in em, px, pt, %. When
         * specified as relative font size like ##em, ##&, the text height will
         * be calculated against 10 px by default. If the font string is
         * invalid, undefined will be returned.
         *
         * @function
         * @param {String}
         *            font the valid css font string
         * @param {Number}
         *            [baseSize] the base font size used to calculate relative
         *            font size, like em, percentage. Default is 10 px.
         * @returns {Number} the height of the bounding box of the font setting
         *          in px
         */
        measureHeight : function(font, baseSize) {
            var m = p.exec(font);
            var bs = baseSize || 10;
            if(m) {
                var s = 0;
                switch (m[2]) {
                    case 'em':
                        s = parseFloat(m[1]) * bs;
                        break;
                    case '%':
                        s = parseFloat(m[1]) * bs / 100;
                        break;
                    case 'pt':
                        // One point(pt) is approximately equal to 1.33 px
                        s = parseFloat(m[1]) * 1.33;
                        break;
                    case 'px':
                        s = parseInt(m[1]);
                        break;
                }
                return Math.ceil(s * 1.2);
            }else {
                m = fsp.exec(font);
                if(m){
                    return Math.ceil(sizeMap[m[0]] *1.2);
                }
            }
            return undefined;
        },
        /**
         * Measure the weight of the text in given font while drawing on Canvas
         *
         * @param {String}
         *            font the valid css font string

         * @returns {Number} the weight of the bounding box of the font setting.
         */
        measureWeight : function(font) {
            var m = w.exec(font);
            var p = 400;
            if(m) {
                switch (m[0]) {
                    // add a white space before 'normal to ignore first normal,
                    // which is define font-style, not weight'
                    case ' normal':
                    case '500':
                        p = 400;
                        break;
                    case 'bold':
                    case 'bolder':
                    case '600':
                    case '700':
                    case '800':
                    case '900':
                        // 400 is normal, and 700 is bold. Those are the only
                        // numeric values that most text rendering engines support.
                        p = 700;
                }
            }
            return p;
        },
        /**
         * Measure the dimension of the text in given font while drawing on
         * Canvas
         *
         * @param {String}
         *            font the font to draw the text in
         * @param {String}
         *            text the text to be measured
         * @returns {Object}
         */
        measureText : function(font, text) {
            var dim = {};
            dim.width = TextRuler.measureWidth(font, text);
            dim.height = TextRuler.measureHeight(font);
            return dim;
        }
    };
    return TextRuler;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Paths',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.FillableShape',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, FillableShape, Math) {
	/**
	 * This class defines closed paths
	 * 
	 * @name sap.riv.graphics.shape.Paths
	 * @class
	 * @augments sap.riv.graphics.shape.FillableShape
	 */
	var Paths = ObjectUtils.derive(FillableShape,
			{
				constructor : function() {
					this._subPaths = [];
					this._interpolatedVertices = [];
				},

				_inplotArc : function(c0, sa, ea, r, vtx) {
					// TODO - optimize the interpolation algorithm
					var min = Math.min(sa, ea);
					var max = Math.max(sa, ea);
					var step = (max - min) / 50;
					for ( var i = min; i <= max; i += step) {
						var sinofhas = Math.sin(i);
						var cosofhas = Math.cos(i);
						vtx.push([ c0[0] + cosofhas * r, c0[1] + sinofhas * r ]);
					}
					if (i != max) {
						var sinofhas = Math.sin(max);
						var cosofhas = Math.cos(max);
						vtx.push([ c0[0] + cosofhas * r, c0[1] + sinofhas * r ]);
					}
				},

				_inplotSpline : function(p0, p1, p2, vtx) {
					// TODO - optimize the interpolation algorithm
					var sqrt = Math.sqrt;
					var dx1 = p1[0] - p0[0], dy1 = p1[1] - p0[1], dx2 = p2[0] - p1[0], dy2 = p2[1] - p1[1];
					var ns = Math.floor((sqrt(dx1 * dx1 + dy1 * dy1) + sqrt(dx2 * dx2 + dy2 * dy2)) * 0.25);
					for ( var s = 1; s <= ns; s++) {
						var t = 1 / ns * s, tu = 1 - t;
						var a = tu * tu, b = 2 * t * tu, c = t * t;
						vtx.push([ a * p0[0] + b * p1[0] + c * p2[0], a * p0[1] + b * p1[1] + c * p2[1] ]);
					}
				},

				_inplotBezier : function(p0, p1, p2, p3, vtx) {
					// TODO - optimize the interpolation algorithm
					var sqrt = Math.sqrt;
					var dx1 = p1[0] - p0[0], dy1 = p1[1] - p0[1], dx2 = p2[0] - p1[0], dy2 = p2[1] - p1[1], dx3 = p3[0]
							- p2[0], dy3 = p3[1] - p2[1];
					var ns = Math.floor((sqrt(dx1 * dx1 + dy1 * dy1) + sqrt(dx2 * dx2 + dy2 * dy2) + sqrt(dx3 * dx3
							+ dy3 * dy3)) * 0.25);
					for ( var s = 1; s <= ns; s++) {
						var t = 1 / ns * s, tu = 1 - t;
						var a = tu * tu * tu, b = 3 * t * tu * tu, c = 3 * t * t * tu, d = t * t * t;
						vtx.push([ a * p0[0] + b * p1[0] + c * p2[0] + d * p3[0],
								a * p0[1] + b * p1[1] + c * p2[1] + d * p3[1] ]);
					}
				},

				/**
				 * Create a new subpath with the specified point as its first
				 * (and only) point
				 * 
				 * @name sap.riv.graphics.shape.Paths#moveTo
				 * @function
				 * @param {Number}
				 *            x
				 * @param {Number}
				 *            y
				 * @returns {this}
				 */
				moveTo : function(x, y) {
					if (x !== undefined && y !== undefined) {
						if (this._subPaths.length > 0) {
							this._interpolatedVertices[this._interpolatedVertices.length - 1]
									.push(this._interpolatedVertices[this._interpolatedVertices.length - 1][0]);// close
							// the
							// hit
							// test
							// vertices
							// array
						}
						this._subPaths.push([ {
							cmd : 'orig',
							x : x,
							y : y
						} ]);
						this._interpolatedVertices.push([ [ x, y ] ]);
						return this;
					}
				},
				/**
				 * Mark the last subpath as closed, create a new subpath whose
				 * first point is the same as the previous subpath's first
				 * point, and finally add this new subpath to the path
				 * 
				 * @name sap.riv.graphics.shape.Paths#closeSubPath
				 * @function
				 * @returns {this}
				 */
				closeSubPath : function() {
					if (this._subPaths.length > 0) {
						this._subPaths[this._subPaths.length - 1].push({
							cmd : 'close'
						});
						var iVtx = this._interpolatedVertices[this._interpolatedVertices.length - 1];
						iVtx.push(iVtx[0]);// close the hit test vertices array
						this.moveTo(iVtx[0][0], iVtx[0][1]);
						return this;
					}
				},
				/**
				 * Connect the last point in the subpath to the given point (x,
				 * y) using a straight line, and must then add the given point
				 * (x, y) to the subpath.
				 * 
				 * @name sap.riv.graphics.shape.Paths#lineTo
				 * @function
				 * @param {Number}
				 *            x
				 * @param {Number}
				 *            y
				 * @returns {this}
				 */
				lineTo : function(x, y) {
					if (x !== undefined && y !== undefined) {
						if (this._subPaths.length == 0) {
							this.moveTo(x, y);
						} else {
							this._subPaths[this._subPaths.length - 1].push({
								cmd : 'lnto',
								x : x,
								y : y
							});
							this._interpolatedVertices[this._interpolatedVertices.length - 1].push([ x, y ]);
						}
						return this;
					}
				},
				/**
				 * Connect the last point in the subpath to the given point (x,
				 * y) using a quadratic Bezier curve with control point (cpx,
				 * cpy), and must then add the given point (x, y) to the subpath
				 * 
				 * @name sap.riv.graphics.shape.Paths#splineTo
				 * @function
				 * @param {POINT}
				 *            controlPoint
				 * @param {POINT}
				 *            point
				 * @returns {this}
				 */
				splineTo : function(controlPoint, point) {
					if (controlPoint !== undefined && point !== undefined) {
						if (this._subPaths.length == 0) {
							this.moveTo(controlPoint.x, controlPoint.y);
						}
						this._subPaths[this._subPaths.length - 1].push({
							cmd : 'spln',
							cx : controlPoint.x,
							cy : controlPoint.y,
							x : point.x,
							y : point.y
						});
						var iVtx = this._interpolatedVertices[this._interpolatedVertices.length - 1];
						this._inplotSpline(iVtx[iVtx.length - 1], [ controlPoint.x, controlPoint.y ], [ point.x,
								point.y ], iVtx);
						return this;
					}
				},
				/**
				 * connect the last point in the subpath to the given point (x,
				 * y) using a cubic Bezier curve with control points (cp1x,
				 * cp1y) and (cp2x, cp2y). Then, it must add the point (x, y) to
				 * the subpath
				 * 
				 * @name sap.riv.graphics.shape.Paths#bezierCurveTo
				 * @function
				 * @param {POINT}
				 *            controlPoint1
				 * @param {POINT}
				 *            controlPoint2
				 * @param {POINT}
				 *            point
				 * @returns {this}
				 */
				bezierCurveTo : function(controlPoint1, controlPoint2, point) {
					if (controlPoint1 !== undefined && controlPoint2 !== undefined && point !== undefined) {
						if (this._subPaths.length == 0) {
							this.moveTo(controlPoint1.x, controlPoint1.y);
						}
						this._subPaths[this._subPaths.length - 1].push({
							cmd : 'bcur',
							c1x : controlPoint1.x,
							c1y : controlPoint1.y,
							c2x : controlPoint2.x,
							c2y : controlPoint2.y,
							x : point.x,
							y : point.y
						});
						var iVtx = this._interpolatedVertices[this._interpolatedVertices.length - 1];
						this._inplotBezier(iVtx[iVtx.length - 1], [ controlPoint1.x, controlPoint1.y ], [
								controlPoint2.x, controlPoint2.y ], [ point.x, point.y ], iVtx);
						return this;
					}
				},
				/**
				 * Draw arc using control point and radius.
				 * 
				 * @name sap.riv.graphics.shape.Paths#arcTo
				 * @function
				 * @param {POINT}
				 *            controlPoint1
				 * @param {POINT}
				 *            controlPoint2
				 * @param {Number}
				 *            radius
				 * @returns {this}
				 */
				arcTo : function(point1, point2, radius) {
					if (point1 !== undefined && point2 !== undefined && radius > 0) {
						if (this._subPaths.length == 0) {
							this.moveTo(point1.x, point1.y);
						}
						this._subPaths[this._subPaths.length - 1].push({
							cmd : 'arct',
							c1x : point1.x,
							c1y : point1.y,
							c2x : point2.x,
							c2y : point2.y,
							r : radius
						});
						// TODO interpolate the intermediate point
						this._interpolatedVertices[this._interpolatedVertices.length - 1].push([ point2.x, point2.y ]);
						return this;
					}
				},
				/**
				 * Draw arc using a set of parameters.
				 * 
				 * @name sap.riv.graphics.shape.Paths#arc
				 * @function
				 * @param {POINT}
				 *            point
				 * @param {Number}
				 *            radius
				 * @param {Number}
				 *            startAngle
				 * @param {Number}
				 *            endAngle
				 * @param {Boolean}
				 *            [clockwise]
				 * @returns {this}
				 */
				arc : function(point, radius, startAngle, endAngle, clockwise) {
					if (point !== undefined && startAngle !== undefined && radius > 0 && endAngle !== undefined) {
						if (startAngle !== endAngle) {
							if (this._subPaths.length == 0) {
								this._subPaths.push([ {
									cmd : 'arc',
									x : point.x,
									y : point.y,
									sa : startAngle,
									ea : endAngle,
									r : radius,
									cw : clockwise !== undefined ? clockwise : false
								} ]);
								var iVtx = [];
								this._inplotArc([ point.x, point.y ], startAngle, endAngle, radius, iVtx);
								this._interpolatedVertices.push(iVtx);
							} else {
								this._subPaths[this._subPaths.length - 1].push({
									cmd : 'arc',
									x : point.x,
									y : point.y,
									sa : startAngle,
									ea : endAngle,
									r : radius,
									cw : clockwise !== undefined ? clockwise : false
								});
								var iVtx = this._interpolatedVertices[this._interpolatedVertices.length - 1];
								this._inplotArc([ point.x, point.y ], startAngle, endAngle, radius, iVtx);
							}
						}
						return this;
					}
				},
				/**
				 * Create a new subpath containing just the four points (x, y),
				 * (x+w, y), (x+w, y+h), (x, y+h), with those four points
				 * connected by straight lines, and must then mark the subpath
				 * as closed. It must then create a new subpath with the point
				 * (x, y) as the only point in the subpath.
				 * 
				 * @name sap.riv.graphics.shape.Paths#rect
				 * @function
				 * @param {Number}
				 *            x
				 * @param {Number}
				 *            y
				 * @param {Number}
				 *            w
				 * @param {Number}
				 *            h
				 * @returns {this}
				 */
				rect : function(x, y, w, h) {
					if (x !== undefined && y !== undefined && w > 0 && h > 0) {
						this._subPaths.push([ {
							cmd : 'rect',
							x : x,
							y : y,
							w : w,
							h : h
						} ]);
						this._interpolatedVertices.push([ [ x, y ], [ x + w, y ], [ x + w, y + h ], [ x, y + h ],
								[ x, y ] ]);
						this.moveTo(x, y);
						return this;
					}
				},
				/**
				 * Reset the paths to empty.
				 * 
				 * @name sap.riv.graphics.shape.Paths#reset
				 * @function
				 * 
				 * @returns {this} this object
				 */
				reset : function() {
					this._subPaths.splice(0, this._subPaths.length);
					this._interpolatedVertices.splice(0, this._subPaths.length);
				},

				doDraw : function(drawingContext) {
					var dCtx = drawingContext;
					dCtx.beginPath();
					for ( var si = 0, spth, spths = this._subPaths, slen = spths.length; si < slen; si++) {
						spth = spths[si];// sub-path
						for ( var di = 0, d, dlen = spth.length; di < dlen; di++) {
							d = spth[di];
							switch (d.cmd) {
							case 'orig':
								dCtx.moveTo(d.x, d.y);
								break;
							case 'close':
								dCtx.closePath();
								break;
							case 'lnto':
								dCtx.lineTo(d.x, d.y);
								break;
							case 'spln':
								dCtx.quadraticCurveTo(d.cx, d.cy, d.x, d.y);
								break;
							case 'bcur':
								dCtx.bezierCurveTo(d.c1x, d.c1y, d.c2x, d.c2y, d.x, d.y);
								break;
							case 'arct':
								dCtx.arcTo(d.c1x, d.c1y, d.c2x, d.c2y, d.r);
								break;
							case 'arc':
								dCtx.arc(d.x, d.y, d.r, d.sa, d.ea, !d.cw);
								break;
							case 'rect':
								dCtx.rect(d.x, d.y, d.w, d.h);
								break;
							}
						}
					}

					if (this.fillingColor()) {
						// we won't close path enthusiastically, but if you want
						// to fill, we close path for you
						dCtx.closePath();
						this.fillShape(dCtx);
					}
					this.drawBorder(dCtx);
				},

				doPointInTest : (function() {
					var isLeft = function(sp, ep, tp) {
						return ((ep[0] - sp[0]) * (tp[1] - sp[1]) - (tp[0] - sp[0]) * (ep[1] - sp[1]));
					};
					return function(point) {
						var wn = 0;
						var x = point.x, y = point.y;
						var p = [ x, y ];
						for ( var i = 0, vtx = this._interpolatedVertices, elen = vtx.length; i < elen; i++) {
							for ( var j = 0, spvtx = vtx[i], selen = spvtx.length - 1; j < selen; j++) {
								if (spvtx[j][1] <= y) {
									if (spvtx[j + 1][1] > y)
										if (isLeft(spvtx[j], spvtx[j + 1], p) > 0)
											++wn;
								} else {
									if (spvtx[j + 1][1] <= y)
										if (isLeft(spvtx[j], spvtx[j + 1], p) < 0)
											--wn;
								}
							}
							if (wn != 0) {
								return true;
							}
						}
						return false;
					};
				})()
			});
	return Paths;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Rectangle',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.DrawableRect',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, CanvasHelper, DrawableRect) {
	/**
	 * This class defines Rectangle
	 * 
	 * @name sap.riv.graphics.shape.Rectangle
	 * @class
	 * @augments sap.riv.graphics.shape.DrawableRect
	 */
	var Rectangle = ObjectUtils.derive(DrawableRect, {
		constructor : function() {
			this._fill = undefined;
		},

		/**
		 * Get or set the color of the rectangle, the color setting should be
		 * CSSColor serialized string or as follow to define gradient
		 * 
		 * <pre>
		 * {
		 *      t: 'lg'|'rg', //line gradient or radial gradient
		 *      s: { x:## , y:## }, //the start position of the gradient
		 *      e: { x:## , y:## }, //the end position of the gradient
		 *      st: [
		 *              {
		 *                  o: //the stop offset
		 *                  v: //the stop color
		 *              },...
		 *          ] //the color stops of the gradient
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.graphics.shape.Rectangle#color
		 * @function
		 * @param {CSSColor|Object}
		 *            color the color of the rectangle
		 * @returns {this|CSSColor|CanvasGradient}
		 */
		color : function(color) {
			if (color !== undefined) {
				if (color !== false) {
					this._fill = CanvasHelper.createColorStyle(color);
				} else {
					this._fill = undefined;
				}
				return this;
			}
			if (this._fill) {
				return this._fill;
			}
		},

		drawInRect : function(drawingContext) {
			if (this._fill) {
				drawingContext.save();
				drawingContext.setFillStyle(this._fill);
				drawingContext.fill();
				drawingContext.restore();
			}
		}
	});
	return Rectangle;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(Observable, ObjectUtils, LinkedHashMap, FuncUtils) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}

	/**
	 * The mask used to specify the auto resizing behavior
	 * 
	 * @name sap.riv.vizkit.UIComponent.Autosizing
	 * @class
	 */
	var ar = {
		/**
		 * Mark width & height is not flexible when its parent component's size
		 * changed
		 * 
		 * @field
		 * 
		 */
		None : 0,
		/**
		 * Mark the left margin is flexible
		 * 
		 * @field
		 */
		FlexibleLeftMargin : 1 << 0,
		/**
		 * Mark the width is flexible
		 * 
		 * @field
		 */
		FlexibleWidth : 1 << 1,
		/**
		 * Mark the right margin is flexible
		 * 
		 * @field
		 */
		FlexibleRightMargin : 1 << 2,
		/**
		 * Mark the top margin is flexible
		 * 
		 * @field
		 */
		FlexibleTopMargin : 1 << 3,
		/**
		 * Mark the height is flexible
		 * 
		 * @field
		 */
		FlexibleHeight : 1 << 4,
		/**
		 * Mark the bottom margin is flexible
		 * 
		 * @field
		 */
		FlexibleBottomMargin : 1 << 5
	};

	var id = 0;
	var nextId = function() {
		return id++;
	};

	/**
	 * This class defines UI component which serves as the super class of every
	 * controls
	 * 
	 * @name sap.riv.vizkit.UIComponent
	 * @class
	 * @augments sap.riv.core.utils.Observable
	 */
	var UIComponent = ObjectUtils
			.derive(
					Observable,
					/**
					 * @lends sap.riv.vizkit.UIComponent
					 * 
					 */
					{
						events : [ 'widthChanged', 'heightChanged', 'sizeChanged', 'positionChanged', 'anchorChanged',
								'beforeShow', 'afterShow', 'beforeHide', 'afterHide', 'focusin', 'focusout', 'focus',
								'blur', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'mousemove', 'click',
								'dblclick', 'touchstart', 'touchmove', 'touchend', 'touchcancel' ],
						/**
						 * @constructs
						 * @param {Object}
						 *            options the options to initialize the UI
						 *            component
						 * @param {Boolean}
						 *            [options.hidden] whether the UI component
						 *            is hidden
						 * @param {Integer}
						 *            [options.autoresizingMask] the bitwise
						 *            combination of the autoresizing mask,
						 *            default is
						 *            {@link  sap.riv.vizkit.UIComponent.Autosizing#None}
						 * @param {Object}
						 *            [options.anchor] the anchor point of the
						 *            UI component, default is
						 * 
						 * <pre>
						 * {
						 * 	x : 0.5,
						 * 	y : 0.5
						 * }
						 * </pre>
						 * 
						 * @param {Object}
						 *            [options.position] the position of the UI
						 *            component, default is
						 * 
						 * <pre>
						 * {
						 * 	x : 0,
						 * 	y : 0
						 * }
						 * </pre>
						 * 
						 * @param {Object}
						 *            [options.size] the size of the UI
						 *            component, default is
						 * 
						 * <pre>
						 * {
						 * 	w : 0,
						 * 	h : 0
						 * }
						 * </pre>
						 */
						constructor : function(options) {
							options = options || {};

							var _nextId = nextId();

							this._id = options.id ? options.id + '_' + _nextId : _nextId;

							this._attached = false;// a internal flag indicates
							// if the underlying div is
							// attached to DOM tree

							this._container = undefined;// DOM div container for
							// this ui component

							this._superComp = undefined;

							this._subComps = new LinkedHashMap();

							this._hidden = false;

							this._clipToBound = true;

							this._parentVisible = false;

							this._printable = true;

							this._autoresizeSubComponents = true;

							this._autoresizingMask = ar.None;

							this._gestureDetectors = [];

							this._bounds = {
								x : 0,
								y : 0,
								width : 1,
								height : 1
							};
							this._position = {
								x : 0,
								y : 0
							};
							this._anchorPoint = {
								x : 0.5,
								y : 0.5
							};
							this._init_(options);
						},

						_init_ : function(options) {
							this._container = $(document.createElement('div')).attr('id', this._id).css('position',
									'absolute').css({
								'font-size' : '10px',
								'box-sizing' : 'border-box',
								'-moz-box-sizing' : 'border-box',
								'-ms-box-sizing' : 'border-box',
								'-webkit-box-sizing' : 'border-box'
							}).data('selfComp', this);
							if (options.clipToBound === false) {
								this._container.css('overflow', 'visible');
								this._clipToBound = false;
							} else {
								this._container.css('overflow', 'hidden');
							}
							if (options.hidden === true) {
								this._container.css('display', 'none');
								this._hidden = true;
							}
							if (options.autoSizingMask != undefined) {
								this._autoresizingMask = options.autoSizingMask;
							}
							if (options.anchor) {
								this._anchorPoint.x = options.anchor.x;
								this._anchorPoint.y = options.anchor.y;
								delete options.anchor;
							}
							if (options.position) {
								this._position.x = options.position.x;
								this._position.y = options.position.y;

								this._container
										.css('left', this._position.x - this._anchorPoint.x * this._bounds.width);
								this._container
										.css('top', this._position.y - this._anchorPoint.y * this._bounds.height);
								delete options.position;
							}

							if (options.size) {
								this._bounds.width = options.size.w;
								this._bounds.height = options.size.h;
								this._container.width(this._bounds.width);
								this._container.height(this._bounds.height);
								delete options.size;
							}

							this._registerMandatoryHandler();

						},

						_registerMandatoryHandler : function() {
							this.on([ {
								eventName : 'sizeChanged',
								listener : this._updateContainerSize,
								scope : this
							}, {
								eventName : 'heightChanged',
								listener : this._updateContainerHeight,
								scope : this
							}, {
								eventName : 'widthChanged',
								listener : this._updateContainerWidth,
								scope : this
							}, {
								eventName : 'positionChanged',
								listener : this._updateContainerPos,
								scope : this
							}, {
								eventName : 'anchorChanged',
								listener : this._updateContainerAnchor,
								scope : this
							} ]);
						},

						_updateContainerSize : function(os, ns) {
							this._container.width(ns.width);
							this._container.height(ns.height);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('left', this._position.x - this._anchorPoint.x * ns.width);
								this._container.css('top', this._position.y - this._anchorPoint.y * ns.height);
							}
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerWidth : function(ow, nw) {
							this._container.width(nw);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('left', this._position.x - this._anchorPoint.x * nw);
							}
							var os = {
								height : this._bounds.height,
								width : ow
							}, ns = {
								height : this._bounds.height,
								width : nw
							};
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerHeight : function(oh, nh) {
							this._container.height(nh);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('top', this._position.y - this._anchorPoint.y * nh);
							}
							var os = {
								height : oh,
								width : this._bounds.width
							}, ns = {
								height : nh,
								width : this._bounds.width
							};
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerPos : function(op, np) {
							this._container.css('left', np.x - this._anchorPoint.x * this._bounds.width);
							this._container.css('top', np.y - this._anchorPoint.y * this._bounds.height);
						},

						_updateContainerAnchor : function(oap, nap) {
							this._container.css('left', this._position.x - nap.x * this._bounds.width);
							this._container.css('top', this._position.y - nap.y * this._bounds.height);
						},

						_markAttached_ : function() {
							this._attached = true;
							var subCompItr = this._subComps.getIterator();
							while (subCompItr.hasMore()) {
								subCompItr.next().value._markAttached_();
							}
							this._handleSubCompShow(this);
						},

						_markDetached_ : function() {
							this._attached = false;
							var subCompItr = this._subComps.getIterator();
							while (subCompItr.hasMore()) {
								subCompItr.next().value._markDetached_();
							}
						},

						/**
						 * Get the id of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#id
						 * @function
						 * @returns {String} the unique id of the component
						 */
						id : function() {
							return this._id;
						},
						/**
						 * Mark the component as hidden, if the component is
						 * already marked as hidden, nothing will happen;
						 * Whether the component will be shown and whether the
						 * events <b>beforeHide</b>, <b>afterHide</b> and the
						 * call-back methods <b>doBeforeHide</b>,
						 * <b>doAfterHide</b> will get triggered depend on
						 * whether two more conditions are true: 1, all of its
						 * ancestors are marked as shown. 2, the component is
						 * currently attached to DOM.
						 * 
						 * @name sap.riv.vizkit.UIComponent#markHide
						 * @function
						 * @returns {this}
						 */
						markHide : function() {
							if (this._hidden === false) {
								if (this._attached && this._parentVisible) {
									this.doBeforeHide();
									this.fireEvent('beforeHide');
								}
								this._hidden = true;
								this._container.css('display', 'none');
								if (this._attached && this._parentVisible) {
									this.doAfterHide();
									this.fireEvent('afterHide');
									var subCompItr = this._subComps.getIterator();
									while (subCompItr.hasMore()) {
										this._handleSubCompHide(subCompItr.next().value);
									}
								}
							}
							return this;
						},

						_handleSubCompHide : function(comp) {
							if (comp._parentVisible && !comp._hidden) {
								comp.doBeforeHide();
								comp.fireEvent('beforeHide');
								comp.doAfterHide();
								comp.fireEvent('afterHide');
							}
							// mark all the descendant components's
							// parentVisible as false.
							comp._parentVisible = false;
							var subCompItr = comp._subComps.getIterator();
							while (subCompItr.hasMore()) {
								comp._handleSubCompHide(subCompItr.next().value);
							}
						},

						/**
						 * Mark the component as shown, if the component is
						 * already marked as shown, nothing will happen; Whether
						 * the component will be shown and whether the events
						 * <b>beforeShow</b>, <b>afterShow</b> and the
						 * call-back methods <b>doBeforeShow</b>,
						 * <b>doAfterShow</b> will get triggered depend on
						 * whether two more conditions are true: 1, all of its
						 * ancestors are marked as shown. 2, the component is
						 * currently attached to DOM.
						 * 
						 * @name sap.riv.vizkit.UIComponent#markShow
						 * @function
						 * @returns {this}
						 */
						markShow : function() {
							if (this._hidden === true) {
								if (this._attached && this._parentVisible) {
									this.doBeforeShow();
									this.fireEvent('beforeShow');
								}
								this._hidden = false;
								this._container.css('display', 'block');
								if (this._attached && this._parentVisible) {
									this.doAfterShow();
									this.fireEvent('afterShow');
									var subCompItr = this._subComps.getIterator();
									while (subCompItr.hasMore()) {
										this._handleSubCompShow(subCompItr.next().value);
									}
								}
							}
							return this;
						},

						_handleSubCompShow : function(comp) {
							// whether parent is visible
							var superComp = comp.superComponent();
							comp._parentVisible = !superComp._hidden && superComp._parentVisible;
							if (comp._parentVisible && !comp._hidden) {
								// whether needs to show
								comp.doBeforeShow();
								comp.fireEvent('beforeShow');
								comp.doAfterShow();
								comp.fireEvent('afterShow');
							}
							var subCompItr = comp._subComps.getIterator();
							while (subCompItr.hasMore()) {
								comp._handleSubCompShow(subCompItr.next().value);
							}
						},

						clipToBound : function(clipToBound) {
							if (clipToBound !== undefined) {
								if (this._clipToBound !== clipToBound) {
									this._clipToBound = clipToBound;
									if (this._clipToBound) {
										this._container.css('overflow', 'hidden');
									} else {
										this._container.css('overflow', 'visible');
									}
								}
								return this;
							} else {
								return this._clipToBound;
							}
						},

						/**
						 * Get the current visibility of the component, the
						 * visibility is affected by the component's
						 * hidden/shown status, whether it's attached to DOM,
						 * whether it's ancestor components are shown.
						 * 
						 * 
						 * @name sap.riv.vizkit.UIComponent#visibility
						 * @function
						 * @returns {Boolean}
						 */
						visibility : function() {
							return !this._hidden && this._attached && this._parentVisible;
						},

						/**
						 * Get and set the printable property of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#printable
						 * @function
						 * @param {undefined|Boolean}
						 *            printable
						 * @returns {this|Boolean}
						 */
						printable : function(printable) {
							if (printable !== undefined) {
								if (this._printable !== printable) {
									this._printable = printable;
								}
								return this;
							} else {
								return this._printable;
							}
						},

						/**
						 * Get and set whether the component should resize
						 * automatically when its parent's size changed
						 * 
						 * @name sap.riv.vizkit.UIComponent#printable
						 * @function
						 * @param {undefined|Boolean}
						 *            autoresize
						 * @returns {this|Boolean}
						 */
						autoresizeSubComponents : function(autoresize) {
							if (autoresize !== undefined) {
								if (this._autoresizeSubComponents !== autoresize) {
									this._autoresizeSubComponents = autoresize;
								}
								return this;
							} else {
								return this._autoresizeSubComponents;
							}
						},

						/**
						 * Get and set the autoresizing mask of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#autoresizingMask
						 * @function
						 * @param {undefined|Integer}
						 *            mask
						 * @returns {this|Integer}
						 */
						autoresizingMask : function(mask) {
							if (mask !== undefined) {
								if (this._autoresizingMask !== mask) {
									this._autoresizingMask = mask;
								}
								return this;
							} else {
								return this._autoresizingMask;
							}
						},
						/**
						 * Get and set the bounds of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#bounds
						 * @function
						 * @param {undefined|Object}
						 *            bounds the new bounds of the component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 *      width : ##,
						 *      height : ##
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						bounds : function(bounds) {
							if (bounds) {
								var ob = this._bounds, nb = bounds;
								this._bounds.x = nb.x;
								this._bounds.y = nb.y;
								if (ob.width !== nb.width || ob.height !== nb.height) {
									var os = {
										width : ob.width,
										height : ob.height
									};
									var ns = {
										width : nb.width,
										height : nb.height
									};
									this._bounds.width = nb.width;
									this._bounds.height = nb.height;
									this.fireEvent('sizeChanged', os, ns);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._bounds);
							}
						},
						/**
						 * Get the position of the component, the position is in
						 * Page coordinate system
						 * 
						 * @name sap.riv.vizkit.UIComponent#pagePosition
						 * @function
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {Object}
						 */
						pagePosition : function() {
							var offset = this._container.offset();
							return {
								x : offset.left,
								y : offset.top
							};
						},
						/**
						 * Get and set the position of the component, the
						 * position is in it's direct super component's
						 * coordinate system
						 * 
						 * @name sap.riv.vizkit.UIComponent#position
						 * @function
						 * @param {undefined|Object}
						 *            position the new position of the
						 *            component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						position : function(position) {
							if (position) {
								var op = this._position, np = position;
								if (op.x !== np.x || op.y !== np.y) {
									var o = {
										x : op.x,
										y : op.y
									};
									var n = {
										x : np.x,
										y : np.y
									};
									op.x = np.x;
									op.y = np.y;
									this.fireEvent('positionChanged', o, n);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._position);
							}
						},
						/**
						 * Get and set the size of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#size
						 * @function
						 * @param {undefined|Object}
						 *            size the new size of the component:
						 * 
						 * <pre>
						 * {
						 *      width : ##,
						 *      height : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object}
						 */
						size : function(size) {
							if (size) {
								var os = {
									width : this._bounds.width,
									height : this._bounds.height
								};
								if (os.width !== size.width || os.height !== size.height) {
									this._bounds.width = size.width;
									this._bounds.height = size.height;
									this.fireEvent('sizeChanged', os, size);
								}
								return this;
							} else {
								return {
									width : this._bounds.width,
									height : this._bounds.height
								};
							}
						},
						/**
						 * Get and set the width of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#width
						 * @function
						 * @param {undefined|Number}
						 *            width the new width of the component:
						 * 
						 * 
						 * @returns {this|Number}
						 */
						width : function(width) {
							if (width) {
								var ow = this._bounds.width;
								if (ow !== width) {
									this._bounds.width = width;
									this.fireEvent('widthChanged', ow, width);
								}
								return this;
							} else {
								return this._bounds.width;
							}
						},
						/**
						 * Get and set the height of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#height
						 * @function
						 * @param {undefined|Number}
						 *            height the new height of the component:
						 * 
						 * 
						 * @returns {this|Number}
						 */
						height : function(height) {
							if (height) {
								var oh = this._bounds.height;
								if (oh !== height) {
									this._bounds.height = height;
									this.fireEvent('heightChanged', oh, height);
								}
								return this;
							} else {
								return this._bounds.height;
							}
						},
						/**
						 * Get and set the anchor of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#anchorPoint
						 * @function
						 * @param {undefined|Object}
						 *            anchorPoint the new anchor of the
						 *            component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						anchorPoint : function(anchorPoint) {
							if (anchorPoint) {
								var oap = this._anchorPoint, nap = anchorPoint;
								if (oap.x !== nap.x || oap.y !== nap.y) {
									var o = {
										x : oap.x,
										y : oap.y
									};
									var n = {
										x : nap.x,
										y : nap.y
									};
									oap.x = nap.x;
									oap.y = nap.y;
									this.fireEvent('anchorChanged', o, n);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._anchorPoint);

							}
						},
						/**
						 * Get and set the frame of the component
						 * 
						 * @name sap.riv.vizkit.UIComponent#frame
						 * @function
						 * @param {undefined|Object}
						 *            rect the new frame of the component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 *      width : ##,
						 *      height : ##
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						frame : function(rect) {
							if (rect) {
								var ob = this._bounds, op = this._position;
								var npx = rect.x + rect.width * this._anchorPoint.x;
								var npy = rect.y + rect.height * this._anchorPoint.y;
								var posChanged = false, o = undefined, n = undefined, sizeChanged = false, os = undefined, ns = undefined;
								if (ob.width !== rect.width || ob.height !== rect.height) {
									os = {
										width : ob.width,
										height : ob.height
									};
									ns = {
										width : rect.width,
										height : rect.height
									};
									ob.width = rect.width;
									ob.height = rect.height;
									sizeChanged = true;
								}
								if (op.x !== npx || op.y !== npy) {
									o = {
										x : op.x,
										y : op.y
									};
									n = {
										x : npx,
										y : npy
									};
									op.x = npx;
									op.y = npy;
									posChanged = true;
								}
								if (posChanged) {
									this.fireEvent('positionChanged', o, n);
								}
								if (sizeChanged) {
									this.fireEvent('sizeChanged', os, ns);
								}
								return this;
							} else {
								return {
									x : this._position.x - this._anchorPoint.x * this._bounds.width,
									y : this._position.y - this._anchorPoint.y * this._bounds.height,
									width : this._bounds.width,
									height : this._bounds.height
								};
							}
						},
						/**
						 * Get the parent component
						 * 
						 * @name sap.riv.vizkit.UIComponent#superComponent
						 * @function
						 * @param {sap.riv.vizkit.UIComponent}
						 * 
						 */
						superComponent : function() {
							return this._superComp;
						},
						/**
						 * Get the parent component
						 * 
						 * @name sap.riv.vizkit.UIComponent#subComponents
						 * @function
						 * @param {sap.riv.core.utils.LinkedHashMap}
						 * 
						 */
						subComponents : function() {
							return this._subComps;
						},
						/**
						 * Add a component as a child component, the visibility
						 * related events and call-back methods will get
						 * triggered on the component tree rooted at the
						 * detached component, if the component in the tree is
						 * visible.
						 * 
						 * @name sap.riv.vizkit.UIComponent#addSubComponent
						 * @function
						 * @param {this}
						 *            return this component
						 * @throws {ExistedParent}
						 */
						addSubComponent : function(subComp) {
							if (subComp) {
								if (subComp._superComp === undefined) {
									subComp._superComp = this;
									this._subComps.add(subComp.id(), subComp);
									this._container.append(subComp._container);
									if (this._attached) {
										subComp._markAttached_();
									}
									return this;
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Detach this component from its parent, the detached
						 * component is not destroyed and could be reattached
						 * later. the visibility related events and call-back
						 * methods will get triggered on the component tree
						 * rooted at the detached component, if the component in
						 * the tree is visible.
						 * 
						 * @name sap.riv.vizkit.UIComponent#detachFromSuperComponent
						 * @function
						 */
						detachFromSuperComponent : function() {
							if (this._superComp) {
								if (this._superComp._attached) {
									this._superComp._handleSubCompHide(this);
									this._markDetached_();
								}
								this._superComp._subComps.remove(this.id());
								this._container.detach();
								this._superComp = undefined;
							}
						},
						/**
						 * Remove this component from its parent, the remove
						 * component is destroyed including its subcomponent,
						 * and should not intend for reuse.
						 * 
						 * @name sap.riv.vizkit.UIComponent#detachFromSuperComponent
						 * @function
						 */
						removeFromSuperComponent : function() {
							if (this._superComp) {
								this._superComp._subComps.remove(this.id());
								this._container.remove();
								if (this._superComp._attached)
									this._markDetached_();
								this._superComp = undefined;

							}
						},
						/**
						 * Insert a component as a child component before other
						 * component, the visibility related events and
						 * call-back methods will get triggered on the component
						 * tree rooted at the detached component, if the
						 * component in the tree is visible.
						 * 
						 * @name sap.riv.vizkit.UIComponent#insertBeforeSubComponent
						 * @function
						 * @param {sap.riv.vizkit.UIComponent}
						 *            subComp the component to insert
						 * @param {sap.riv.vizkit.UIComponent}
						 *            beforeComp the component to be inserted
						 *            before
						 */
						insertBeforeSubComponent : function(subComp, beforeComp) {
							if (subComp && beforeComp) {
								if (subComp._superComp === undefined) {
									var newKey = subComp.id();
									var beforeKey = beforeComp.id();
									if (this._subComps.has(beforeKey) && newKey !== beforeKey) {
										subComp._superComp = this;
										this._subComps.insertBefore(newKey, subComp, beforeKey);
										subComp._container.before(beforeComp._container);
										if (this._attached) {
											subComp._markAttached_();
										}
									}
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Insert a component as a child component after other
						 * component, the visibility related events and
						 * call-back methods will get triggered on the component
						 * tree rooted at the detached component, if the
						 * component in the tree is visible.
						 * 
						 * @name sap.riv.vizkit.UIComponent#insertAfterSubComponent
						 * @function
						 * @param {sap.riv.vizkit.UIComponent}
						 *            subComp the component to insert
						 * @param {sap.riv.vizkit.UIComponent}
						 *            afterComp the component to be inserted
						 *            before
						 */
						insertAfterSubComponent : function(subComp, afterComp) {
							if (subComp && afterComp) {
								if (subComp._superComp === undefined) {
									var newKey = subComp.id();
									var afterKey = afterComp.id();
									if (this._subComps.has(afterKey) && newKey !== afterKey) {
										subComp._superComp = this;
										this._subComps.insertAfter(newKey, subComp, afterKey);
										subComp._container.after(afterComp._container);
										if (this._attached) {
											subComp._markAttached_();
										}
									}
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Bring the sub component to the front of other sub
						 * components
						 * 
						 * @name sap.riv.vizkit.UIComponent#bringToFront
						 * @function
						 * @param {sap.riv.vizkit.UIComponent}
						 *            subComp the sub component to move
						 */
						bringToFront : function(subComp) {
							if (subComp && this._subComps.has(subComp.id())
									&& this._subComps.getLastInsert().id() !== subComp.id()) {
								this._subComps.moveToLast(subComp.id());
								subComp._container.detach();
								this._container.append(subComp._container);
							}
						},
						/**
						 * Send the sub component to the back of other sub
						 * component
						 * 
						 * @name sap.riv.vizkit.UIComponent#sendToBack
						 * @function
						 * @param {sap.riv.vizkit.UIComponent}
						 *            subComp the sub component to move
						 */
						sendToBack : function(subComp) {
							if (subComp && this._subComps.has(subComp.id())
									&& this._subComps.getFirstInsert().id() !== subComp.id()) {
								this._subComps.moveToFirst(subComp.id());
								subComp._container.detach();
								this._container.prepend(subComp._container);
							}
						},

						/**
						 * Convert the point in parent's coordinate system to
						 * local point
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointFromSuper
						 * @function
						 * @param {Object}
						 *            pointInSuper
						 * @returns {Object}
						 */
						convertPointFromSuper : function(pointInSuper) {
							var frame = this.frame();
							return {
								x : pointInSuper.x - frame.x,
								y : pointInSuper.y - frame.y
							};
						},
						/**
						 * Convert the point to point in parent's coordinate
						 * system
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointToSuper
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @returns {Object}
						 */
						convertPointToSuper : function(pointInLocal) {
							var frame = this.frame();
							return {
								x : pointInLocal.x + frame.x,
								y : pointInLocal.y + frame.y
							};
						},
						/**
						 * Convert the point in global coordinate system to
						 * local point
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointFromGlobal
						 * @function
						 * @param {Object}
						 *            globalPoint
						 * @returns {Object}
						 */
						convertPointFromGlobal : function(globalPoint) {
							var path = [ this ];
							var currentLevel = this;
							var pointInProgress = globalPoint;
							while (currentLevel._superComp) {
								path.push(currentLevel._superComp);
								currentLevel = currentLevel._superComp;
							}
							while (path.length) {
								currentLevel = path.pop();
								pointInProgress = currentLevel.convertPointFromSuper(pointInProgress);
							}
							return pointInProgress;
						},

						/**
						 * Convert the point to point in global coordinate
						 * system
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointToGlobal
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @returns {Object}
						 */
						convertPointToGlobal : function(pointInLocal) {
							var currentLevel = this;
							var pointInProgress = pointInLocal;
							while (currentLevel) {
								pointInProgress = currentLevel.convertPointToSuper(pointInProgress);
								currentLevel = currentLevel._superComp;
							}
							return pointInProgress;
						},

						/**
						 * Convert the point in source component's coordinate
						 * system to local coordinate system. Two components
						 * should rooted at same component.
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointFromComp
						 * @function
						 * @param {Object}
						 *            pointInSourceComp
						 * @param {sap.riv.vizkit.UIComponent}
						 *            sourceComp
						 * @returns {Object}
						 */
						convertPointFromComp : function(pointInSourceComp, sourceComp) {
							return this.convertPointFromGlobal(sourceComp.convertPointToGlobal(pointInSourceComp));
						},

						/**
						 * Convert the point in local coordinate system to
						 * target Component's coordinate system. Two components
						 * should rooted at same component.
						 * 
						 * @name sap.riv.vizkit.UIComponent#convertPointToComp
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @param {sap.riv.vizkit.UIComponent}
						 *            targetComp
						 * @returns {Object}
						 */
						convertPointToComp : function(pointInLocal, targetComp) {
							return targetComp.convertPointFromGlobal(this.convertPointToGlobal(pointInLocal));
						},

						_resizeSubComp : function(subComp, oldsize, newsize) {
							var origFrame = subComp.frame();
							var x = origFrame.x, y = origFrame.y, width = origFrame.width, height = origFrame.height;
							var ml = x, mr = oldsize.width - x - width, mt = y, mb = oldsize.height - y - height;
							var wdiff = newsize.width - oldsize.width, hdiff = newsize.height - oldsize.height;
							var arMask = subComp._autoresizingMask;
							var horizontalMask = ar.FlexibleLeftMargin | ar.FlexibleWidth | ar.FlexibleRightMargin;
							var verticalMask = ar.FlexibleTopMargin | ar.FlexibleHeight | ar.FlexibleBottomMargin;
							switch (arMask & horizontalMask) {
							case ar.None:
								if (ml !== 0) {
									x += wdiff * ml / (ml + mr);
								}
								break;
							case ar.FlexibleLeftMargin:
								x += wdiff;
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleRightMargin:
							case ar.FlexibleRightMargin:
								break;
							case ar.FlexibleWidth:
								width += wdiff;
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleWidth:
								if (width !== 0) {
									x += wdiff * ml / (ml + width);
									width += wdiff * width / (ml + width);
								}
								break;
							case ar.FlexibleRightMargin | ar.FlexibleWidth:
								if (width !== 0) {
									width += wdiff * width / (mr + width);
								}
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleWidth | ar.FlexibleRightMargin:
								if (oldsize.width !== 0) {
									var r = wdiff / oldsize.width;
									x += x * r;
									width += width * r;
								}
								break;
							}
							switch (arMask & verticalMask) {
							case ar.None:
								if (mt !== 0) {
									y += hdiff * mt / (mt + mb);
								}
								break;
							case ar.FlexibleTopMargin:
								y += hdiff;
								break;
							case ar.FlexibleTopMargin | ar.FlexibleBottomMargin:
							case ar.FlexibleBottomMargin:
								break;
							case ar.FlexibleHeight:
								height += hdiff;
								break;
							case ar.FlexibleTopMargin | ar.FlexibleHeight:
								if (height !== 0) {
									y += hdiff * mt / (mt + height);
									height += hdiff * height / (mt + height);
								}
								break;
							case ar.FlexibleBottomMargin | ar.FlexibleHeight:
								if (height != 0) {
									height += hdiff * height / (mb + height);
								}
								break;
							case ar.FlexibleTopMargin | ar.FlexibleHeight | ar.FlexibleBottomMargin:
								if (oldsize.height) {
									var r = hdiff / oldsize.height;
									y += y * r;
									height += height * r;
								}
								break;
							}
							return {
								x : x,
								y : y,
								height : height,
								width : width
							};
						},

						_layout : function(oldsize, newsize) {
							if (this._autoresizeSubComponents) {
								var subCompItr = this._subComps.getIterator();
								var subComp, newFrame;
								while (subCompItr.hasMore()) {
									subComp = subCompItr.next().value;
									newFrame = this._resizeSubComp(subComp, oldsize, newsize);
									subComp.frame(newFrame);
								}
							} else if (this.doLayout != FuncUtils.noop && this.doLayout !== undefined) {
								this.doLayout();
							}
						},

						_fireEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								this._superComp._fireEvent_(event);
							}
						},

						_fireMouseEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								event._setCurrentLocalXY_({
									x : event.currentLocalXY().x + this._position.x - this._anchorPoint.x
											* this._bounds.width,
									y : event.currentLocalXY().y + this._position.y - this._anchorPoint.y
											* this._bounds.height
								});
								this._superComp._fireMouseEvent_(event);
							}
						},

						_fireTouchEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								this._superComp._fireTouchEvent_(event);
							}
						},

						/**
						 * Remove all listeners currently attached to the
						 * component
						 * 
						 * @name sap.riv.vizkit.UIComponent#purgeListeners
						 * @function
						 */
						purgeListeners : function() {
							this.callParent('purgeListeners');
							this._registerMandatoryHandler();
						},
						/**
						 * Remove all listeners currently listening on the given
						 * event
						 * 
						 * @name sap.riv.vizkit.UIComponent#removeAllListeners
						 * @function
						 * @param {String}
						 *            eventName
						 */
						removeAllListeners : function(eventName) {
							this.callParent('removeAllListeners', eventName);
							switch (eventName) {
							case 'sizeChanged':
								this.on({
									eventName : 'sizeChanged',
									listener : this._updateContainerSize,
									scope : this
								});
								break;
							case 'heightChanged':
								this.on({
									eventName : 'heightChanged',
									listener : this._updateContainerHeight,
									scope : this
								});
								break;
							case 'widthChanged':
								this.on({
									eventName : 'widthChanged',
									listener : this._updateContainerWidth,
									scope : this
								});
								break;
							case 'positionChanged':
								this.on({
									eventName : 'positionChanged',
									listener : this._updateContainerPos,
									scope : this
								});
								break;
							case 'anchorChanged':
								this.on({
									eventName : 'anchorChanged',
									listener : this._updateContainerAnchor,
									scope : this
								});
								break;
							}
						},
						/**
						 * Add a gesture detector to this component
						 * 
						 * @name sap.riv.vizkit.UIComponent#addGestureDetector
						 * @function
						 * @param {sap.riv.vizkit.GestureDetector}
						 *            detector
						 */
						addGestureDetector : function(detector) {
							if (detector !== undefined) {
								detector._setOwnerComp_(this);
								this._gestureDetectors.push(detector);
							}
						},
						/**
						 * remove a previously added gesture detector to this
						 * component
						 * 
						 * @name sap.riv.vizkit.UIComponent#addGestureDetector
						 * @function
						 * @param {sap.riv.vizkit.GestureDetector}
						 *            detector
						 */
						removeGestureDetector : function(detector) {
							for ( var i = 0, len = this._gestureDetectors.length; i < len; i++) {
								if (this._gestureDetectors[i] === detector) {
									this._gestureDetectors.splice(i, 1);
									detector._setOwnerComp_(undefined);
									len--;
								}
							}
						},

						/**
						 * Returns the farthest descendant uicomponent in the
						 * hierarchy rooted at this component, that contains the
						 * specified point.
						 * 
						 * @name sap.riv.vizkit.UIComponent#hitTest
						 * @param {POINT}
						 *            localXY
						 * @returns {sap.riv.vizkit.UIComponent#}
						 */
						hitTest : function(localXY) {
							var pStack = [ {
								comp : this,
								pointInLocal : localXY,
								subCompsItr : this._subComps.getIterator(true)
							} ];
							var levelInTest, localPoint, comp, subCompsItr;
							while (pStack.length) {
								levelInTest = pStack[pStack.length - 1];
								comp = levelInTest.comp;
								localPoint = levelInTest.pointInLocal;
								subCompsItr = levelInTest.subCompsItr;
								if (comp.visibility()) {
									if (subCompsItr.hasMore()) {
										var subComp = subCompsItr.next().value;
										pStack.push({
											comp : subComp,
											pointInLocal : subComp.convertPointFromSuper(localPoint),
											subCompsItr : subComp._subComps.getIterator(true)
										});
										continue;
									} else if (comp.containsPoint(localPoint)) {
										// find the top layer which contains the
										// point and can
										// respond to event
										return comp;
									}
									pStack.pop();
								} else {
									pStack.pop();
								}
							}
						},

						/**
						 * Test whether the given local point(point in local
						 * coordinate system) is contained in the component's
						 * boundary
						 * 
						 * @name sap.riv.vizkit.UIComponent#containsPoint
						 * @function
						 * @param {Object}
						 *            localPoint the point to test
						 * @returns {Boolean}
						 */
						containsPoint : function(localPoint) {
							var bounds = this.bounds();
							return localPoint.x >= bounds.x && localPoint.x <= (bounds.x + bounds.width)
									&& localPoint.y >= bounds.y && localPoint.y <= (bounds.y + bounds.height);
						},

						printTo : function(drawingCtx) {
							drawingCtx.clearRect(0, 0, this._bounds.width, this._bounds.height);
							this.doPrint(drawingCtx);
						},

						/**
						 * Implement this method to do adhoc sub-components
						 * layout, this method will be called on super component
						 * when its size changed.
						 * 
						 * @name sap.riv.vizkit.UIComponent#doLayout
						 * @function
						 */
						doLayout : FuncUtils.noop,

						/**
						 * Resize component's visual content, when the
						 * component's size changed, this method will be invoked
						 * before layout sub components
						 * 
						 * @name sap.riv.vizkit.UIComponent#doContentResize
						 * @function
						 * @param {Object}
						 *            os the old size of the component
						 * @param {Object}
						 *            ns the new size of the component
						 */
						doContentResize : FuncUtils.noop,

						/**
						 * Print the component visual content into the passed-in
						 * drawing context
						 * 
						 * @name sap.riv.vizkit.UIComponent#doPrint
						 * @function
						 * @param {sap.riv.graphic.DrawingContext}
						 */
						doPrint : FuncUtils.noop,

						/**
						 * This method will get called before the component
						 * becoming hidden
						 * 
						 * @name sap.riv.vizkit.UIComponent#doBeforeHide
						 * @function
						 */
						doBeforeHide : FuncUtils.noop,
						/**
						 * This method will get called after the component is
						 * hided
						 * 
						 * @name sap.riv.vizkit.UIComponent#doAfterHide
						 * @function
						 */
						doAfterHide : FuncUtils.noop,
						/**
						 * This method will get called before the component
						 * becoming visible
						 * 
						 * @name sap.riv.vizkit.UIComponent#doBeforeShow
						 * @function
						 */
						doBeforeShow : FuncUtils.noop,
						/**
						 * This method will get called after the component is
						 * visible
						 * 
						 * @name sap.riv.vizkit.UIComponent#doAfterShow
						 * @function
						 */
						doAfterShow : FuncUtils.noop
					});
	UIComponent.Autosizing = ar;
	return UIComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.BaseRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(FunctionUtils) {
	var baseRenderer = function(layer, options) {
		this._mainLayer = layer;
		this._seriesGroup = [];
		this._eventLisntener = {};
		this._seriesShapes = [];
		this._highlights = [];

		this._initialize(options);
	};

	/**
	 * initialize the base renderer
	 */
	baseRenderer.prototype._initialize = function(options) {

	};

	/**
	 * 
	 * @param seriesGroup
	 *            sap.riv.viz.shared.series.SeriesGroup
	 */
	baseRenderer.prototype.addSeriesGroup = function(seriesGroup) {
		this._seriesGroup.push(seriesGroup);
	};

	/**
	 * Returns series groups.
	 * 
	 * @returns Array SeriesGroup
	 */
	baseRenderer.prototype.getSeriesGroups = function() {
		return this._seriesGroup;
	};

	/**
	 * 
	 * @returns Array SeriesGroup
	 */
	baseRenderer.prototype.resetSeriesGroup = function() {
		this._seriesGroup = [];
	};

	baseRenderer.prototype.getSeriesShapes = function() {
		return this._seriesShapes;
	};

	baseRenderer.prototype.findShape = function(path) {
		if (this._seriesShapes[path.measureIndex]
				&& this._seriesShapes[path.measureIndex][path.dimensionItemIndex]) {
			return this._seriesShapes[path.measureIndex][path.dimensionItemIndex];
		}
	};

	/**
	 * Sets to-highlight paths for the renderer. Renderer is expected to perform
	 * the highlights during chart initialization and re-drawing.
	 * 
	 * @param {Array}
	 *            highlights - To-highlight indexes
	 * 
	 * @param {Boolean}
	 *            layerPrioritization - Whether to prioritize the presence of
	 *            the logical layer of the highlighted shape
	 */
	baseRenderer.prototype.setHighlights = function(highlights, layerPrioritization) {
		this._highlights = highlights;
		this._layerPrioritization = layerPrioritization;
	};

	baseRenderer.prototype.getHighlights = function () {
		return this._highlights;
	};
	
	/**
	 * private function. register event listener
	 * 
	 * @param eventType
	 * @param evnetListener
	 */
	baseRenderer.prototype._addEventListener = function(eventType,
			evnetListener) {
		this._eventLisntener[eventType] = evnetListener;
	};

	/**
	 * 
	 * @returns Event Listener Array
	 */
	baseRenderer.prototype.getEventListener = function() {
		return this._eventLisntener;
	};

	/**
	 * 
	 * @returns layer sap.riv.graphics.Layer
	 */
	baseRenderer.prototype.getLayer = function() {
		return this._mainLayer;
	};

	baseRenderer.prototype.refresh = function() {
		this._mainLayer.setNeedsDisplay();
	};

	/* optional functions */
	/**
	 * @param point
	 *            {x,y} coordination in this.getLayer()
	 * @return dataContextObjects [{seriesIndex:0, dataPointIndex:1, series:
	 *         sap.riv.viz.shared.series.Series }] | null
	 */
	baseRenderer.prototype.getDataContextOnPoint = FunctionUtils.noop;

	/**
	 * 
	 */
	baseRenderer.prototype.highlight = FunctionUtils.noop;

	baseRenderer.prototype.removeHighlights = FunctionUtils.noop;

	/**
	 * @param point
	 *            {x,y} coordination in this.getLayer()
	 * @return dataContextObjects [{seriesIndex:0, dataPointIndex:1, series:
	 *         sap.riv.viz.shared.series.Series }] | null
	 */
	baseRenderer.prototype.hoverOnPoint = FunctionUtils.noop;

	/**
	 * reset the status of hover on point
	 */
	baseRenderer.prototype.onblur = FunctionUtils.noop;

	return baseRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Canvas2DSurface',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
}
],
function Setup(ObjUtils, CanvasHelper, Canvas2DSurface, UIComponent) {
	/**
	 * Base class for all graphics framework powered component
	 * 
	 * @name sap.riv.vizkit.Canvas2DSurfaceComponent
	 * @class
	 * @augments sap.riv.vizkit.UIComponent
	 */
	var Canvas2DSurfaceComponent = ObjUtils.derive(UIComponent,
	/**
	 * @lends sap.riv.vizkit.Canvas2DSurfaceComponent
	 */
	{
		constructor : function(options) {
			this._canvasElement = CanvasHelper.createCanvasElement(this.width(), this.height(), this._container);
			this._canvasSurface = new Canvas2DSurface({
				canvasEl : this._canvasElement
			});
			this._registerEventDispatcher();
		},

		_canvasSurfaceEventDispatcher : function(vizkitUIEvent) {
			this._canvasSurface.dispatchComponentUIEvent(vizkitUIEvent);
		},

		_registerEventDispatcher : function() {

			this.on({
				eventName : 'click',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'dblclick',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'mouseup',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'mousedown',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'mousemove',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'mouseleave',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'touchstart',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'touchmove',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
			this.on({
				eventName : 'touchend',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});

			this.on({
				eventName : 'touchcancel',
				listener : this._canvasSurfaceEventDispatcher,
				scope : this
			});
		},

		purgeListeners : function() {
			this.callParent('purgeListeners');
			this._registerEventDispatcher();
		},

		removeAllListeners : function(eventName) {
			this.callParent('removeAllListeners', eventName);
			switch (eventName) {
			case 'click':
				this.on({
					eventName : 'click',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'dblclick':
				this.on({
					eventName : 'dblclick',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'mouseup':
				this.on({
					eventName : 'mouseup',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'mousedown':
				this.on({
					eventName : 'mousedown',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'mousemove':
				this.on({
					eventName : 'mousemove',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'mouseleave':
				this.on({
					eventName : 'mouseleave',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'touchstart':
				this.on({
					eventName : 'touchstart',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'touchmove':
				this.on({
					eventName : 'touchmove',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'touchend':
				this.on({
					eventName : 'touchend',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			case 'touchcancel':
				this.on({
					eventName : 'touchcancel',
					listener : this._canvasSurfaceEventDispatcher,
					scope : this
				});
				break;
			}
		},

		doContentResize : function(oldSize, newSize) {
			this.callParent('doContentResize', oldSize, newSize);
			if (oldSize.width !== newSize.width) {
				this._canvasSurface.width(newSize.width);
			}
			if (oldSize.height !== newSize.height) {
				this._canvasSurface.height(newSize.height);
			}
		},

		/**
		 * This function returns a 2D surface for displaying visual content.
		 * Subclass could use this surface to draw anything belonging to the
		 * component
		 * 
		 * @final
		 * @name sap.riv.vizkit.Canvas2DSurfaceComponent#getCanvasSurface
		 * @function
		 * @returns {sap.riv.graphics.Canvas2DSurface}
		 */
		getCanvasSurface : function() {
			return this._canvasSurface;
		},

		doPrint : function(drawingCtx) {
			drawingCtx.drawImage(this._canvasElement, 0, 0);
		}
	});
	return Canvas2DSurfaceComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.BasicModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
}
],
function Setup(ObjUtils,FunctionUtils, Observable) {
	var BasicModule = ObjUtils.derive(Observable, {
		constructor : function(options) {
			this._chart_options = ObjUtils.extend(true, {}, options);
			this._dataTree = this._chart_options.dataTree;
			this._metaData = this._chart_options.metaData;
			this._defaultSelectionArmed = true;
			this.addEvents(this.getSupportedAppEvents());
		},

		init : function() {
			this.buildData();
			this.initSeries();
		},

		updateProperties : function(propBag){
			var options = {};
			options.properties = propBag;
			this._chart_options = options;
		},
		
		updateOptions : function(options) {
			this._chart_options = options;
			this._dataTree = this._chart_options.dataTree;
			this._metaData = this._chart_options.metaData;
			this._hasDrawed = false;
		},

		/* mandatory functions, should be implemented by sub classes */

		buildData : FunctionUtils.unsupported,
		
		initSeries : FunctionUtils.unsupported,

		drawSeries : FunctionUtils.unsupported,

		doChartLayout : FunctionUtils.unsupported,

		bindRenderer : FunctionUtils.unsupported,
		
		applyTheme : FunctionUtils.unsupported,

		/**
		 * @return events which can be listened by clients
		 */
		getSupportedAppEvents : FunctionUtils.unsupported,

		/* optional functions */

		marqueeOverPoint : FunctionUtils.noop,

		hoverOnPoint : FunctionUtils.noop,

		clickOnPoint : FunctionUtils.noop
	});
	return BasicModule;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Drawable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, TextRuler, CanvasHelper, Drawable, Math) {
    var decorateText = function(textLine, drawingContext) {
        drawingContext.save();
        var x = textLine._vtx[0][0], y = textLine._vtx[0][1];
        var height = textLine._height;
        // get proper longness for decoration line
        var width = (textLine._width < textLine._textOriginalWidth) ? textLine._width : textLine._textOriginalWidth;
        drawingContext.beginPath();
        var roundXStart = Math.round(x), roundXEnd = Math.round(x + width), roundY;

        //To make a crisp line, if the thickness is even, the start point coords should be integers,
        // else, should be integers plus 0.5, another way is to use fillrect() instead of stroke()
        var startPointOffset = (textLine._decorationLineThickness % 2 === 0) ? 0 : 0.5;

        switch(textLine._textDecoration) {
            case 'overline' :
                roundY = Math.round(y + height / 30) + startPointOffset;
                // drawingContext.fillRect(x, roundY, width, textLine._decorationLineThickness);
                drawingContext.moveTo(roundXStart, roundY);
                drawingContext.lineTo(roundXEnd, roundY);
                break;
            case 'underline':
                roundY = Math.round(y + height * 5 / 6) + startPointOffset;
                // drawingContext.fillRect(x, roundY, width, textLine._decorationLineThickness);
                drawingContext.moveTo(roundXStart, roundY);
                drawingContext.lineTo(roundXEnd, roundY);
                break;
            case 'line-through':
                roundY = Math.round(y + height / 2) + startPointOffset;
                // drawingContext.fillRect(x, roundY, width, textLine._decorationLineThickness);
                drawingContext.moveTo(roundXStart, roundY);
                drawingContext.lineTo(roundXEnd, roundY);
                break;
            default:
        }
        drawingContext.setLineWidth(textLine._decorationLineThickness);
        drawingContext.setStrokeStyle(textLine._textColor);
        drawingContext.stroke();
        drawingContext.restore();
    };
    /**
     * This class defines Text Line
     *
     * @name sap.riv.graphics.shape.TextLine
     * @class
     * @augments sap.riv.graphics.Drawable
     */
    var TextLine = ObjectUtils.derive(Drawable, {
        constructor : function() {
            this._anchor = 'tl';
            this._cornerRadius = 0;
            this._vtx = [[0, 0], [0, 0], [0, 0], [0, 0]];
            // tl,tr,br,bl
            this._font = '10px sans-serif';
            this._height = TextRuler.measureHeight(this._font);
            //this is border width
            this._width = 30;
            this._text = '';
            this._textAlign = 'l';
            this._textColor = '#000000';
            this._strokeAnchor = [0, 0];
            this._adjustVertices();
            this._weight = TextRuler.measureWeight(this._font);
            //the width of complete text
            this._textOriginalWidth = TextRuler.measureWidth(this._font, this._text);
            this._decorationLineThickness = Math.round(this._height * (this._weight === 700 ? 1.5 : 1) / 25);
            this._textDecoration = null;
        },
        _calcVertices : function(anchor, position) {
            var p = position;
            var vtx = this._vtx;
            var width = this._width;
            var height = this._height;
            switch (anchor) {
                case 'tl':
                    vtx[0][0] = p[0];
                    vtx[0][1] = p[1];
                    vtx[1][0] = p[0] + width;
                    vtx[1][1] = p[1];
                    vtx[2][0] = p[0] + width;
                    vtx[2][1] = p[1] + height;
                    vtx[3][0] = p[0];
                    vtx[3][1] = p[1] + height;
                    break;
                case 'tc':
                    vtx[0][0] = p[0] - width / 2;
                    vtx[0][1] = p[1];
                    vtx[1][0] = p[0] + width / 2;
                    vtx[1][1] = p[1];
                    vtx[2][0] = p[0] + width / 2;
                    vtx[2][1] = p[1] + height;
                    vtx[3][0] = p[0] - width / 2;
                    vtx[3][1] = p[1] + height;
                    break;
                case 'tr':
                    vtx[0][0] = p[0] - width;
                    vtx[0][1] = p[1];
                    vtx[1][0] = p[0];
                    vtx[1][1] = p[1];
                    vtx[2][0] = p[0];
                    vtx[2][1] = p[1] + height;
                    vtx[3][0] = p[0] - width;
                    vtx[3][1] = p[1] + height;
                    break;
                case 'rc':
                    vtx[0][0] = p[0] - width;
                    vtx[0][1] = p[1] - height / 2;
                    vtx[1][0] = p[0];
                    vtx[1][1] = p[1] - height / 2;
                    vtx[2][0] = p[0];
                    vtx[2][1] = p[1] + height / 2;
                    vtx[3][0] = p[0] - width;
                    vtx[3][1] = p[1] + height / 2;
                    break;
                case 'br':
                    vtx[0][0] = p[0] - width;
                    vtx[0][1] = p[1] - height;
                    vtx[1][0] = p[0];
                    vtx[1][1] = p[1] - height;
                    vtx[2][0] = p[0];
                    vtx[2][1] = p[1];
                    vtx[3][0] = p[0] - width;
                    vtx[3][1] = p[1];
                    break;
                case 'bc':
                    vtx[0][0] = p[0] - width / 2;
                    vtx[0][1] = p[1] - height;
                    vtx[1][0] = p[0] + width / 2;
                    vtx[1][1] = p[1] - height;
                    vtx[2][0] = p[0] + width / 2;
                    vtx[2][1] = p[1];
                    vtx[3][0] = p[0] - width / 2;
                    vtx[3][1] = p[1];
                    break;
                case 'bl':
                    vtx[0][0] = p[0];
                    vtx[0][1] = p[1] - height;
                    vtx[1][0] = p[0] + width;
                    vtx[1][1] = p[1] - height;
                    vtx[2][0] = p[0] + width;
                    vtx[2][1] = p[1];
                    vtx[3][0] = p[0];
                    vtx[3][1] = p[1];
                    break;
                case 'lc':
                    vtx[0][0] = p[0];
                    vtx[0][1] = p[1] - height / 2;
                    vtx[1][0] = p[0] + width;
                    vtx[1][1] = p[1] - height / 2;
                    vtx[2][0] = p[0] + width;
                    vtx[2][1] = p[1] + height / 2;
                    vtx[3][0] = p[0];
                    vtx[3][1] = p[1] + height / 2;
                    break;
                case 'c':
                    vtx[0][0] = p[0] - width / 2;
                    vtx[0][1] = p[1] - height / 2;
                    vtx[1][0] = p[0] + width / 2;
                    vtx[1][1] = p[1] - height / 2;
                    vtx[2][0] = p[0] + width / 2;
                    vtx[2][1] = p[1] + height / 2;
                    vtx[3][0] = p[0] - width / 2;
                    vtx[3][1] = p[1] + height / 2;
                    break;
            }
            switch (this._textAlign) {
                case 'l':
                    this._strokeAnchor[0] = vtx[0][0];
                    this._strokeAnchor[1] = vtx[0][1] + height / 2;
                    break;
                case 'c':
                    this._strokeAnchor[0] = vtx[0][0] + width / 2;
                    this._strokeAnchor[1] = vtx[0][1] + height / 2;
                    break;
                case 'r':
                    this._strokeAnchor[0] = vtx[0][0] + width;
                    this._strokeAnchor[1] = vtx[0][1] + height / 2;
                    break;
            }
        },
        _adjustVertices : function() {
            var vtx = this._vtx;
            var w = vtx[1][0] - vtx[0][0];
            var h = vtx[3][1] - vtx[0][1];
            switch (this._anchor) {
                case 'tl':
                    this._calcVertices('tl', vtx[0]);
                    break;
                case 'tc':
                    this._calcVertices('tc', [vtx[0][0] + w / 2, vtx[0][1]]);
                    break;
                case 'tr':
                    this._calcVertices('tr', vtx[1]);
                    break;
                case 'rc':
                    this._calcVertices('rc', [vtx[1][0], vtx[1][1] + h / 2]);
                    break;
                case 'br':
                    this._calcVertices('br', vtx[2]);
                    break;
                case 'bc':
                    this._calcVertices('bc', [vtx[2][0] - w / 2, vtx[2][1]]);
                    break;
                case 'bl':
                    this._calcVertices('bl', vtx[3]);
                    break;
                case 'lc':
                    this._calcVertices('lc', [vtx[3][0], vtx[3][1] - h / 2]);
                    break;
                case 'c':
                    this._calcVertices('c', [vtx[0][0] + w / 2, vtx[0][1] + h / 2]);
                    break;
            }
            this._cornerRadius = Math.min(this._width / 2, this._height / 2, this._cornerRadius);
        },
        /**
         * Get or set the top left corner.
         *
         * @name sap.riv.graphics.shape.TextLine#topLeft
         * @function
         * @param {[x,y]}
         *            tl top left corner coordinates
         * @returns {this|[x,y]}
         */
        topLeft : function(tl) {
            if(tl !== undefined) {
                this._anchor = 'tl';
                this._calcVertices('tl', tl);
                return this;
            }
            return {
                x : this._vtx[0][0],
                y : this._vtx[0][1]
            };
        },
        /**
         * Get or set the top center corner.
         *
         * @name sap.riv.graphics.shape.TextLine#topCenter
         * @function
         * @param {[x,y]}
         *            tc top center corner coordinates
         * @returns {this|[x,y]}
         */
        topCenter : function(tc) {
            if(tc !== undefined) {
                this._anchor = 'tc';
                this._calcVertices('tc', tc);
                return this;
            }
            return {
                x : this._vtx[0][0] + this._width / 2,
                y : this._vtx[0][1]
            };
        },
        /**
         * Get or set the top right corner.
         *
         * @name sap.riv.graphics.shape.TextLine#topRight
         * @function
         * @param {[x,y]}
         *            tr top right corner coordinates
         * @returns {this|[x,y]}
         */
        topRight : function(tr) {
            if(tr !== undefined) {
                this._anchor = 'tr';
                this._calcVertices('tr', tr);
                return this;
            }
            return {
                x : this._vtx[1][0],
                y : this._vtx[1][1]
            };
        },
        /**
         * Get or set the right center corner.
         *
         * @name sap.riv.graphics.shape.TextLine#rightCenter
         * @function
         * @param {[x,y]}
         *            rc rignt center corner coordinates
         * @returns {this|[x,y]}
         */
        rightCenter : function(rc) {
            if(rc !== undefined) {
                this._anchor = 'rc';
                this._calcVertices('rc', rc);
                return this;
            }
            return {
                x : this._vtx[1][0],
                y : this._vtx[1][1] + this._height / 2
            };
        },
        /**
         * Get or set the bottom right corner.
         *
         * @name sap.riv.graphics.shape.TextLine#bottomRight
         * @function
         * @param {[x,y]}
         *            br bottom right corner coordinates
         * @returns {this|[x,y]}
         */
        bottomRight : function(br) {
            if(br !== undefined) {
                this._anchor = 'br';
                this._calcVertices('br', br);
                return this;
            }
            return {
                x : this._vtx[2][0],
                y : this._vtx[2][1]
            };
        },
        /**
         * Get or set the bottom center corner.
         *
         * @name sap.riv.graphics.shape.TextLine#bottomCenter
         * @function
         * @param {[x,y]}
         *            bc bottom center corner coordinates
         * @returns {this|[x,y]}
         */
        bottomCenter : function(bc) {
            if(bc !== undefined) {
                this._anchor = 'bc';
                this._calcVertices('bc', bc);
                return this;
            }
            return {
                x : this._vtx[2][0] - this._width / 2,
                y : this._vtx[2][1]
            };
        },
        /**
         * Get or set the bottom left corner.
         *
         * @name sap.riv.graphics.shape.TextLine#bottomLeft
         * @function
         * @param {[x,y]}
         *            bl bottom left corner coordinates
         * @returns {this|[x,y]}
         */
        bottomLeft : function(bl) {
            if(bl !== undefined) {
                this._anchor = 'bl';
                this._calcVertices('bl', bl);
                return this;
            }
            return {
                x : this._vtx[3][0],
                y : this._vtx[3][1]
            };
        },
        /**
         * Get or set the left center corner.
         *
         * @name sap.riv.graphics.shape.TextLine#leftCenter
         * @function
         * @param {[x,y]}
         *            lc left center corner coordinates
         * @returns {this|[x,y]}
         */
        leftCenter : function(lc) {
            if(lc !== undefined) {
                this._anchor = 'lc';
                this._calcVertices('lc', lc);
                return this;
            }
            return {
                x : this._vtx[3][0],
                y : this._vtx[3][1] - this._height / 2
            };
        },
        /**
         * Get or set the center.
         *
         * @name sap.riv.graphics.shape.TextLine#center
         * @function
         * @param {[x,y]}
         *            c center coordinates
         * @returns {this|[x,y]}
         */
        center : function(c) {
            if(c !== undefined) {
                this._anchor = 'c';
                this._calcVertices('c', c);
                return this;
            }
            return {
                x : this._vtx[0][0] + this._width / 2,
                y : this._vtx[0][1] + this._height / 2
            };
        },
        /**
         * Get or set the corner radius. Value should be greater or equals to
         * zero. Zero means no rounded corner.
         *
         * @name sap.riv.graphics.shape.TextLine#cornerRadius
         * @function
         * @param {Number}
         *            radius the corner radius
         * @returns {this|Number}
         */
        cornerRadius : function(radius) {
            if(radius !== undefined) {
                if(radius >= 0) {
                    this._cornerRadius = Math.min(this._width / 2, this._height / 2, radius);
                }
                return this;
            }
            return this._cornerRadius;
        },
        /**
         * Get or set the text font. Value should be in css font serialized
         * string.
         *
         * @name sap.riv.graphics.shape.TextLine#font
         * @function
         * @param {CSSFONT}
         *            cssFont the css font
         * @returns {this|CSSFONT}
         */
        font : function(cssFont) {
            if(cssFont !== undefined) {
                this._font = cssFont;
                var newHeight = TextRuler.measureHeight(this._font);
                var newWeight = TextRuler.measureWeight(this._font);
                var newTextOriginalWidth = TextRuler.measureWidth(this._font, this._text);
                if(this._height !== newHeight) {
                    this._height = newHeight;
                    this._adjustVertices();
                }
                if(this._weight !== newWeight) {
                    this._weight = newWeight;
                }
                if(this._textOriginalWidth !== newTextOriginalWidth) {
                    this._textOriginalWidth = newTextOriginalWidth;
                }
                var newDecorationLineThickness = Math.round(this._height * (this._weight === 700 ? 1.5 : 1) / 25);
                if(this._decorationLineThickness !== newDecorationLineThickness) {
                    this._decorationLineThickness = newDecorationLineThickness;
                }
                return this;
            }
            return this._font;
        },
        /**
         * Get or set the width of the text line. The value should be greater
         * than zero. The default width is 30px.
         *
         * @name sap.riv.graphics.shape.TextLine#width
         * @function
         * @param {Number}
         *            width the width of the text line
         * @returns {this|Number}
         */
        width : function(width) {
            if(width !== undefined) {
                if(this._width > 0 && this._width !== width) {
                    this._width = width;
                    this._adjustVertices();
                }
                return this;
            }
            return this._width;
        },
        /**
         * Get or set the text.
         *
         * @name sap.riv.graphics.shape.TextLine#text
         * @function
         * @param {String}
         *            text the text to draw
         * @returns {this|String}
         */
        text : function(text) {
            if(text !== undefined) {
                this._text = text.toString();
                return this;
            }
            return this._text;
        },
        /**
         * Get or set the text alignment. The possible values are 'l','c','r'
         * representing left, center, right respectively.
         *
         * @name sap.riv.graphics.shape.TextLine#textAlign
         * @function
         * @param {String}
         *            textAlign the text alignment to set
         * @returns {this|String}
         */
        textAlign : function(textAlign) {
            if(textAlign !== undefined) {
                this._textAlign = textAlign;
                return this;
            }
            return this._textAlign;
        },
        /**
         * Get or set the filling color of the text line, the color setting
         * should be CSSColor serialized string or as follow to define gradient
         *
         * <pre>
         * {
         *      t: 'lg'|'rg', //line gradient or radial gradient
         *      s: { x:## , y:## }, //the start position of the gradient
         *      e: { x:## , y:## }, //the end position of the gradient
         *      st: [
         *              {
         *                  o: //the stop offset
         *                  v: //the stop color
         *              },...
         *          ] //the color stops of the gradient
         * }
         * </pre>
         *
         * @name sap.riv.graphics.shape.TextLine#textColor
         * @function
         * @param {CSSColor|Object}
         *            color the filling color
         * @returns {this|CSSColor|CanvasGradient}
         */
        textColor : function(color) {
            if(color !== undefined) {
                if(color !== false) {
                    this._textColor = CanvasHelper.createColorStyle(color);
                } else {
                    this._textColor = undefined;
                }
                return this;
            }
            if(this._textColor) {
                return this._textColor;
            }
        },
        /**
         * Get or set the css text decoration, the avaliable values are
         * overline, line-through, underline and blink
         *
         * @name sap.riv.graphics.TextLine#textDecoration
         * @function
         * @param {String}
         * @return {this|String}
         */
        textDecoration : function(decoration) {
            if(decoration !== undefined && (decoration === null || decoration === "overline" || decoration === "underline" || decoration === "line-through")) {
                this._textDecoration = decoration;
                return this;
            }
            if(this._textDecoration) {
                return this._textDecoration;
            }
        },
        doDraw : function(drawingContext) {
            var dCtx = drawingContext;
            dCtx.setFont(this._font);
            switch (this._textAlign) {
                case 'r':
                    dCtx.setTextAlign('right');
                    break;
                case 'c':
                    dCtx.setTextAlign('center');
                    break;
                case 'l':
                default:
                    dCtx.setTextAlign('left');
                    break;
            }

            dCtx.setTextBaseline('middle');
            dCtx.setFillStyle(this._textColor);
            decorateText(this, dCtx);
            dCtx.save();
            dCtx.beginPath();
            var vtx = this._vtx;
            if(this._cornerRadius > 0) {
                var radius = this._cornerRadius;
                dCtx.moveTo(vtx[0][0], (vtx[0][1] + vtx[3][1]) / 2);
                dCtx.arcTo(vtx[0][0], vtx[0][1], (vtx[0][0] + vtx[1][0]) / 2, vtx[0][1], radius);
                dCtx.arcTo(vtx[1][0], vtx[0][1], vtx[1][0], (vtx[0][1] + vtx[3][1]) / 2, radius);
                dCtx.arcTo(vtx[1][0], vtx[3][1], (vtx[0][0] + vtx[1][0]) / 2, vtx[3][1], radius);
                dCtx.arcTo(vtx[0][0], vtx[3][1], vtx[0][0], (vtx[0][1] + vtx[3][1]) / 2, radius);
            } else {
                dCtx.moveTo(vtx[0][0], vtx[0][1]);
                dCtx.lineTo(vtx[1][0], vtx[1][1]);
                dCtx.lineTo(vtx[2][0], vtx[2][1]);
                dCtx.lineTo(vtx[3][0], vtx[3][1]);
            }
            dCtx.closePath();
            dCtx.clip();
            dCtx.fillText(this._text, this._strokeAnchor[0], this._strokeAnchor[1]);
            dCtx.restore();
        },
        doPointInTest : function(point) {
            var x = point.x;
            var y = point.y;
            var vtx = this._vtx;
            return vtx[0][0] <= x && x <= vtx[2][0] && vtx[0][1] <= y && y <= vtx[2][1];
        }
    });
    return TextLine;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.PieRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ColorUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.BaseRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Paths',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Circle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Sector',
  version : '1.0.0'
}
],
function Setup(TypeUtils, ColorUtils, BaseRenderer, Math, Series, TextRuler, ObjectUtils, Animator, ThemeManager,
		Paths, Circle, TextLine, Sector) {
	var textPhrase = "The quick brown fox jumps over the lazy dog";
	var pieRenderer = ObjectUtils.derive(BaseRenderer, {

		constructor : function(layer, options, multiMode) {
			// default values
			this._fontFamily = 'Arial';
			this._donutType = 'donut';
			this._pieType = 'pie';
			this._donutMeasureFont = 'bold 14px Arial';
			this._donutMeasureColor = '#000';
			this._donutBackground = '#FFF';
			this._innerShadowBlur = 20;
			this._multiMode = multiMode;
			this._subChartTitleVisible = false;
			this._centralSeriesNameVisible = false;
			this._truncReplacement = '...';
			// ///////////end default
			// values//////////////////////

			// ///////////internal
			// members////////////////////////
			this._isDrawn = false;
			this._shapes = {
				pieSectors : [],
				centerCircle : null,
				measureLabel : null,
				sectorInnerShadow : [],
				sectorOuterShadow : [],
				cover : null,
				subChartTitle : null
			};
			this._isShowInnerShadow = false;
			this._isShowOuterShadow = false;

			this._tooltip = {
				shape : null,
				dimensionLabel : null,
				valueLabel : null,
				percentLabel : null
			};

			this._meta = {
				center : null,
				radiusInner : null,
				radiusOutter : null
			};

			/**
			 * array of { value: percent: displayPercent: color: }
			 */
			this._values = [];
			// ////////////end internal
			// members////////////////////

			// ////////////to be removed out of renderer
			// [eye]///////////
			this._allSelectable = true;
			this._allDeSelectable = true;

			this._defaultSelectedSectorIndexes = [];
			this._interactionStatus = {
				mouseDown : false,
				mouseOnPieIndex : null,
				selected : []
			};
			// ////////////to be removed out of
			// renderer///////////

			this._parseOptions(options);
			this._initialize();
		},

		/**
		 * 
		 * @param options
		 *            parse pie renderer options
		 */
		_parseOptions : function(propi) {
			this._options = propi.properties;
			// ////////////to be removed out of renderer
			// [eye]///////////
			this._selectionMode = this._options.selectionMode;
			this._allSelectable = this._options.allSelectable;
			this._allDeSelectable = this._options.allDeSelectable;
			this._defaultSelectedSectorIndexes = this._options.selectedDataIndexes;
			// ////////////end of to be removed out of renderer
			// [eye]////

			this._isShowInnerShadow = this._options.isShowPieInnerShadow;
			this._isShowOuterShadow = this._options.isShowPieOuterShadow;

			this._subChartTitleVisible = this._multiMode && this._options.subChartTitle.visible;
			// [JYANG, 3/29/2012] we split the visible
			// controlling of measureLabel from centerCircle as
			// we have special
			// behavior for measureLabel in multiple pie
			this._centralSeriesNameVisible = (this._options.pieType === this._donutType) && (!this._multiMode);
			this._colorList = this._options._additional.colorList;

			this._type = this._options.pieType;
			this._toolTipTextFont = this._options.tooltip.text.font;
			this._toolTipTextFontColor = this._options.tooltip.text.color;
			this._toolTipTextFormatString = this._options._additional.tooltipeTextNumberFormat;

			this._toolTipMainValueFont = this._options.tooltip.mainValue.font;
			this._toolTipMainValueFontColor = this._options.tooltip.mainValue.color;
			this._toolTipMainValueFormatString = this._options._additional.tooltipeMainValueNumberFormat;

			this._toolTipSubValueFont = this._options.tooltip.subValue.font;
			this._toolTipSubValueFontColor = this._options.tooltip.subValue.color;
			this._toolTipSubValueFormatString = this._options._additional.tooltipeSubValueNumberFormat;
		},

		/**
		 * for pie renderer, we only draw the first series of the first series
		 * group of series groups
		 */
		_getSeries : function() {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}
			var series = seriesList[0];
			return series;
		},

		draw : function() {
			this._reset();
			var series = this._getSeries();
			if (series) {
				this._initSeries(series);
				this._isDrawn = true;
				this._update();
			}
		},

		redraw : function() {
			this._reCalculateSize();
			this._update();
			this.refresh();
		},

		_update : function() {
			var series = this._getSeries();
			if (series) {
				this._drawSeries(series);
			}
		},

		_reCalculateSize : function() {
			delete this._meta;
			this._meta = {
				center : null,
				radiusInner : null,
				radiusOutter : null
			};
			var layer = this.getLayer();
			var newSize = layer.size();
			var subChartTitleHeight = 0;
			if (this._subChartTitleVisible) {
				// we are using series name as multi title
				var series = this._getSeries();
				if (series) {
					var name = series.getName();
					var font = this._options.subChartTitle.font;
					subChartTitleHeight = TextRuler.measureHeight(font, name);
				}
			}
			var pieHeight = newSize.height - subChartTitleHeight;
			this._meta.center = {
				x : newSize.width / 2,
				y : pieHeight / 2
			};
			var radius = (newSize.width < pieHeight) ? newSize.width : pieHeight;
			this._meta.radiusInner = radius / ((1.5 + 1) * 2);
			this._meta.radiusOutter = this._meta.radiusInner * 2.3;
		},

		/**
		 * 
		 * @param values
		 *            object array. {dimensionItemIndex: 0, measureIndex: 0,
		 *            value: 34108752}
		 */
		_initSeries : function(series) {
			var values = series.getData();
			this._reCalculateSize(series);
			var layer = this.getLayer();
			var total = 0;
			for ( var i = 0; i < values.length; i++) {
				var o = {
					'vo' : values[i]
				};
				this._values.push(o);
				total += values[i].value;
			}

			var tempSum = 0, percent = 0;
			for ( var i = 0; i < values.length; i++) {
				this._values[i].percent = this._values[i].vo.value / total;
				this._values[i].color = this._colorList[this._values[i].vo.dimensionItemIndex];
				this._shapes.sectorOuterShadow.push(layer.addShape(new Paths()));
				this._shapes.pieSectors.push(layer.addShape(new Sector()));
				// this._shapes.sectorInnerShadow.push(layer.addShape('pths'));
				this._shapes.sectorInnerShadow.push(layer.addShape(new Sector()));
			}

			// initial center circle
			this._shapes.centerCircle = layer.addShape(new Circle());
			// initial measure label
			this._shapes.measureLabel = layer.addShape(new TextLine());
			if (this._type == this._pieType) {
				this._shapes.centerCircle.visible(false);
			}

			this._shapes.subChartTitle = layer.addShape(new TextLine()).visible(this._subChartTitleVisible);

			this._tooltip.shape = layer.addShape(new Paths());
			this._tooltip.dimensionLabel = layer.addShape(new TextLine());
			this._tooltip.valueLabel = layer.addShape(new TextLine());
			this._tooltip.percentLabel = layer.addShape(new TextLine());
		},

		/**
		 * 
		 * @param series
		 *            sap.riv.viz.shared.series.Series
		 */
		_drawSeries : function(series) {
			var radius = this._meta.radiusOutter;
			// [Chrisyt] Use Robin images.
			// this._shapes.cover.width(225).height(225).scale((2*radius)/225,
			// (2*radius)/225)//center([this._meta.center.x,
			// this._meta.center.y]);
			// .translate(this._meta.center.x-radius*(2*radius)/225,
			// this._meta.center.y-radius*(2*radius)/225);

			for ( var i = 0, start = 0, end = 0; i < this._shapes.pieSectors.length; i++) {
				end = start + this._values[i].percent * Math.PI * 2;
				this._shapes.pieSectors[i].center(this._meta.center).radius(this._meta.radiusOutter).clockwise(true)
						.startAngle(start).endAngle(end).borderWidth(1).borderColor("#fff").fillingColor(
								this._values[i].color);

				this._shapes.sectorOuterShadow[i].reset();
				this._shapes.sectorOuterShadow[i].visible(this._isShowOuterShadow).arc(this._meta.center,
						this._meta.radiusOutter, start, end, true).borderWidth(2).borderColor("#fff").shadow({
					offsetX : 1,
					offsetY : 1,
					blur : 8,
					color : '#000'
				});

				var innerBlur = this._innerShadowBlur;
				this._shapes.sectorInnerShadow[i].visible(this._isShowInnerShadow).center(this._meta.center).radius(
						this._meta.radiusOutter).clockwise(true).startAngle(start).endAngle(end).fillingColor({
					t : 'rg',
					s : {
						c : this._meta.center,
						r : radius
					},
					e : {
						c : this._meta.center,
						r : (radius - innerBlur < 0) ? 0 :  radius - innerBlur
					},
					st : [ {
						o : 0,
						v : '#000'
					}, {
						o : 1,
						v : '#fff'
					} ]
				}).compositionMode({
					alpha : 0.2
				});

				start = end;
			}

			if (this._subChartTitleVisible) {
				// we are using series name as multi title
				var name = series.getName();
				var font = this._options.subChartTitle.font;
				var color = this._options.subChartTitle.color;
				var layer = this.getLayer();
				var newSize = layer.size();
				var subChartTitleHeight = TextRuler.measureHeight(font, name);
				var subChartTitleWidth = TextRuler.measureWidth(font, name);
				this._shapes.subChartTitle.center([ this._meta.center.x, newSize.height - subChartTitleHeight / 2 ]).width(
						subChartTitleWidth).text(name).font(font).textColor(color);
			}

			if (this._type == this._donutType) {
				// FIXME: JY, which color do we want to fill in
				// the
				// centerCircle? maybe the background color
				var measureName = series.getName();
				this._shapes.centerCircle.center(this._meta.center).radius(this._meta.radiusInner).fillingColor(
						this._donutBackground);
				this._shapes.measureLabel.width(TextRuler.measureWidth(this._donutMeasureFont, measureName)).text(
						measureName).font(this._donutMeasureFont).center([ this._meta.center.x, this._meta.center.y ])
						.textColor(this._donutMeasureColor);
				if (this._shapes.pieSectors.length < 1) {
					this._shapes.centerCircle.visible(false);
				}
			}

			// [JYANG, 3/29/2012] we split the visible
			// controlling of measureLabel from centerCircle as
			// we have special
			// behavior for measureLabel in multiple pie
			this._shapes.measureLabel.visible(this._centralSeriesNameVisible);

			this._hideTooltip();

			// In case user/client resizes/re-layouts chart
			// components which triggers
			// doContentResize(), thus duplicates the
			// _interactionStatus states if possible, the
			// _defaultSelectedSectorIndexes field must be set
			// empty here.
			this._defaultSelectedSectorIndexes = [];
			
			// Nick. As requested by POs, there should be one default font size for each part of tooltip if user has 
			// no settings for this.
			if(!TypeUtils.isExist(this._toolTipMainValueFont)){
				this._toolTipMainValueFont = 'bold 12px Arial';
			}
			if(!TypeUtils.isExist(this._toolTipTextFont)){
				this._toolTipTextFont =  'normal 12px Arial';
			}
			if(!TypeUtils.isExist(this._toolTipSubValueFont)){
				this._toolTipSubValueFont =  'normal 12px Arial';
			} 
			
			this.getTooltipFontStyle();
			this._refresh();
		},

		autoResizeTooltipFont : function(){
 
			var fontStyleArray = ['bold ',' Arial'];			
			var	labelFontStyleArray = ['normal ',' Arial'];
			var percentFontStyleArray = ['normal ',' Arial'];
		 
			
			var newFontStyle, maxWidth = 0, values = [];
			var longestNumber = this._getValueWithLongestNumberOfDigits(values);
			
			var j = 9;
			for (var i = 0; i < values.length; i++) {
				// Only the number with longest length is
				// considered, after test, the width of 9999 is
				// smaller than the width of 11111
				if (values[i].toString().length === longestNumber) {
					
					while(j >= 9) {
						var fontStyle = fontStyleArray[0] + j + 'px' + fontStyleArray[1];
						var fontWidth = TextRuler.measureWidth(fontStyle, values[i]);
						if (fontWidth >= (this._meta.radiusInner * 2)) {
							j--;
							break;
						}
						j++;
					}
					// In case, the values array has two values
					// that have the same number of digits, the
					// one with longer width is taken.
					if (fontWidth > maxWidth) {
						maxWidth = fontWidth;
						newFontStyle = fontStyle;
					}
					var labelFontStyle = labelFontStyleArray[0] + j + 'px' + labelFontStyleArray[1];
					var percentFontStyle = percentFontStyleArray[0] + j + 'px' + percentFontStyleArray[1];
				}
			}
			this._applyTooltipFontStyleSetting(labelFontStyle, newFontStyle, percentFontStyle);
		},
		
		/**
		 * 	format values of tooltip and find the one with longest length
		 */
		_getValueWithLongestNumberOfDigits : function(values){
			// Nick.Sun - 16.04.2012
			var tooltipFT, longestNumber = 0;
			for ( var i = 0; i < this._values.length; i++) {
				tooltipFT = sap.common.globalization.NumericFormatManager
						.getFormat(this._toolTipMainValueFormatString[i]);
				values.push((TypeUtils.isExist(tooltipFT) ? tooltipFT.display(this._values[i].vo.value)
						: this._values[i].vo.value));
				if (values[i].toString().length >= longestNumber) {
					longestNumber = values[i].toString().length;
				}
			}
			return longestNumber;
			
		},
		
		/**
		 * Apply the new font style to all tooltip members
		 * @param labelFontStyle
		 * @param newFontStyle
		 * @param percentFontStyle
		 */
		_applyTooltipFontStyleSetting : function(labelFontStyle, newFontStyle, percentFontStyle){
			// Nick.Sun - 16.04.2012
			this._toolTipTextFont = TypeUtils.isExist(labelFontStyle) ? labelFontStyle : this._toolTipTextFont;
			this._toolTipMainValueFont = TypeUtils.isExist(newFontStyle) ? newFontStyle : this._toolTipMainValueFont;
			this._toolTipSubValueFont = TypeUtils.isExist(percentFontStyle) ? percentFontStyle : this._toolTipSubValueFont;
		},
		
		
		getTooltipFontStyle : function() {
			// 03/22/2012 - Nick.Sun
			// Find the 'best' font style for the value of
			// tooltip. The 'best' means the font style that
			// makes the width of value closest to the diameter
			// of tooltip circle.
			var p = /(\d+)(px|em|pt|%)/i;
			var m = p.exec(this._toolTipMainValueFont);
			var m1 = p.exec(this._toolTipTextFont);
			var m2 = p.exec(this._toolTipSubValueFont);
			var fontStyleArray = this._toolTipMainValueFont.split(m[0]);
			
			var labelFontStyleArray = ['normal ',' Arial'];
			var percentFontStyleArray = ['normal ',' Arial'];
			if(TypeUtils.isExist(m1)){
				labelFontStyleArray = this._toolTipTextFont.split(m1[0]);
			}
			if(TypeUtils.isExist(m2)){
				percentFontStyleArray = this._toolTipSubValueFont.split(m2[0]);
			}

			// format values of tooltip and find the one with
			// longest length
			var newFontStyle, maxWidth = 0, values = [];
			var longestNumber= this._getValueWithLongestNumberOfDigits(values);

			for (var i = 0; i < values.length; i++) {
				// Only the number with longest length is
				// considered, after test, the width of 9999 is
				// smaller than the width of 11111
				if (values[i].toString().length === longestNumber) {
					for ( var j = m[1]; j >= 9; j--) {
						var fontStyle = fontStyleArray[0] + j + 'px' + fontStyleArray[1];
						var fontWidth = TextRuler.measureWidth(fontStyle, values[i]);
						if (fontWidth <= (this._meta.radiusInner * 2)) {
							break;
						}
					}
					// In case, the values array has two values
					// that have the same number of digits, the
					// one with longer
					// width is taken.
					if (fontWidth > maxWidth) {
						maxWidth = fontWidth;
						newFontStyle = fontStyle;
					}
					var labelFontStyle = labelFontStyleArray[0] + j + 'px' + labelFontStyleArray[1];
					var percentFontStyle = percentFontStyleArray[0] + j + 'px' + percentFontStyleArray[1];
				}
			}

			this._applyTooltipFontStyleSetting(labelFontStyle, newFontStyle, percentFontStyle);
		},

		applyTheme : function(theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var globalStyle = settings.global;
			var pieStyle = settings['pie'];

			var donutStyle = pieStyle.donut;
			var measureStyle = ObjectUtils.extend(true, {}, globalStyle, donutStyle.measureLabel);
			this._donutMeasureFont = measureStyle['font-weight'] + " " + measureStyle['font-size'] + " "
					+ measureStyle['font-family'];
			this._donutMeasureColor = measureStyle['color'];
			this._donutBackground = TypeUtils.isExist(donutStyle.background) ? donutStyle.background
					: settings.background;

			var isShowOuterShadow = this._isShowOuterShadow = pieStyle['isShowOuterShadow'];
			var isShowInnerShadow = this._isShowInnerShadow = pieStyle['isShowInnerShadow'];

			var tooltipStyle = pieStyle.tooltip;
			var dimensionStyle = ObjectUtils.extend(true, {}, globalStyle, tooltipStyle.dimensionLabel);
			this._toolTipTextFont = dimensionStyle['font-weight'] + " " + dimensionStyle['font-size'] + " "
					+ dimensionStyle['font-family'];
			this._toolTipTextFontColor = dimensionStyle['color'];
			var valueStyle = ObjectUtils.extend(true, {}, globalStyle, tooltipStyle.valueLabel);
			this._toolTipMainValueFont = valueStyle['font-weight'] + " " + valueStyle['font-size'] + " "
					+ valueStyle['font-family'];
			this._toolTipMainValueFontColor = valueStyle['color'];
			var percentStyle = ObjectUtils.extend(true, {}, globalStyle, tooltipStyle.percentLabel);
			this._toolTipSubValueFont = percentStyle['font-weight'] + " " + percentStyle['font-size'] + " "
					+ percentStyle['font-family'];
			this._toolTipSubValueFontColor = percentStyle['color'];

			// Update shape view.
			if (this._isDrawn) {
				this._shapes.centerCircle.fillingColor(this._donutBackground);
				if (this._type == this._donutType) {
					this._shapes.measureLabel.width(
							TextRuler.measureWidth(this._donutMeasureFont, this._getSeries().getName())).font(
							this._donutMeasureFont).textColor(this._donutMeasureColor);
				}
				var sectorOuterShadowShape = this._shapes.sectorOuterShadow;
				var sectorInnerShadowShape = this._shapes.sectorInnerShadow;
				var sectorLength = this._shapes.pieSectors.length;
				for ( var i = 0; i < sectorLength; i++) {
					sectorOuterShadowShape[i].visible(isShowOuterShadow);
					sectorInnerShadowShape[i].visible(isShowInnerShadow);
				}

				// [Christy]Remove selected sector's outer
				// shadow.
				var selectedList = this._interactionStatus.selected;
				for ( var i = 0, length = selectedList.length; i < length; i++) {
					sectorOuterShadowShape[selectedList[i]].visible(false);
				}

				if (this._interactionStatus.mouseOnPieIndex !== null) {
					var value = this._mainValueFT
							.display(this._values[this._interactionStatus.mouseOnPieIndex].vo.value);
					this._tooltip.valueLabel.font(this._toolTipMainValueFont)
							.textColor(this._toolTipMainValueFontColor).width(
									TextRuler.measureWidth(this._toolTipMainValueFont, value));
					var dimensionItem = this._textValueFT
							.display(this._values[this._interactionStatus.mouseOnPieIndex].vo.dimensionItem);
					this._tooltip.dimensionLabel.font(this._toolTipTextFont).textColor(this._toolTipTextFontColor)
							.width(TextRuler.measureWidth(this._toolTipTextFont, dimensionItem));
					var percent = this._subValueFT
							.display(this._values[this._interactionStatus.mouseOnPieIndex].percent);
					this._tooltip.percentLabel.font(this._toolTipSubValueFont)
							.textColor(this._toolTipSubValueFontColor).width(
									TextRuler.measureWidth(this._toolTipSubValueFont, percent));
				}
			}
			this.getTooltipFontStyle();
			this._refresh();
		},

		_reset : function() {
			delete this._values;
			this._values = [];
			this._resetShapes();
		},

		_resetShapes : function() {
			var layer = this.getLayer();
			var shapes = this._shapes.pieSectors;
			var innerShadow = this._shapes.sectorInnerShadow;
			var outerShadow = this._shapes.sectorOuterShadow;
			for ( var i = 0, len = shapes.length; i < len; i++) {
				layer.removeShape(shapes[i]);
				layer.removeShape(outerShadow[i]);
				layer.removeShape(innerShadow[i]);
			}
			layer.removeShape(this._shapes.centerCircle);
			layer.removeShape(this._shapes.measureLabel);
			layer.removeShape(this._shapes.subChartTitle);

			layer.removeShape(this._tooltip.shape);
			layer.removeShape(this._tooltip.dimensionLabel);
			layer.removeShape(this._tooltip.valueLabel);
			layer.removeShape(this._tooltip.percentLabel);

			delete this._shapes;
			this._shapes = {
				pieSectors : [],
				centerCircle : null,
				measureLabel : null,
				sectorInnerShadow : [],
				sectorOuterShadow : [],
				cover : null,
				subChartTitle : null
			};
			delete this._tooltip;
			this._tooltip = {
				shape : null,
				dimensionLabel : null,
				valueLabel : null,
				percentLabel : null
			};
		},

		_refresh : function() {
			this.getLayer().setNeedsDisplay();
		},

		// /////////////some of them to be removed out of
		// renderer[eeye]////

		_mouseMoveOnPie : function(evt) {
			this._moveOnPie(evt.currentLocalXY());
		},

		_mouseDownOnPie : function(evt) {
			this._clickOnPie(evt.currentLocalXY());
		},

		_touchStartOnPie : function(evt) {
			// TODO: need investigate why length not equal 1
			var touch = evt.targetTouches().item(0);
			this._moveOnPie(touch.localXY());
		},

		_touchEndOnPie : function(evt) {
			if (evt.changedTouches().length() != 1) {
				return;
			}

			var touch = evt.changedTouches().item(0);
			this._clickOnPie(touch.localXY());
		},

		_touchMoveOnPie : function(evt) {
			if (evt.targetTouches().length() != 1) {
				return;
			}

			var touch = evt.targetTouches().item(0);
			this._moveOnPie(touch.localXY());
		},

		_getPieIndexByPos : function(pos) {
			var pieIndex = null;
			if (this._type == this._donutType && this._shapes.centerCircle.doPointInTest(pos)) {
				// ignore the event if it happens in inner
				// circle
				return pieIndex;
			}

			for ( var i = 0; i < this._shapes.pieSectors.length; i++) {
				if (this._shapes.pieSectors[i].doPointInTest(pos)) {
					pieIndex = i;
					break;
				}
			}
			return pieIndex;
		},

		_moveOnPie : function(pos) {
			var pieIndex = this._getPieIndexByPos(pos);
			var lastIndex = this._interactionStatus.mouseOnPieIndex;
			this._interactionStatus.mouseOnPieIndex = pieIndex;
			if (this._interactionStatus.mouseOnPieIndex == null) {
				this._hideTooltip();
				return;
			}

			if (lastIndex != this._interactionStatus.mouseOnPieIndex) {
				this._hideTooltip();
				this._showTooltip();
			}

			// get data context and return
			return {
				dimensionAxisIndex : 0, // reserved for multiple
				// charts
				dimensionIndex : 0, // reserved for multiple
				// charts
				dimensionItemIndex : this._values[pieIndex].vo.dimensionItemIndex,
				measureIndex : this._values[pieIndex].vo.measureIndex,
				dimensionLabel : this._values[pieIndex].vo.dimensionItem, // display
				// value
				// in
				// the
				// chart
				measureValue : this._values[pieIndex].vo.value
			// display value in the chart
			};
		},

		_clickOnPie : function(pos) {
			var layer = this.getLayer();
			var currentIndex = this._getPieIndexByPos(pos);

			var selected = null;
			for ( var i = 0; i < this._interactionStatus.selected.length; i++) {
				if (this._interactionStatus.selected[i] === currentIndex) {
					selected = i;
					break;
				}
			}

			if (currentIndex != null) {
				if (selected == null) {
					// If sectors ain't select-able according to
					// chart options, event processing just
					// ends here and ignores further executions.
					if (!this._allSelectable) {
						return;
					}
					if (this._selectionMode === 'single') {
						this._deselectPies(this._interactionStatus.selected);
						this._interactionStatus.selected = [];
						selected = null;
					}
					this._interactionStatus.selected.push(currentIndex);
					this._selectPie(currentIndex);

					// [jyang 03/13/2012] we return all selected
					// data context here
					// and we create new each time so that we
					// can return it directly
					// to client
					var dataContextRet = [];
					for ( var i = 0, len = this._interactionStatus.selected.length; i < len; i++) {
						var index = this._interactionStatus.selected[i];
						var dctx = {
							measureIndex : this._values[index].vo.measureIndex,
							dimensionLabel : this._values[index].vo.dimensionItem, // display
							// value
							// in
							// the
							// chart
							measureValue : this._values[index].vo.value
						// display value in the chart
						};
						if (TypeUtils.isExist(this._values[index].vo.dimensionPath)) {
							dctx.dimensionPath = this._values[index].vo.dimensionPath;
						} else {
							dctx.dimensionItemIndex = this._values[index].vo.dimensionItemIndex;
						}
						dataContextRet.push(dctx);
					}
					return dataContextRet;
				} else {
					// Client doesn't allow de-selection, so the
					// remaining execution will be ignored.
					if (!this._allDeSelectable) {
						return;
					}
					this._interactionStatus.selected.splice(selected, 1);
					this._deselectPies([ currentIndex ]);
				}
			} else {
				// User could click some blank area of the pie
				// canvas component which will trigger
				// de-selection.
				if (!this._allDeSelectable) {
					return;
				}
				this._deselectPies(this._interactionStatus.selected);
				this._interactionStatus.selected = [];
			}
		},

		_showTooltip : function() {
			//hide measure name in donut
			this._shapes.measureLabel.visible(false);
			var currentPie = this._shapes.pieSectors[this._interactionStatus.mouseOnPieIndex];
			var pointAngle = (currentPie.endAngle() + currentPie.startAngle()) / 2;
			var radius = this._meta.radiusInner * 1.2;
			var tooltipFT;
			var dimensionItemIndex = this._values[this._interactionStatus.mouseOnPieIndex].vo.dimensionItemIndex;

			this._tooltip.shape.reset();
			this._tooltip.shape.visible(true).arc(this._meta.center, this._meta.radiusInner, pointAngle - 0.15,
					pointAngle + 0.15, false).lineTo(this._meta.center.x + radius * Math.cos(pointAngle),
					this._meta.center.y + radius * Math.sin(pointAngle)).shadow({
				offsetX : 0,
				offsetY : 0,
				blur : 5,
				color : '#000000'
			});
			this._tooltip.shape.fillingColor('#FFFFFF');
			tooltipFT = sap.common.globalization.NumericFormatManager
					.getFormat(this._toolTipMainValueFormatString[dimensionItemIndex]);
			var value = TypeUtils.isExist(tooltipFT) ? tooltipFT
					.display(this._values[this._interactionStatus.mouseOnPieIndex].vo.value)
					: this._values[this._interactionStatus.mouseOnPieIndex].vo.value;
			var fontHeight = TextRuler.measureText(this._toolTipMainValueFont, value).height;
			this._tooltip.valueLabel.visible(true).width(TextRuler.measureWidth(this._toolTipMainValueFont, value))
					.text(value).font(this._toolTipMainValueFont).textColor(this._toolTipMainValueFontColor).center(
							[ this._meta.center.x, this._meta.center.y ]);

			tooltipFT = sap.common.globalization.NumericFormatManager
					.getFormat(this._toolTipTextFormatString[dimensionItemIndex]);
			var dimensionItem = TypeUtils.isExist(tooltipFT) ? tooltipFT
					.display(this._values[this._interactionStatus.mouseOnPieIndex].vo.dimensionItem)
					: this._values[this._interactionStatus.mouseOnPieIndex].vo.dimensionItem;

			var dimensionItemWidth = TextRuler.measureWidth(this._toolTipTextFont, dimensionItem);
			var unitHeight = TextRuler.measureText(this._toolTipTextFont, textPhrase).height;
			// unitHeight means how many pixels 1em is for current font style

			var availableHeight = this._meta.radiusInner - fontHeight / 2;
			var showTooltipLabel = true;
			// if height for label is less than 1em, just hide
			// the label.
			if (availableHeight < unitHeight) {
				showTooltipLabel = false;
			}
			// 1em padding in total (left and right)
			if (dimensionItemWidth > (this._meta.radiusInner * 2 - unitHeight)) {
				var referenceCharacter = 'r'; // The widest
				// alphabet
				var truncReplacementWidth = TextRuler.measureWidth(this._toolTipTextFont, this._truncReplacement);
				var unitWidth = TextRuler.measureText(this._toolTipTextFont, referenceCharacter).width;
				// Calculate the number of letters can be
				// applied here. The available width = (the
				// diameter of tooltip circle - padding - width
				// of '...')
				var lineCapacity = Math.floor((this._meta.radiusInner * 2 - unitHeight - truncReplacementWidth)
						/ unitWidth);
				// Make the new dimension label
				dimensionItem = dimensionItem.substring(0, lineCapacity) + this._truncReplacement;
			}

			this._tooltip.dimensionLabel.visible(showTooltipLabel).width(
					TextRuler.measureWidth(this._toolTipTextFont, dimensionItem)).text(dimensionItem).font(
					this._toolTipTextFont).textColor(this._toolTipTextFontColor)
					.bottomCenter(
							[ this._tooltip.valueLabel.topCenter().x,
									this._tooltip.valueLabel.topCenter().y - fontHeight / 4 ]);

			tooltipFT = sap.common.globalization.NumericFormatManager
					.getFormat(this._toolTipSubValueFormatString[dimensionItemIndex]);
			var percent = TypeUtils.isExist(tooltipFT) ? tooltipFT
					.display(this._values[this._interactionStatus.mouseOnPieIndex].percent)
					: this._values[this._interactionStatus.mouseOnPieIndex].percent;
			this._tooltip.percentLabel.visible(true).width(TextRuler.measureWidth(this._toolTipSubValueFont, percent))
					.text(percent).font(this._toolTipSubValueFont).textColor(this._toolTipSubValueFontColor).topCenter(
							[ this._tooltip.valueLabel.bottomCenter().x,
									this._tooltip.valueLabel.bottomCenter().y + fontHeight / 4 ]);

			this._refresh();
		},

		_hideTooltip : function() {
			if (!this._tooltip || this._tooltip.shape == null) {
				return;
			}
			this._tooltip.shape.visible(false);
			this._tooltip.dimensionLabel.visible(false);
			this._tooltip.valueLabel.visible(false);
			this._tooltip.percentLabel.visible(false);
			this._shapes.measureLabel.visible(this._centralSeriesNameVisible);
			this._refresh();
		},

		_selectPie : function(index) {
			var pieShape = this._shapes.pieSectors[index];
			var innerShadowShape = this._shapes.sectorInnerShadow[index];
			var innerBlur = this._innerShadowBlur;
			var radius = this._meta.radiusOutter;
			var self = this;

			// [Christy | 2012/3/13] Hide Selected sector outer
			// shadow.
			if (this._isShowOuterShadow) {
				self._shapes.sectorOuterShadow[index].visible(false);
			}
			self._refresh();

			var pointAngle = (pieShape.endAngle() + pieShape.startAngle()) / 2;
			Animator.animate({
				values : [ {
					type : 'POINT',
					from : [ self._meta.center.x, self._meta.center.y ],
					to : [ self._meta.center.x + 10 * Math.cos(pointAngle),
							self._meta.center.y + 10 * Math.sin(pointAngle) ]
				} ],
				duration : 200,
				onStep : function(values) {
					var centerPoint = {
						x : values[0][0],
						y : values[0][1]
					};
					pieShape.center(centerPoint);
					innerShadowShape.center(centerPoint)
						.fillingColor({
									t : 'rg',
									s : {
										c : centerPoint,
										r : radius
									},
									e : {
										c : centerPoint,
										r : radius - innerBlur
									},
									st : [ {
										o : 0,
										v : '#000'
									}, {
										o : 1,
										v : '#fff'
									} ]
								});
					self._refresh();
				}
			});
		},

		_deselectPies : function(indexes) {
			var innerBlur = this._innerShadowBlur;
			var radius = this._meta.radiusOutter;
			var self = this;
			var animationValues = [];
			for ( var i = 0; i < indexes.length; i++) {
				var pieShape = this._shapes.pieSectors[indexes[i]];
				animationValues.push({
					type : 'POINT',
					from : [ pieShape.center().x, pieShape.center().y ],
					to : [ self._meta.center.x, self._meta.center.y ]
				});
			}

			Animator.animate({
				values : animationValues,
				duration : 200,
				onStep : function(values) {
					var pieShape, innerShadowShape, centerPoint;
					for ( var i = 0; i < indexes.length; i++) {
						centerPoint = {
							x : values[i][0],
							y : values[i][1]
						};
						innerShadowShape = self._shapes.sectorInnerShadow[indexes[i]];
						innerShadowShape.center(centerPoint).fillingColor({
							t : 'rg',
							s : {
								c : centerPoint,
								r : radius
							},
							e : {
								c : centerPoint,
								r : radius - innerBlur
							},
							st : [ {
								o : 0,
								v : '#000'
							}, {
								o : 1,
								v : '#fff'
							} ]
						});

						pieShape = self._shapes.pieSectors[indexes[i]];
						pieShape.center(centerPoint);
					}
					self._refresh();
				},
				onComplete : function() {
					var isShowOuterShadow = self._isShowOuterShadow;
					for ( var i = 0; i < indexes.length; i++) {
						if (isShowOuterShadow) {
							self._shapes.sectorOuterShadow[indexes[i]].visible(true);
						}
					}
				}
			});
		},
		// /////////////end of some of them to be removed out of
		// renderer///

		updateProperties : function(propBag) {
			this._selectionMode = propBag.selectionMode;
			if (this._selectionMode == 'single' && this._interactionStatus.selected.length > 1) {
				var uncheck = this._interactionStatus.selected.slice(0, this._interactionStatus.selected.length - 1);
				this._interactionStatus.selected.splice(0, this._interactionStatus.selected.length - 1);
				this._deselectPies(uncheck);
			}

			this._colorList = propBag._additional.colorList;
			for ( var i = 0, len = this._shapes.pieSectors.length; i < len; i++) {
				// the length should be same as colorList, and
				// this._values
				this._values[i].color = this._colorList[this._values[i].vo.dimensionItemIndex];
				this._shapes.pieSectors[i].fillingColor(this._values[i].color);
			}

			this._type = propBag.pieType;
			this._centralSeriesNameVisible = (this._type === this._donutType) && (!this._multiMode);

			if (this._type == this._pieType) {
				this._shapes.centerCircle.visible(false);
			} else {
				this._shapes.centerCircle.visible(true);
			}

			this._isShowInnerShadow = propBag.isShowPieInnerShadow;
			this._isShowOuterShadow = propBag.isShowPieOuterShadow;

			this._toolTipTextFont = propBag.tooltip.text.font;
			this._toolTipTextFontColor = propBag.tooltip.text.color;
			this._toolTipTextFormatString = propBag.tooltip.text.numberFormat;
			this._toolTipTextFormatString = propBag._additional.tooltipeTextNumberFormat;

			this._toolTipMainValueFont = propBag.tooltip.mainValue.font;
			this._toolTipMainValueFontColor = propBag.tooltip.mainValue.color;
			this._toolTipMainValueFormatString = propBag.tooltip.mainValue.numberFormat;
			this._toolTipMainValueFormatString = propBag._additional.tooltipeMainValueNumberFormat;

			this._toolTipSubValueFont = propBag.tooltip.subValue.font;
			this._toolTipSubValueFontColor = propBag.tooltip.subValue.color;
			this._toolTipSubValueFormatString = propBag.tooltip.subValue.numberFormat;
			this._toolTipSubValueFormatString = propBag._additional.tooltipeSubValueNumberFormat;

			this._refresh();
		},

		updateOptions : function(pie) {
			this._resetShapes();
			this._shapes = {
				pieSectors : [],
				centerCircle : null,
				measureLabel : null,
				sectorInnerShadow : [],
				sectorOuterShadow : [],
				cover : null,
			};
			this._isShowInnerShadow = false;
			this._isShowOuterShadow = false;

			this._interactionStatus = {
				mouseDown : false,
				mouseOnPieIndex : null,
				selected : []
			};
			this._tooltip = {
				shape : null,
				dimensionLabel : null,
				valueLabel : null,
				percentLabel : null
			};
			this._parseOptions(pie);
		},

		/**
		 * 
		 * @override sap.riv.viz.shared.series.BaseRenderer.highlightOnPoint
		 */
		highlightOnPoint : function(point) {
			var dataContextOnPoint = this._clickOnPie(point);
			return dataContextOnPoint;
		},

		/**
		 * 
		 * @override sap.riv.viz.shared.series.BaseRenderer.hoverOnPoint
		 */
		hoverOnPoint : function(point) {
			var dataContextOnPoint = this._moveOnPie(point);
			return dataContextOnPoint;
		}
	});

	return pieRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.BasicAxisRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.PositionCalculator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Line',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, Math, TextRuler, TypeUtils, FunctionUtils, Layer, PositionCalculator, ThemeManager, Line,
		TextLine) {

	var basicAxisRenderer = function(options) {

		this._baxr_options = options;

		/**
		 * label metrics
		 */
		this._labelMetrics = {
			top : 2,
			left : 2,
			right : 2,
			bottom : 2
		};

		/*
		 * font direction: horizontal or vertical
		 */
		this._direction = 'horizontal';

		/*
		 * show or hide major tick mark of axis
		 */
		this._showMajorTicks = false;

		/*
		 * show or hide minor tick mark of axis
		 */
		this._showMinorTicks = false;

		/*
		 * minor divisions
		 */
		this._minorDivisions = 3;

		/*
		 * major tick mark size
		 */
		this._majorMarkSize = 8;

		/*
		 * minor tick mark size
		 */
		this._minorMarkSize = 4;

		/*
		 * whether to show axis line
		 */
		this._showAxisLine = true;

		/*
		 * axis line size
		 */
		this._lineThickness = 1;

		/*
		 * line color
		 */
		this._lineColor = '#ffffff';

		/*
		 * margin of all lables
		 */
		this._textMargin = {
			top : 4,
			left : 4,
			right : 4,
			bottom : 4
		};

		/*
		 * axis position, hb ht vl or vr
		 */
		this._position = 'hb';

		/*
		 * whether to show or hidden overlapping lables
		 */
		this._hideOverlappingLabels = true;

		/*
		 * axis martics
		 */
		this._axisMatrics = {
			top : 0,
			right : 0,
			left : 0,
			bottom : 0
		};

		/*
		 * axis title options
		 */
		this._title = {
			show : false,
			value : '',
			style : 'bold 13px Arial',
			color : '#ffffff',
			formatString : '',
			margin : {
				top : 4,
				left : 4,
				right : 4,
				bottom : 4
			}
		};

		/*
		 * axis label options
		 */
		this._labels = {
			show : true,
			itemsValue : [],
			color : '#ffffff',
			font : 'normal 11px Arial',
			formatString : '',
			itemsPosition : []
		};

		this._shapeRenderer = {
			title : null,
			axisLine : null,
			majorTicks : [],
			minorTicks : [],
			labels : []
		};

		// Visible range options
		this._visibleStart = 0;
		this._visibleEnd = Number.POSITIVE_INFINITY;
		this._scaled = false;

		this._baxr_initialize();
	};

	/*
	 * init the axis render options
	 */
	basicAxisRenderer.prototype._baxr_initialize = function() {
		var opts = this._baxr_options;
		this._position = TypeUtils.isExist(opts.position) ? opts.position : 'hb';
		this._lineScaling = TypeUtils.isExist(opts.lineScaling) ? opts.lineScaling : 'linear';
		this._distance = opts.distance;
		this._direction = TypeUtils.isExist(opts.direction) ? opts.direction : 'horizontal';
		this._lineColor = TypeUtils.isExist(opts.lineColor) ? opts.lineColor : this._lineColor;
		this._labels.color = TypeUtils.isExist(opts.labelColor) ? opts.labelColor : this._labels.color;
		this._labels.font = TypeUtils.isExist(opts.labelFont) ? opts.labelFont : this._labels.font;
		this._labels.formatString = (TypeUtils.isExist(opts.labelsFormatString) && opts.labelsFormatString.length !== 0) ? opts.labelsFormatString
				: this._labels.formatString;
		this._lineThickness = TypeUtils.isExist(opts.lineThickness) ? opts.lineThickness : this._lineThickness;
		this._showMajorTicks = TypeUtils.isExist(this._baxr_options.showMajorTicks) ? this._baxr_options.showMajorTicks
				: false;
		; // disable show the major mark and minor mark
		this._showMinorTicks = TypeUtils.isExist(this._baxr_options.showMinorTicks) ? this._baxr_options.showMinorTicks
				: false;
		if (TypeUtils.isExist(opts.showTitle)) {
			this._title.show = opts.showTitle;
			if ( TypeUtils.isExist(opts.title) ) {
				this._title.value = opts.title;
			}
			if (TypeUtils.isExist(opts.titleFont)) {
				this._title.style = opts.titleFont;
			}
			if (TypeUtils.isExist(opts.titleColor)) {
				this._title.color = opts.titleColor;
			}
			if (TypeUtils.isExist(opts.titleNumberFormat)) {
				this._title.formatString = opts.titleFormatString;
			}
			this._titleFT = sap.common.globalization.NumericFormatManager.getFormat(this._title.formatString);
		}
		var labelsEM = TextRuler.measureWidth(this._labels.font, 'M');
		var labelsPadding = Math.round(0.2 * labelsEM);
		this._textMargin = {
			top : labelsPadding,
			left : labelsPadding + 2,
			right : labelsPadding,
			bottom : labelsPadding
		};
		var titleEM = TextRuler.measureWidth(this._title.style, 'M');
		var titlePadding = Math.round(0.2 * titleEM);
		this._title.margin = {
			top : titlePadding,
			bottom : titlePadding,
			left : titlePadding,
			right : titlePadding
		};
	};

	/*
	 * 
	 */
	basicAxisRenderer.prototype.setLayer = function(layer) {
		this._layer = layer;
		layer.clipToBounds(true);

		var bounds = layer.bounds();
		this._subLayer = new Layer({
			anchor : {
				x : 0,
				y : 0
			},
			size : {
				w : bounds.width,
				h : bounds.height
			}
		});
		this._layer.addSubLayer(this._subLayer);
	};

	/*
	 * 
	 */
	basicAxisRenderer.prototype.getSubLayer = function() {
		return this._subLayer;
	};

	/*
	 * 
	 */
	basicAxisRenderer.prototype.getPreferredSize = function() {
		return this._getPreferredSize();
	};

	/*
	 * return the preferred size of asix
	 */
	basicAxisRenderer.prototype._getPreferredSize = function() {
		var tu = TextRuler;

		var h = 0;
		var w = 0;

		// vertical left or vertical right
		if (this._position == 'vl' || this._position == 'vr') {
			// if the direction is vertical, measure the width of chart axis

			w = this._measureWidth();
			h = this._distance;

			this._axisMatrics.bottom = this._axisMatrics.top = tu.measureHeight(this._labels.font) / 2;

			h += this._axisMatrics.top;
			h += this._axisMatrics.bottom;
		}
		// horizontal bottom or horizontal top
		else {
			// if the direction is horizontal, measure the height of chart axis
			h = this._measureHeight();
			w = this._distance;

			this._axisMatrics.left = tu.measureWidth(this._labels.font, this._labels.itemsValue[0].value()) / 2;
			this._axisMatrics.right = tu.measureWidth(this._labels.font, this._labels.itemsValue[0].value()) / 2;

			w += this._axisMatrics.left;
			w += this._axisMatrics.right;
		}

		return {
			width : w,
			height : h
		};
	};

	/*
	 * 
	 */
	basicAxisRenderer.prototype.getPreferredWidth = function() {
		if (this._position == 'vl' || this._position == 'vr') {
			this._preferredWidth = this._measureWidth();
			return this._preferredWidth;
		} else {
			if (TypeUtils.isExist(this._distance) && this._distance != 0) {
				this._preferredWidth = this._distance;

				this._preferredWidth += this._axisMatrics.left;
				this._preferredWidth += this._axisMatrics.right;

				return this._preferredWidth;
			}
			return 0;
		}
	};

	basicAxisRenderer.prototype.getPreferredHeight = function() {
		if (this._position == 'hb' || this._position == 'ht') {
			this._preferredHeight = this._measureHeight();
			return this._preferredHeight;
		} else {
			if (TypeUtils.isExist(this._distance) && this._distance != 0) {
				this._preferredHeight = this._distance;

				this._preferredHeight += this._axisMatrics.top;
				this._preferredHeight += this._axisMatrics.bottom;

				return this._preferredHeight;
			}
			return 0;
		}
	};

	/**
	 * 
	 */
	basicAxisRenderer.prototype._measureHeight = function() {
		var tu = TextRuler;

		var h = 0;

		if (this._showMajorTicks) {

			if (this._showMinorTicks) {
				if (this._majorMarkSize >= this._minorMarkSize && this._majorMarkSize >= this._lineThickness) {
					h += this._majorMarkSize;
				} else if (this._majorMarkSize < this._minorMarkSize && this._minorMarkSize >= this._lineThickness) {
					h += this._minorMarkSize;
				} else {
					h += this._lineThickness;
				}
			} else {
				if (this._majorMarkSize >= this._lineThickness) {
					h += this._majorMarkSize;
				} else {
					h += this._lineThickness;
				}
			}
		} else if (this._showMinorTicks) {
			if (this._minorMarkSize >= this._lineThickness) {
				h += this._minorMarkSize;
			} else {
				h += this._lineThickness;
			}
		} else {
			h += this._lineThickness;
		}

		// add the text label top margin
		h += this._textMargin.top;

		if (this._direction === 'vertical') {
			// TODO: Now if the label is already vertical, we will do not change
			// the direction. it is mostly happen in pinch.
			// if in first status, the labels is in vertical direction, we will
			// keep it.
		} else if (!this._isLabelHorizontal()) {
			this._direction = 'vertical';
		} else {
			this._direction = 'horizontal';
		}

		if (this._direction == 'horizontal') {
			h += tu.measureHeight(this._labels.font);
		} else {
			// find the longest str
			h += this._getLongestWidth();
		}

		// add the text label bottom margin
		h += this._textMargin.bottom;

		if (this._title.show) {
			h += this._title.margin.top;
			h += tu.measureHeight(this._title.style);
			h += this._title.margin.bottom;
		}

		return h;
	};

	basicAxisRenderer.prototype._isLabelHorizontal = function() {

		if (this._position == 'vl' || this._position == 'vr') {
			return true;
		}

		var tu = TextRuler;
		var labelpositions = this._labels.itemsPosition;

		// test whether we can draw all the label vertical
		var lw = tu.measureWidth(this._labels.font, this._labels.itemsValue[0].value());
		var lp = labelpositions[0];

		var rw = tu
				.measureWidth(this._labels.font, this._labels.itemsValue[this._labels.itemsValue.length - 1].value());
		var rp = labelpositions[labelpositions.length - 1];

		var w = 0;
		var p = 0;
		var isFitable = true;

		// 3/20/2012 - N.Sun
		// The following logic is to check two boundary cases:
		// (1) if half width of the first label is longer than the distance
		// [between first label position and starting point of axis], the lable
		// is vertical
		// (2) if half width of the last label is longer than the distance
		// [between last label position and end point of axis], the lable is
		// vertical
		// if the first label position is 0, it should be value axis, just
		// ignore the check here.
		if (lp != 0 && (lw / 2 > lp || rw / 2 > this._distance - rp)) {
			isFitable = false;
		}
		if (this._direction == 'horizontal' && isFitable) {
			for ( var i = 1, cLabelsText = this._labels.itemsValue, len = cLabelsText.length; i < len; i++) {
				w = tu.measureWidth(this._labels.font, cLabelsText[i].value());
				p = labelpositions[i];

				if ((lp + lw / 2) > (p - w / 2)) {
					isFitable = false;
					break;
				}
				lw = w;
				lp = p;
			}
		} else {
			return false;
		}

		if (isFitable)
			return true;

		return false;

	};

	/**
	 * measure with of axis
	 */
	basicAxisRenderer.prototype._measureWidth = function() {
		var tu = TextRuler;

		var w = 0;

		if (this._title.show) {
			w += this._title.margin.top;

			w += tu.measureHeight(this._title.style);

			w += this._title.margin.bottom;
		}

		if (this._showMajorTicks) {

			if (this._showMinorTicks) {
				if (this._majorMarkSize >= this._minorMarkSize && this._majorMarkSize >= this._lineThickness) {
					w += this._majorMarkSize;
				} else if (this._majorMarkSize < this._minorMarkSize && this._minorMarkSize >= this._lineThickness) {
					w += this._minorMarkSize;
				} else {
					w += this._lineThickness;
				}
			} else {
				if (this._majorMarkSize >= this._lineThickness) {
					w += this._majorMarkSize;
				} else {
					w += this._lineThickness;
				}
			}
		} else if (this._showMinorTicks) {
			if (this._minorMarkSize >= this._lineThickness) {
				w += this._minorMarkSize;
			} else {
				w += this._lineThickness;
			}
		} else {
			w += this._lineThickness;
		}

		// add the text right margin
		w += this._textMargin.right;

		w += this._getLongestWidth();

		w += this._textMargin.left;

		return w;
	};

	/**
	 * if the preferredHeight and preferredWidth is undefined, call
	 * _measureHeight and _measureWidth
	 * 
	 */
	basicAxisRenderer.prototype.draw = function(reset) {

		if (!reset) {
			this._resetShapes();
			this.createRenderer();

			if (this._scaled === false) {
				this.getSubLayer().size(this._layer.size());
				this.getSubLayer().position({
					x : 0,
					y : 0
				});
			}

		}

		if (this._position == 'hb' || this._position == 'ht') {
			if (!TypeUtils.isExist(this._preferredHeight) || this._preferredHeight == 0)
				this._preferredHeight = this._measureHeight();
		} else {
			if (!TypeUtils.isExist(this._preferredWidth) || this._preferredWidth == 0)
				this._preferredWidth = this._measureWidth();
		}

		this._draw(this.getSubLayer());
	};

	/**
	 * draw title, axis line, major ticks, minor ticks and labels
	 */
	basicAxisRenderer.prototype._draw = function(layer) {
		var tu = TextRuler;

		var baseLine = 0;

		if (this._position == 'hb') {

			baseLine += this._drawLineAndTick(layer, baseLine);

			// add the text top margin
			baseLine += this._textMargin.top;

			this._drawLabels(layer, baseLine);

			if (this._direction == 'horizontal') {
				baseLine += tu.measureHeight(this._labels.font);
			} else {
				baseLine += this._getLongestWidth();
			}

			baseLine += this._textMargin.bottom;

			// add title margin top
			if (this._title.show) {
				baseLine += this._title.margin.top;

				this._drawAxisTitle(layer, (this._axisMatrics.left + this._distance + this._axisMatrics.right) / 2,
						baseLine);

				baseLine += tu.measureHeight(this._title.style);

				baseLine += this._title.margin.bottom;
			}

		} else if (this._position == 'ht') {

			if (this._title.show) {
				baseLine += this._title.margin.top;

				this._drawAxisTitle(layer, (this._axisMatrics.left + this._distance + this._axisMatrics.right) / 2,
						baseLine);

				baseLine += tu.measureHeight(this._title.style);

				baseLine += this._title.margin.bottom;
			}

			baseLine += this._textMargin.top;

			this._drawLabels(layer, baseLine);

			if (this._direction == 'horizontal') {
				baseLine += tu.measureHeight(this._labels.font);
			} else {
				baseLine += this._getLongestWidth();
			}

			// add the bottom margin
			baseLine += this._textMargin.bottom;

			baseLine += this._drawLineAndTick(layer, baseLine);

		} else if (this._position == 'vl') {

			if (this._title.show) {
				baseLine += this._title.margin.top;

				this._drawAxisTitle(layer, baseLine,
						(this._axisMatrics.top + this._distance + this._axisMatrics.bottom) / 2);

				baseLine += tu.measureHeight(this._title.style);

				baseLine += this._title.margin.bottom;
			}

			var axisTop = this._axisMatrics.top;

			baseLine += this._textMargin.left;

			baseLine += this._getLongestWidth();

			this._drawLabels(layer, baseLine);
			// add the right margin
			baseLine += this._textMargin.right;

			baseLine += this._drawLineAndTick(layer, baseLine);

		} else if (this._position == 'vr') {

			var axisTop = this._axisMatrics.top;

			baseLine += this._drawLineAndTick(layer, baseLine);

			// add the left margin
			baseLine += this._textMargin.left;

			this._drawLabels(layer, baseLine);

			baseLine += this._getLongestWidth();

			baseLine += this._textMargin.right;

			if (this._title.show) {
				baseLine += this._title.margin.top;

				this._drawAxisTitle(layer, baseLine,
						(this._axisMatrics.top + this._distance + this._axisMatrics.bottom) / 2);

				baseLine += tu.measureHeight(this._title.style);

				baseLine += this._title.margin.bottom;
			}

		}
	};

	basicAxisRenderer.prototype.createRenderer = function() {

		this._shapeRenderer.backgroundAxisLine = this._layer.addShape(new Line());

		var subLayer = this.getSubLayer();
		if (this._title.show) {
			this._shapeRenderer.title = subLayer.addShape(new TextLine());
		}

		this._shapeRenderer.axisLine = subLayer.addShape(new Line());

		if (this._showMajorTicks) {
			var majorTickPositions = this.getMajorTicks();
			for ( var i = 0, len = majorTickPositions.length; i < len; i++) {
				this._shapeRenderer.majorTicks[i] = subLayer.addShape(new Line());
				// [Ian 2012-2-13] Current, we will do not show first tick
				if (i == 0) {
					this._shapeRenderer.majorTicks[i].visible(false);
				}
				// End
			}
		}

		if (this._showMinorTicks) {
			var minorTicksPositions = this.getMinorTicks();
			for ( var i = 0, len = minorTicksPositions.length; i < len; i++) {
				this._shapeRenderer.minorTicks[i] = subLayer.addShape(new Line());
			}
		}

		for ( var i = 0, cLabelsText = this._labels.itemsValue, len = cLabelsText.length; i < len; i++) {
			this._shapeRenderer.labels[i] = subLayer.addShape(new TextLine());
		}

	};

	/**
	 * draw axis line and major ticks and minor ticks
	 */
	basicAxisRenderer.prototype._drawLineAndTick = function(layer, baseLine) {
		if (this._showMajorTicks) {
			if (this._showMinorTicks) {
				if (this._majorMarkSize >= this._minorMarkSize && this._majorMarkSize >= this._lineThickness) {
					this._drawLine(layer, baseLine + this._majorMarkSize / 2);
					this._drawMajorTickMarks(layer, baseLine + this._majorMarkSize / 2);
					this._drawMinorTickMarks(layer, baseLine + this._majorMarkSize / 2);
					baseLine += this._majorMarkSize;
				} else if (this._majorMarkSize < this._minorMarkSize && this._minorMarkSize >= this._lineThickness) {
					this._drawLine(layer, baseLine + this._minorMarkSize / 2);
					this._drawMajorTickMarks(layer, baseLine + this._minorMarkSize / 2);
					this._drawMinorTickMarks(layer, baseLine + this._minorMarkSize / 2);
					baseLine += this._minorMarkSize;
				} else {
					/*
					 * mark size is less than line size
					 */
					this._drawLine(layer, baseLine + this._lineThickness / 2);
					this._drawMajorTickMarks(layer, baseLine + this._lineThickness / 2);
					this._drawMinorTickMarks(layer, baseLine + this._lineThickness / 2);
					baseLine += this._lineThickness;
				}
			} else {
				if (this._majorMarkSize > this._lineThickness) {
					this._drawLine(layer, baseLine + this._majorMarkSize / 2);
					this._drawMajorTickMarks(layer, baseLine + this._majorMarkSize / 2);
					baseLine += this._majorMarkSize;
				} else {
					/*
					 * mark size is less than line size
					 */
					this._drawLine(layer, baseLine + this._lineThickness / 2);
					this._drawMajorTickMarks(layer, baseLine + this._lineThickness / 2);
					baseLine += this._lineThickness;
				}
			}
		} else if (this._showMinorTicks) {
			if (this._minorMarkSize >= this._lineThickness) {
				this._drawLine(layer, baseLine + this._minorMarkSize / 2);
				this._drawMinorTickMarks(layer, baseLine + this._minorMarkSize / 2);
				baseLine += this._minorMarkSize;
			} else {
				this._drawLine(layer, baseLine + this._lineThickness / 2);
				this._drawMinorTickMarks(layer, baseLine + this._lineThickness / 2);
				baseLine += this._lineThickness;
			}
		} else {
			baseLine += this._drawLine(layer, baseLine + this._lineThickness / 2);
		}

		return baseLine;
	};

	/*
	 * draw the axis line
	 */
	basicAxisRenderer.prototype._drawLine = function(layer, baseLine) {
		// add shape line

		if (this._showAxisLine) {
			var line = this._shapeRenderer.axisLine;
			line.color(this._lineColor);
			line.width(this._lineThickness);

			if (this._position == 'hb' || this._position == 'ht') { // horizontal
				// bottom or
				// horizontal
				// top

				line.from({
					x : this._axisMatrics.left,
					y : baseLine
				}).to({
					x : this._axisMatrics.left + this._distance,
					y : baseLine
				});

			} else { // vertical left or vertical right

				line.from({
					x : baseLine,
					y : this._axisMatrics.top
				}).to({
					x : baseLine,
					y : this._axisMatrics.top + this._distance
				});

			}

			// draw back ground axis line
			var backgrouldLine = this._shapeRenderer.backgroundAxisLine;
			backgrouldLine.color(this._lineColor);
			backgrouldLine.width(this._lineThickness);

			if (this._position == 'hb' || this._position == 'ht') { // horizontal
				// bottom or
				// horizontal
				// top

				backgrouldLine.from({
					x : this._axisMatrics.left,
					y : baseLine
				}).to({
					x : this._layer.size().width - this._axisMatrics.right,
					y : baseLine
				});

			} else { // vertical left or vertical right

				backgrouldLine.from({
					x : baseLine,
					y : this._axisMatrics.top
				}).to({
					x : baseLine,
					y : this._layer.size().height - this._axisMatrics.bottom
				});

			}

			return this._lineThickness;
		}
		return 0;
	};

	/*
	 * draw the axis labels
	 * 
	 */
	basicAxisRenderer.prototype._drawLabel = function(render, layer, value, x, y, align) {

		if (this._direction == 'horizontal') {
			render.visible(true).width(TextRuler.measureWidth(this._labels.font, value)).text(value).font(
					this._labels.font).textColor(this._labels.color);

			if (align == 'topCenter')
				render.topCenter([ x, y ]);
			else if (align == 'rightCenter')
				render.rightCenter([ x, y ]);
			else if (align == 'leftCenter') {
				render.leftCenter([ x, y ]);
			}
		} else {
			var tu = TextRuler;

			render.visible(true).font(this._labels.font).textColor(this._labels.color);

			if (this._position == 'hb') {
				render.width(tu.measureWidth(this._labels.font, value)).translate(x, y).text(value).rightCenter(
						[ 0, 0 ]).rotate(-Math.PI / 2);
			} else if (this._position == 'ht') {
				render.width(this._longestWidth).translate(x, y + this._longestWidth).text(value).leftCenter([ 0, 0 ])
						.rotate(3 * Math.PI / 2);
			}
		}
	};

	basicAxisRenderer.prototype._drawLabels = function(layer, baseLine) {
		var majorTicks = this.getMajorTicks();

		if (this._position == 'hb') {
			var axisLeft = this._axisMatrics.left;
			for ( var i = 0, cLabelsText = this._labels.itemsValue, len = majorTicks.length; i < len; i++) {
				if (cLabelsText[i].visible()) {
					this._drawLabel(this._shapeRenderer.labels[i], layer, cLabelsText[i].value(), majorTicks[i],
							baseLine, 'topCenter');
				}
			}
		} else if (this._position == 'ht') {
			var axisLeft = this._axisMatrics.left;
			for ( var i = 0, cLabelsText = this._labels.itemsValue, len = majorTicks.length; i < len; i++) {
				if (cLabelsText[i].visible()) {
					this._drawLabel(this._shapeRenderer.labels[i], layer, cLabelsText[i].value(), majorTicks[i],
							baseLine, 'topCenter');
				}
			}
		} else if (this._position == 'vl') {
			var axisTop = this._axisMatrics.top;
			for ( var i = 0, cLabelsText = this._labels.itemsValue, len = majorTicks.length; i < len; i++) {
				if (cLabelsText[i].visible()) {
					this._drawLabel(this._shapeRenderer.labels[i], layer, cLabelsText[i].value(), baseLine,
							majorTicks[i], 'rightCenter');
				}
			}
		} else {
			var axisTop = this._axisMatrics.top;
			for ( var i = 0, cLabelsText = this._labels.itemsValue, len = majorTicks.length; i < len; i++) {
				if (cLabelsText[i].visible()) {
					this._drawLabel(this._shapeRenderer.labels[i], layer, cLabelsText[i].value(), baseLine,
							majorTicks[i], 'leftCenter');
				}
			}
		}
	};

	basicAxisRenderer.prototype._drawSignalTickMark = function(render, layer, x, y, tickSize) {

		render.color(this._lineColor);
		render.width(this._lineThickness);

		if (this._position == 'hb' || this._position == 'ht') {
			render.from({
				x : x,
				y : y - tickSize / 2
			}).to({
				x : x,
				y : y + tickSize / 2
			});
		} else {
			render.from({
				x : x - tickSize / 2,
				y : y
			}).to({
				x : x + tickSize / 2,
				y : y
			});
		}
	};

	/**
	 * 
	 * @param layer
	 * @param baseLine
	 */
	basicAxisRenderer.prototype._drawMajorTickMarks = function(layer, baseLine) {

		var majorTickPositions = this.getMajorTicks();
		if (this._position == 'hb' || this._position == 'ht') {
			for ( var i = 0, len = majorTickPositions.length; i < len; i++) {
				this._drawSignalTickMark(this._shapeRenderer.majorTicks[i], layer, majorTickPositions[i], baseLine,
						this._majorMarkSize);
			}
		} else {
			for ( var i = 0, len = majorTickPositions.length; i < len; i++) {
				this._drawSignalTickMark(this._shapeRenderer.majorTicks[i], layer, baseLine, majorTickPositions[i],
						this._majorMarkSize);
			}
		}
	};

	/**
	 * 
	 * @param layer
	 * @param baseLine
	 */
	basicAxisRenderer.prototype._drawMinorTickMarks = function(layer, baseLine) {
		var minorTickPositions = this.getMinorTicks();
		if (this._position == 'hb' || this._position == 'ht') {
			for ( var i = 0, len = minorTickPositions.length; i < len; i++) {
				this._drawSignalTickMark(this._shapeRenderer.minorTicks[i], layer, minorTickPositions[i], baseLine,
						this._minorMarkSize);
			}
		} else {
			for ( var i = 0, len = minorTickPositions.length; i < len; i++) {
				this._drawSignalTickMark(this._shapeRenderer.minorTicks[i], layer, baseLine, minorTickPositions[i],
						this._minorMarkSize);
			}
		}
	};

	/**
	 * 
	 * 
	 * @param layer
	 * @param baseLine
	 */
	basicAxisRenderer.prototype._drawAxisTitle = function(layer, x, y) {

		if (this._title.show) {
			var label = this._shapeRenderer.title;
			var formattedTitle = TypeUtils.isExist(this._titleFT) ? this._titleFT.display(this._title.value)
					: this._title.value;
			if (this._position == 'hb' || this._position == 'ht') {
				label.visible(true).width(TextRuler.measureWidth(this._title.style, formattedTitle)).text(
						formattedTitle).font(this._title.style).textColor(this._title.color).topCenter([ x, y ]);

			} else {
				label.visible(true).width(TextRuler.measureWidth(this._title.style, formattedTitle)).text(
						formattedTitle).font(this._title.style).textColor(this._title.color);

				if (this._position == 'vl') {
					label.translate(x, y).topCenter([ 0, 0 ]).rotate(-Math.PI / 2);
				} else if (this._position == 'vr') {
					label.translate(x, y).topCenter([ 0, 0 ]).rotate(3 * Math.PI / 2);
				}

			}
		}

	};

	/*
	 * return the position
	 */
	basicAxisRenderer.prototype.u2p = function(value) {

		if (this._lineScaling == "linear") {
			if (this._position == 'hb' || this._position == 'ht') {
				return PositionCalculator.calculateLinearPosition(value, this._positionMultiplier, this._minValue);
			} else {
				return this.getMajorTicks()[0]
						- PositionCalculator.calculateLinearPosition(value, this._positionMultiplier, this._minValue);
			}
		} else {
			if (this._position == 'hb' || this._position == 'ht') {
				return PositionCalculator.calculateLogarithmicPosition(value, this._positionMultiplier, this._minValue);
			} else {
				return this.getMajorTicks()[0]
						- PositionCalculator.calculateLogarithmicPosition(value, this._positionMultiplier,
								this._minValue);
			}
		}

	};

	/*
	 * return the value
	 */
	basicAxisRenderer.prototype.p2u = function(position) {
		var pCalculator = PositionCalculator;

		if (this._lineScaling == "linear") {
			if (this._position == 'hb' || this._position == 'ht') {
				return pCalculator.calculateLinearValue(position, this._positionMultiplier, this._minValue)
						- this._axisMatrics.left;
			} else {
				return pCalculator.calculateLinearPosition(position, this._positionMultiplier, this._minValue)//where get the value?
						- this._axisMatrics.top;
			}
		} else {
			if (this._position == 'hb' || this._position == 'ht') {
				return pCalculator.calculateLogarithmicValue(position, this._positionMultiplier, this._minValue)
						- this._axisMatrics.left;
			} else {
				return pCalculator.calculateLogarithmicValue(position, this._positionMultiplier, this._minValue)
						- this._axisMatrics.top;
			}
		}
	};

	/**
	 * 
	 * @returns {Array} return major tick based on the label positions
	 */
	basicAxisRenderer.prototype.getMajorTicks = function() {
		if (!TypeUtils.isExist(this._majorTickPositions) || this._majorTickPositions.length == 0) {
			var majorTicks = this._majorTickPositions = [];
			var labelpositions = this._labels.itemsPosition;
			if (this._position == 'hb' || this._position == 'ht') {
				var axisLeft = this._axisMatrics.left;
				for ( var i = 0, cLabelsText = this._labels.itemsValue, len = labelpositions.length; i < len; i++) {
					majorTicks[i] = axisLeft + labelpositions[i];
				}
			} else {
				var axisTop = this._axisMatrics.top;
				for ( var cLabelsText = this._labels.itemsValue, len = labelpositions.length, i = 0; i < len; i++) {
					majorTicks[i] = axisTop + labelpositions[len - i - 1];
				}
			}
		}
		return this._majorTickPositions;
	};

	/**
	 * 
	 * @returns {Array} return minor tick based on the minor interval and label
	 *          position
	 */
	basicAxisRenderer.prototype.getMinorTicks = function() {
		if (!TypeUtils.isExist(this._minorTickPositions) || this._minorTickPositions.length == 0) {
			var minorTicks = this._minorTickPositions = [];
			var majorTicks = this.getMajorTicks();
			var majorInterval = majorTicks[1] - majorTicks[0]; // always there
			// are two major
			// tick, min and
			// max
			var minorInterval = majorInterval / this._minorDivisions;
			for ( var i = 0, len = majorTicks.length; i < len; i++) {
				if (i != len - 1) {
					for ( var j = 0, dlen = this._minorDivisions - 1; j < dlen; j++) {
						minorTicks[i * dlen + j] = majorTicks[i] + minorInterval * (j + 1);
					}
				}
			}
		}

		return this._minorTickPositions;
	};

	basicAxisRenderer.prototype.getTickInterval = function() {
		// 09-Apr-2012 Nick.Sun remove the selection of minor tick position. It will cause 
		// the wrong calculation of interval.
		var axisMajorTicks = this.getMajorTicks();
		var tickInterval;
		if (axisMajorTicks.length > 1) {
			tickInterval = Math.abs(axisMajorTicks[1] - axisMajorTicks[0]);
		} else {
			tickInterval = this._distance;
		}
		return tickInterval;
	};

	basicAxisRenderer.prototype.getMajorTickWidth = function() {
		if (this._showMajorTicks) {
			return this._majorMarkSize;
		}
		return 0;
	};
	/**
	 * remove all the shape on the layer
	 */
	basicAxisRenderer.prototype._resetShapes = function() {
		var shapeRenderer = this._shapeRenderer;
		var layer = this.getSubLayer();
		var mainLayer = this._layer;

		if (shapeRenderer.backgroundAxisLine) {
			mainLayer.removeShape(shapeRenderer.backgroundAxisLine);
		}

		// remove title renderer
		if (shapeRenderer.title) {
			layer.removeShape(shapeRenderer.title);
		}

		// remove axis line renderer
		if (shapeRenderer.axisLine) {
			layer.removeShape(shapeRenderer.axisLine);
		}

		// remove major tick renderers
		for ( var i = 0, majorTicks = shapeRenderer.majorTicks, len = majorTicks.length; i < len; i++) {
			layer.removeShape(majorTicks[i]);
		}

		// remove minor tick renderers
		for ( var i = 0, minorTicks = shapeRenderer.minorTicks, len = minorTicks.length; i < len; i++) {
			layer.removeShape(minorTicks[i]);
		}

		// remove label renderers
		for ( var i = 0, labels = shapeRenderer.labels, len = labels.length; i < len; i++) {
			layer.removeShape(labels[i]);
		}
	};

	basicAxisRenderer.prototype.reset = function() {
		this._majorTickPositions = null;
		this._minorTickPositions = null;
		this._positionMultiplier = null;
		this._preferredHeight = null;
		this._preferredWidth = null;
		this._direction = 'horizontal';
	};

	/**
	 * 
	 * @param xoffset
	 * @param yoffset
	 */
	basicAxisRenderer.prototype.position = function(xoffset, yoffset) {
		this.getSubLayer().position({
			x : xoffset,
			y : yoffset
		});
	};

	basicAxisRenderer.prototype.parseOptions = function(options) {

		if (options && options.distance === this.distance) {

		}

	};

	basicAxisRenderer.prototype.updateProperties = function(propertyBag) {

		this.parseOptions();

	};

	/**
	 * 
	 * @returns axis width. when show major mark, the width do not contain the
	 *          major mark size
	 */
	basicAxisRenderer.prototype.getAxisWidth = function() {
		if (this._position == 'hb' || this._position == 'ht') {
			if (this._showMajorTicks) {
				return this.getPreferredHeight() - this._majorMarkSize / 2;
			} else {
				return this.getPreferredHeight();
			}
		} else {
			if (this._showMajorTicks) {
				return this.getPreferredWidth() - this._majorMarkSize / 2;
			} else {
				return this.getPreferredWidth();
			}
		}
	};

	/**
	 * 
	 * @returns Number the first tick offset
	 */
	basicAxisRenderer.prototype.getFirstTickOffset = function() {
		return this.getMajorTicks()[0];
	};

	basicAxisRenderer.prototype.getLastTickOffset = function() {
		var majorTicks = this.getMajorTicks();
		return majorTicks[majorTicks.length - 1];
	};

	basicAxisRenderer.prototype.getLineThickness = function() {
		return this._lineThickness;
	};

	basicAxisRenderer.prototype.zoom = FunctionUtils.noop;

	/*
	 * return position Multiplier
	 */
	basicAxisRenderer.prototype._calculatePositionMultiplier = function() {
		if (!TypeUtils.isExist(this._positionMultiplier)) {

			this._positionMultiplier = PositionCalculator.generateLinearMultiplier(this._minValue, this._maxValue,
					this._distance);
		}

		return this._positionMultiplier;
	};

	basicAxisRenderer.prototype.applyTheme = function(theme) {
		var settings = ThemeManager.getThemeSettings(theme);
		var globalStyle = settings.global;
		var axisStyle = settings.axis;

		var titleStyle = ObjectUtils.extend(true, {}, globalStyle, axisStyle.title);
		this._title.style = titleStyle['font-weight'] + " " + titleStyle['font-size'] + " " + titleStyle['font-family'];
		this._title.color = titleStyle['color'];

		var labelStyle = ObjectUtils.extend(true, {}, globalStyle, axisStyle.label);
		this._labels.font = labelStyle['font-weight'] + " " + labelStyle['font-size'] + " " + labelStyle['font-family'];
		this._labels.color = labelStyle['color'];

		this._lineColor = axisStyle.lineColor;

		// Update Axis View
		if (this._shapeRenderer.title) {
			this._shapeRenderer.title.font(this._title.style).textColor(this._title.color);
		}
		if ((this._shapeRenderer.labels) && (this._shapeRenderer.labels.length)) {
			for ( var i = 0, len = this._shapeRenderer.labels.length; i < len; i++) {
				this._shapeRenderer.labels[i].font(this._labels.font).textColor(this._labels.color);
			}
		}
		if (this._shapeRenderer.axisLine) {
			this._shapeRenderer.axisLine.color(this._lineColor);
		}
		if (this._shapeRenderer.backgroundAxisLine) {
			this._shapeRenderer.backgroundAxisLine.color(this._lineColor);
		}
		if ((this._shapeRenderer.majorTicks) && (this._shapeRenderer.majorTicks.length)) {
			for ( var i = 0, len = this._shapeRenderer.majorTicks.length; i < len; i++) {
				this._shapeRenderer.majorTicks[i].color(this._lineColor);
			}
		}
		if ((this._shapeRenderer.minorTicks) && (this._shapeRenderer.minorTicks.length)) {
			for ( var i = 0, len = this._shapeRenderer.minorTicks.length; i < len; i++) {
				this._shapeRenderer.minorTicks[i].color(this._lineColor);
			}
		}
	};

	basicAxisRenderer.prototype.Label = function() {
		this._value = '';
		this._visible = true;
	};

	basicAxisRenderer.prototype.Label.prototype.value = function(value) {
		if (TypeUtils.isExist(value)) {
			this._value = value;
			return this;
		}
		return this._value;
	};

	basicAxisRenderer.prototype.Label.prototype.visible = function(visible) {
		if (TypeUtils.isExist(visible)) {
			this._visible = visible;
			return this;
		}
		return this._visible;
	};

	return basicAxisRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.MultiPieModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.BasicModule',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.SeriesGroup',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.multilayout.ColumnMultiLayout',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.PieRenderer',
  version : '1.0.0'
}
],
function Setup(ObjUtils,TypeUtils,BasicModule,SeriesGroup,Series,ColumnMultiLayout,Layer,PieRenderer) {
	var MultiPieModule = ObjUtils.derive(BasicModule, {
		events : [ 'selectData' ],
		constructor : function(options) {
			this._seriesGroups = null;
			this._multiLayout = null;
			this._layoutModeType = null;
			this._pieRenderers = [];
			this._mainLayer = null;
			this._subLayers = [];
			this._hasDrawed = false;
			this._options = options;
		},
		
		buildData : function () {
			this._data = [];
			//[jyang 3/15/2012] for pie now we support up to 2 axis, for single axis
        	//we will use it to feed pie sectors. for dual axes, we will use the first(as well as measures)
        	//as multiplier and the second as feed of pie sectors
			var axisNum = this._metaData.axisNum;
			var dataTree = this._dataTree;
			var sectorFeedAxis = 0;
        	if ( axisNum === 2) {
        		sectorFeedAxis = 1;
        	}
			//for each dimension in multiplierFeedAxis we go through each path of their cartesian product of dimension items
        	var cartesianPath = [];//it's used for iterate tree
        	var namePath = [];//it's used for title of each sub pie, include measure name
			var dimensions = this._metaData.dimension;
			for ( var i = 0, len = dimensions.length; i < len; i++ ){
        		var dt = dimensions[i];
        		if ( dt.analysisAxisIndex !== sectorFeedAxis ) {
        			if ( cartesianPath.length === 0 ) {
        				var members = dataTree.getSubMembersAt();
        				var memberLabels = dataTree.getSubMemberLabels();
        				for ( var j = 0, jlen = members.length; j < jlen; j++ ){
        					cartesianPath.push([members[j]]);
        					namePath.push([memberLabels[j]]);
        				}
        			} else {
        				var tempCartesianPath = [];
        				var tempNamePath = [];
        				for ( var j = 0, jlen = cartesianPath.length; j < jlen; j++ ) {
        					var pathIter = cartesianPath[j];
        					var membersAtPathIter = dataTree.getSubMembersAt(pathIter);
        					var memberLabelsAtPathIter = dataTree.getSubMemberLabels(pathIter);
        					for ( var k = 0, klen = membersAtPathIter.length; k < klen; k++ ) {
        						tempCartesianPath.push(pathIter.concat(membersAtPathIter[k]));
        						tempNamePath.push(namePath[j].concat(memberLabelsAtPathIter[k]));
        					}
        				}
        				cartesianPath = tempCartesianPath;
        				namePath = tempNamePath;
        			}
        		} else {
        			if ( cartesianPath.length === 0 ) {
        				//we haven't found any multiplier feed axis, we just
        				//read the root path.
        				cartesianPath.push([]);
        				namePath.push([]);
        			}
        			//jyang, 3/16/2012 currently we only support one dimension in sectorFeedAxis
        			//so we only read one and try to get its measure values on the tree
        			//if we want to support more dimensions in sectorFeedAxis, we can 
        			//#1, move extra dimensions to multiplier
        			//#2, do cartesian product 
        			for ( var j = 0, jlen = cartesianPath.length; j < jlen; j++ ) {
        				var pathIter = cartesianPath[j];
        				var membersAtPathIter = dataTree.getSubMembersAt(pathIter);
        				var memberLabelsAtPathIter = dataTree.getSubMemberLabels(pathIter);
        				var measureValues = {};
        				for ( var k = 0, klen = membersAtPathIter.length; k < klen; k++ ) {
        					//measuresAtPathIter is an object instead of array returned from datatree
        					var measuresAtPathIter = dataTree.getMeasuresAt(
        							pathIter.concat(membersAtPathIter[k]));
        					for ( var eachMeasure in measuresAtPathIter ) {
        						if ( measuresAtPathIter.hasOwnProperty(eachMeasure) ) {
        							if ( !TypeUtils.isExist(measureValues[eachMeasure]) ) {
        								measureValues[eachMeasure] = {
        									'namePath': namePath[j].concat(eachMeasure),
        									'data': []
        								};
        							}
        							var value = measuresAtPathIter[eachMeasure].sum.result;
        							measureValues[eachMeasure].data.push({
        								'value': (TypeUtils.isNumber(value)) ? value : 'NaN',
        								'dimensionPath': measuresAtPathIter[eachMeasure].sum.tags.dimensionPath,
        								'measureIndex': measuresAtPathIter[eachMeasure].sum.tags.measureIndex,
        								'dimensionItem': memberLabelsAtPathIter[k],
        								'dimensionItemIndex': k
        							});
        						}
        					}
        				}
        				for ( var item in measureValues ) {
        					this._data.push(measureValues[item]);
        				}
        			}
        		}
        	}
		},
		
		initSeries : function() {
			//TODO Jyang 3/15/2012 how to set property for multi chart?
			var seriesOption = this._chart_options.properties.measures;
			var seriesDefault = this._chart_options.properties.measureDefault;
			this._seriesGroups = [];

			for ( var i = 0, len = this._data.length; i < len; i++) {
				var data = this._data[i];
				var seriesGroup = new SeriesGroup();
				var o = ObjUtils.extend(true, {}, seriesDefault, seriesOption[i]);
				//TODO JY: HOW TO STORE PROPERTIES INSIDE SERIES? WE NEED SEPERATE PROPERTY OBJECT?
				var s = new Series(o);
				s.setName(data.namePath.join('/'));
				//[jy 03/13/2012]for pie chart we won't draw any invalid values (NaN or less than 0)
				var seriesData = [];
				var dataCandidateArray = data.data;
				for ( var j = 0, jlen = dataCandidateArray.length; j < jlen; j++ ) {
					var valueCandidate = dataCandidateArray[j];
					if ( valueCandidate.value !== 'NaN' && valueCandidate.value > 0 ) {
						seriesData.push(valueCandidate);
					}
				}
				this._processData(seriesData);
				s.setData(seriesData);
				seriesGroup.addSeries(s);
				this._seriesGroups.push(seriesGroup);
			}
		},

		// See PieModule._processData()
		_processData : function ( array ) {
			var replica = array.slice();
			replica.sort(function ( a, b ) { return a - b; });
			var maxValue = replica[replica.length - 1];
			
			for ( var i = 0, len = array.length; i < len; i++ ) {
				if ( (array[i] / maxValue - 0.0001) < 0 ) {
					array[i] = 0;
				}
			}
		},
		
		bindRenderer : function(layer) {
			//jyang, 3/16/2012,  we rely on multi layout to create sub layer and bind it to pie renderer
			//what info do we need for multi layout? especially for multi of multi series stacked bar chart in the future?
			this._mainLayer = layer;
			if(this._multiLayout == null){
				this._layoutModeType = this._options.properties.layoutMode.type;
				//TODO JYANG 3/16/2012, we need support different multi layout, now we only support column
				switch(this._layoutModeType){
					case 'column':
					default:
						this._multiLayout = new ColumnMultiLayout(layer.size(), {
							'itemLength': this._seriesGroups.length,
							'columnLength': this._options.properties.layoutMode.columnLength
						})
						break;
				}
			}
			for(var i = 0, len = this._seriesGroups.length; i < len; i++){
				var subLayer = new Layer({
                    anchor : {
                        x : 0,
                        y : 0
                    }
                });
				this._subLayers.push(subLayer);
                layer.addSubLayer(subLayer);
                
				var seriesGroup = this._seriesGroups[i];
				var pieRenderer = this._pieRenderers[i];
				if (!TypeUtils.isExist(pieRenderer)) {
					pieRenderer = new PieRenderer(subLayer, this._options, true);
					this._pieRenderers[i] = pieRenderer;
				} else {
					pieRenderer.resetSeriesGroup();
				}
				pieRenderer.addSeriesGroup(seriesGroup);
			}
		},
		
		drawSeries : function() {
			if (!this._hasDrawed) {
				for(var i = 0, len = this._pieRenderers.length; i < len; i++){
					var pieRenderer = this._pieRenderers[i];
					pieRenderer.draw();
				}
				this._hasDrawed = true;
			} else {
				for(var i = 0, len = this._pieRenderers.length; i < len; i++){
					var pieRenderer = this._pieRenderers[i];
					pieRenderer.redraw();
				}
			}
			
			if ( this._defaultSelectionArmed ) {
				var defaultSelectedSlices = this._chart_options.properties.selectedDataIndexes;
				if ( this._chart_options.properties.allSelectable 
						&& defaultSelectedSlices.length > 0 ) {
					for ( i = 0; i < this._pieRenderers.length; i++ ) {
						for ( var j = 0, jlen = defaultSelectedSlices.length; j < jlen; j++ ) {
							if ( !this._pieRenderers[i]._shapes.pieSectors[defaultSelectedSlices[j]] ) {
								continue;
							}
							if ( this._chart_options.properties.selectionMode.toLowerCase() === 'single'
									&& j === 1 ) {
								break;
							}
							this._pieRenderers[i]._selectPie(defaultSelectedSlices[j]);
							this._pieRenderers[i]._interactionStatus.selected.push(defaultSelectedSlices[j]);
						}
					}
				}
				this._defaultSelectionArmed = false;
			}
			var selections;
			for ( i = 0, len = this._pieRenderers.length; i < len; i++ ) {
				selections = this._pieRenderers[i]._interactionStatus.selected;
				if ( TypeUtils.isExist(selections) && selections.length > 0 ) {
					for ( var j = 0, jlen = selections.length; j < jlen; j++ ) {
						if ( this._chart_options.properties.selectionMode.toLowerCase() === 'single'
								&& j === 1 ) {
							break;
						}
						this._pieRenderers[i]._selectPie(selections[j]);
					}
				}
			}
		},
		
		doChartLayout : function(nsize, seriesMaskLayer, seriesLayer) {
			//do main layout
			seriesMaskLayer.size(nsize);
			seriesMaskLayer.position({
				x : 0,
				y : 0
			});
			seriesLayer.size(nsize);
			seriesLayer.position({
				x : 0,
				y : 0
			});
			
			//do sub layout
			this._multiLayout.updateSize(nsize);
			this._relayoutSubItems();
		},
		
		_relayoutSubItems : function(){
			if(this._multiLayout.layoutChanged()){
				var layoutInfo = this._multiLayout.getLayoutInfo();
				for(var i = 0, len = this._subLayers.length; i < len; i++){
					this._subLayers[i].position({
						'x': layoutInfo[i].x,
						'y': layoutInfo[i].y
					});
					this._subLayers[i].size({
						'width': layoutInfo[i].width,
						'height': layoutInfo[i].height
					});
				}
			}
		},
		
		updateProperties : function(propBag){
			this.callParent('updateProperties', propBag);
			
			//update layout
			var layer = this._mainLayer;
			var newtype = this._options.properties.layoutMode.type;
			if(newtype !== this._layoutModeType){
				this._layoutModeType = newtype;
				//TODO JYANG 3/16/2012, we need support different multi layout, now we only support column
				switch(this._layoutModeType){
					case 'column':
					default:
						this._multiLayout = new ColumnMultiLayout(layer.size(), {
							'itemLength': this._seriesGroups.length,
							'columnLength': this._options.properties.layoutMode.columnLength
						})
						break;
				}
			}else{
				//update current layout
				this._multiLayout.updateSettings(this._options.properties.layoutMode);
			}
			this._relayoutSubItems();
			
			//[jyang 3/12/2012] how to update properties? 
			//store properties in series group or renderer?
			//now we just pass it to renderer, need refactor
			for(var i = 0, len = this._pieRenderers.length; i < len; i++){
				this._pieRenderers[i].updateProperties(propBag);
			}
			
			var seriesOption = this._chart_options.properties.measures;
			var defaultOption = this._chart_options.properties.measureDefault;
			var seriesProperties = [];
			
			for ( var i = 0, len = seriesOption.length; i < len; i++) {
				var opts = ObjUtils.extend(true, {}, defaultOption, seriesOption[i]);
				seriesProperties.push(opts);
			}
			
			for(var i = 0, len = this._seriesGroups.length; i < len; i++){
				this._seriesGroups[i].updateProperties(seriesProperties);
			}						
		},

		/**
		 * @return events 'selectData'
		 * @override sap.riv.viz.pie.BasicModule.getSupportedEvents
		 */
		getSupportedAppEvents : function() {
			return [ 'selectData' ];
		},

		/**
		 * @param point
		 *            object {x:,y:} in seriesLayer
		 */
		clickOnPoint : function(point) {
			//check which sublayer contains this point  containsPoint
			for(var i = 0, len = this._subLayers.length; i < len; i++){
				var subLayer = this._subLayers[i];
				var pointOnSubLayer = subLayer.convertPointFromSuperLayer(point);
				if(subLayer.containsPoint(pointOnSubLayer)){
					var dataCtxOnPoint = this._pieRenderers[i].highlightOnPoint(pointOnSubLayer);
					//[jyang 3/13/2012] dataCtx is an array for multi selection case
					//and it's safe we return dataCtxOnPoint directly here as we create
					//new inside renderer
					if (dataCtxOnPoint) {
						this.fireEvent('selectData', {
							name : 'selectData',
							data : dataCtxOnPoint
						});
					}
				}
			}
		},
		
		/**
		 * @param point
		 *            object {x:,y:} in seriesLayer
		 */
		hoverOnPoint : function(point) {
			//check which sublayer contains this point  containsPoint
			for(var i = 0, len = this._subLayers.length; i < len; i++){
				var subLayer = this._subLayers[i];
				var pointOnSubLayer = subLayer.convertPointFromSuperLayer(point);
				if(subLayer.containsPoint(pointOnSubLayer)){
					//currently we don't need dataCtx returned from this API
					this._pieRenderers[i].hoverOnPoint(pointOnSubLayer);
				}
			}
		},
		
		/**
		 * @override sap.riv.viz.pie.BasicModule.applyTheme
		 */
		applyTheme : function(theme){
			for(var i = 0, len = this._pieRenderers.length; i < len; i++){
				this._pieRenderers[i].applyTheme(theme);
			}
		},
		
		updateOptions : function(options) {
			this.callParent('updateOptions', options);
			for(var i = 0, len = this._pieRenderers.length; i < len; i++){
				var pieRenderer = this._pieRenderers[i];
				pieRenderer.updateOptions(options);
			}
		},
	});
	return MultiPieModule;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.descriptor.Descriptor',
  version : '1.0.0'
},
function Setup() {

	var des = {

		getCommonChartProperties : function() {
			var json = {
				type: {
					name: 'type',
					supportedValueType: 'String',
					supportedValues: 'combination',
					defaultValue: 'combination',
					description: 'internal property to determine which chart module we should use',
					isExported: false
				},
				theme : {
					name : 'theme',
					supportedValueType : 'List',
					supportedValues : [ 'classic-day', 'classic-night' ],
					defaultValue : null,
					description : 'Set theme of chart. Be noted that theme can only be updated through applyTheme().'
				},
				background : {
					name : 'background',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'color',
						supportedValueType : 'Color',
						defaultValue : '#000000',
						description : 'Set background color of chart.'
					}, {
						name : 'visible',
						supportedValueType : 'Boolean',
						defaultValue : true,
						description : 'Set visibility of background.'
					} ],
					description : 'Set background of chart.'
				},
				legend : {
					name : 'legend',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'position',
								supportedValueType : 'List',
								supportedValues : [ 'left', 'right', 'top',
										'bottom' ],
								defaultValue : 'right',
								description : 'Set legend position.'
							},
							{
								name : 'verticalOffset',
								supportedValueType : 'Int',
								defaultValue : 0,
								description : 'Set vertical offset of legend only if legend position is left or right.'
							},
							{
								name : 'horizontalOffset',
								supportedValueType : 'Int',
								defaultValue : 0,
								description : 'Set horizontal offset of legend only if legend position is top or bottom.'
							},
							{
								name : 'visible',
								supportedValueType : 'Boolean',
								defaultValue : true,
								description : 'Set visibility of legend.'
							},
							{
								name : 'labelFont',
								supportedValueType : 'Font',
								defaultValue : 'bold 16px Arial',
								description : 'Set label font style of legend label.'
							},
							{
								name : 'labelColor',
								supportedValueType : 'Color',
								defaultValue : '#ffffff',
								description : 'Set label color of legend label.'
							},
							{
								name : 'titleFont',
								supportedValueType : 'Font',
								defaultValue : 'bold 16px Arial',
								description : 'Set title font style of legend title.',
								isExported: false
							},
							{
								name : 'titleColor',
								supportedValueType : 'Color',
								defaultValue : '#ffffff',
								description : 'Set title color of legend title.',
								isExported: false
							},
							{
								name : 'formatString',
								supportedValueType : 'StringArray',
								defaultValue : [ '' ],
								description : 'Set format string of legend and re-use the last one in the array.'
							} ],
					description : 'Set legend related properties. The labels come from measure names for Bar/Column/Line/Combination chart and dimension names for Pie chart.'
				},
				layout : {
					name : 'layout',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'padding',
								supportedValueType : 'IntArray[4]',
								defaultValue : [ 0, 0, 0, 0 ],
								description : 'Set padding of layout. The padding clears an area inside of chart. The corresponding directions of padding are top, right, bottom, left.'

							},
							{
								name : 'legendFirst',
								supportedValueType : 'Boolean',
								defaultValue : true,
								description : 'Set whether the layout is legend first.',
								isExported : false
							} ],
					description : 'Set the layout related properties.'
				},
				tooltip : {
					name : 'tooltip',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'text',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font style of tooltip text. '
										},
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set color of tooltip text.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : "Set number format of tooltip text."
										} ],
								description : 'Set display properties of tooltip text.'
							},
							{
								name : 'mainValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font style of tooltip main value.'
										},
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set font color of tooltip main value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : "Set number format of tooltip main value and re-use the last one in the array."
										} ],
								description : 'Set display properties of tooltip main value.'
							},
							{
								name : 'subValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font style of sub value.'
										},
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set font color of tooltip sub value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '0.00%' ],
											description : "Set number format of tooltip sub value."
										} ],
								description : 'Set display property of tooltip sub value.'
							} ],
					description : 'Set tooltip related properties.'
				},
				title : {
					name : 'title',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'main',
						supportedValueType : 'Object',
						supportedValues : [ {
							name : 'text',
							supportedValueType : 'String',
							defaultValue : 'Default Chart Title',
							description : 'Set text value of main title.'
						}, {
							name : 'font',
							supportedValueType : 'Font',
							defaultValue : 'bold 16px Arial',
							description : 'Set font style of main title.'
						}, {
							name : 'color',
							supportedValueType : 'Color',
							defaultValue : '#ffffff',
							description : 'Set font color of main title.'
						}, {
							name : 'visible',
							supportedValueType : 'Boolean',
							defaultValue : false,
							description : 'Set visibility of main title.'
						}, {
							name : 'horizontalAlign',
							supportedValueType : 'List',
							supportedValues : [ 'center', 'left', 'right' ],
							defaultValue : 'center',
							description : 'Set horizontal align of main title.'
						}, {
							name : 'formatString',
							supportedValueType : 'String',
							defaultValue : '',
							description : 'Set format string of main title.'
						} ],
						description : 'Set main title related properties.'
					}, {
						name : 'sub',
						supportedValueType : 'Object',
						supportedValues : [ {
							name : 'text',
							supportedValueType : 'String',
							defaultValue : 'Default Sub Title',
							description : 'Set text value of sub title.'
						}, {
							name : 'font',
							supportedValueType : 'Font',
							defaultValue : 'bold 14px Arial',
							description : 'Set font style of sub title.'
						}, {
							name : 'color',
							supportedValueType : 'Color',
							defaultValue : '#ffffff',
							description : 'Set font color of sub title.'
						}, {
							name : 'visible',
							supportedValueType : 'Boolean',
							defaultValue : false,
							description : 'Set visibility of sub title.'
						}, {
							name : 'horizontalAlign',
							supportedValueType : 'List',
							supportedValues : [ 'center', 'left', 'right' ],
							defaultValue : 'center',
							description : 'Set horizontal align of sub title.'
						}, {
							name : 'formatString',
							supportedValueType : 'String',
							defaultValue : '',
							description : 'Set format string of sub title.'
						} ],
						description : 'Set sub title related properties.'
					} ],
					description : 'Set the title related properties.'
				},
				selectability : {
					name : 'selectability',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'mode',
								supportedValueType : 'List',
								supportedValues : [ 'single', 'multiple',
										'none' ],
								defaultValue : 'single',
								description : 'Set select mode. Be noted that it cannot be updated after chart initialization.'
							},
							{
								name : 'deSelectable',
								supportedValueType : 'Boolean',
								defaultValue : true,
								description : 'Set whether it can be de-selectable. Be noted that it cannot be updated after chart initialization.'
							},
							{
								name : 'defaultSelectedItems',
								supportedValueType : 'ObjectArray',
								supportedValues : [
										{
											name : 'measureIndex',
											supportedValueType : 'PositiveInt',
											defaultValue : undefined,
											description : 'Set default selected measure items. Be noted that it cannot be updated after chart initialization.'
										},
										{
											name : 'dimensionItemIndex',
											supportedValueType : 'PositiveInt',
											defaultValue : undefined,
											description : 'Set default selected dimension items. Be noted that it cannot be updated after chart initialization.'
										} ],
								defaultValue : [],
								description : 'Set default selectedItems. Be noted that it cannot be updated after chart initialization.'
							} ],
					description : 'Set the selectability related properties. Be noted that it cannot be updated after chart initialization.',
					isExported : false
				},
				xAxis : {
					name : 'xAxis',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'xAxis member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'title',
									supportedValueType : 'String',
									defaultValue : 'X1',
									description : 'Set value of X axis title.'
								},
								{
									name : 'lineThickness',
									supportedValueType : 'PositiveInt',
									defaultValue : 1,
									description : 'set line thickness of X axis.'
								},
								{
									name : 'lineColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set line color of X axis.'
								},
								{
									name : 'labelColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set label color of X axis.'
								},
								{
									name : 'titleColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set X axis title color.'
								},
								{
									name : 'labelFont',
									supportedValueType : 'Font',
									defaultValue : 'normal 11px Arial',
									description : 'Set label color of X axis.'
								},
								{
									name : 'titleFont',
									supportedValueType : 'Font',
									defaultValue : 'bold 13px Arial',
									description : 'Set label color of X axis.'
								},
								{
									name : 'showTitle',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide X axis title.'
								},
								{
									name : 'titleFormatString',
									supportedValueType : 'String',
									defaultValue : '',
									description : 'Set title format string.'
								},
								{
									name : 'showMajorTicks',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide X axis majorTicks.'
								},
								{
									name : 'showMinorTicks',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide X axis minorTicks.'
								},
								{
									name : 'labelsFormatString',
									supportedValueType : 'StringArray',
									defaultValue : [ '' ],
									description : 'Set X axis labels format string, re-use the last one in the array.'
								},
								{
									name : 'gridLine',
									supportedValueType : 'Object',
									supportedValues : [
											{
												name : 'showMajor',
												supportedValueType : 'Boolean',
												defaultValue : undefined,
												description : 'Show/hide major grid line and only works on value axis'
											},
											{
												name : 'majorColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set the major grid line color.'
											},
											{
												name : 'majorThickness',
												supportedValueType : 'Int',
												defaultValue : 1,
												description : 'Set the major grid line thickness.'
											},
											{
												name : 'showMinor',
												supportedValueType : 'Boolean',
												defaultValue : false,
												description : 'Show/hide minor grid line and only works on value axis. If showMajor is false, this option will not work'
											},
											{
												name : 'minorColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set the minor grid line color.'
											},
											{
												name : 'minorThickness',
												supportedValueType : 'Int',
												defaultValue : 1,
												description : 'Set the minor grid line thickness.'
											},
											{
												name : 'showSub',
												supportedValueType : 'Boolean',
												defaultValue : false,
												description : 'Show/hide sub grid line and only works on dimension axis'
											},
											{
												name : 'subColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set sub grid line color.'
											} ],
									description : 'Set the grid line releated properties.' +
												  'For value axis, only showMajor and showMinor options work. If showSub is set to true on value axis, it takes effect but the behavior is unexpected.' +
												  'For dimension axis, only showSub option works. If showMajor and showMinor options are set to true on dimension axis, it takes effect but the behavior is unexpected.'
												  
								} ]
					} ],
					description : 'Set X axis releated properties.'
				},
				yAxis : {
					name : 'yAxis',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'yAxis member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'title',
									supportedValueType : 'String',
									defaultValue : 'Y1',
									description : 'Set value of Y axis title.'
								},
								{
									name : 'lineColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set line color of Y axis.'
								},
								{
									name : 'lineTickness',
									supportedValueType : 'PositiveInt',
									defaultValue : 1,
									description : 'Set line thickness of Y axis.'
								},
								{
									name : 'labelColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set label color of Y axis.'
								},
								{
									name : 'titleColor',
									supportedValueType : 'Color',
									defaultValue : '#ffffff',
									description : 'Set Y axis title color.'
								},
								{
									name : 'labelFont',
									supportedValueType : 'String',
									defaultValue : 'normal 11px Arial',
									description : 'Set label font style of Y axis.'
								},
								{
									name : 'titleFont',
									supportedValueType : 'String',
									defaultValue : 'bold 13px Arial',
									description : 'Set title font style of Y axis.'
								},
								{
									name : 'showTitle',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide Y axis title.'
								},
								{
									name : 'titleFormatString',
									supportedValueType : 'String',
									defaultValue : '',
									description : 'set the title format string.'
								},
								{
									name : 'showMajorTicks',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide Y axis majorTicks.'
								},
								{
									name : 'showMinorTicks',
									supportedValueType : 'Boolean',
									defaultValue : false,
									description : 'Show/hide Y axis minorTicks.'
								},
								{
									name : 'labelsFormatString',
									supportedValueType : 'StringArray',
									defaultValue : [ '' ],
									description : 'Set Y axis labels fromat string and re-use the last one in the array.'
								},
								{
									name : 'gridLine',
									supportedValueType : 'Object',
									supportedValues : [
											{
												name : 'showMajor',
												supportedValueType : 'Boolean',
												defaultValue : undefined,
												description : 'Show/hide major grid line and only works on value axis'
											},
											{
												name : 'majorColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set the major grid line color.'
											},
											{
												name : 'majorThickness',
												supportedValueType : 'Int',
												defaultValue : 1,
												description : 'Set the major grid line thickness.'
											},
											{
												name : 'showMinor',
												supportedValueType : 'Boolean',
												defaultValue : false,
												description : 'Show/hide the minor grid line and only works on value axis. If showMajor is false, this option will not work'
											},
											{
												name : 'minorColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set minor grid line color.'
											},
											{
												name : 'minorThickness',
												supportedValueType : 'Int',
												defaultValue : 1,
												description : 'Set the minor grid line thickness.'
											},
											{
												name : 'showSub',
												supportedValueType : 'Boolean',
												defaultValue : false,
												description : 'Show/hide sub grid line and only works on dimension axis'
											},
											{
												name : 'subColor',
												supportedValueType : 'Color',
												defaultValue : '#B8B8B8',
												description : 'Set sub grid line color.'
											} ],
								description : 'Set the grid line releated properties.' +
											  'For value axis, only showMajor and showMinor options work. If showSub is set to true on value axis, it takes effect but the behavior is unexpected.' +
											  'For dimension axis, only showSub option works. If showMajor and showMinor options are set to true on dimension axis, it takes effect but the behavior is unexpected.'
								} ]
					} ],
					description : 'Set Y axis releated properties.'
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'type',
									supportedValueType : 'List',
									supportedValues : [ 'bar', 'line' ],
									defaultValue : 'line',
									description : 'Set measure type'
								},
								{
									name : 'valueAxis',
									supportedValueType : 'Int',
									defaultValue : '',
									description : 'Set index value for the axis.'
								},
								{
									name : 'fillColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set barMarker color of measure member. if it is unspecified, we will use following color palette: [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f", "#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]'
								},
								{
									name : 'barMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : undefined,
									description : 'An internal properties, as it does not make sense to set size per series. Set barMarker size of measure member.',
									isExported: false
								},
								{
									name : 'lineMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : 10,
									description : 'An internal properties, as it does not make sense to set size per series. Set lineMarker size of measure member.',
									isExported: false
								},
								{
									name : 'lineColor',
									supportedValueType : 'Color',
									defaultValue : '#000000',
									description : 'Set line color of measure member.'
								},
								{
									name : 'lineThickness',
									supportedValueType : 'PositiveInt',
									defaultValue : 1,
									description : 'Set line thickness of measure member.'
								},
								{
									name : 'markerSymbol',
									supportedValueType : 'List',
									supportedValues : [ 'circle', 'triangle',
											'diamond' ],
									defaultValue : 'circle',
									description : 'Set line markerSymbol of measure member.'
								} ],
						description : 'Set measure member related properties.'
					} ],
					description : 'Set measures related properties.'
				},
				visibleRange : {
					name : 'visibleRange',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'start',
						supportedValueType : 'Int',
						defaultValue : 0,
						description : 'Set start value of visible range.'
					}, {
						name : 'end',
						supportedValueType : 'Int',
						defaultValue : Number.POSITIVE_INFINITY,
						description : 'Set end value of visible range.'
					} ],
					description : 'Set the visible range releated propertie.',
					isExported: false
				}
			};
			return json;
		},

		getBarDescriptor : function() {
			var json = {
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				layout : this.getCommonChartProperties().layout,
				tooltip : this.getCommonChartProperties().tooltip,
				title : this.getCommonChartProperties().title,
				selectability : {
					name : 'selectability',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'mode',
								supportedValueType : 'List',
								supportedValues : [ 'single', 'none' ],
								defaultValue : 'single',
								description : 'Set selection mode. Be noted that it cannot be updated after chart initialization.'
							},
							{
								name : 'deSelectable',
								supportedValueType : 'Boolean',
								defaultValue : true,
								description : 'Set whether it can be de-selectable. Be noted that it cannot be updated after chart initialization.'
							},
							{
								name : 'defaultSelectedItems',
								supportedValueType : 'ObjectArray',
								supportedValues : [
										{
											name : 'measureIndex',
											supportedValueType : 'PositiveInt',
											defaultValue : undefined,
											description : 'Set default selected measure items. Be noted that it cannot be updated after chart initialization.'
										},
										{
											name : 'dimensionItemIndex',
											supportedValueType : 'PositiveInt',
											defaultValue : undefined,
											description : 'Set default selected dimension items. Be noted that it cannot be updated after chart initialization.'
										} ],
								defaultValue : [],
								description : 'Set default selectedItems. Be noted that it cannot be updated after chart initialization.'
							} ],
					description : 'Set the selectability related properties. Be noted that it cannot be updated after chart initialization.'
				},
				xAxis : this.getCommonChartProperties().xAxis,
				yAxis : this.getCommonChartProperties().yAxis,
				bar : {
					name : 'bar',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'barMarkerSize',
						supportedValueType : 'PositiveInt',
						defaultValue : undefined,
						description : 'Set bar marker size of bar.'
					} ],
					description : 'It is applied for all bar series.'
				},
				visibleRange : this.getCommonChartProperties().visibleRange,
				measure : {
					name : 'measure',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'visibilityChangeable',
						supportedValueType : 'Boolean',
						defaultValue : false,
						description : 'Set the visibility changeable property.'
					} ],
					description : 'Set measure releated properties.',
					isExported: false
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'fillColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the fill color of measure member. if it is unspecified, we will use following color palette: [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f", "#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]'
								},
								{
									name : 'barMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : undefined,
									description : 'An internal properties, as it does not make sense to set size per series. Set the bar marker size of measure member.',
									isExported: false
								},
								{
									name : 'valueAxis',
									supportedValueType : 'PositiveInt',
									defaultValue : 0,
									description : 'Set value axis of measure member.'
								},
								{
									name : 'visible',
									supportedValueType : 'Boolean',
									defaultValue : true,
									description : 'Set visibility of measure member.',
									isExported: false
								} ],
						description : 'Set the measure member releated properties.'
					} ],
					description : 'Set the measures releated properties.'
				}
			};
			return json;
		},

		getCombinationDescriptor : function() {
			var json = {
				type : this.getCommonChartProperties().type,
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				layout : this.getCommonChartProperties().layout,
				tooltip : this.getCommonChartProperties().tooltip,
				title : this.getCommonChartProperties().title,
				xAxis : this.getCommonChartProperties().xAxis,
				yAxis : this.getCommonChartProperties().yAxis,
				selectability : {
                    name : 'selectability',
                    supportedValueType : 'Object',
                    supportedValues : [
                            {
                                name : 'mode',
                                supportedValueType : 'List',
                                supportedValues : [ 'single', 'none' ],
                                defaultValue : 'none',
                                description : 'Set select mode. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'deSelectable',
                                supportedValueType : 'Boolean',
                                defaultValue : true,
                                description : 'Set whether it can be de-selectable. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'defaultSelectedItems',
                                supportedValueType : 'ObjectArray',
                                supportedValues : [
                                        {
                                            name : 'measureIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected measure items.'
                                        },
                                        {
                                            name : 'dimensionItemIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected dimension items.'
                                        } ],
                                defaultValue : [],
                                description : 'Set default selectedItems. Be noted that it cannot be updated after chart initialization.'
                            } ],
                    description : 'Set the selectability related properties. Be noted that it cannot be updated after chart initialization.',
                    isExported : false
                },
				line : {
					name : 'line',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'lineMarkerSize',
						supportedValueType : 'PositiveInt',
						defaultValue : 10,
						description : 'Set line marker size of series.'
					}, {
						name : 'lineThickness',
						supportedValueType : 'PositiveInt',
						defaultValue : 1,
						description : 'Set line thinkness of series.'
					} ],
					description : 'Set line releated properties.'
				},
				bar : {
					name : 'bar',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'barMarkerSize',
						supportedValueType : 'PositiveInt',
						defaultValue : undefined,
						description : 'Set bar marker size of series.'
					} ],
					description : 'Set bar releated properties.'
				},
				visibleRange : this.getCommonChartProperties().visibleRange,
				measure : {
					name : 'measure',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'visibilityChangeable',
						supportedValueType : 'Boolean',
						defaultValue : false,
						description : 'Set the visibility changeable property.'
					} ],
					description : 'Set measure releated properties.',
					isExported: false
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'type',
									supportedValueType : 'List',
									supportedValues : [ 'bar', 'line' ],
									defaultValue : 'line',
									description : 'Set the measure type. Be noted that it cannot be updated after chart initialization.'
								},
								{
									name : 'fillColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the fill color of measure member. if it is unspecified, we will use following color palette: [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f", "#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]'
								},
								{
									name : 'barMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : undefined,
									description : 'An internal properties, as it does not make sense to set size per series. Set the bar marker size of measure member.',
									isExported: false
								},
								{
									name : 'lineMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : 10,
									description : 'An internal properties, as it does not make sense to set size per series. Set the line marker size of measure member.',
									isExported: false
								},
								{
									name : 'lineColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the line color of measure member.'
								},
								{
									name : 'lineThickness',
									supportedValueType : 'PositiveInt',
									defaultValue : 1,
									description : 'Set the line size of measure member.'
								},
								{
									name : 'valueAxis',
									supportedValueType : 'PositiveInt',
									defaultValue : 0,
									description : 'Set value axis of measure member.'
								},
								{
									name : 'visible',
									supportedValueType : 'Boolean',
									defaultValue : true,
									description : 'Set visibility of measure member.',
									isExported: false
								},
								{
									name : 'markerSymbol',
									supportedValueType : 'List',
									supportedValues : [ 'circle', 'triangle',
											'diamond' ],
									defaultValue : 'circle',
									description : 'Set marker symbol of measure member.'
								} ],
						description : 'Set the measure member releated properties'
					} ],
					description : 'Set the measures releated properties.'
				}
			};

			return json;
		},

		getMultiPieDescriptor : function() {
			var json = {
				type : this.getCommonChartProperties().type,
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				title : this.getCommonChartProperties().title,
				layout : this.getCommonChartProperties().layout,
				pieType : {
					name : 'pieType',
					supportedValueType : 'List',
					supportedValues : [ 'pie', 'donut' ],
					defaultValue : 'pie',
					description : 'Set display type of every sub pie.'
				},
				selectionMode : {
					name : 'selectionMode',
					supportedValueType : 'List',
					supportedValues : [ 'single', 'multiple' ],
					defaultValue : 'single',
					description : 'Set the selection mode of every sub pie.'
				},
				allSelectable : {
					name : 'allSelectable',
					supportedValueType : 'Boolean',
					defaultValue : true,
					description : 'Set whether every sub pie is selectable. Be noted that it cannot be updated after chart initialization.'
				},
				allDeSelectable : {
					name : 'allDeSelectable',
					supportedValueType : 'Boolean',
					defaultValue : true,
					description : 'Set whether every sub pie is deselectable. Be noted that it cannot be updated after chart initialization.'
				},
				selectedDataIndexes : {
					name : 'selectedDataIndexes',
					supportedValueType : 'IntArray',
					defaultValue : [],
					description : 'Set the default selected sector. Be noted that it cannot be updated after chart initialization.'
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues: [{
							name : 'sectorColors',
							supportedValueType : 'ColorArray',
							defaultValue : [ "#113975", "#e06f00", "#5a92e2",
									"#624628", "#e03c2f", "#ffbe7f", "#96a8c3",
									"#a9a9a9", "#830b00", "#344b6d", "#e2ce44",
									"#ff6657" ],
							description : 'Color palette to be used for sectors of each sub pie.'
						}],
						description : 'Set measure member for each sub pie.'
					} ],
					description : 'Set measure properties.'
				},
				tooltip : {
					name : 'tooltip',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'mainValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set color of tooltip main value.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip main value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip main value.'
										} ],
								description : 'Set properties of tooltip main value (data value) for every sub pie. '
							},
							{
								name : 'subValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set color of tooltip sub value.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip sub value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip sub value.'
										} ],
								description : 'Set properties of tooltip sub value (percentage) for every sub pie.'
							},
							{
								name : 'text',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : undefined,
											description : 'Set color of tooltip text.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip text.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringObject',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip text.'
										} ],
								description : 'Set properties of tooltip text (dimension label) for every sub pie.'
							} ],
					description : 'Set tooltip properties for every sub pie.'
				},
				layoutMode : {
					name : 'layoutMode',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'type',
						supportedValueType : 'List',
						supportedValues : [ 'column' ],
						defaultValue : 'column',
						description : 'Set the layout mode of multi-pie.'
					}, {
						name : 'columnLength',
						supportedValueType : 'PositiveInt',
						defaultValue : 2,
						description : 'Set the column number of column layout mode.'
					} ],
					description : 'Set layout mode of multi-pie.'
				},
				subChartTitle : {
					name : 'subChartTitle',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'visible',
						supportedValueType : 'Boolean',
						defaultValue : true,
						description : 'Set the visibility of sub chart title.'
					}, {
						name : 'font',
						supportedValueType : 'Font',
						defaultValue : 'normal 14px Arial',
						description : 'Set font of sub chart title.'
					}, {
						name : 'color',
						supportedValueType : 'Color',
						defaultValue : '#ffffff',
						description : 'Set color of sub chart title.'
					} ],
					description : 'Set sub chart title releated properties of multi-pie.'
				}
			};
			return json;
		},

		getPieDescriptor : function() {
			var json = {
				type : this.getCommonChartProperties().type,
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				title : this.getCommonChartProperties().title,
				layout : this.getCommonChartProperties().layout,
				pieType : {
					name : 'pieType',
					supportedValueType : 'List',
					supportedValues : [ 'pie', 'donut' ],
					defaultValue : 'pie',
					description : 'Set display type of pie chart.'
				},
				selectionMode : {
					name : 'selectionMode',
					supportedValueType : 'List',
					supportedValues : [ 'single', 'multiple' ],
					defaultValue : 'single',
					description : 'Set the selection mode of pie chart.'
				},
				allSelectable : {
					name : 'allSelectable',
					supportedValueType : 'Boolean',
					defaultValue : true,
					description : 'Set whether the pie chart is selectable. Be noted that it cannot be updated after chart initialization.'
				},
				allDeSelectable : {
					name : 'allDeSelectable',
					supportedValueType : 'Boolean',
					defaultValue : true,
					description : 'Set whether the pie chart is deselectable. Be noted that it cannot be updated after chart initialization.'
				},
				selectedDataIndexes : {
					name : 'selectedDataIndexes',
					supportedValueType : 'IntArray',
					defaultValue : [],
					description : 'Set the default selected sector. Be noted that it cannot be updated after chart initialization.'
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues: [{
							name : 'sectorColors',
							supportedValueType : 'ColorArray',
							defaultValue : [ "#113975", "#e06f00", "#5a92e2",
									"#624628", "#e03c2f", "#ffbe7f", "#96a8c3",
									"#a9a9a9", "#830b00", "#344b6d", "#e2ce44",
									"#ff6657" ],
							description : 'Color palette to be used for sectors of each sub pie.'
						}],
						description : 'Set measure member for each sub pie.'
					} ],
					description : 'Set measure properties.'
				},
				tooltip : {
					name : 'tooltip',
					supportedValueType : 'Object',
					supportedValues : [
							{
								name : 'mainValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : '#000000',
											description : 'Set color of tooltip main value.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip main value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip main value.'
										} ],
								description : 'Set properties of tooltip main value (data value).'
							},
							{
								name : 'subValue',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : '#000000',
											description : 'Set color of tooltip sub value.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip sub value.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip sub value.'
										} ],
								description : 'Set properties of tooltip sub value (percentage).'
							},
							{
								name : 'text',
								supportedValueType : 'Object',
								supportedValues : [
										{
											name : 'color',
											supportedValueType : 'Color',
											defaultValue : '#000000',
											description : 'Set color of tooltip text.'
										},
										{
											name : 'font',
											supportedValueType : 'Font',
											defaultValue : undefined,
											description : 'Set font of tooltip text.'
										},
										{
											name : 'formatString',
											supportedValueType : 'StringArray',
											defaultValue : [ '' ],
											description : 'Set format string of tooltip text.'
										} ],
								description : 'Set properties of tooltip text (dimension label).'
							} ],
					description : 'Set tooltip properties of pie chart.'
				}
			};
			return json;
		},

		getColumnDescriptor : function() {
			var json = {
				type : this.getCommonChartProperties().type,
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				layout : this.getCommonChartProperties().layout,
				tooltip : this.getCommonChartProperties().tooltip,
				title : this.getCommonChartProperties().title,
				xAxis : this.getCommonChartProperties().xAxis,
				yAxis : this.getCommonChartProperties().yAxis,
				visibleRange : this.getCommonChartProperties().visibleRange,
				selectability : {
                    name : 'selectability',
                    supportedValueType : 'Object',
                    supportedValues : [
                            {
                                name : 'mode',
                                supportedValueType : 'List',
                                supportedValues : [ 'single', 'none' ],
                                defaultValue : 'none',
                                description : 'Set select mode. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'deSelectable',
                                supportedValueType : 'Boolean',
                                defaultValue : true,
                                description : 'Set whether it can be de-selectable. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'defaultSelectedItems',
                                supportedValueType : 'ObjectArray',
                                supportedValues : [
                                        {
                                            name : 'measureIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected measure items.'
                                        },
                                        {
                                            name : 'dimensionItemIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected dimension items.'
                                        } ],
                                defaultValue : [],
                                description : 'Set default selectedItems. Be noted that it cannot be updated after chart initialization.'
                            } ],
                    description : 'Set the selectability related properties. Be noted that it cannot be updated after chart initialization.',
                    isExported : false
                },
				measure : {
					name : 'measure',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'visibilityChangeable',
						supportedValueType : 'Boolean',
						defaultValue : false,
						description : 'Set the visibility changeable property.'
					}, {
						name : 'type',
						supportedValueType : 'String',
						defaultValue : '',
						description : 'Top level type of element shapes',
						isExported : false
					} ],
					description : 'Set the measure releated properties.',
					isExported : false
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'fillColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the fill color of measure member. if it is unspecified, we will use following color palette: [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f", "#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]'
								},
								{
									name : 'barMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : undefined,
									description : 'Set the bar marker size of measure member.',
									isExported: false
								},
								{
									name : 'valueAxis',
									supportedValueType : 'PositiveInt',
									defaultValue : 0,
									description : 'Set value axis of measure member.'
								},
								{
									name : 'visible',
									supportedValueType : 'Boolean',
									defaultValue : true,
									description : 'Set visibility of measure member.',
									isExported: false
								} ],
						description : 'Set the measure member releated properties.'
					} ],
					description : 'Set the measures releated properties.'
				},
				bar : {
					name : 'bar',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'barMarkerSize',
						supportedValueType : 'PositiveInt',
						defaultValue : undefined,
						description : 'Set bar marker size of series.'
					} ],
					description : 'Set bar releated properties.'
				}
			};
			return json;
		},

		getLineDescriptor : function() {
			var json = {
				type : this.getCommonChartProperties().type,
				theme : this.getCommonChartProperties().theme,
				background : this.getCommonChartProperties().background,
				legend : this.getCommonChartProperties().legend,
				layout : this.getCommonChartProperties().layout,
				tooltip : this.getCommonChartProperties().tooltip,
				title : this.getCommonChartProperties().title,
				xAxis : this.getCommonChartProperties().xAxis,
				yAxis : this.getCommonChartProperties().yAxis,
				selectability : {
                    name : 'selectability',
                    supportedValueType : 'Object',
                    supportedValues : [
                            {
                                name : 'mode',
                                supportedValueType : 'List',
                                supportedValues : [ 'single', 'none' ],
                                defaultValue : 'none',
                                description : 'Set select mode. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'deSelectable',
                                supportedValueType : 'Boolean',
                                defaultValue : true,
                                description : 'Set whether it can be de-selectable. Be noted that it cannot be updated after chart initialization.'
                            },
                            {
                                name : 'defaultSelectedItems',
                                supportedValueType : 'ObjectArray',
                                supportedValues : [
                                        {
                                            name : 'measureIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected measure items.'
                                        },
                                        {
                                            name : 'dimensionItemIndex',
                                            supportedValueType : 'PositiveInt',
                                            defaultValue : undefined,
                                            description : 'Set default selected dimension items.'
                                        } ],
                                defaultValue : [],
                                description : 'Set default selectedItems. Be noted that it cannot be updated after chart initialization.'
                            } ],
                    description : 'Set the selectability related properties. Be noted that it cannot be updated after chart initialization.',
                    isExported : false
                },
				line : {
					name : 'line',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'lineMarkerSize',
						supportedValueType : 'PositiveInt',
						defaultValue : 10,
						description : 'Set line marker size of series.'
					}, {
						name : 'lineThickness',
						supportedValueType : 'PositiveInt',
						defaultValue : 1,
						description : 'Set line thinkness of series.'
					} ],
					description : 'Set the line releated properties.'
				},
				visibleRange : this.getCommonChartProperties().visibleRange,
				measure : {
					name : 'measure',
					supportedValueType : 'Object',
					supportedValues : [ {
						name : 'visibilityChangeable',
						supportedValueType : 'Boolean',
						defaultValue : false,
						description : 'Set the visibility changeable property.'
					} ],
					description : 'Set the measure releated properties.',
					isExported : false
				},
				measures : {
					name : 'measures',
					supportedValueType : 'ObjectArray',
					supportedValues : [ {
						name : 'measure member',
						supportedValueType : 'Object',
						supportedValues : [
								{
									name : 'fillColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the fill color of measure member. if it is unspecified, we will use following color palette: [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f", "#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]'
								},
								{
									name : 'lineMarkerSize',
									supportedValueType : 'PositiveInt',
									defaultValue : 10,
									description : 'An internal properties, as it does not make sense to set size per series. Set the line marker size of measure member.',
									isExported: false
								},
								{
									name : 'lineColor',
									supportedValueType : 'Color',
									defaultValue : undefined,
									description : 'Set the line color of measure mmeber.'
								},
								{
									name : 'lineThickness',
									supportedValueType : 'PositiveInt',
									defaultValue : 1,
									description : 'Set the line size of measure mmeber.'
								},
								{
									name : 'valueAxis',
									supportedValueType : 'PositiveInt',
									defaultValue : 0,
									description : 'Set value axis of measure mmeber.'
								},
								{
									name : 'visible',
									supportedValueType : 'Boolean',
									defaultValue : true,
									description : 'Set visibility of measure mmeber.',
									isExported: false
								},
								{
									name : 'markerSymbol',
									supportedValueType : 'List',
									supportedValues : [ 'circle', 'triangle',
											'diamond' ],
									defaultValue : 'circle',
									description : 'Set marker symbol of measure mmeber.'

								} ],
						description : 'Set the measure mmeber releated properties.'
					} ],
					description : 'Set the measures releated properties.'
				}

			};

			return json;
		},

	};

	return des;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.PieModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.BasicModule',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.PieRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.SeriesGroup',
  version : '1.0.0'
}
],
function Setup ( ObjUtils, TypeUtils, BasicModule, PieRenderer, Series, SeriesGroup ) {
	var PieModule = ObjUtils.derive(BasicModule, {
		events : [ 'selectData' ],
		constructor : function(options) {
			this._seriesGroup = null;
			this._pieRenderer = null;
			this._hasDrawed = false;
		},
		
		buildData : function() {
			this._data = [];
			var dimensionList = this._dataTree.getSubMembersAt();
			var dimensionLabels = this._dataTree.getSubMemberLabels();
			
			var initialData = [];
			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++ ) {
				var measure = this._metaData.measureMembers[i];
				for ( var j = 0, jlen = dimensionList.length; j < jlen; j++ ) {
					var dimension = [ dimensionList[j] ];
					var sum = this._dataTree.getMeasuresAt(dimension)[measure].sum;
					initialData.push(sum.result);
				}
			}
			
			this._processData(initialData);
			
			for ( i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var subData = [];
				var measure = this._metaData.measureMembers[i];
				for ( var j = 0, jLen = dimensionList.length; j < jLen; j++) {
					var d = [ dimensionList[j] ];
					var sumObj = this._dataTree.getMeasuresAt(d)[measure].sum;
					var dimensionPathArr = sumObj.tags.dimensionPath;
					//[jyang, 20/3/2012]FIXME for pie module, we only use the first dimension path
					//but we need extra steps to support multi dimensions in single pie chart
					var dimensionPath = dimensionPathArr.length > 0 ? dimensionPathArr[0] : {};
					var value = initialData[j];
					subData.push({
							value : TypeUtils.isNumber(value) ? value : 'NaN',
							dimensionItemIndex : dimensionPath.dimensionItemIndex,
							measureIndex : sumObj.tags.measureIndex,
							dimensionItem: dimensionLabels[j]
						});
				}
				this._data.push(subData);
			}
		},
		
		// Filters out irrational data when the data is technically
		// valid but semantically meaningless, say, in case of a huge 
		// magical number exists. Here we set the threshold value of 
		// ratio between largest and smallest number to 1/10000, below
		// which numbers will be set to 0 and simply bypassed.
		_processData : function ( array ) {
			for ( var i = 0, len = array.length; i < len; i++ ) { 
				if ( array[i] === 'NaN' || array[i] < 0 ) array[i] = 0;
			}
			
			var replica = array.slice();
			replica.sort(function ( a, b ) { return a - b; });
			var maxValue = replica[replica.length - 1];
			
			for ( var i = 0, len = array.length; i < len; i++ ) {
				if ( (array[i] / maxValue - 0.0001) < 0 ) {
					array[i] = 0;
				}
			}
		},
		
		initSeries : function() {
			var seriesOption = this._chart_options.properties.measures;
			var measureMembers = this._metaData.measureMembers;
			var seriesDefault = this._chart_options.properties.measureDefault;
			this._seriesGroup = new SeriesGroup();

			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var o = ObjUtils.extend(true, {}, seriesDefault, seriesOption[i]);
				//TODO JY: HOW TO STORE PROPERTIES INSIDE SERIES? WE NEED SEPERATE PROPERTY OBJECT?
				var s = new Series(o);
				s.setName(measureMembers[i]);
				//[jy 03/13/2012]for pie chart we won't draw any invalid values (NaN or less than 0)
				var seriesData = [];
				var dataCandidateArray = this._data[i];
				for(var j = 0, jlen = dataCandidateArray.length; j < jlen; j++){
					var valueCandidate = dataCandidateArray[j];
					if(valueCandidate.value !== 'NaN' && valueCandidate.value > 0){
						seriesData.push(valueCandidate);
					}
				}
				s.setData(seriesData);
				this._seriesGroup.addSeries(s);
			}
		},

		bindRenderer : function(layer) {
			if (this._pieRenderer == null) {
				this._pieRenderer = new PieRenderer(layer, this._chart_options, false);
			} else {
				this._pieRenderer.resetSeriesGroup();
			}
			this._pieRenderer.addSeriesGroup(this._seriesGroup);
		},
		
		drawSeries : function() {
			if (!this._hasDrawed) {
				this._pieRenderer.draw();
				this._hasDrawed = true;
			} else {
				this._pieRenderer.redraw();
			}
			
			if ( this._defaultSelectionArmed ) {
				var defaultSelectedSlices = this._chart_options.properties.selectedDataIndexes;
				if ( this._chart_options.properties.allSelectable && defaultSelectedSlices.length > 0 ) {
					for ( var index = 0; index < defaultSelectedSlices.length; index++ ) {
						if ( !this._pieRenderer._shapes.pieSectors[defaultSelectedSlices[index]] ) {
							continue;
						}
						if ( this._chart_options.properties.selectionMode.toLowerCase() === 'single'
								&& index === 1 ) {
							break;
						}
						this._pieRenderer._selectPie(defaultSelectedSlices[index]);
						this._pieRenderer._interactionStatus.selected.push(defaultSelectedSlices[index]);
					}
				}
				this._defaultSelectionArmed = false;
			} else {
				var selections = this._pieRenderer._interactionStatus.selected;
				if ( TypeUtils.isExist(selections) && selections.length > 0 ) {
					for ( var i = 0; i < selections.length; i++ ) {
						if ( this._chart_options.properties.selectionMode.toLowerCase() === 'single'
								&& i === 1 ) {
							break;
						}
						this._pieRenderer._selectPie(selections[i]);	
					}
				}
			}
		},
		
		doChartLayout : function(nsize, seriesMaskLayer, seriesLayer) {

			seriesMaskLayer.size(nsize);
			seriesMaskLayer.position({
				x : 0,
				y : 0
			});
			seriesLayer.size(nsize);
			seriesLayer.position({
				x : 0,
				y : 0
			});
		},
		
		updateProperties : function(propBag){
			this.callParent('updateProperties', propBag);
			//[jyang 3/12/2012] how to update properties? 
			//store properties in series group or renderer?
			//now we just pass it to renderer, need refactor			
			this._pieRenderer.updateProperties(propBag);
			
			var seriesOption = this._chart_options.properties.measures;
			var defaultOption = this._chart_options.properties.measureDefault;
			var seriesProperties = [];
			
			for ( var i = 0, len = seriesOption.length; i < len; i++) {
				var opts = ObjUtils.extend(true, {}, defaultOption, seriesOption[i]);
				seriesProperties.push(opts);
			}
			this._seriesGroup.updateProperties(seriesProperties);
			
			
		},

		/**
		 * @return events 'selectData'
		 * @override sap.riv.viz.pie.BasicModule.getSupportedEvents
		 */
		getSupportedAppEvents : function() {
			return [ 'selectData' ];
		},

		/**
		 * @param point
		 *            object {x:,y:} in seriesLayer
		 */
		clickOnPoint : function(point) {
			if (this._pieRenderer == null) {
				ObjUtils.error('No renderer to handle event!');
			}
			var dataCtxOnPoint = this._pieRenderer.highlightOnPoint(point);
			//[jyang 3/13/2012] dataCtx is an array for multi selection case
			//and it's safe we return dataCtxOnPoint directly here as we create
			//new inside renderer
			if (dataCtxOnPoint) {
				this.fireEvent('selectData', {
					name : 'selectData',
					data : dataCtxOnPoint
				});
			}
		},
		
		/**
		 * @param point
		 *            object {x:,y:} in seriesLayer
		 */
		hoverOnPoint : function(point) {
			if (this._pieRenderer == null) {
				ObjUtils.error('No renderer to handle event!');
			}
			//currently we don't need dataCtx returned from this API
			this._pieRenderer.hoverOnPoint(point);
		},
		
		applyTheme : function(theme){
			this._pieRenderer.applyTheme(theme);
		},
		
		updateOptions : function(options) {
			this.callParent('updateOptions', options);
			this._pieRenderer.updateOptions(options);
		},
	});
	return PieModule;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.title.TitleCanvasComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, TextRuler, Canvas2DSurfaceComponent, PropsMgr, ThemeManager, TextLine,NumericFormatManager) {
	/**
	 * Default options for drawing chart titles. See usage example below:
	 * 
	 * <pre>
	 * {
	 * 	main : {
	 * 		text : 'This is the main title',
	 * 		font : 'bold 16px Arial',
	 * 		color : '#000000',
	 * 		horizontalAlign : 'center',
	 * 		visible : false
	 * 	},
	 * 	sub : {
	 * 		text : 'This is the sub title',
	 * 		font : 'normal 14px Arial',
	 * 		color : '#000000',
	 * 		horizontalAlign : 'center',
	 * 		visible : false
	 * 	}
	 * }
	 * </pre>
	 * 
	 * Note that the font size here represents a preferred size, it will be
	 * automatically adjusted if the container can't contain such big font.
	 */
	var defaultOptions = {
		main : {
			"text" : 'Default Chart Title',
			"font" : 'bold 16px Arial',
			"color" : '#ffffff',
			"horizontalAlign" : 'center',
			"formatString" : '',
			"visible" : false
		},
		sub : {
			"text" : 'Default Sub Title',
			"font" : 'normal 14px Arial',
			"color" : '#ffffff',
			"horizontalAlign" : 'center',
			"formatString" : '',
			"visible" : false
		}
	};
	
	var trimString = function ( str ) {
		return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	};

	/**
	 * Represents a light weight text processor who provides similar
	 * functionalities of a word processor.
	 * @author eye
	 */
	var TextProcessor = function ( inputString, prefs ) {
		this._text = inputString;
		this._lineCapacity = prefs.lineWidth;
		this._wordWrap = prefs.wordWrap;
	};

	TextProcessor.prototype = {
		constructor : this,	

		/**
		 * Returns lines of word-wrapped sliced text string.
		 * @returns {Array} lineData - Text string sliced in lines
		 */
		getLines : function () {
			// String lines
			this._lineData = [];
		
			// Converts text string to character array.
			this._text = trimString(this._text + '');
			var characters = this._text.split('');
			
			if ( this._wordWrap ) {
				if ( characters.length <= this._lineCapacity ) {
					this._lineData.push(this._text);
					return this._lineData;
				}
			
				var space = ' ';
				var spaceSlots = []; // Stores space indexes.
				for ( var i = 0; i < characters.length; i++ ) 
					if ( characters[i] === space ) 
						spaceSlots.push(i);
				
				// Append additional space index which helps find the last few "lefts".
				spaceSlots.push(characters.length);
				
				var cursor = 0; // Cursor marks start of the unprocessed char array.
				var sentinel = this._lineCapacity;
				var 
					// Stores line string. 
					line, 
					// Current measurement means the current range starting from right after
					// the last processed character to the next space, against which the
					// line width will be compared.
					currentMeasurement, 
					// Progress marks the last processed space (characters before has been
					// added to lines) as a line string ending, which helps determine 
					// if there's unprocessed short ones.
					progress; 
				for ( i = 0; i < spaceSlots.length; i++ ) {
					currentMeasurement = spaceSlots[i] - cursor;
					if ( currentMeasurement === sentinel ) {
						line = characters.slice(cursor, spaceSlots[i]).join('');
						this._lineData.push(line);
						cursor = spaceSlots[i];
						progress = spaceSlots[i]; // File progress
					} else if ( currentMeasurement > sentinel ) {
						line = characters.slice(cursor, spaceSlots[i - 1]).join('');
						this._lineData.push(line);
						cursor = spaceSlots[i - 1] + 1;
						progress = spaceSlots[i - 1]; // File progress
					} else {
						continue;
					}
				}
				
				if ( TypeUtils.isDefined(progress)
						&& trimString(this._lineData.join('')).length < characters.length ) {
					line = characters.slice(progress + 1, characters.length);
					this._lineData.push(line.join(''));
				}
				
				return this._lineData;
			}
		},
		
		setText : function ( inputString ) {
			this._text = inputString;
		},
		
		setWidth : function ( width ) {
			this._lineCapacity = width;
		},
		
		setWordWrapEnabled : function ( enabled ) {
			this._wordWrap = enabled;
		}
	};

	/**
	 * Represents a <code>Canvas2DSurfaceComponent</code> object been used to
	 * draw chart titles.
	 */
	var TitleCanvasComponent = ObjUtils.derive(Canvas2DSurfaceComponent, {
		constructor : function(options) {
			this._options = options.titleOptions;

			this._canvasSurface = this.getCanvasSurface();
			this._layer = this._canvasSurface.getRootLayer();
			
			// Container of main and sub title shapes
			this._textShapes = [];
			
			// Line painting anchor
			this._anchor = { x : 0, y : 0 };
			
			this._textProcessor;
			this._theme;
		},
		
		/**
		 * Paints the title with given <code>attributes</code>. This painting job has the assumption
		 * of the stable state of paint-ability, i.e., the canvas is always empty and ready for
		 * painting.
		 * 
		 * @param {Object} attributes - Title settings
		 * @author eye
		 */
		paint : function ( attributes ) {
			for ( var i = 0; i < this._textShapes.length; i++ ) {
				this._layer.removeShape(this._textShapes[i]);
			}
			
			if ( !attributes || !attributes.main || !attributes.main.visible ) {
				this._refresh();
				return;
			}
			
			this._textShapes.splice(0, this._textShapes.length);
			this._anchor = { x : 0, y : 0 };
			
			var mainTitleLines = this.wrapWord(attributes.main.text,
					this.getLineCapacity(attributes.main.font));
			
			var mainTitleShape;
			for ( i = 0; i < mainTitleLines.length; i++ ) {
				mainTitleShape = this._layer.addShape(new TextLine());
				this.paintln({
					text : mainTitleLines[i],
					font : attributes.main.font,
					color : attributes.main.color,
					align : attributes.main.horizontalAlign
				}, mainTitleShape);
				this._textShapes.push(mainTitleShape);
			}
			
			if ( attributes.sub && attributes.sub.visible ) {
				var subTitleLines = this.wrapWord(attributes.sub.text, 
						this.getLineCapacity(attributes.sub.font));
				
				var subTitleShape;
				for ( i = 0; i < subTitleLines.length; i++ ) {
					subTitleShape = this._layer.addShape(new TextLine());
					this.paintln({
						text : subTitleLines[i],
						font : attributes.sub.font,
						color : attributes.sub.color,
						align : attributes.sub.horizontalAlign
					}, subTitleShape);
					this._textShapes.push(subTitleShape);
				}
			}
			
			this._refresh();
		},
		
		/**
		 * Paints and appends a line of text on the last painted line if any onto the target
		 * painting area which can be a layer or shape and at least an instance of a 
		 * <code>Drawable</code> object.
		 * 
		 * @param {Object} titleLine 
		 * - Title line data including text, font, color and horizontal alignment.
		 * 
		 * @param {Object} target - Instance of a <code>Shape</code>
		 * 
		 * @author eye
		 */
		paintln : function ( titleLine, target ) {
			if ( !titleLine || !target ) return;
			
			var titleWidth = TextRuler.measureWidth(titleLine.font, titleLine.text);
			target.text(titleLine.text).font(titleLine.font).textColor(titleLine.color).width(titleWidth).visible(true);
			
			var centerX = this._containerSize.width / 2;
			var height = TextRuler.measureHeight(titleLine.font);

			switch ( titleLine.align.toLowerCase() ) {
			case "center" :
				this._anchor.x = centerX;
				target.center([ this._anchor.x, this._anchor.y + height / 2 ]);
				break;
			case "left" :
				this._anchor.x = 0;
				target.leftCenter([ this._anchor.x, this._anchor.y + height / 2 ]);
				break;
			case "right" :
				this._anchor.x = this._containerSize.width;
				target.rightCenter([ this._anchor.x, this._anchor.y + height / 2 ]);
				break;
			default :
				this._anchor.x = centerX;
				target.center([ this._anchor.x, this._anchor.y + height / 2 ]);
			}
			this._anchor.y += height;
		},
	
		/**
		 * Helper function that slices a string of text into pieces within
		 * the <code>threshold</code>, a.k.a., a word wrap function.
		 * 
		 * @param {String} inputString - Input text string
		 * @param {Integer} width - Carriage return threshold
		 * 
		 * @author eye
		 */
		wrapWord : function ( inputString, width ) {
			if ( this._textProcessor ) {
				this._textProcessor.setText(inputString);
				this._textProcessor.setWidth(width);
				this._textProcessor.setWordWrapEnabled(true);
				return this._textProcessor.getLines();
			} else {
				this._textProcessor = new TextProcessor(
						inputString, { lineWidth : width, wordWrap : true });
				return this._textProcessor.getLines();
			}
		},
		
		/**
		 * Calculates and returns the actual size of the title texts
		 * according to user settings. This function determines title
		 * width by picking up the longer one, and title height will
		 * always be the addition of the two titles, if sub title is set.
		 * 
		 * @param {Object} settings 
		 * - User settings on title texts in terms of text value and font value
		 * 							
		 * @returns {Object} preferred size in JSON object
		 * 
		 * @author eye
		 */
		getPreferredSize : function ( containerSize, settings ) {
			if ( !containerSize || !settings || !settings.main ) {
				//utils.error("Container size or main title property setting is required.");
				return;
			}
			
			this._containerSize = containerSize;
			
			var returnSize = { width : 0, height : 0 }, 
				lineCapacity, 
				mtWidth, stWidth; // Main and sub title width
			
			if ( TypeUtils.isExist(settings.main.visible) && !settings.main.visible ) {
				return returnSize;
			}
			
			// Width
			lineCapacity = this.getLineCapacity(settings.main.font);
			if ( settings.main.text.length >= lineCapacity ) {
				returnSize.width = mtWidth = this._containerSize.width;
			} else {
				if ( settings.sub && settings.sub.visible ) {
					lineCapacity = this.getLineCapacity(settings.sub.font);
					if ( settings.sub.text.length >= lineCapacity ) {
						returnSize.width = stWidth = this._containerSize.width;
					} else {
						mtWidth = TextRuler.measureWidth(settings.main.font, settings.main.text);
						stWidth = TextRuler.measureWidth(settings.sub.font, settings.sub.text);
						
						mtWidth > stWidth ? returnSize.width = mtWidth : 
							returnSize.width = stWidth;
					}
				}
			}
			
			// Height
			lineCapacity = this.getLineCapacity(settings.main.font);
			var mtLines = this.wrapWord(settings.main.text, lineCapacity);
			returnSize.height += (mtLines.length * TextRuler.measureHeight(settings.main.font));
			
			lineCapacity = this.getLineCapacity(settings.sub.font);
			var stLines = this.wrapWord(settings.sub.text, lineCapacity);
			returnSize.height += (stLines.length * TextRuler.measureHeight(settings.sub.font));

			return returnSize;
		},
		
		setPreferredSize : function ( size ) {
			this._containerSize = size;
		},
		
		/**
		 * Calculates line character containment threshold by given font information.
		 * 
		 * @param {String} fontString 
		 * - The font that will be applied
		 * 
		 * @returns {Number} lineCapacity 
		 * - Number of line capacity of character containment
		 * 
		 * @author eye
		 */
		getLineCapacity : function ( fontString ) {
			var lineCapacity = 0;
			var referenceCharacter = 'r'; // The widest alphabet
			
			var unitWidth = TextRuler.measureText(fontString, referenceCharacter).width;
			// Conservative estimate is employed here.
			lineCapacity = Math.floor(this._containerSize.width / unitWidth);
			
			return lineCapacity;
		},
		
		_refresh : function () {
			this._layer.setNeedsDisplay();
		},
		
		updateProperties : function( props ) {
			delete this._options;
			this._options = props.title;
			
			var mainTitleTextFormat =  TypeUtils.isExist(this._options.main.formatString) ? this._options.main.formatString : defaultOptions.main.formatString;
			var mainTitileFT = sap.common.globalization.NumericFormatManager.getFormat(mainTitleTextFormat);
			
			var subTitleTextFormat = TypeUtils.isExist(this._options.sub.formatString) ? this._options.sub.formatString : defaultOptions.sub.formatString;
			var subTitleFT =  sap.common.globalization.NumericFormatManager.getFormat(subTitleTextFormat);
			
			this._options.main.text = TypeUtils.isExist(mainTitileFT) ? mainTitileFT.display(this._options.main.text) : this._options.main.text;
			this._options.sub.text = TypeUtils.isExist(subTitleFT) ? subTitleFT.display(this._options.sub.text) : this._options.sub.text;
			
			this.paint( this._options );
		},

		doContentResize : function(oldSize, newSize) {
			this.callParent( 'doContentResize', oldSize, newSize );
			
			var mainTitleTextFormat =  TypeUtils.isExist(this._options.main.formatString) ? this._options.main.formatString : defaultOptions.main.formatString;
			var mainTitileFT = sap.common.globalization.NumericFormatManager.getFormat(mainTitleTextFormat);
			
			var subTitleTextFormat = TypeUtils.isExist(this._options.sub.formatString) ? this._options.sub.formatString : defaultOptions.sub.formatString;
			var subTitleFT =  sap.common.globalization.NumericFormatManager.getFormat(subTitleTextFormat);
			
			this._options.main.text = TypeUtils.isExist(mainTitileFT) ? mainTitileFT.display(this._options.main.text) : this._options.main.text;
			this._options.sub.text = TypeUtils.isExist(subTitleFT) ? subTitleFT.display(this._options.sub.text) : this._options.sub.text;
			
			this.paint( this._options );
		},

		/**
		 * Applies a set of theme values into the component. This function
		 * simply modifies title properties. Graphics related function invocations
		 * are not allowed here because the title component is ignorant of
		 * shape owners, i.e., difference between main or sub title.
		 * 
		 * @param {Object} theme - Theme items
		 */
		applyTheme : function ( theme ) {
			this._theme =  ThemeManager.getThemeSettings(theme);
			
			var font, color, space = ' ';
			
			var mtStyle = ObjUtils.extend(true, {}, this._theme.global, this._theme.title.mainTitle);
			var stStyle = ObjUtils.extend(true, {}, this._theme.global, this._theme.title.subTitle);
			
			font = mtStyle["font-weight"] + space + mtStyle["font-size"] + space + mtStyle["font-family"];
			color = mtStyle["color"];
			
			this._options.main.font = font;
			this._options.main.color = color;
			
			if ( this._options.sub ) {
				font = stStyle["font-weight"] + space + stStyle["font-size"] + space + stStyle["font-family"];
				color = stStyle["color"];
				
				this._options.sub.font = font;
				this._options.sub.color = color;
			}
			
			if ( this._textShapes.length !== 0 ) {
				// Repaints the titles due to the theme change.
				this.paint(this._options);
			}
		},

		doPrint : function(drawingCtx) {
			drawingCtx.drawImage(this._canvasElement, 0, 0);
		}
	});
	TitleCanvasComponent.getDefaultOption = function() {
		return defaultOptions;
	};
	return TitleCanvasComponent;
});sap.riv.module(
{
  qname : 'sap.riv.graphics.shape.Polygon',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.FillableShape',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, TypeUtils, FillableShape, Math) {
	var _crispLineOptimization = function(start, end, width){
		
		var xEquals = (start[0] === end[0]);
    	var yEquals = (start[1] === end[1]);
    	
    	if(xEquals || yEquals){ 
    		if(xEquals){
    			start[0] = end[0] = Math.floor(start[0]);
    			
    			if(width%2 === 1){
    				start[0] = end[0] = start[0]+0.5;
    			}
    		} 
    		
    		if(yEquals){
    			start[1] = end[1] = Math.floor(start[1]);
    			
    			if(width%2 === 1){
    				start[1] = end[1] = start[1]+0.5;
    			}
    		}
    	}
    	
    	return {start:[start[0], start[1]], end:[end[0], end[1]]};
	};
	
	/**
	 * This class defines Polygon
	 * 
	 * @name sap.riv.graphics.shape.Polygon
	 * @class
	 * @augments sap.riv.graphics.shape.FillableShape
	 */
	var Polygon = ObjectUtils.derive(FillableShape, {
		constructor : function() {
			this._isClosed = false;
			this._vertices = [];
			this._hitTestVertices = [];
		},
		/**
		 * Add polygon vertices
		 * 
		 * @name sap.riv.graphics.shape.Polygon#addVertices
		 * @function
		 * @param {Number|[[x,y]]}
		 *            x the x coordinate of one vertex, or an array of vertices
		 * @param {Number}
		 *            [y] the y coordinate of one vertex
		 * 
		 * @returns {this} this object
		 */
		addVertices : function(x, y) {
			if (TypeUtils.isArray(x)) {
				var vertices = x;
				for ( var i = 0, len = vertices.length; i < len; i++) {
					this._vertices.push([ vertices[i][0], vertices[i][1] ]);
					this._hitTestVertices.push([ vertices[i][0], vertices[i][1] ]);
				}
			} else {
				if (x !== undefined, y !== undefined) {
					this._vertices.push([ x, y ]);
					this._hitTestVertices.push([ x, y ]);
				}
			}
			return this;
		},
		/**
		 * Mark the polygon is closed. You must explicitly call this method to
		 * indicate the polygon is closed.
		 * 
		 * @name sap.riv.graphics.shape.Polygon#close
		 * @function
		 * 
		 * @returns {this} this object
		 */
		close : function() {
			if (!this._isClosed) {
				this._hitTestVertices.push([].concat(this._vertices[0]));
				this._isClosed = true;
			}
			return this;
		},
		/**
		 * Reset the polygon to empty.
		 * 
		 * @name sap.riv.graphics.shape.Polygon#reset
		 * @function
		 * 
		 * @returns {this} this object
		 */
		reset : function() {
			this._isClosed = false;
			this._vertices.splice(0, this._vertices.length);
			this._hitTestVertices.splice(0, this._hitTestVertices.length);
		},

		doDraw : function(drawingContext) {
			var vtx = this._vertices;
            if (vtx.length < 2) {
                return;
            }
            
            // Adjust vertices for crisp line optimization 
            for ( var i = 1, e, len = vtx.length; i < len; i++) {
                var start = vtx[i-1];
                var end = vtx[i];
                var result = _crispLineOptimization(start, end, this.borderWidth());
                vtx[i-1] = result.start;
                vtx[i] = result.end;
            }
            
            var dCtx = drawingContext;
            dCtx.beginPath();
            dCtx.moveTo(vtx[0][0], vtx[0][1]);
            
            for ( var i = 1, e, len = vtx.length; i < len; i++) {
                e = vtx[i];
                dCtx.lineTo(e[0], e[1]);
            }
            dCtx.closePath();
            this.fillShape(dCtx);
            this.drawBorder(dCtx);
		},

		doPointInTest : (function() {
			var isLeft = function(sp, ep, tp) {
				return ((ep[0] - sp[0]) * (tp[1] - sp[1]) - (tp[0] - sp[0]) * (ep[1] - sp[1]));
			};
			return function(point) {
				var wn = 0;
				var x = point.x, y = point.y;
				var p = [ x, y ];
				for ( var i = 0, vtx = this._hitTestVertices, elen = vtx.length - 1; i < elen; i++) {
					if (vtx[i][1] <= y) {
						if (vtx[i + 1][1] > y)
							if (isLeft(vtx[i], vtx[i + 1], p) > 0)
								++wn;
					} else {
						if (vtx[i + 1][1] <= y)
							if (isLeft(vtx[i], vtx[i + 1], p) < 0)
								--wn;
					}
				}
				return wn;
			};
		})()
	});
	return Polygon;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.layout.BasicLayout',
  version : '1.0.0'
},
function Setup() {
	/**
	 * Represents a data structure for storing layout data on chart legend, title and
	 * the main chart graphical area. See legend and title parameterization settings example below:
	 * 
	 * <pre>
	 * chartOptions = {
	 *     legend:{
	 *         show: true|false, // true by default
	 *         position: 'right'|'top'|'bottom'|'left', // 'right' by default
	 * 	   },
	 * 	   title:{
	 * 	       main:{
	 * 		       show:true|false // false by default; Sub title visibility depends on that of main title.
	 *         },
	 *         sub:{
	 * 	           show:true|false // false by default
	 * 	       }
	 * 	   }
	 * }
	 * </pre>
	 */
	var basicLayout = function(size, initProps) {
		this._size = {
			width : size.width,
			height : size.height
		};
		this._layoutChanged = false;
		
		this._mainTitleVisible = false;
		this._subTitleVisible = false;
		
		this._showLegend = true;

		this._legendDock = "right";
		
		this._padding = [0, 0, 0, 0];
		this._legendFirst = false;
		this._maxLegendWidth = 0;
		this._maxLegendHeight = 0;
		this._preferredTitleWidth = 0;
		this._preferredTitleHeight = 0;
		this._parseOptions(initProps);
	};

	basicLayout.prototype = {
		_parseOptions : function ( options ) {
			// Each "!=" operator here just assumes client might pass a string value.
			if ( options.legend ) {
				if ( this._showLegend != options.legend.visible ) {
					this._showLegend = options.legend.visible;
					this._layoutChanged = true;
				}
				
				if ( this._legendDock != options.legend.position ) {
					this._legendDock = options.legend.position;
					this._layoutChanged = true;
				}
			}
			
			if ( options.title ) {
				if ( options.title.main ) {
					if ( this._mainTitleVisible !== options.title.main.visible ) {
						if ( options.title.main.visible === false ) {
							this._mainTitleVisible = false;
							this._subTitleVisible = false;
						} else {
							this._mainTitleVisible = true;
						}
						this._layoutChanged = true;
					}
				}
				
				if ( options.title.sub ) {
					if ( this._mainTitleVisible && this._subTitleVisible != options.title.sub.visible ) {
						this._subTitleVisible = options.title.sub.visible;
						this._layoutChanged = true;
					}
				}
			}
			
			if ( options.layout ) {
				if ( this._padding != options.layout.padding ) {
					this._padding = options.layout.padding;
					this._layoutChanged = true;
				}
				
				if ( this._legendFirst != options.layout.legendFirst ) {
					this._legendFirst = options.layout.legendFirst;
					this._layoutChanged = true;
				}
			}
		},
		
		layoutChanged : function () {
			return this._layoutChanged;
		},
		
		updateSize : function ( newSize ) {
			if ( this._size.width != newSize.width || this._size.height != newSize.height ) {
				this._size.width = newSize.width;
				this._size.height = newSize.height;
				this._layoutChanged = true;
			}
		},
		
		updateSettings : function ( settings ) {
			this._parseOptions(settings);
		},
		
		/**
		 * Returns layout data in terms of sub-component paddings.
		 * <pre>
		 * {
	     * 	main : [ x, y, w, h ],
	     * 	title : [ x, y, w, h ], //optional, if title is show
	     * 	legend : [ x, y, w, h ], //optional, if legend is show
	     *  background : [0, 0, w, h]
	     * }
	     * </pre>
		 */
		getLayoutInfo : function () {
			var returnObject = new Object();
			
			var padding = transformPadding(this._padding);
			var width = this._size.width - padding[1] - padding[3];
			var height = this._size.height - padding[0] - padding[2];
			
			var titleHeight = 0;
			if (this._mainTitleVisible) {
				returnObject.title = [];
				returnObject.title.push(padding[3], padding[0], width);
				titleHeight = this._preferredTitleHeight;
				returnObject.title.push(titleHeight);
			}
			
			if (this._showLegend) {
				var chartWidth, chartHeight, legendWidth, legendHeight, legendSpace = 0;
				if ( this._legendDock === 'left' || this._legendDock === 'right' ) {
					// left/right of legend
					chartWidth = width * 0.79;
					chartHeight = height - titleHeight;
					legendWidth = width * 0.15;// and we have 3% space
					legendHeight = height;
					legendSpace = width * 0.03;
					
					if(this._legendFirst){
						legendWidth = this._maxLegendWidth;
						chartWidth = width - legendWidth - 2 * legendSpace;
					}
				} else {
					legendWidth = width;
					legendHeight = height * 0.06;
					legendSpace = height * 0.03;
					chartWidth = width;
					chartHeight = height - legendHeight - titleHeight - 2 * legendSpace;
					
					if( this._legendFirst ) {
						legendHeight = this._maxLegendHeight;
						chartHeight = height - titleHeight - legendHeight - 2 * legendSpace;
					}
				}
				
				var legendX = 0, legendY = 0, mainX = 0, mainY = 0;
				returnObject.main = [];
				returnObject.legend = [];
				switch ( this._legendDock ) {
					case 'top':
						legendX = 0;
						legendY = titleHeight + legendSpace;
						mainX = 0;
						mainY = titleHeight + 2 * legendSpace + legendHeight;
						break;
					case 'bottom':
						legendX = 0;
						legendY = titleHeight + chartHeight + legendSpace;
						mainX = 0;
						mainY = titleHeight;
						break;
					case 'left':
						legendX = legendSpace;
						legendY = 0;
						mainX = legendSpace + legendWidth + legendSpace;
						mainY = titleHeight;
						break;
					case 'right':
					default:
						legendX = chartWidth + legendSpace;
						legendY = 0;
						mainX = 0;
						mainY = titleHeight;
						break;
				}
				returnObject.main.push(mainX + padding[3], mainY + padding[0], chartWidth, chartHeight);
				returnObject.legend.push(legendX + padding[3], legendY + padding[0], legendWidth, legendHeight);
			} else {
				var chartWidth = width;
				returnObject.main = [];
				returnObject.main.push(padding[3], titleHeight + padding[0], chartWidth, height - titleHeight);
			}
			returnObject.background = [];
			returnObject.background.push(0, 0, this._size.width, this._size.height);
			return returnObject;
		},
		
		setMaxLegendWidth : function ( value ) {
			this._maxLegendWidth = value;
		},
		
		setMaxLegendHeight : function ( value ) {
			this._maxLegendHeight = value;
		},
		
		setPreferredTitleWidth : function ( value ) {
			this._preferredTitleWidth = value;
		},
		
		setPreferredTitleHeight : function ( value ) {
			this._preferredTitleHeight = value;
		}
	};
	
	// Static function that transforms raw padding data into the format of
	// standard CSS padding attribute.
	// [10] => [10,10,10,10]
	// [2,3] => [2,3,2,3]
	// [1,30,5] => [1,30,5,30]
	var transformPadding = function( padding ){
		if( padding.length === 0 ){
			padding[0] = 0;
		}
		for ( var index = 0; index < 4; index++) {
			var value = padding[index];
			if (value == undefined) {
				if (index != 3) {
					padding[index] = padding[0];
				} else {
					padding[index] = padding[1];
				}
			}
		}
		return padding;
	};
	return basicLayout;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.FoucsCalculator',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math) {
	var fCalculator = function() {
	};

	fCalculator.createFocus = function(value) {
		switch (value) {
		case 'off':
			return new fCalculator.NoFocus();
		case 'full':
			return new fCalculator.StandardFocus();
		case 'growth':
			return new fCalculator.ZoomOutFocus();
		default:
			return new fCalculator.ManualFocus();
		}
	};

	fCalculator.StandardFocus = function() {
		return this;
	};

	fCalculator.StandardFocus.prototype.calculateFocus = function(options) {
		switch (options.lineScaling) {
		case 'logarithmic':
		case 'log10':
			return this.calculateLogarithmicFocus(options.minValue,
					options.maxValue);
		default:
			return this
					.calculateLinearFocus(options.minValue, options.maxValue);
		}
	};

	fCalculator.StandardFocus.prototype.calculateLogarithmicFocus = function(
			minimum, maximum) {

		var bounds = {};

		bounds.major = this.calculateMajorUnitFromBounds(minimum, maximum);
		bounds.minor = bounds.major / 3;

		var minLog = Math.log(minimum) / Math.log(10);
		var maxLog = Math.log(maximum) / Math.log(10);

		// both bounds are positive
		if (maxLog >= 0 && minLog >= 0) {
			bounds.max = maximum + 0.05 * (maximum - minimum);
			var multiplier = Math.ceil(bounds.max / bounds.major);
			bounds.max = multiplier * bounds.major;

			bounds.min = minimum - ((maximum - minimum) / 2);
			bounds.min = bounds.major * Math.ceil(bounds.min / bounds.major);
			bounds.min = Math.max(1, bounds.min);
		} else if (maxLog <= 0 && minLog <= 0) {
			if (maxLog - minLog > 0.16667 * minLog)
				bounds.max = 1;
		}

		if (bounds.min < 1)
			bounds.min = 1 / Math.pow(10, Math.max(1,
					bounds.min.toString().length - 1));

		return bounds;
	};

	fCalculator.StandardFocus.prototype.calculateLinearFocus = function(
			minimum, maximum) {
		var bounds = {};

		// standard focus overrides the user's desired intervals
		bounds.major = this.calculateMajorUnitFromBounds(minimum, maximum);
		bounds.minor = bounds.major / 3;

		// both bounds are positive
		if (maximum >= 0 && minimum >= 0) {
			bounds.max = maximum + 0.05 * (maximum - minimum);
			var multiplier = Math.ceil(bounds.max / bounds.major);
			bounds.max = multiplier * bounds.major;

			/*
			 * X4.5 had this code, but it doesn't seem to be used. Disabling it
			 * here... if(maximum - minimum > 0.16667 * maximum) { bounds.min =
			 * 0; } else
			 */
			{
				bounds.min = minimum - ((maximum - minimum) / 2);
				multiplier = Math.max(0, Math.floor(bounds.min / bounds.major));
				bounds.min = multiplier * bounds.major;
			}
		}
		// both bounds are negative
		// both bounds are negative
		else if (maximum <= 0 && minimum <= 0) {
			bounds.min = minimum + 0.05 * (minimum - maximum);
			multiplier = Math.floor(bounds.min / bounds.major);
			bounds.min = multiplier * bounds.major;
			/*
			 * X4.5 had this code, but it doesn't seem to be used. Disabling it
			 * here... if(maximum - minimum > 0.16667 * minimum) { bounds.max =
			 * 0; } else
			 */
			{
				bounds.max = maximum - ((minimum - maximum) / 2);
				multiplier = Math.min(0, Math.ceil(bounds.max / bounds.major));
				bounds.max = multiplier * bounds.major;
			}
		} else // Max is positive and min is negative
		{
			bounds.max = maximum + 0.05 * (maximum - minimum);
			multiplier = Math.ceil(bounds.max / bounds.major);
			bounds.max = multiplier * bounds.major;

			bounds.min = minimum + 0.05 * (minimum - maximum);
			multiplier = Math.floor(bounds.min / bounds.major);
			bounds.min = multiplier * bounds.major;
		}

		return bounds;

	};

	fCalculator.DEFAULT_MIN_BOUND = 0;
	fCalculator.DEFAULT_MAX_BOUND = 5;
	/**
	 * If bounds have been set to invalid values such as NaN, this function sets
	 * them to defaults. It changes min and max values that are equal so that
	 * the bounds are a proper range. It's a last resort to any other validation
	 * that has taken place so that labels are always numbers.
	 * 
	 * @param min
	 *            the desired minimum value for the axis
	 * @param max
	 *            the desired maximum value for the axis
	 * @return an Object containing validated minimum and maximum values for an
	 *         axis
	 */
	fCalculator.validateBounds = function(min, max) {
		// if we have bad data, we have defaults so the chart displays correctly
		if (TypeUtils.isNaN(min) || TypeUtils.isNaN(max)) {
			min = fCalculator.DEFAULT_MIN_BOUND;
			max = fCalculator.DEFAULT_MAX_BOUND;
		}

		// compensate for duplicate bounds, by either changing a bound to zero,
		// or reseting to defaults
		if (min === max) {
			if (min > 0)
				min = 0;
			else if (max < 0)
				max = 0;
			// last chance, min and max both must be zero, so go to our default
			// values
			else {
				min = fCalculator.DEFAULT_MIN_BOUND;
				max = fCalculator.DEFAULT_MAX_BOUND;
			}
		}

		return {
			min : min,
			max : max
		};
	};

	fCalculator.StandardFocus.prototype.calculateMajorUnitFromBounds = function(
			minValue, maxValue) {

		var s = 0;
		var range = maxValue - minValue;

		if (maxValue > 0 && minValue < 0) {
			s = Math.log(range) / Math.log(10);
			s = Math.floor(s);
			range = range / Math.pow(10, s);
			if (1 <= range && range < 1 + (81 / 99))
				range = 0.2;
			else if (1 + (81 / 99) <= range && range < 4 + (54 / 99))
				range = 0.5;
			else if (4 + (54 / 99) <= range && range < 9 + (1 / 11))
				range = 1;
			else
				range = 2;

			return range * Math.pow(10, s);
		} else if (range < (maxValue * 0.16667)) {
			range = range / 6.3492063492063;
			s = Math.log(range) / Math.log(10);
			s = Math.floor(s);
			range = range / Math.pow(10, s);
			if (range / 5 > 1)
				range = 10;
			else if (range / 2 > 1)
				range = 5;
			else if (range > 1)
				range = 2;
			else
				range = 1;

			return range * Math.pow(10, s);
		} else {
			if (minValue < 0)
				maxValue = Math.abs(minValue);

			// scale to 1 - 10
			range = Math.log(maxValue) / Math.log(10);
			s = Math.floor(range);
			range = maxValue / Math.pow(10, s);

			if (1 <= range && range < 1.90476)
				return 0.2 * Math.pow(10, s);

			if (1.09476 <= range && range < 4.76190)
				return 0.5 * Math.pow(10, s);

			if (4.76190 <= range && range < 9.5239)
				return Math.pow(10, s);

			return 2 * Math.pow(10, s);
		}
	};

	fCalculator.NoFocus = function() {
		return this;
	};

	fCalculator.NoFocus.prototype.calculateFocus = function(options) {

	};

	fCalculator.ZoomOutFocus = function() {

	};

	fCalculator.ZoomOutFocus.prototype.calculateFocus = function(options) {

	};

	fCalculator.ManualFocus = function() {

	};

	fCalculator.ManualFocus.prototype.calculateFocus = function(options) {

	};

	return fCalculator;

});sap.riv.module(
{
  qname : 'sap.riv.vizkit.VizAppDelegate',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
}
],
function Setup(FuncUtils, ThemeManager) {
	/**
	 * The abstract application delegate class. Application delegate is used to
	 * plug in your specific application logic. The object is created by
	 * VizApplication automatically
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate
	 * @constructor
	 */
	var VizAppDelegate = function() {
		this._publicMethodsRegistry = {};
		this._theme = ThemeManager.defaultTheme();
		this._application;
	};

	var vp = VizAppDelegate.prototype;

	vp._afterLaunched = function(application, launchOption) {
		this._application = application;
		this.appDidFinishLaunching(application, launchOption);
		var rootController = this.rootController();
		rootController._setApplication_(this._application);
		this._application._setRootController(rootController);
	};

	/**
	 * This method will be called after the application fully launched, the
	 * Application will pass launchOption (if any) to this method. Any
	 * application specific initialization should be put here, e.g. initialize
	 * necessary data structure.
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#appDidFinishLaunching
	 * @function
	 * @param {Object}
	 *            launchOption the launchOption which is passed in
	 *            VizApplication constructor
	 */
	vp.appDidFinishLaunching = FuncUtils.noop;

	/**
	 * Subclass <b>MUST</b> implement this method to return the root controller
	 * of the application
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#rootController
	 * @return {sap.riv.vizkit.UIController}
	 */
	vp.rootController = FuncUtils.unimplemented;

	/**
	 * This method is used to register any method specific to the current
	 * visualization implementation, and exposed to the consumer. This method is
	 * expected to be called during initialization phase, like in
	 * appDidFinishLaunching. The 'this' object of the function during invoking
	 * will be pointing to delegate object.
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#registerPublicMethod
	 * @param {String}
	 *            methodName the name of the method to be exposed
	 * @param {Function}
	 *            func the function of the method.
	 */
	vp.registerPublicMethod = function(methodName, func) {
		this._publicMethodsRegistry[methodName] = func;
	};

	vp._invokePublicMethod = function(publicMethodName, options) {
		if (this._publicMethodsRegistry.hasOwnProperty(publicMethodName)) {
			this._publicMethodsRegistry[publicMethodName].call(this, options);
		}
	};

	vp._currentTheme = function() {
		return this._theme;
	};

	vp._applyTheme = function(theme) {
		if (this._theme !== theme) {
			this.rootController().doThemeApplied(theme);
		}
	};

	vp._updateThemeSetting = function(theme, key, oldValue, newValue) {
		if (this._theme === theme) {
			this.rootController().doThemeUpdated(key, oldValue, newValue);
		}
	};
	/**
	 * Subclass should implement this method to return plain object contains all
	 * of the modifiable properties and their current value.
	 * 
	 * 
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#getProperties
	 * 
	 * @returns {Object} property bag
	 * 
	 */
	vp.getProperties = function() {
		return {};
	};

	/**
	 * Subclass should implement this method to accept a property bag.
	 * 
	 * 
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#updateProperties
	 * @param {Object}
	 *            propBag
	 * 
	 */
	vp.updateProperties = FuncUtils.noop;

	/**
	 * Subclass should implement this method to accept a dataset.
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#setDataset
	 * @param {Object}
	 */
	vp.setDataset = FuncUtils.noop;

	/**
	 * Subclass should implement this method to return a list of assets(only
	 * image supported) to be preload.
	 * 
	 * 
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#getPreloadAssets
	 * 
	 * @returns {[]} the item in the array should follow below structure
	 * 
	 * <pre>
	 * [ {
	 * 	id : 'IMAGE_ID',
	 * 	url : 'IMAGE_URL'
	 * } ]
	 * </pre>
	 */
	vp.getPreloadAssets = function() {
		return [];
	};
	/**
	 * Subclass should implement this method to return a list of supported
	 * events that could be listened by visualization user.
	 * 
	 * 
	 * 
	 * @name sap.riv.vizkit.VizAppDelegate#getSupportedEvents
	 * 
	 * @returns {[]} the list of event names
	 * 
	 */
	vp.getSupportedEvents = function() {
		return [];
	};

	vp.getSupportedMethods = function() {
		var ret = [];
		for ( var p in this._publicMethodsRegistry) {
			ret.push(p);
		}
		return ret;
	};
	return VizAppDelegate;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.DimensionAxisRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.BasicAxisRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.PositionCalculator',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, TextRuler, TypeUtils, BasicAxisRenderer, PositionCalculator) {

	var dimensionAxisRenderer = ObjectUtils
			.derive(
					BasicAxisRenderer,
					{

						constructor : function(options) {
							this._daxr_initialize();
							return this;
						},

						_daxr_initialize : function() {

							this._maxValue = this._baxr_options.labels.length + 0.5;
							this._minValue = 0.5;
							this._num_interval = this._baxr_options.labels.length - 1;
							this._dimensionAxisFT = [];
							for ( var i = 0; i < this._baxr_options.labels.length; i++) {
								if (i < this._labels.formatString.length) {
									this._dimensionAxisFT
											.push(sap.common.globalization.NumericFormatManager
													.getFormat(this._labels.formatString[i]));
								} else {
									this._dimensionAxisFT
											.push(sap.common.globalization.NumericFormatManager
													.getFormat(this._labels.formatString[this._labels.formatString.length - 1]));
								}
							}
							this._hideOverlappingLabels = false;

						},

						_getLongestWidth : function() {
							if (!TypeUtils.isExist(this._longestWidth)
									|| this._longestWidth == 0) {
								var tu = TextRuler;

								// find the longest str
								var str = TypeUtils
										.isExist(this._dimensionAxisFT[0]) ? this._dimensionAxisFT[0]
										.display(this._baxr_options.labels[0])
										: this._baxr_options.labels[0];
								var strLength = str.toString().length;
								var formatDisplay,cLabelsLength;
								for ( var i = 1, cLabelsText = this._baxr_options.labels, len = cLabelsText.length; i < len; i++) {
									// Fix the issue [Ian 2012-3-11] if all the
									// labels are number, as the length function
									// is not exist
									// we way get the incorrect max length. so
									// we call toString function to convert
									// number to string.
									formatDisplay = TypeUtils
											.isExist(this._dimensionAxisFT[i]) ? this._dimensionAxisFT[i]
											.display(cLabelsText[i])
											: cLabelsText[i];
									cLabelsLength = formatDisplay.toString().length;
									if (strLength < cLabelsLength) {
										strLength = cLabelsText[i].toString().length;
										str = formatDisplay;
									}
									// End
								}
								this._longestWidth = tu.measureWidth(
										this._labels.font, str);
							}
							return this._longestWidth;
						},

						_createLabelsAndPosition : function() {

							var opts = this._baxr_options;
							var cLabels = this._labels.itemsValue;
							var labelpositions = this._labels.itemsPosition = [];
							var multiplier = this
									._calculatePositionMultiplier();

							for ( var i = 0, labels = opts.labels; i < labels.length; i++) {
								cLabels[i] = new this.Label();
								cLabels[i]
										.value(TypeUtils
												.isExist(this._dimensionAxisFT[i]) ? this._dimensionAxisFT[i]
												.display(labels[i])
												: labels[i]);
								cLabels[i].visible(true);

								// calculate the label position
								labelpositions[i] = PositionCalculator
										.calculateLinearPosition(i + 1,
												multiplier, this._minValue);
							}
						},

						/*
						 * return the longest width among labels
						 */
						distance : function(distance) {
							if (TypeUtils.isExist(distance)) {
								this._distance = distance;

								this._createLabelsAndPosition();
								if (this._hideOverlappingLabels) {
									// Don't remove category labels, or labels
									// that can be rotated but haven't been
									this
											._removeOverlappingLabels(this._labels.itemsPosition.length);
								}

								if (this._position == 'hb'
										|| this._position == 'ht') {
									this._axisMatrics.left = this._axisMatrics.right = 0;
								} else {
									this._axisMatrics.bottom = this._axisMatrics.top = 0;
								}

								return this;
							}
							return this._distance;
						},

						/**
						 * 
						 * @param xscale
						 *            xaxis scale
						 * @param yscale
						 *            yaxis scale
						 * @param dscale
						 *            distance scale
						 */
						zoom : function(xscale, yscale, dscale) {
							this._scaled = true;
							// reset the variable
							this._positionMultiplier = null;
							this._majorTickPositions = null;
							this._minorTickPositions = null;

							var subLayer = this.getSubLayer();
							var oldSize = subLayer.size();
							subLayer.size({
								height : oldSize.height * yscale,
								width : oldSize.width * xscale
							});

							this.distance(this._distance * dscale);
							this.draw();

						},

						setVisibleRange : function(xscale, yscale, dscale) {
							this._scaled = true;
							// reset the variable
							this._positionMultiplier = null;
							this._majorTickPositions = null;
							this._minorTickPositions = null;

							var subLayer = this.getSubLayer();
							var oldSize = this._layer.size();
							subLayer.size({
								height : oldSize.height * yscale,
								width : oldSize.width * xscale
							});

							this.distance(this._distance * dscale);
						}
					});

	return dimensionAxisRenderer;

});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.legend.LegendCanvasComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Circle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Rectangle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Polygon',
  version : '1.0.0'
}
],
function Setup(TypeUtils, ObjUtils, TextRuler, Canvas2DSurfaceComponent, PropsMgr, ThemeManager, Circle, TextLine,
		Rectangle, Polygon) {
	/**
	 * canvas based legend component which accepts following options:
	 * 
	 * <pre>
	 * {
	 * 		show: true/false,//default true
	 * 		position: 'right'/'top'/'bottom'/'left',//default right
	 * 		verticalOffset : 0,
	 * 	horizontalOffset : 0
	 * 	font : 'bold 16px Arial',
	 * 		color : '#000000',
	 * }
	 * 
	 */
	var defaultOptions = {
		visible : true,
		position : 'right',
		verticalOffset : 0,
		horizontalOffset : 0,
		labelFont : 'bold 16px Arial',
		labelColor : '#000000',
		titleFont : 'bold 16px Arial',
		titleColor : '#000000',
		formatString : ['']
	};
	var textPhrase = "The quick brown fox jumps over the lazy dog";
	var LegendCanvasComponent = ObjUtils.derive(Canvas2DSurfaceComponent, {
		constructor : function(options) {
			this._options = options.legendOptions.properties.legend;

			this._parseOptions(options.legendOptions.properties);

			this._canvasSurface = this.getCanvasSurface();
			this._layer = this._canvasSurface.getRootLayer();
			this._content = null;
			this._maxLabelHeight = null;
			this._curmaxLabelHeight = this._maxLabelHeight;
			this._eventObservers = []; // Event observers who're interested in legend events.
			this._stateChangeable = false; // Used to determine if legend state and appearance can be changed upon state changes.
			this._initialize();
			this._hookEvents();
		},

		// here we get additional data
		_parseOptions : function(options) {
			this._titletxt = options._additional.legendTitle || "";
			this._colorList = options._additional.colorList;
			this._labels = options._additional.legendLabels;
			this._labelFont = options.legend.labelFont;
			this._labelFontColor = options.legend.labelColor;
			this._titleLabelFont = options.legend.titleFont;
			this._titleLabelFontColor = options.legend.titleColor;
			this._markerList = options._additional.legendMarkers || [];
			this._formatString =  options._additional.legendNumberFormat;
			this._legendFirst =  options.layout.legendFirst;
		},

		_initialize : function() {
			var labels = this._labels;
			this._title = this._layer.addShape(new TextLine());
			this._content = [];
			var markerList = this._markerList;
			var legendFT;

			this._maxLabelHeight = TextRuler.measureText(this._labelFont, textPhrase).height;
			for ( var i = 0; i < labels.length; i++) {
				var element = {};
				element.active = true;
				element.label = this._layer.addShape(new TextLine());
                element.colorListIndex = i;
                
                // If legendFirst property is true, this step will be skipped, the format is done by calMaxLegendSize function
                // It is critical that the format is only done once.
                if(!this._legendFirst){
                	// Nick - format label category if the formatString exists. if the label category is a string object, formatter will not work
                	legendFT = sap.common.globalization.NumericFormatManager.getFormat(this._formatString[i]);
                	this._labels[i].category = TypeUtils.isExist(legendFT) ? legendFT.display(this._labels[i].category) : this._labels[i].category;
                }
                element.measureIndex = labels[i].measureIndex;
                this._createMarkupShape(element, markerList[i]);
                this._content.push(element);
			}
		},

		_createMarkupShape : function(element, markerType) {
			switch (markerType) {
			case "circle":
				element.markup = this._layer.addShape(new Circle());
				element.checkedShape = this._layer.addShape(new Circle());
				break;
			case "diamond":
			case "triangle":
				element.markup = this._layer.addShape(new Polygon());
				element.checkedShape = this._layer.addShape(new Polygon());
				break;
			case "rect":
			default:
				element.markup = this._layer.addShape(new Rectangle());
				element.checkedShape = this._layer.addShape(new Rectangle());
				break;
			}
		},

		_refresh : function() {
			this._layer.setNeedsDisplay();
		},

		_resetShapes : function() {
			this._layer.removeShape(this._title);
			for ( var i = 0, len = this._content.length; i < len; i++) {
				this._layer.removeShape(this._content[i].label);
				this._layer.removeShape(this._content[i].markup);
				this._layer.removeShape(this._content[i].checkedShape);
			}
		},

		_update : function() {
			var options = this._options;
			var markerList = this._markerList;

			var titleWidth = TextRuler.measureWidth(this._titleLabelFont, this._titletxt);
			var labelHeight = this._maxLabelHeight;
        	var markupMarginRight = 0.5 * labelHeight;
        	var markupMarginTop = 0.2 * labelHeight;
        	var markupSize = 0.6 * labelHeight;
        	var labelSpace = 0.1 * labelHeight;
        	var padding = 0.2 * labelHeight;
        	var colorListIndex;
//        	this._title.text(this._titletxt).textAlign('l').font(this._titleLabelFont).textColor(
//            		this._titleLabelFontColor).width(titleWidth);
            if(options.position == 'right' || options.position == 'left'){
            	var titleHeight = 0, contentHeight = 0;
	        	if(TypeUtils.isExist(this._titletxt) && this._titletxt.toString() !== ''){
	        		this._title.text(this._titletxt).textAlign('l').font(this._titleLabelFont).textColor(
	                		this._titleLabelFontColor).width(titleWidth);
	        		titleHeight = this._title._height + labelSpace;
	        	}
            	contentHeight = titleHeight + (labelHeight + labelSpace)*this._content.length - labelSpace;
	        	var startX = padding, startY = padding + (this._chartHeight - contentHeight - 2*padding)/2; //[Christy | 2012/3/12]Start from Zero.
	        	startY = startY - options.verticalOffset;
	        	//Handler vertical offset overflow
//	        	if(startY < 0){
//	        		startY = 0;
//	        	}else if(startY > (this._chartHeight - contentHeight)){
//	        		startY = this._chartHeight - contentHeight;
//	        	}
	        	if(TypeUtils.isExist(this._titletxt) && this._titletxt.toString() !== ''){
	        		//[Christy/2012/3/16]Legend title. align left.
	        		this._title.topLeft([startX, startY]);
	        	}
	        	var py = titleHeight + startY;
	          
	            for (var i = 0; i < this._content.length; i++) {
	            
	                var element = this._content[i];
	                colorListIndex = i;
	                this._drawMarkup(markerList[i], element.markup, {x:startX, y:py + markupMarginTop}, this._colorList[colorListIndex]);
	                //[Christy || Add checked box shape.
	                this._drawCheckedShape(markerList[i], element.checkedShape, {x:startX, y:py + markupMarginTop}, this._colorList[colorListIndex]);
	                element.label.text(this._labels[i].category).textAlign('l').font(this._labelFont).textColor(
	                		this._labelFontColor).leftCenter([startX + markupSize + markupMarginRight, py + labelHeight/2])
	                        .width(TextRuler.measureWidth(this._labelFont, this._labels[i].category));
	                py += labelSpace + labelHeight;
	            }
            }else{
            	var contentWidth = 0, startX = padding, startY = padding;
            	for (var i = 0; i < this._content.length; i++) {
            		
            		contentWidth += TextRuler.measureWidth(this._labelFont, this._labels[i].category) + this._maxLabelHeight + 10;
            	}
            	//[Christy | 2012/3/12]Start from Zero.
            	startX = startX + (this._chartWidth - contentWidth)/2;
            	startX = startX + options.horizontalOffset;
            	
            	//[Christy | 2012/3/12]Don't show legend title when legend orientation is top/bottom.
            	this._title.text('');
//            	this._title.topLeft([startX, 0]);
//            	startX = startX + titleWidth +10;
            	var px = startX;
            	 for (var i = 0; i < this._content.length; i++) {
 	                var element = this._content[i];
 	                colorListIndex = i;
 	                var textWidth = TextRuler.measureWidth(this._labelFont, this._labels[i].category);
 	                this._drawMarkup(markerList[i], element.markup, {x:px, y:startY + markupMarginTop}, this._colorList[colorListIndex]);
 	                this._drawCheckedShape(markerList[i], element.checkedShape, {x:px, y:startY + markupMarginTop}, this._colorList[colorListIndex]);
 	                element.label.text(this._labels[i].category).textAlign('l').font(this._labelFont).textColor(
 	                		this._labelFontColor).topLeft([px + markupSize + markupMarginRight, startY])
 	                        .width(textWidth);
 	                px += markupSize + markupMarginRight + textWidth + labelSpace;
 	            }
            }
            this._refresh();
        },

		_drawMarkup : function(markerType, markerShape, point, fillColor) {
			var markerSize = this._maxLabelHeight * 0.6;
			markerShape.borderWidth(1).borderColor(fillColor);
			switch (markerType) {
			case "circle":
				markerShape.center({
					x : point.x + markerSize / 2,
					y : point.y + markerSize / 2
				}).radius(markerSize / 2);
				break;
			case "diamond":
				markerShape.reset();
				markerShape.addVertices(point.x + markerSize / 2, point.y);
				markerShape.addVertices(point.x, point.y + markerSize / 2);
				markerShape.addVertices(point.x + markerSize / 2, point.y + markerSize);
				markerShape.addVertices(point.x + markerSize, point.y + markerSize / 2);
				markerShape.close();
				break;
			case "triangle":
				markerShape.reset();
				var radius = markerSize / 2;
				point.x =  point.x + markerSize / 2;
				point.y = point.y + markerSize / 2;
				markerShape.addVertices(point.x, point.y - radius);
				markerShape.addVertices(point.x + radius * Math.sqrt(3) / 2, point.y + radius / 2);
				markerShape.addVertices(point.x - radius * Math.sqrt(3) / 2, point.y + radius / 2);
				markerShape.close();
				break;
			case "rect":
			default:
				markerShape.topLeft([ point.x, point.y ]).width(markerSize).height(markerSize);
				break;
			}
		},
		
		_drawCheckedShape : function(markerType, markerShape, point, fillColor){
			//[Christy] Add check box.
			var markerSize = this._maxLabelHeight * 0.6 - 4;
			point.x = point.x + 2;
			point.y = point.y + 2;
			switch (markerType) {
			case "circle":
				markerShape.center({
					x : point.x + markerSize / 2,
					y : point.y + markerSize / 2
				}).radius(markerSize / 2);
				markerShape.fillingColor(fillColor);
				break;
			case "diamond":
				markerShape.reset();
				markerShape.addVertices(point.x + markerSize / 2, point.y);
				markerShape.addVertices(point.x, point.y + markerSize / 2);
				markerShape.addVertices(point.x + markerSize / 2, point.y + markerSize);
				markerShape.addVertices(point.x + markerSize, point.y + markerSize / 2);
				markerShape.close();
				markerShape.fillingColor(fillColor);
				break;
			case "triangle":
				markerShape.reset();
				var radius = markerSize / 2;
				point.x =  point.x + markerSize / 2;
				point.y = point.y + markerSize / 2;
				markerShape.addVertices(point.x, point.y - radius);
				markerShape.addVertices(point.x + radius * Math.sqrt(3) / 2, point.y + radius / 2);
				markerShape.addVertices(point.x - radius * Math.sqrt(3) / 2, point.y + radius / 2);
				markerShape.close();
				markerShape.fillingColor(fillColor);
				break;
			case "rect":
			default:
				markerShape.topLeft([ point.x, point.y ]).width(markerSize).height(markerSize).color(fillColor);
				break;
			}
		},

		doContentResize : function(oldSize, newSize) {
			this.callParent('doContentResize', oldSize, newSize);
			this._chartHeight = newSize.height;
			this._chartWidth = newSize.width;
			this._update();
		},

		applyTheme : function(theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var legendStyle = settings.legend;
           		var globalStyle = settings.global;
            		var titleStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.title);
           		this._titleLabelFont = titleStyle['font-weight'] + " " + titleStyle['font-size'] + " " + titleStyle['font-family'];
            		this._titleLabelFontColor = titleStyle['color'];
            var labelStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.label);
            this._labelFont = labelStyle['font-weight'] + " " + labelStyle['font-size'] + " " + labelStyle['font-family'];
            this._labelFontColor = labelStyle['color'];

            this._title.font(this._titleLabelFont).textColor(this._titleLabelFontColor).width(TextRuler.measureWidth(this._titleLabelFont, this._titletxt));
            
            for (var i = 0; i < this._content.length; i++) {
                this._content[i].label.font(this._labelFont).textColor(this._labelFontColor).width(TextRuler.measureWidth(this._labelFont, this._labels[i].category));
            }
			this._refresh();
		},

		updateOptions : function(legend) {
			this._parseOptions(legend.properties);
			this._resetShapes();
			this._title = null;
			this._content = null;

			this._initialize();
			this._update();
		},

		updateProperties : function(propertyBag) {
			var oldMarkerList = this._markerList;
			this._options = propertyBag.legend;
			this._parseOptions(propertyBag);
			for ( var i = 0, len = oldMarkerList.length; i < len; i++) {
				if (oldMarkerList[i] !== this._markerList[i]) {
					var element = this._content[i];
					this._layer.removeShape(element.markup);
					this._layer.removeShape(element.checkedShape);
					this._createMarkupShape(element, this._markerList[i]);
				}
			}

			this._maxLabelHeight = TextRuler.measureText(this._labelFont, textPhrase).height;
			
			var labels = this._labels;
			
			var legendFT;
        	for(var i = 0; i < labels.length; i++) {
        		legendFT = sap.common.globalization.NumericFormatManager.getFormat(this._formatString[i]);
                labels[i].category = TypeUtils.isExist(legendFT) ? legendFT.display(labels[i].category) : labels[i].category;
        	}
			this._update();
		},

		doPrint : function(drawingCtx) {
			drawingCtx.drawImage(this._canvasElement, 0, 0);
		},
		
		calMaxLegendSize : function(options) {
			var labelFont = options.legend.labelFont;
			var maxLabelHeight = 0, maxLabelWidth = 0;
			var labelWidth = 0, labelHeight = 0, labelSize;

        	var labels = options._additional.legendLabels;
        	var labelsLength = labels.length;
        	var legendFT;
        	for(var i = 0; i < labelsLength; i++) {
        		legendFT = sap.common.globalization.NumericFormatManager.getFormat(options._additional.legendNumberFormat[i]);
                labels[i].category = TypeUtils.isExist(legendFT) ? legendFT.display(labels[i].category) : labels[i].category;
        		labelSize = TextRuler.measureText(labelFont, labels[i].category);
                labelHeight = labelSize.height;
				labelWidth = labelSize.width;
				if (labelHeight > maxLabelHeight) {
					maxLabelHeight = labelHeight;
				}
				if (labelWidth > maxLabelWidth) {
					maxLabelWidth = labelWidth;
				}
			}
			return {
				width : maxLabelWidth + maxLabelHeight + 10,
				height : maxLabelHeight
			};
		},
		
        /**
         * Attaches event observer who's interested in the legend events.
         * The event observers added here are expected to own a <code>notify</code>
         * method as a hook for being notified.
         *  
         * @param {Object} observer
         * - Interested observer
         * 
         * @author eye
         */
        addEventObserver : function ( observer ) {
        	this._eventObservers.push(observer);
        },
        
        getStateChangeable : function () {
        	return this._stateChangeable;
        },
        
        setStateChangeable : function ( changeable ) {
        	this._stateChangeable = changeable;
        },
        
		_hookEvents : function () {
        	this._layer.on([{
        		eventName : 'mouseup',
        		listener : this._dispatchEvent,
        		scope : this
        	}, {
                eventName : 'touchstart',
                listener : this._dispatchEvent,
                scope : this
            }]);
		},
		
		_dispatchEvent : function ( event ) {
        	var eventType = event.type();
        	switch ( eventType ) {
        	case 'mouseup' :
        		this._handleClick(event.targetLocalXY());
        		break;
        	case 'touchstart' :
        		this._handleClick(event.targetTouches().item(0).localXY());
        		break;
        	default:
        		break;
	        }
		},
		
		_handleClick : function ( pointCoord ) {
			if ( !this._stateChangeable ) return;
			
			var command = new Object();
			command.commandText = "ChangeSeriesVisibility";
			
			for ( var i = 0; i < this._content.length; i++ ) {
				if ( this._content[i].label.doPointInTest(pointCoord) 
        				|| this._content[i].markup.doPointInTest(pointCoord)
        				|| (this._content[i].markup.rect 
        					&& this._content[i].markup.rect.doPointInTest(pointCoord)) ) {
					command.seriesIndex = this._content[i].colorListIndex;
					if ( this._content[i].active ) {
        				this._content[i].active = false;
        				command.setVisible = false;
        				this._deactivateItem(command.seriesIndex);
        			} else {
        				this._content[i].active = true;
        				command.setVisible = true;
        				this._activateItem(command.seriesIndex);
        			}
				}
			}
			this._refresh();
			
			if ( !TypeUtils.isDefined(command.seriesIndex) ) {
				return;
			}
			
        	for ( i = 0; i < this._eventObservers.length; i++ ) {
        		this._eventObservers[i].notify(command);
        	}
		},
		
		_activateItem : function (seriesIndex) {
			var element = this._content[seriesIndex];
			element.checkedShape.visible(true);
		},
		
		_deactivateItem : function (seriesIndex) {
			var element = this._content[seriesIndex];
			element.checkedShape.visible(false);
		}
	});

	LegendCanvasComponent.getDefaultOption = function() {
		return defaultOptions;
	};
	return LegendCanvasComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.PiePlotComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.MultiPieModule',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.PieModule',
  version : '1.0.0'
}
],
function Setup(ObjUtils, LOG, UIComponent,Canvas2DSurfaceComponent, Layer,MultiPieModule,PieModule) {
	var PiePlotComponent = ObjUtils.derive(Canvas2DSurfaceComponent,
	{
		constructor : function(options) {
		 this._canvasSurface = this.getCanvasSurface();
            this._rootLayer = this._canvasSurface.getRootLayer();

            this._chart_options = options.chart;
            this._metaData = this._chart_options.metaData;
            this._dataTree = this._chart_options.dataTree;

            // the layer we actual drawing on
            this._seriesLayer = null;
            // the layer which controls the visible area and listen on event
            this._seriesMaskLayer = null;

            this._chartModule = null;

            this._init(false);

		},

        _init : function(redraw) {
            if(!redraw) {
                this._initModule();
            }
            
            this._chartModule.init();

            if(!redraw) {
                this._seriesMaskLayer = new Layer({
                    anchor : {
                        x : 0,
                        y : 0
                    }
                });
                this._seriesMaskLayer.clipToBounds(true);
                this._rootLayer.addSubLayer(this._seriesMaskLayer);
                this._seriesLayer = new Layer({
                    anchor : {
                        x : 0,
                        y : 0
                    }
                });
                this._seriesMaskLayer.addSubLayer(this._seriesLayer);
            }

            this._chartModule.bindRenderer(this._seriesLayer);

            if(!redraw) {
                this._registerEvents();
            }
        },

        _initModule : function() {
        	//[jimmy 3/7/2012] type is passed from sap.riv.html.Visualization.prototype._init
        	//it's the graphic_id user used when creating viz
            switch (this._chart_options.properties.type) {
            	case 'multipie':
            		this._chartModule = new MultiPieModule(this._chart_options);
                	break;
                case 'pie':
                default:
                	this._chartModule = new PieModule(this._chart_options);
                	break;
            }
        },

        _chart_layout : function(nsize) {
            this._chartModule.doChartLayout(nsize, this._seriesMaskLayer, this._seriesLayer);
        },

        _doDraw : function(size) {
            this._chart_layout(size);
            this._chartModule.drawSeries();
            this._rootLayer.setNeedsDisplay();
        },

        _resetEventStatusVariables : function() {
            // variables used to store mouse/touch status
            this._mouseAlreadyDown = false;
            this._mouseAlreadyMoved = false;
            // [Jimmy- 021512]we don't want mousemove too sensitive, use this
            // var to track the distance of mouse moving.
            // only when it's large than 0.5px, we think user is moving the mouse
            this._mouseMoveThreshold = 0.3;
            // [Jimmy- 021512]make sure you have to give it a value before using
            // it
            this._previousMousePosition = undefined;
            // end of variables
        },

        /**
         * [jimmy-021512]now the native event handlers are registered on layer,
         * while gestures handlers are registered on component. please note
         * touchCancel is required to handle if any other touch related events
         * are listened.
         */
        _registerEvents : function() {
            this._resetEventStatusVariables();
            this._seriesMaskLayer.on([{
                eventName : 'mousemove',
                listener : this._mouseEventHandler,
                scope : this
            }, {
                eventName : 'mouseup',
                listener : this._mouseEventHandler,
                scope : this
            }, {
                eventName : 'mousedown',
                listener : this._mouseEventHandler,
                scope : this
            }, {
                eventName : 'mouseleave',
                listener : this._mouseEventHandler,
                scope : this
            }, {
                eventName : 'touchstart',
                listener : this._touchEventHandler,
                scope : this
            }, {
                eventName : 'touchend',
                listener : this._touchEventHandler,
                scope : this
            }, {
                eventName : 'touchmove',
                listener : this._touchEventHandler,
                scope : this
            }, {
                eventName : 'touchcancel',
                listener : this._touchEventHandler,
                scope : this
            }]);
        },

        /**
         * in single chart, we directly draw shapes on series layer in the module, so actually
         * we don't need do this kind of conversion. this is only for multi chart case or other
         * special case that we create sub layers on series layer to draw chart shapes or sub charts
         * and we may not want to specify which layer to handle the event, it's up to module to determine
         * which layer to handle based on the passed in point.
         * @param mouseEvent
         *            an instance of sap.riv.graphics.MouseEvent
         */
        _convertXYForMouseEvent : function(mouseEvent) {
            // [jimmy-021512] here we'll convert coordinate from target layer to
            // the series layer
            if(this._seriesLayer == null) {
                ObjUtils.error('Series Layer should be initialized before any event handler!')
            }
            var xyOnTargetLayer = mouseEvent.targetLocalXY();
            var targetLayer = mouseEvent.targetLayer();
            var xyOnSeriesLayer = this._seriesLayer.convertPointFromLayer(xyOnTargetLayer, targetLayer);
            return xyOnSeriesLayer;
        },
        
        /**
         * in single chart, we directly draw shapes on series layer in the module, so actually
         * we don't need do this kind of conversion. this is only for multi chart case or other
         * special case that we create sub layers on series layer to draw chart shapes or sub charts
         * and we may not want to specify which layer to handle the event, it's up to module to determine
         * which layer to handle based on the passed in point.
         * @param touch
         *            an instance of sap.riv.graphics.Touch
         */
        _convertXYForTouch : function(touch) {
            // [jimmy-021512] here we'll convert coordinate from target layer to
            // the series layer
            if(this._seriesLayer == null) {
                ObjUtils.error('Series Layer should be initialized before any event handler!')
            }
            var xyOnTargetLayer = touch.localXY();
            var targetLayer = touch.targetLayer();
            var xyOnSeriesLayer = this._seriesLayer.convertPointFromLayer(xyOnTargetLayer, targetLayer);
            return xyOnSeriesLayer;
        },

        /**
         * @param mouseEvent
         *            an instance of sap.riv.graphics.MouseEvent
         */
        _mouseEventHandler : function(mouseEvent) {
            var eventType = mouseEvent.type();
            switch (eventType) {
                case 'mousedown':
                    this._mouseAlreadyDown = true;
                    // [jimmy-021512]set it to false so that we can have click after
                    // we do mouse move
                    this._mouseAlreadyMoved = false;
                    break;
                case 'mouseup':
                    this._mouseAlreadyDown = false;
                    if(!this._mouseAlreadyMoved) {
                        this._chartModule.clickOnPoint(this._convertXYForMouseEvent(mouseEvent));
                    }
                    this._mouseAlreadyMoved = false;
                    break;
                case 'mousemove':
                    if(this._previousMousePosition) {
                        var currentPosition = mouseEvent.targetLocalXY();
                        if(Math.abs(currentPosition.x - this._previousMousePosition.x) > this._mouseMoveThreshold || Math.abs(currentPosition.x - this._previousMousePosition.x) > this._mouseMoveThreshold) {
                            // we are actually moving
                            if(this._mouseAlreadyDown) {
                                // marquee selection
                                this._chartModule.marqueeOverPoint(this._convertXYForMouseEvent(mouseEvent));
                            } else {
                                // tooltip
                                this._chartModule.hoverOnPoint(this._convertXYForMouseEvent(mouseEvent));
                            }
                            // reset the moving tracking
                            this._previousMousePosition = undefined;
                            // we already move
                            this._mouseAlreadyMoved = true;
                        }
                    } else {
                        this._previousMousePosition = mouseEvent.targetLocalXY();
                    }
                    break;
                case 'mouseleave':
                    this._resetEventStatusVariables();
                    break;
                default:
                    break;
            }
        },

        _touchEventHandler: function(touchEvent){
        	var eventType = touchEvent.type();
        	switch (eventType){
	        	case 'touchstart':
	        		// TODO: need investigate why length not equal 1
	                var touch = touchEvent.targetTouches().item(0);
	                this._chartModule.hoverOnPoint(this._convertXYForTouch(touch));
	        		break;
	        	case 'touchmove':
	        		if (touchEvent.targetTouches().length() != 1) {
	                    return;
	                }
	                var touch = touchEvent.targetTouches().item(0);
	                this._chartModule.hoverOnPoint(this._convertXYForTouch(touch));
	        		break;
	        	case 'touchend':
	        		if (touchEvent.changedTouches().length() != 1) {
	                    return;
	                }
	                var touch = touchEvent.changedTouches().item(0);
	                this._chartModule.clickOnPoint(this._convertXYForTouch(touch));
	        		break;
	        	case 'touchcancel':
	        		//LOG.debug('about to cancel touch!')
	        		break;
	        	default:
	                break;
        	}
        },
        
        /**
         * Resize component's visual content, when the component's size changed,
         * this method will be invoked before layout sub components
         */
        doContentResize : function(osize, nsize) {
            this.callParent('doContentResize', osize, nsize);
            this._doDraw(nsize);
        },

        applyTheme : function(theme) {
        	this._chartModule.applyTheme(theme);
        },

        updateProperties : function(propBag) {
        	this._chart_options.properties = propBag;
        	this._chartModule.updateProperties(propBag);
        	this._doDraw(this.size());
        },

        updateOptions : function(options) {
            this._chart_options = options;
            this._metaData = options.metaData;
            this._dataTree = options.dataTree;

            this._chartModule.updateOptions(this._chart_options);
            this._init(true);
            this._doDraw(this.size());
        },

        /**
         * @return events which can be listened by clients
         */
        getSupportedAppEvents : function() {
            return this._chartModule.getSupportedAppEvents();
        },

		doPrint : function(drawingCtx) {

		}
	});
	return PiePlotComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.background.BackgroundComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Canvas2DSurfaceComponent, PropsMgr, Layer, ThemeManager) {
	/**
	 * It accepts following options:
	 * 
	 * <pre>
	 * {
	 * 	color : null
	 *  visible : true
	 * }
	 * by default, we don't draw any background 
	 * </pre>
	 */
	var defaultOptions = {
		color : null,
		visible : true
	};

	var BackgroundComponent = ObjUtils.derive(Canvas2DSurfaceComponent, {
		constructor : function(options) {
			this._options = options.backgroundOptions;

			this._canvasSurface = this.getCanvasSurface();
			this._layer = this._canvasSurface.getRootLayer();

			var size = this.size();
			// FIXME currently there is a bug in framework to set
			// bgcolor in
			// rootlayer, so we add a new sublayer to draw the
			// background
			this._mainLayer = new Layer({
				anchor : {
					x : 0,
					y : 0
				},
				position : {
					x : 0,
					y : 0
				},
				size : {
					w : size.width,
					h : size.height
				}
			});
			this._layer.addSubLayer(this._mainLayer);
			this._bgc_initialize();
		},

		_bgc_initialize : function() {
			this._bgc_setBgColor();
		},

		_bgc_setBgColor : function() {
			// TODO currently we only support background color, we need
			// draw something if we have more requirement
			if (this._options.visible && this._options.color) {
				this._mainLayer.backgroundColor(this._options.color);
			} else {
				this._mainLayer.backgroundColor(false);
			}
		},

		_bgc_refresh : function() {
			this._mainLayer.setNeedsDisplay();
		},

		updateProperties : function(propertyBag) {
			delete this._options;
			this._options = propertyBag.background;
			this._bgc_setBgColor();
			this._bgc_refresh();
		},

		doContentResize : function(oldSize, newSize) {
			this.callParent('doContentResize', oldSize, newSize);
			this._mainLayer.size(newSize);
		},

		applyTheme : function(theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			this.updateProperties({
				background: {
					color : settings['background']
				}
			});
		},

		doPrint : function(drawingCtx) {
			drawingCtx.drawImage(this._canvasElement, 0, 0);
		}
	});

	BackgroundComponent.getDefaultOption = function() {
		return defaultOptions;
	};
	return BackgroundComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.PieComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.title.TitleCanvasComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.background.BackgroundComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.legend.LegendCanvasComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.descriptor.Descriptor',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.layout.BasicLayout',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.PiePlotComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
}
],
function Setup(ObjUtils,TypeUtils, LOG, UIComponent, TitleCanvasComponent, BackgroundComponent, LegendCanvasComponent, PropsMgr,
		Descriptor, BasicLayout, PiePlotComponent,ThemeManager) {
	var PieComponent = ObjUtils.derive(UIComponent,
	/**
	 * @lends sap.riv.vizkit.UIComponent
	 */
	{
		constructor : function(options) {
			this._dataTree = options.dataset.dataTree;
			this._metaData = options.dataset.metaData;
			this._pie_options = {
				selectionMode : 'single',
				allSelectable : true,
				allDeSelectable : true,
				selectedDataIndexes : [],
            			//possible value pie|donut
				pieType : 'pie',
				//possible value pie/multipie, internal property
            			type: 'pie',
				measures : [],// pass in array to override this
				
				measureDefault : {
					sectorColors : ["#113975","#e06f00","#5a92e2","#624628",
					                "#e03c2f","#ffbe7f","#96a8c3","#a9a9a9",
					                "#830b00","#344b6d","#e2ce44","#ff6657"
					               ],
					
				},
				
				tooltip : {
					text : {
						font :  undefined,
	            		color : '#000000',
	            		formatString:[''] // re-use last one
					},
				
					mainValue : {
	            		font :  undefined,
	                	color : '#000000',
	                	formatString:[''] // re-use last one
					},
					
					subValue : {
	            		font :  undefined,
	                	color : '#000000',
	                	formatString:['0.00%'] // re-use last one
					}
				},
				layout : {
					padding : [0, 0, 0, 0],
					legendFirst : true
				},
				theme : '',
				isShowPieInnerShadow : false,
				isShowPieOuterShadow : false
			};
			this._pie_options.title = ObjUtils.extend(true, {}, TitleCanvasComponent.getDefaultOption());
			this._pie_options.background = ObjUtils.extend(true, {}, BackgroundComponent.getDefaultOption());
			this._pie_options.legend = ObjUtils.extend(true, {}, LegendCanvasComponent.getDefaultOption());
			
			// default value
			var descriptor;
			if (options.pieOptions.type === 'pie') {
			    descriptor = Descriptor.getPieDescriptor();
			} else if (options.pieOptions.type === 'multipie') {
			    descriptor = Descriptor.getMultiPieDescriptor();
			}
			this._propsMgr = new PropsMgr(descriptor);
			var validatedOptions = this._propsMgr.properties(options.pieOptions);
			this._pie_options = ObjUtils.extend(true, this._pie_options, validatedOptions);
			
			//[Christy/20120423] Check theme propeties.
      		if(TypeUtils.isExist(options.pieOptions.theme) && options.pieOptions.theme !== ''){
      			this._resolveThemeAndProperties(options.pieOptions);
      		}
      		this._pie_options = ObjUtils.extend(true, this._pie_options, options.pieOptions);
      		this._propsMgr.properties(this._pie_options);
      		 
			this._attach_additional_properties();

			this._legendComponent = null;
			this._pieComponent = null;
			this._titleComponent = null;
			this._pie_layout = null;
			this._mode = null;
			this._colorList = null;
			this._initSubComponents(false);
		},

        _resolveThemeAndProperties : function(options){
        	var theme = options.theme;
        	var settings = ThemeManager.getThemeSettings(theme);
        	var globalStyle = settings.global;
        	
        	//Background 
        	options.background = options.background || {};
        	options.background.color = options.background.color || settings.background;
        	
        	//Legend Style
        	var legendStyle = settings.legend;
        	var legendTitleStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.title);
        	var legendLabelStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.label);
        	options.legend = options.legend || {};
        	options.legend.titleFont = options.legend.titleFont || (legendTitleStyle['font-weight'] + " " + legendTitleStyle['font-size'] + " " + legendTitleStyle['font-family']);
        	options.legend.titleColor = options.legend.titleColor || (legendTitleStyle['color']);
        	options.legend.labelFont = options.legend.labelFont || (legendLabelStyle['font-weight'] + " " + legendLabelStyle['font-size'] + " " + legendLabelStyle['font-family']);
        	options.legend.labelColor = options.legend.labelColor || (legendLabelStyle['color']);
        	
            //Title Style
        	var mainTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.mainTitle);
        	var subTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.subTitle);
        	options.title = options.title || {};
        	options.title.main = options.title.main || {};
        	options.title.main.font = options.title.main.font || (mainTitleStyle["font-weight"] + ' ' + mainTitleStyle["font-size"] + ' ' + mainTitleStyle["font-family"]);
        	options.title.main.color = options.title.main.color || (mainTitleStyle["color"]);
        	
        	options.title.sub = options.title.sub || {};
        	options.title.sub.font = options.title.sub.font || (subTitleStyle["font-weight"] + ' ' + subTitleStyle["font-size"] + ' ' + subTitleStyle["font-family"]);
        	options.title.sub.color = options.title.sub.color || (subTitleStyle["color"]);
        	
			//Pie Sector
			var pieStyle = settings.pie;
			options.isShowPieInnerShadow = options.isShowPieInnerShadow || pieStyle.isShowInnerShadow;
			options.isShowPieOuterShadow = options.isShowPieOuterShadow || pieStyle.isShowOuterShadow
			
			//TODO Merge Tooltip properties and theme
			var donutStyle = pieStyle.donut;
			var measureStyle = ObjUtils.extend(true, {}, globalStyle, donutStyle.measureLabel);
			
			var tooltipStyle = pieStyle.tooltip;
			options.tooltip = options.tooltip || {};
			var dimensionStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.dimensionLabel);
			options.tooltip.text = options.tooltip.text || {};
			options.tooltip.text.font = options.tooltip.text.font || dimensionStyle['font-weight'] + " " + dimensionStyle['font-size'] + " " + dimensionStyle['font-family'];
    		options.tooltip.text.color = options.tooltip.text.color || dimensionStyle['color'];
			
			var valueStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.valueLabel);
			options.tooltip.mainValue = options.tooltip.mainValue || {};
			options.tooltip.mainValue.font = options.tooltip.mainValue.font || valueStyle['font-weight'] + " " + valueStyle['font-size'] + " " + valueStyle['font-family'];
			options.tooltip.mainValue.color = options.tooltip.mainValue.color || valueStyle['color'];
			
			var percentStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.percentLabel);
			options.tooltip.subValue = options.tooltip.subValue || {};
			options.tooltip.subValue.font = options.tooltip.subValue.font || percentStyle['font-weight'] + " " + percentStyle['font-size'] + " " + percentStyle['font-family'];
			options.tooltip.subValue.color = options.tooltip.subValue.color || percentStyle['color'];
        },
        
        _initSubComponents : function(redraw) {
            //LOG.debug("chart[" + this.id() + "]start initialize SubComponents.", "perf");
            this.autoresizeSubComponents(false);
            var size = this.size();
            if (!redraw) {
                this._pie_layout = new BasicLayout(size, this._pie_options);
            }

				if (!redraw) {
					this._backgroundComponent = new BackgroundComponent({
						enable : true,
						anchor : {
							x : 0,
							y : 0
						},
						position : {
							x : 0,
							y : 0
						},
						size : {
							w : size.width,
							h : size.height
						},
						backgroundOptions : this._pie_options.background,
						id : 'backgroundComponent'
					});
					// background component is always the first component
					this.addSubComponent(this._backgroundComponent);
					//LOG.debug("chartComponent["+this.id() + "]subComponent[" + this._backgroundComponent.getCanvasSurface().getRootLayer().id() + "]initialized.", "perf");

					// here we give a default size to title(or any other sub)
					// component to ensure
					// sub component has initial size to rely on
					// sap.riv.vizkit.UIComponent.Autosizing
					// for auto layout
					this._titleComponent = new TitleCanvasComponent({
						enable : true,
						anchor : {
							x : 0,
							y : 0
						},
						position : {
							x : 0,
							y : 0
						},
						size : {
							w : size.width,
							h : size.height
						},
						titleOptions : this._pie_options.title,
						id : 'pieTitleComponent'
					});
					//LOG.debug("chartComponent["+this.id() + "]subComponent[" + this._titleComponent.getCanvasSurface().getRootLayer().id() + "]initialized.", "perf");

					this._legendComponent = new LegendCanvasComponent({
						enable : true,
						anchor : {
							x : 0,
							y : 0
						},
						position : {
							x : 0,
							y : 0
						},
						size : {
							w : size.width,
							h : size.height
						},
						legendOptions : {
							properties : this._pie_options
						},
						id : 'pieLegendComponent'
					});
					//LOG.debug("chartComponent["+this.id() + "]subComponent[" + this._legendComponent.getCanvasSurface().getRootLayer().id() + "]initialized.", "perf");

					this._pieComponent = new PiePlotComponent({
						enable : true,
						anchor : {
							x : 0,
							y : 0
						},
						position : {
							x : 0,
							y : 0
						},
						size : {
							w : size.width,
							h : size.height
						},
						chart : {
							metaData : this._metaData,
							dataTree : this._dataTree,
							properties : this._pie_options
						},
						id : 'piePlotComponent'
					});
					//LOG.debug("chartComponent["+this.id() + "]subComponent[" + this._pieComponent.getCanvasSurface().getRootLayer().id() + "]initialized.", "perf");
				}
		},

		/**
		 * Resize component's visual content, when the component's size changed,
		 * this method will be invoked before layout sub components
		 */
		doContentResize : function(osize, nsize) {
			this.callParent('doContentResize', osize, nsize);
        	this._pie_layout.updateSize(nsize);
			this._pie_relayout();
        },
        
        /**
         * when we pass properties to the sub components, we may 
         * want to attach some special properties(calculated properties) for sub
         * components. these properties are internal and should not be returned
         * to clients
         */
        _attach_additional_properties : function(){
        	if(this._pie_options){
        		var options = this._pie_options;
        		//reset before we attach 
        		delete options._additional;
        		var _additional = {};
        		//attach colorlist
                var colorList = [];
                var legendNumberFormat = [], tooltipeTextNumberFormat=[],tooltipeMainValueNumberFormat = [],tooltipeSubValueNumberFormat = [];
                var labels = this._getEffectiveLables();
    			if (options.measures) {
    				//for single pie, we only have one measure
    				var smeasure = options.measures[0];
    				if(smeasure && smeasure.sectorColors && smeasure.sectorColors.length > 0){
    					var scolors = smeasure.sectorColors;
						for ( var i = 0, j = 0, colorLen = scolors.length, len = labels.length; i < len; i++) {
    						j = i % colorLen;
    						colorList.push(scolors[j]);
						}
    				}
    				else {
        				var scolors = options.measureDefault.sectorColors;
        				if(scolors){
    						for ( var i = 0, j = 0, colorLen = scolors.length, len = labels.length; i < len; i++) {
    							j = i % colorLen;
    							colorList.push(scolors[j]);
    						}
    					}
        			}
    			}
    			
    		 
    			var formats = options.legend.formatString;
    			for(var i=0, formatsLen=formats.length, len =labels.length; i<len; i++){
    				if(i < formatsLen){
    					legendNumberFormat.push(formats[i]);
    				}else{
    					legendNumberFormat.push(formats[formatsLen-1]);
    				}
    			}
    		 
    			// Tooltip dimension lable format  
     			var formats = options.tooltip.text.formatString;
    			for(var i=0, formatsLen=formats.length, len =labels.length; i<len; i++){
    				if(i < formatsLen){
    					tooltipeTextNumberFormat.push(formats[i]);
    				}else{
    					tooltipeTextNumberFormat.push(formats[formatsLen-1]);
    				}
    			}
    		 
    			// Tooltip dimension value format  
    			var formats = options.tooltip.mainValue.formatString;
    			for(var i=0, formatsLen=formats.length, len =labels.length; i<len; i++){
    				if(i < formatsLen){
    					tooltipeMainValueNumberFormat.push(formats[i]);
    				}else{
    					tooltipeMainValueNumberFormat.push(formats[formatsLen-1]);
    				}
    			}
    		 
    			
    			// Tooltip dimension percentage format  
    			var formats = options.tooltip.subValue.formatString;
    			for(var i=0, formatsLen=formats.length, len =labels.length; i<len; i++){
    				if(i < formatsLen){
    					tooltipeSubValueNumberFormat.push(formats[i]);
    				}else{
    					tooltipeSubValueNumberFormat.push(formats[formatsLen-1]);
    				}
    			}
    		 
    			
    			_additional.colorList = colorList;
    			_additional.legendNumberFormat = legendNumberFormat;
    			_additional.tooltipeTextNumberFormat = tooltipeTextNumberFormat;
    			_additional.tooltipeMainValueNumberFormat = tooltipeMainValueNumberFormat;
    			_additional.tooltipeSubValueNumberFormat = tooltipeSubValueNumberFormat;
 
    			//attach legend labels
    			_additional.legendLabels = labels;
    			//attach legend title
    			_additional.legendTitle = this._metaData.dimension[this._metaData.dimension.length - 1].name;
    			
    			this._pie_options._additional = _additional;
        	}
        },        
        
        _getEffectiveLables : function(){
        	var tree = this._dataTree;
        	var dimensions = this._metaData.dimension;
        	//[jyang 3/15/2012] for pie now we support up to 2 axis, for single axis
        	//we will use it to feed pie sectors. for dual axes, we will use the first(as well as measures)
        	//as multiplier and the second as feed of pie sectors
        	//only pie sectors feed need show in the legend
        	var axisNum = this._metaData.axisNum;
        	var whichAnalysisAxis = 0;
        	if(axisNum == 2){
        		whichAnalysisAxis = 1;
        	}
        	//[jyang 3/15/2012] currently we only support one dimension on the second axis. if we 
        	//support more, here we should do cartesian product on all dimensions on the second axis for sector feed
        	var pathToLegendDimension = [];
        	for(var i = 0, len = dimensions.length; i < len; i++){
        		var dt = dimensions[i];
        		if(dt.analysisAxisIndex === whichAnalysisAxis){
        			//we only support one, so we break here
        			break;
        		}else{
        			pathToLegendDimension.push(0);
        		}
        	}
        	var categories = tree.getSubMemberLabels(pathToLegendDimension);
        	var labels = [], category, value;
        	var length = categories.length;
        	for(var i = 0; i < length; i++){
        		category = categories[i];
                labels.push({
    				category : category
        		});
        		 
        	}
        	return labels;
        },
        
        _pie_processLayoutOfComponent : function(component, layarr) {
			if (!layarr) {
			    //log component which won't be layout.
			    //LOG.debug("chart["+this.id()+"]"+"subComponent["+component.getCanvasSurface().getRootLayer().id()+"]skipped.", "perf");
				component.detachFromSuperComponent();
			} else {
			    LOG.debug("chartComponent["+this.id()+"]"+"subComponent["+component.getCanvasSurface().getRootLayer().id()+"]initialized.", "perf");
				if (!component.superComponent()) {
					// has been detached, re-attach
					this.addSubComponent(component);
				}
				component.position({
					x : layarr[0],
					y : layarr[1],
				});
				component.size({
					width : layarr[2],
					height : layarr[3],
				});
			}
		},

		_pie_relayout : function(force) {
			if (this._pie_layout.layoutChanged() || force) {
				if (this._pie_options.layout.legendFirst) {
					var legendSize = this._legendComponent.calMaxLegendSize(this._pie_options);
					this._pie_layout.setMaxLegendWidth(legendSize.width);
					this._pie_layout.setMaxLegendHeight(legendSize.height);
				}
				
				var titleSize = this._titleComponent.getPreferredSize(this._pie_layout._size, 
						this._pie_options.title);
				
				this._pie_layout.setPreferredTitleWidth(titleSize.width);
				this._pie_layout.setPreferredTitleHeight(titleSize.height);
				
				var layoutinfo = this._pie_layout.getLayoutInfo();
	        	//Ian [2012-4-10] fix the bug:ADAPT01629959, when the chart's width or height is less than 0, we should do nothing.
				//Nick [2012-4-19] move the following code from doContentResize function here.
	        	if(layoutinfo.main[2] <=0 || layoutinfo.main[3] <=0){
	        		return;
	        	}
	        	//End
				if ( layoutinfo.title ) {
					this._titleComponent.setPreferredSize({
						width : layoutinfo.title[2],
						height : layoutinfo.title[3]
					});
				}
				this._pie_processLayoutOfComponent(this._pieComponent, layoutinfo.main);
				this._pie_processLayoutOfComponent(this._titleComponent, layoutinfo.title);
				this._pie_processLayoutOfComponent(this._legendComponent, layoutinfo.legend);
				this._pie_processLayoutOfComponent(this._backgroundComponent, layoutinfo.background);
			}
		},
        
        applyTheme : function(theme) {
        	var options = this._pie_options;
        	this._setThemes(options, theme);
        	this.updateProperties(options);
//            this._backgroundComponent.applyTheme(theme);
//            this._titleComponent.applyTheme(theme);
//            this._legendComponent.applyTheme(theme);
//            this._pieComponent.applyTheme(theme);
        },
        
        _setThemes : function(options, theme){
        	var settings = ThemeManager.getThemeSettings(theme);
        	var globalStyle = settings.global;
        	
        	//Background 
        	options.background.color = settings.background;
        	
        	//Legend Style
        	var legendStyle = settings.legend;
        	var legendTitleStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.title);
        	var legendLabelStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.label);
        	options.legend.titleFont = (legendTitleStyle['font-weight'] + " " + legendTitleStyle['font-size'] + " " + legendTitleStyle['font-family']);
        	options.legend.titleColor = (legendTitleStyle['color']);
        	options.legend.labelFont = (legendLabelStyle['font-weight'] + " " + legendLabelStyle['font-size'] + " " + legendLabelStyle['font-family']);
        	options.legend.labelColor = (legendLabelStyle['color']);
        	
            //Title Style
        	var mainTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.mainTitle);
        	var subTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.subTitle);
        	options.title.main.font = (mainTitleStyle["font-weight"] + ' ' + mainTitleStyle["font-size"] + ' ' + mainTitleStyle["font-family"]);
        	options.title.main.color = (mainTitleStyle["color"]);
        	
        	options.title.sub.font = (subTitleStyle["font-weight"] + ' ' + subTitleStyle["font-size"] + ' ' + subTitleStyle["font-family"]);
        	options.title.sub.color = (subTitleStyle["color"]);
        	
			//Pie Sector
			var pieStyle = settings.pie;
			options.isShowPieInnerShadow = pieStyle.isShowInnerShadow;
			options.isShowPieOuterShadow = pieStyle.isShowOuterShadow
			
			//TODO Merge Tooltip properties and theme
			var donutStyle = pieStyle.donut;
			var measureStyle = ObjUtils.extend(true, {}, globalStyle, donutStyle.measureLabel);
			
			var tooltipStyle = pieStyle.tooltip;
			var dimensionStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.dimensionLabel);
			options.tooltip.text.font = dimensionStyle['font-weight'] + " " + dimensionStyle['font-size'] + " " + dimensionStyle['font-family'];
    		options.tooltip.text.color = dimensionStyle['color'];
			
			var valueStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.valueLabel);
			options.tooltip.mainValue.font = valueStyle['font-weight'] + " " + valueStyle['font-size'] + " " + valueStyle['font-family'];
			options.tooltip.mainValue.color = valueStyle['color'];
			
			var percentStyle = ObjUtils.extend(true, {}, globalStyle, tooltipStyle.percentLabel);
			options.tooltip.subValue.font = percentStyle['font-weight'] + " " + percentStyle['font-size'] + " " + percentStyle['font-family'];
			options.tooltip.subValue.color = percentStyle['color'];
        },
        
        updateProperties : function(propBag) {
			var validatedOptions = this._propsMgr.properties(propBag);
			this._pie_options = ObjUtils.extend(true, this._pie_options, validatedOptions);
			this._attach_additional_properties();
			this._pie_layout.updateSettings(this._pie_options);

			this._pie_relayout(false);
			// sub component update properties
			this._backgroundComponent.updateProperties(this._pie_options);
			this._pieComponent.updateProperties(this._pie_options);
			this._titleComponent.updateProperties(this._pie_options);
			this._legendComponent.updateProperties(this._pie_options);
		},

		getProperties : function() {
			return this._propsMgr.properties();
		},

		setDataset : function(dataset) {
			this._dataTree = dataset.dataTree;
			this._metaData = dataset.metaData;
			this._initSubComponents(true);
			// re_attach additional properties
			this._attach_additional_properties();
			this._pie_relayout(false);
			this._pieComponent.updateOptions({
				mode : this._mode,
				metaData : this._metaData,
				dataTree : this._dataTree,
				properties : this._pie_options
			});

            this._legendComponent.updateOptions({
                title : this._metaData.dimension[0],
                labels : this._dataTree.getSubMembersAt(),
                properties : this._pie_options
            });
			if(this._pie_options.layout.legendFirst==true){
                this._pie_relayout();
			}
        },
        
        /**
         * @return events which can be listened by clients
         */
        getSupportedAppEvents : function(){
        	return this._pieComponent.getSupportedAppEvents();
        },

		doPrint : function(drawingCtx) {

		}
	});
	return PieComponent;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.UIController',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
}
],
function Setup(FuncUtils, UIComponent) {
	/**
	 * The base class of Controller in VizKit MVC framework
	 * 
	 * @name sap.riv.vizkit.UIController
	 * @constructor
	 * @param {Object}
	 *            options any arguments you want to pass in when initialize your
	 *            concrete subclass of controller
	 */
	var controller = function(options) {
		this._defaultWidth = 300;
		this._defaultHeight = 150;
		this._app;
		this._uiComp;
	};

	var cp = controller.prototype;

	/**
	 * Return the root component of the hierarchy that this controller manages
	 * 
	 * @name sap.riv.vizkit.UIController#rootUIComponent
	 * @function
	 * @returns {sap.riv.vizkit.UIComponent}
	 */
	cp.rootUIComponent = function() {
		if (!this._uiComp) {
			this._uiComp = this.initUIComponent(this._defaultWidth, this._defaultHeight);
			this._uiComp.on({
				eventName : 'beforeShow',
				listener : this._handleBeforeShow,
				scope : this
			});
			this._uiComp.on({
				eventName : 'beforeHide',
				listener : this._handleBeforeHide,
				scope : this
			});
			this._uiComp.on({
				eventName : 'afterShow',
				listener : this._handleAfterShow,
				scope : this
			});
			this._uiComp.on({
				eventName : 'afterHide',
				listener : this._handleAfterHide,
				scope : this
			});
			this.afterUIComponentLoaded();
		}
		return this._uiComp;
	};

	cp._handleBeforeHide = function(hide) {
		this.beforeUIComponentDisappear();
	};

	cp._handleBeforeShow = function(hide) {
		this.beforeUIComponentAppear();
	};

	cp._handleAfterHide = function(hide) {
		this.afterUIComponentDisappear();
	};

	cp._handleAfterShow = function(hide) {
		this.afterUIComponentAppear();
	};

	cp._setApplication_ = function(application) {
		this._app = application;
	};

	/**
	 * Get the application instance
	 * 
	 * @name sap.riv.vizkit.UIController#getApplication
	 * @function
	 * @returns {sap.riv.vizkit.VizApplication}
	 */
	cp.getApplication = function() {
		return this._app;
	};
	/**
	 * Fire the event supported by application which is declared in
	 * {@link sap.riv.vizkit.VizAppDelegate#getSupportedEvents}
	 * 
	 * @name sap.riv.vizkit.UIController#fireAppEvent
	 * @function
	 */
	cp.fireAppEvent = function(event, arguments) {
		this._app._fireEvent(event, arguments);
	};

	/**
	 * Subclass should override this method to initialize its own UIComponent
	 * hierarchy and return the root UIComponent. The default implementation
	 * creates an empty UIComponent
	 * 
	 * @name sap.riv.vizkit.UIController#initUIComponent
	 * @function
	 * @param {Number}
	 *            initWidth the initial width of the root component
	 * @param {Number}
	 *            initHeight the initial height of the root component
	 * 
	 */
	cp.initUIComponent = function(initWidth, initHeight) {
		return new UIComponent({
			size : {
				w : initWidth,
				h : initHeight
			}
		});
	};

	/**
	 * This method will be called after the root UIComponent initialized
	 * 
	 * @name sap.riv.vizkit.UIController#afterUIComponentLoaded
	 * @function
	 */
	cp.afterUIComponentLoaded = FuncUtils.noop;

	/**
	 * This method will be called when the managed UIComponent will become
	 * visible via set the hidden property
	 * 
	 * @name sap.riv.vizkit.UIController#beforeUIComponentAppear
	 * @function
	 */
	cp.beforeUIComponentAppear = FuncUtils.noop;

	/**
	 * This method will be called after the managed UIComponent became visible
	 * via set the hidden property
	 * 
	 * @name sap.riv.vizkit.UIController#afterUIComponentAppear
	 * @function
	 */
	cp.afterUIComponentAppear = FuncUtils.noop;
	/**
	 * This method will be called when the managed UIComponent will become
	 * visible via set the hidden property
	 * 
	 * @name sap.riv.vizkit.UIController#beforeUIComponentDisappear
	 * @function
	 */
	cp.beforeUIComponentDisappear = FuncUtils.noop;
	/**
	 * This method will be called after the managed UIComponent became visible
	 * via set the hidden property
	 * 
	 * @name sap.riv.vizkit.UIController#afterUIComponentDisappear
	 * @function
	 */
	cp.afterUIComponentDisappear = FuncUtils.noop;

	/**
	 * This method will be called when user apply a new theme, and if and only
	 * if the controller is the root controller.
	 * 
	 * @name sap.riv.vizkit.UIController#doThemeApplied
	 * @function
	 * @param {String}
	 *            old the name of the old theme
	 * @param {String}
	 *            new the name of the new theme
	 */
	cp.doThemeApplied = FuncUtils.noop;

	/**
	 * This method will be called when user update the theme setting and if and
	 * only if the controller is the root controller.
	 * 
	 * @name sap.riv.vizkit.UIController#doThemeUpdated
	 * @function
	 * @param {String}
	 *            key the key of the updated property
	 * @param {Object}
	 *            oldValue the old value
	 * @param {Object}
	 *            newValue the new value
	 */
	cp.doThemeUpdated = FuncUtils.noop;
	return controller;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.gridLine.GridLine',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Line',
  version : '1.0.0'
}
],
function Setup(TypeUtils, PropsMgr, ThemeManager, Math, Line) {
	var defaultOptions = {
		showMajor : false,
		majorColor : '#c9c9c9',
		majorThickness : '1',

		showMinor : false,
		minorColor : '#c9c9c9',
		minorThickness : '1',

		showSub : false,
		subColor : '#c9c9c9',
	};

	/**
	 * 
	 */
	var gridLine = function() {

		this._xAxis = null;
		this._yAxis = null;
		this._xAxisLayer = null;
		this._yAxisLayer = null;
		this._seriesMaskLayer = null;

		this._majorGridLineShape = [];
		this._minorGridLineShape = [];
		this._subGridLineShape = [];

	};

	gridLine.prototype.setXAxis = function(xAxis) {
		this._xAxis = xAxis;
	};

	gridLine.prototype.setXAxisLayer = function(xAxisLayer) {
		this._xAxisLayer = xAxisLayer;
	};

	gridLine.prototype.setYAxis = function(yAxis) {
		this._yAxis = yAxis;
	};

	gridLine.prototype.setYAxisLayer = function(yAxisLayer) {
		this._yAxisLayer = yAxisLayer;
	};

	gridLine.prototype.setYAxisOptions = function(yAxisOptions) {
		this._yAxis_options = yAxisOptions;
	};

	gridLine.prototype.setXAxisOptions = function(xAxisOptions) {
		this._xAxis_options = xAxisOptions;
	};

	gridLine.prototype.setSeriesMaskLayer = function(seriesMaskLayer) {
		this._seriesMaskLayer = seriesMaskLayer;
	};

	gridLine.prototype.setSeriesLayer = function(seriesLayer) {
		this._seriesLayer = seriesLayer;
	};

	gridLine.prototype.getXAxis = function() {
		if (TypeUtils.isExist(this._xAxis)) {
			return this._xAxis;
		}
		return null;
	};

	gridLine.prototype.getYAxis = function() {
		if (TypeUtils.isExist(this._yAxis)) {
			return this._yAxis;
		}
		return null;
	};

	/**
	 * Draw grid line
	 */
	gridLine.prototype.drawGridLine = function() {
		// add major grid line place holder if it is not exist
		if (!TypeUtils.isExist(this._majorGridLineShape[0])) {
			this._majorGridLineShape[0] = this._seriesLayer
					.addShape(new Line());
		}
		;
		this._drawMajorGridLine();

		// add minor grid line place holder if it is not exist
		if (!TypeUtils.isExist(this._minorGridLineShape[0])) {
			this._minorGridLineShape[0] = this._seriesLayer
					.addShape(new Line());
		}
		;
		this._drawMinorGridLine();

		// add sub grid line place holder if it is not exist
		if (!TypeUtils.isExist(this._subGridLineShape[0])) {
			this._subGridLineShape[0] = this._seriesLayer.addShape(new Line());
		}
		this._drawSubGridLine();
	};

	/**
	 * Draw major grid line
	 */
	gridLine.prototype._drawMajorGridLine = function() {
		this.resetMajorGridLineShape();

		if (this._xAxis_options.showMajor) {
			var xAxis = this._xAxis;
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var layer = this._seriesLayer;
			// there is a little offset between seriesMaskLayer and axislayer.
			// it is necessary to get the offset
			// and correct it when the grid line is drawn.
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().x
					- this._xAxisLayer[0].position().x);

			for ( var i = 1, len = xAxisMajorTicks.length; i < len; i++) {
				// When the properties are updated, the bar shapes are not
				// removed from the layer, but the grid line shapes are removed.
				// On the other hand, the grid line shapes must be on the top of
				// bar shapes. So, this._majorGridLineShape[0] is used as
				// a placeholder to make sure all the grid line shapes are on
				// the top of bar shapes.
				this._majorGridLineShape[i] = layer.insertShapeAfter(
						new Line(), this._majorGridLineShape[0]);
				this._majorGridLineShape[i].visible(true).color(
						this._xAxis_options.majorColor).width(
						this._xAxis_options.majorThickness).from({
					x : xAxisMajorTicks[i] - layerOffSet,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMajorTicks[i] - layerOffSet,
					y : 0
				});
			}
		}

		// the same as xaxis
		if (this._yAxis_options.showMajor) {
			var yAxis = this._yAxis;
			var yAxisMajorTicks = yAxis.getMajorTicks();
			var layer = this._seriesLayer;
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().y
					- this._yAxisLayer[0].position().y);

			for ( var i = 0, len = yAxisMajorTicks.length; i < len; i++) {
				this._majorGridLineShape[i+1] = layer.insertShapeAfter(
						new Line(), this._majorGridLineShape[0]);
				this._majorGridLineShape[i+1].visible(true).color(
						this._yAxis_options.majorColor).width(
						this._yAxis_options.majorThickness).from({
					x : 0,
					y : yAxisMajorTicks[i] + layerOffSet
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : yAxisMajorTicks[i] + layerOffSet
				});
			}
		}
	};

	/**
	 * Draw minor grid line.
	 */
	gridLine.prototype._drawMinorGridLine = function() {
		this.resetMinorGridLineShape();

		// The minor grid line is only shown when both of showMajor and
		// showMinor are true
		if (this._xAxis_options.showMajor && this._xAxis_options.showMinor) {
			var xAxis = this._xAxis;
			var xAxisMinorTicks = xAxis.getMinorTicks();
			var layer = this._seriesLayer;
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().x
					- this._xAxisLayer[0].position().x);

			for ( var i = 0, len = xAxisMinorTicks.length; i < len; i++) {
				// When the properties are updated, the bar shapes are not
				// removed from the layer, but the grid line shapes are removed.
				// On the other hand, the grid line shapes must be on the top of
				// bar shapes. So, this._minorGridLineShape[0] is used as
				// a placeholder to make sure all the grid line shapes are on
				// the top of bar shapes.
				this._minorGridLineShape[i + 1] = layer.insertShapeAfter(
						new Line(), this._minorGridLineShape[0]);
				this._minorGridLineShape[i + 1].visible(true).color(
						this._xAxis_options.minorColor).width(
						this._xAxis_options.minorThickness).from({
					x : xAxisMinorTicks[i] - layerOffSet,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMinorTicks[i] - layerOffSet,
					y : 0
				});
			}
		}

		// the same as xAxis
		if (this._yAxis_options.showMajor && this._yAxis_options.showMinor) {
			var yAxis = this._yAxis;
			var yAxisMinorTicks = yAxis.getMinorTicks();
			var layer = this._seriesLayer;
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().y
					- this._yAxisLayer[0].position().y);

			for ( var i = 0, len = yAxisMinorTicks.length; i < len; i++) {
				this._minorGridLineShape[i + 1] = layer.insertShapeAfter(
						new Line(), this._minorGridLineShape[0]);
				this._minorGridLineShape[i + 1].visible(true).color(
						this._yAxis_options.minorColor).width(
						this._yAxis_options.majorThickness).from({
					x : 0,
					y : yAxisMinorTicks[i] + layerOffSet
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : yAxisMinorTicks[i] + layerOffSet
				});
			}
		}

	};

	/**
	 * Draw sub grid line -- always be hidden for now
	 */
	gridLine.prototype._drawSubGridLine = function() {
		this.resetSubGridLineShape();

		// When both of showMajor and showSub are true, the showSub will be
		// ignored.
		if (!this._xAxis_options.showMajor && this._xAxis_options.showSub) {
			var xAxisMajorTicks = this._xAxis.getMajorTicks();
			var halfTickInterval = this._xAxis.getTickInterval() / 2;

			for ( var i = 1; i < xAxisMajorTicks.length; i++) {
				// When the properties are updated, the bar shapes are not
				// removed from the layer, but the grid line shapes are removed.
				// On the other hand, the grid line shapes must be on the top of
				// bar shapes. So, this._subGridLineShape[0] is used as
				// a placeholder to make sure all the grid line shapes are on
				// the top of bar shapes.
				this._subGridLineShape[i] = this._seriesLayer.insertShapeAfter(
						new Line(), this._subGridLineShape[0]);
				this._subGridLineShape[i].width('1').color(
						this._xAxis_options.subColor).from({
					x : xAxisMajorTicks[i] - halfTickInterval,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMajorTicks[i] - halfTickInterval,
					y : this._yAxis.getLastTickOffset()
				});
			}
		}

		// the same as xAxis
		if (!this._yAxis_options.showMajor && this._yAxis_options.showSub) {
			var yAxisMajorTicks = this._yAxis.getMajorTicks();
			var halfTickInterval = this._yAxis.getTickInterval() / 2;

			for ( var i = 0; i < yAxisMajorTicks.length; i++) {
				this._subGridLineShape[i + 1] = this._seriesLayer
						.insertShapeAfter(new Line(), this._subGridLineShape[0]);
				this._subGridLineShape[i + 1].width('1').color(
						this._yAxis_options.subColor).from({
					x : 0,
					y : Math.abs(yAxisMajorTicks[i] - halfTickInterval)
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : Math.abs(yAxisMajorTicks[i] - halfTickInterval)
				});
			}
		}
	};

	/**
	 * Update properties and will re-draw all grid line
	 * 
	 * @param propsBag
	 */
	gridLine.prototype.parseProperties = function(propsBag) {
		this._propsMgr = new PropsMgr(defaultOptions);
		this._xAxis_options = this._propsMgr
				.properties(propsBag.properties.xAxis[0].gridLine);
		this._yAxis_options = this._propsMgr
				.properties(propsBag.properties.yAxis[0].gridLine);

	};

	/**
	 * Apply the theme properties to grid line properties, which includes color,
	 * thickness for both of axis.
	 * 
	 * @param theme
	 */
	gridLine.prototype.applyTheme = function(theme) {
		var settings = ThemeManager.getThemeSettings(theme);

		this._xAxis_options.majorColor = settings.axis.xAxisMajorGridLine.color;
		this._xAxis_options.majorThickness = settings.axis.xAxisMajorGridLine.thickness;
		this._xAxis_options.minorColor = settings.axis.xAxisMinorGridLine.color;
		this._xAxis_options.minorThickness = settings.axis.xAxisMinorGridLine.thickness;
		this._xAxis_options.subColor = settings.axis.xAxisSubGridLine.color;

		this._yAxis_options.majorColor = settings.axis.yAxisMajorGridLine.color;
		this._yAxis_options.majorThickness = settings.axis.yAxisMajorGridLine.thickness;
		this._yAxis_options.minorColor = settings.axis.yAxisMinorGridLine.color;
		this._yAxis_options.minorThickness = settings.axis.yAxisMinorGridLine.thickness;
		this._yAxis_options.subColor = settings.axis.yAxisSubGridLine.color;

		if (this._xAxis_options.showMajor) {
			for ( var i = 1, len = this._majorGridLineShape.length; i < len; i++) {
				this._majorGridLineShape[i].color(
						this._xAxis_options.majorColor).width(
						this._xAxis_options.majorThickness);
			}
			;
		}

		if (this._yAxis_options.showMajor) {
			for ( var i = 1, len = this._majorGridLineShape.length; i < len; i++) {
				this._majorGridLineShape[i].color(
						this._yAxis_options.majorColor).width(
						this._yAxis_options.majorThickness);
			}
			;
		}

		if (this._xAxis_options.showMinor) {
			for ( var i = 1, len = this._minorGridLineShape.length; i < len; i++) {
				this._minorGridLineShape[i].color(
						this._xAxis_options.minorColor).width(
						this._xAxis_options.minorThickness);
			}
			;
		}

		if (this._yAxis_options.showMinor) {
			for ( var i = 1, len = this._minorGridLineShape.length; i < len; i++) {
				this._minorGridLineShape[i].color(
						this._yAxis_options.minorColor).width(
						this._yAxis_options.minorThickness);
			}
			;
		}

		if (this._xAxis_options.showSub) {
			for ( var i = 1, len = this._subGridLineShape.length; i < len; i++) {
				this._subGridLineShape[i].color(this._xAxis_options.subColor)
						.width("1");
			}
			;
		}

		if (this._yAxis_options.showSub) {
			for ( var i = 1, len = this._subGridLineShape.length; i < len; i++) {
				this._subGridLineShape[i].color(this._yAxis_options.subColor)
						.width("1");
			}
			;
		}
	};

	/**
	 * Reset all sub grid line shapes except the first one -
	 * this._subGridLineShape[0](place holder)
	 */
	gridLine.prototype.resetSubGridLineShape = function() {
		for ( var i = 1, len = this._subGridLineShape.length; i < len; i++) {
			this._seriesLayer.removeShape(this._subGridLineShape[i]);
		}
	};

	/**
	 * Reset all major grid line shapes except the first one -
	 * this._majorGridLineShape[0](place holder)
	 */
	gridLine.prototype.resetMajorGridLineShape = function() {
		for ( var i = 1; i < this._majorGridLineShape.length; i++) {
			this._seriesLayer.removeShape(this._majorGridLineShape[i]);
		}
	};

	/**
	 * Reset all minor grid line shapes except the first one -
	 * this._minorGridLineShape[0](place holder)
	 */
	gridLine.prototype.resetMinorGridLineShape = function() {
		for ( var i = 1; i < this._minorGridLineShape.length; i++) {
			this._seriesLayer.removeShape(this._minorGridLineShape[i]);
		}
	};

	gridLine.prototype.gestureUpdate = function() {

		if (this._xAxis_options.showMajor) {
			var xAxis = this._xAxis;
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().x
					- this._xAxisLayer[0].position().x);

			for ( var i = 1, len = xAxisMajorTicks.length; i < len; i++) {
				this._majorGridLineShape[i].from({
					x : xAxisMajorTicks[i] - layerOffSet,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMajorTicks[i] - layerOffSet,
					y : 0
				});
			}
		}

		// the same as xaxis
		if (this._yAxis_options.showMajor) {
			var yAxis = this._yAxis;
			var yAxisMajorTicks = yAxis.getMajorTicks();
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().y
					- this._yAxisLayer[0].position().y);

			for ( var i = 1, len = yAxisMajorTicks.length; i < len; i++) {
				this._majorGridLineShape[i].from({
					x : 0,
					y : yAxisMajorTicks[i] + layerOffSet
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : yAxisMajorTicks[i] + layerOffSet
				});
			}
		}

		if (this._xAxis_options.showMajor && this._xAxis_options.showMinor) {
			var xAxis = this._xAxis;
			var xAxisMinorTicks = xAxis.getMinorTicks();
			var layerOffSet = Math.abs(this._seriesMaskLayer.position().x
					- this._xAxisLayer[0].position().x);

			for ( var i = 0, len = xAxisMinorTicks.length; i < len; i++) {
				this._minorGridLineShape[i + 1].from({
					x : xAxisMinorTicks[i] - layerOffSet,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMinorTicks[i] - layerOffSet,
					y : 0
				});
			}
		}

		// the same as xAxis
		if (this._yAxis_options.showMajor && this._yAxis_options.showMinor) {
			var yAxis = this._yAxis;
			var yAxisMinorTicks = yAxis.getMinorTicks();

			var layerOffSet = Math.abs(this._seriesMaskLayer.position().y
					- this._yAxisLayer[0].position().y);

			for ( var i = 0, len = yAxisMinorTicks.length; i < len; i++) {
				this._minorGridLineShape[i + 1].from({
					x : 0,
					y : yAxisMinorTicks[i] + layerOffSet
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : yAxisMinorTicks[i] + layerOffSet
				});
			}
		}

		// When both of showMajor and showSub are true, the showSub will be
		// ignored.
		if (!this._xAxis_options.showMajor && this._xAxis_options.showSub) {
			var xAxisMajorTicks = this._xAxis.getMajorTicks();
			var halfTickInterval = this._xAxis.getTickInterval() / 2;

			for ( var i = 1; i < xAxisMajorTicks.length; i++) {
				this._subGridLineShape[i].from({
					x : xAxisMajorTicks[i] - halfTickInterval,
					y : this._yAxis.getPreferredHeight()
				}).to({
					x : xAxisMajorTicks[i] - halfTickInterval,
					y : this._yAxis.getLastTickOffset()
				});
			}
		}

		// the same as xAxis
		if (!this._yAxis_options.showMajor && this._yAxis_options.showSub) {
			var yAxisMajorTicks = this._yAxis.getMajorTicks();
			var halfTickInterval = this._yAxis.getTickInterval() / 2;

			for ( var i = 0; i < yAxisMajorTicks.length; i++) {
				this._subGridLineShape[i + 1].from({
					x : 0,
					y : Math.abs(yAxisMajorTicks[i] - halfTickInterval)
				}).to({
					x : this._xAxis.getPreferredWidth(),
					y : Math.abs(yAxisMajorTicks[i] - halfTickInterval)
				});
			}
		}
	};
	return gridLine;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.Event',
  version : '1.0.0'
},
function Setup() {
	/**
	 * Event class
	 * 
	 * @name sap.riv.vizkit.Event
	 * @constructor
	 */
	var Event = function(type, target, canBubbling) {
		this._type = type;
		this._target = this._currentTarget = target;
		this._canBubbling = canBubbling !== undefined ? canBubbling : true;
		this._timestamp = +new Date;
	};

	var Ep = Event.prototype;

	Ep._setCurrentTarget_ = function(currentTarget) {
		this._currentTarget = currentTarget;
	};

	/**
	 * Get the type of the event
	 * 
	 * @name sap.riv.vizkit.Event#type
	 * @function
	 * @returns {String}
	 */
	Ep.type = function() {
		return this._type;
	};

	/**
	 * Get the timestamp of the event
	 * 
	 * @name sap.riv.vizkit.Event#timestamp
	 * @function
	 * @returns {Integer}
	 */
	Ep.timestamp = function() {
		return this._timestamp;
	};

	/**
	 * Get the target component the event is originated from
	 * 
	 * @name sap.riv.vizkit.Event#target
	 * @function
	 * @returns {sap.riv.vizkit.UIComponent}
	 */
	Ep.target = function() {
		return this._target;
	};

	/**
	 * Get the current target component the event is currently going through it
	 * can be different with the target component
	 * 
	 * @name sap.riv.vizkit.Event#currentTarget
	 * @function
	 * @returns {sap.riv.vizkit.UIComponent}
	 */
	Ep.currentTarget = function() {
		return this._currentTarget;
	};

	/**
	 * Whether the event is in the bubbling phase
	 * 
	 * @name sap.riv.vizkit.Event#isInBubbling
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.isInBubbling = function() {
		return this._target.id() != this._currentTarget.id();
	};
	/**
	 * Whether the event should be bubbled
	 * 
	 * @name sap.riv.vizkit.Event#shouldBubble
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.shouldBubble = function() {
		return this._canBubbling;
	};
	/**
	 * Stop the event propagation in the bubbling phase
	 * 
	 * @name sap.riv.vizkit.Event#stopPropagation
	 * @function
	 * 
	 */
	Ep.stopPropagation = function() {
		this._canBubbling = false;
	};
	return Event;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(FuncUtils) {
	/**
	 * The mask used to specify gesture detector's state
	 * 
	 * @name sap.riv.vizkit.GestureDetector.TransitionState
	 * @class
	 */
	var ts = {
		/**
		 * Possible State. Gesture Detector is ready to detect gesture
		 * 
		 * @field
		 * 
		 */
		Possible : 0,
		/**
		 * Began State. Gesture Detector is ready to detect continuous gesture
		 * 
		 * @field
		 * 
		 */
		Began : 1,
		/**
		 * Began State. Gesture Detector is continuous to detect continuous
		 * gesture
		 * 
		 * @field
		 * 
		 */
		Changed : 2,
		/**
		 * Recognized State. Discrete Gesture is detected
		 * 
		 * @field
		 * 
		 */
		Recognized : 3,// Recognized == Ended
		/**
		 * Ended State. Continuous Gesture is detected
		 * 
		 * @field
		 * 
		 */
		Ended : 3,
		/**
		 * Ended State. Continuous Gesture is stop to detected
		 * 
		 * @field
		 * 
		 */
		Cancelled : 4,
		/**
		 * Ended State. Detector fails to detect in current touch sequence
		 * 
		 * @field
		 * 
		 */
		Failed : 5
	};

	/**
	 * The base abstract gesture detector class
	 * 
	 * @name sap.riv.vizkit.GestureDetector
	 * @constructor
	 */
	var GestureDetector = function() {
		this._grOwnerComp;
		this._grEnabled = true;
		this._grTouchTotal = 0;
		this._grTouchTracker = {};
		this._grState = ts.Possible;
		this._grActions = [];
		this._grCancelTouches = true;
	};
	var grp = GestureDetector.prototype;

	grp._setOwnerComp_ = function(ownerComp) {
		this._grOwnerComp = ownerComp;
	};
	/**
	 * Get the attached UI component
	 * 
	 * @name sap.riv.vizkit.GestureDetector#attachedComponent
	 * @function
	 * @returns {sap,riv.vizkit.UIComponent}
	 */
	grp.attachedComponent = function() {
		return this._grOwnerComp;
	};

	/**
	 * Add a gesture action function which will get triggered when gesture
	 * detected.
	 * 
	 * @name sap.riv.vizkit.GestureDetector#addGestureAction
	 * @function
	 * @param {Function}
	 *            actionFn, function to be called when gesture detected.
	 * @returns {Boolean}
	 */
	grp.addGestureAction = function(actionFn) {
		var added = false;
		for ( var i = 0, len = this._grActions.length; i < len; i++) {
			if (this._grActions[i] === actionFn) {
				added = true;
				break;
			}
		}
		if (!added) {
			this._grActions.push(actionFn);
		}
		return !added;
	};

	/**
	 * Remove a previously added gesture action
	 * 
	 * @name sap.riv.vizkit.GestureDetector#removeGestureAction
	 * @function
	 * @param {Function}
	 *            actionFn, the function to be removed.
	 * @returns {Boolean}
	 */
	grp.removeGestureAction = function(actionFn) {
		var found = false;
		for ( var i = 0, len = this._grActions.length; i < len; i++) {
			if (this._grActions[i] === actionFn) {
				found = true;
				this._grActions.splice(i, 1);
				break;
			}
		}
		return found;
	};

	/**
	 * Return the current global location of the gesture, the location is
	 * calculated as the center of the current touches. Caution: This function
	 * only return meaningful point value IF and ONLY IF the current state of
	 * this gesture detector is in Recognizing state, a.k.a Began, Cancelled,
	 * Ended, Recognized, otherwise undefined will return.
	 * 
	 * @function
	 * @returns {Object}
	 */
	grp.globalLocOfGesture = function() {
		var state = this.state();
		if (this._grEnabled
				&& (state === ts.Began || state === ts.Cancelled || state === ts.Ended || state === ts.Recognized)) {
			var count = 0;
			var ttracker = this._grTouchTracker, xy;
			var x = y = 0;
			for ( var tId in ttracker) {
				xy = ttracker[tId].globalXY;
				x += xy.x;
				y += xy.y;
				count++;
			}
			if (count) {
				return {
					x : x / count,
					y : y / count
				};
			}
		} else {
			return;
		}
	};

	/**
	 * Return a list of identifier of touches currently involved in the gesture
	 * detection, Caution: This function only return meaningful array of touches
	 * IF and ONLY IF the current state of this gesture detector is in
	 * Recognizing state, a.k.a Began, Cancelled, Ended, Recognized, otherwise
	 * empty array will return.
	 * 
	 * @function
	 * @returns {Array}
	 */
	grp.involvedTouchePoints = function() {
		var ret = [];
		var state = this.state();
		if (this._grEnabled
				&& (state === ts.Began || state === ts.Cancelled || state === ts.Ended || state === ts.Recognized)) {
			var ttracker = this._grTouchTracker;
			for ( var tId in ttracker) {
				ret.push(tId);
			}
		}
		return ret;
	};

	/**
	 * Return the current global location of all the current touches, the
	 * location is calculated as the center of the touches currently contacting
	 * with the screen.
	 * 
	 * @function
	 * @returns {Object}
	 */
	grp.globalLocOfTouchPoints = function() {
		var count = 0;
		var ttracker = this._grTouchTracker, xy;
		var x = y = 0;
		for ( var tId in ttracker) {
			xy = ttracker[tId].globalXY;
			x += xy.x;
			y += xy.y;
			count++;
		}
		if (count) {
			return {
				x : x / count,
				y : y / count
			};
		}
	};

	/**
	 * Return the number of touches currently contacting with the screen
	 * 
	 * @function
	 * @returns {Number}
	 */
	grp.totalTouches = function() {
		return this._grTouchTotal;
	};

	/**
	 * Get or set whether canceling previous touches when a gesture detected.
	 * Default is yes.
	 * 
	 * @function
	 * @returns {Boolean|this}
	 */
	grp.cancelTouches = function(cancel) {
		if (cancel !== undefined) {
			this._grCancelTouches = cancel;
			return this;
		} else {
			return this._grCancelTouches;
		}
	};
	/**
	 * Get or set the enable status of the gesture detector. If the gesture
	 * detector is in detecting some continuous gesture it will immediately
	 * transit to cancelled state. Default is yes.
	 * 
	 * @function
	 * @returns {Boolean|this}
	 */
	grp.enable = function(enable) {
		if (enable !== undefined) {
			this._grEnabled = enable;
			if (!enable) {
				if (this._grState === ts.Began || this._grState === ts.Cancelled) {
					this.state(ts.Cancelled);
				} else {
					this.state(ts.Failed);
				}
			}
		} else {
			return this._grEnabled;
		}
	};

	grp.touchBegin = function(touchStartEvent) {
		if (this._grEnabled) {
			var newTouches = touchStartEvent.changedTouches;
			var ttracker = this._grTouchTracker;
			var ownerComp = this._grOwnerComp;
			var pagePosition = ownerComp.pagePosition();
			for ( var i = 0, t, len = newTouches.length; i < len; i++) {
				t = newTouches.item(i);
				ttracker[t.identifier] = {
					globalXY : ownerComp.convertPointToGlobal({
						x : t.pageX - pagePosition.x,
						y : t.pageY - pagePosition.y
					}),
					stopped : false
				};
				this._grTouchTotal++;
			}
			this.doTouchBegin(touchStartEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in moving phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#touchMove
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchMoveEvent
	 */
	grp.touchMove = function(touchMoveEvent) {
		if (this._grEnabled) {
			var movedTouches = touchMoveEvent.changedTouches;
			var ownerComp = this._grOwnerComp;
			var pagePosition = ownerComp.pagePosition();
			var ttracker = this._grTouchTracker;
			for ( var i = 0, t, len = movedTouches.length; i < len; i++) {
				t = movedTouches.item(i);
				if (ttracker[t.identifier]) {
					ttracker[t.identifier].globalXY = ownerComp.convertPointToGlobal({
						x : t.pageX - pagePosition.x,
						y : t.pageY - pagePosition.y
					});
				}
			}
			this.doTouchMove(touchMoveEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in ending phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#touchEnd
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchEndEvent
	 */
	grp.touchEnd = function(touchEndEvent) {
		if (this._grEnabled) {
			var endedTouches = touchEndEvent.changedTouches;
			var ttracker = this._grTouchTracker;
			var ownerComp = this._grOwnerComp;
			var pagePosition = ownerComp.pagePosition();
			for ( var i = 0, t,tId, track, len = endedTouches.length; i < len; i++) {
				t = endedTouches.item(i);
				tId = t.identifier;
				track = ttracker[tId];
				if (track) {
					track.globalXY = ownerComp.convertPointToGlobal({
						x : t.pageX - pagePosition.x,
						y : t.pageY - pagePosition.y
					});
					track.stopped = true;
					this._grTouchTotal--;
				}
			}
			this.doTouchEnd(touchEndEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in cancellation
	 * phase of a touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#touchCancel
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchCancelEvent
	 */
	grp.touchCancel = function(touchCancelEvent) {
		if (this._grEnabled) {
			var cancelledTouches = touchCancelEvent.changedTouches;
			var ttracker = this._grTouchTracker;
			var ownerComp = this._grOwnerComp;
			var pagePosition = ownerComp.pagePosition();
			for ( var i = 0, t,tId, track, len = cancelledTouches.length; i < len; i++) {
				t = cancelledTouches.item(i);
				tId = t.identifier;
				track = ttracker[tId];
				if (track) {
					track.globalXY = ownerComp.convertPointToGlobal({
						x : t.pageX - pagePosition.x,
						y : t.pageY - pagePosition.y
					});
					track.stopped = true;
					this._grTouchTotal--;
				}
			}
			this.doTouchCancel(touchCancelEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in start phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#doTouchBegin
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchStartEvent
	 */
	grp.doTouchBegin = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in moving phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#doTouchMove
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchMoveEvent
	 */
	grp.doTouchMove = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in ending phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#doTouchEnd
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchEndEvent
	 */
	grp.doTouchEnd = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in cancellation
	 * phase of a touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#doTouchCancel
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchCancelEvent
	 */
	grp.doTouchCancel = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to reset the internal state, before
	 * start to do next around recognition.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#reset
	 * @function
	 */
	grp.reset = function() {
		this._grState = ts.Possible;
		this._grTouchTotal = 0;
		this._grTouchTracker = {};
	};
	/**
	 * Gesture Detector uses this method to set or get the current state.
	 * Subclass should set correct state at correct time, usually in overriding
	 * touchBegin/touchMove/touchEnd/touchCancel method.
	 * <P>
	 * <b>This method is not meant to be overridden</b>
	 * </p>
	 * 
	 * 
	 * @name sap.riv.vizkit.GestureDetector#state
	 * @function
	 * @param {sap.riv.vizkit.GestureDetector.TransitionState}
	 *            transState
	 */
	grp.state = function(transState) {
		return this._grState;
	};

	grp._setState_ = function(transState) {
		switch (transState) {
		case ts.Possible:
			break;
		case ts.Began:
			this._grState = ts.Began;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			break;
		case ts.Changed:
			if (this._grState === ts.Began) {
				this._grState = ts.Changed;
			}
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			break;
		case ts.Cancelled:
			this._grState = ts.Cancelled;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			this.reset();
			break;
		case ts.Failed:
			this._grState = ts.Failed;
			this.reset();
			break;
		case ts.Ended:
		case ts.Recognized:
			this._grState = transState;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			this.reset();
			break;
		}
	};

	GestureDetector.TransitionState = ts;
	return GestureDetector;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.TapGestureDetector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjUtils, GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	var _distance = function(xy1, xy2) {
		var dx = xy1.x - xy2.x;
		var dy = xy1.y - xy2.y;
		return Math.sqrt(dx * dx + dy * dy);
	};

	var _startNewTapSequence = function(tapDetector, event) {
		tapDetector._sequenceStarted = true;
		tapDetector._currentNumberOfTaps = 0;
		tapDetector._firstStartXY = tapDetector.globalLocOfTouchPoints();
	};

	// Defines the maximum distance from current tap to where
	// the first tap
	// starts
	var _maxDistance = 50;
	// Defines the maximum and minimum time for each tap
	var _maxTapTime = 150;
	var _minTapTime = 20;
	// Defines the maximum time gap
	// between the time the previous tap ends and the time the
	// next one starts
	var _maxTapGap = 150;

	/**
	 * This class defines detector for detecting Tapping gesture. Tapping
	 * gesture is detected when required number of fingers tap the screen for
	 * required number of times.
	 * 
	 * @name sap.riv.vizkit.TapGestureDetector
	 * @class
	 * @augments sap.riv.vizkit.GestureDetector
	 */

	var TapGestureDetector = ObjUtils
			.derive(
					GestureDetector,
					{
						constructor : function(touchesRequired, tapsRequired) {
							this._touchesRequired = (typeof touchesRequired === 'number' && touchesRequired > 0 && touchesRequired < 6) ? touchesRequired
									: 1;
							this._tapsRequired = (typeof tapsRequired === 'number' && tapsRequired > 0) ? tapsRequired
									: 1;

							this._currentNumberOfTaps = 0;
							this._firstStartXY = undefined;
							this._sequenceStarted = false;
							this._currentStartWhen = 0;
						},

						doTouchBegin : function(touchStartEvent) {
							if (this.state() === ts.Possible) {
								var currentNumOfTouches = this.totalTouches();

								if (currentNumOfTouches === this._touchesRequired) {
									var currentTimeStamp = touchStartEvent.timeStamp;

									// Beginning of the first
									// tap in a tap
									// sequence
									if (this._currentNumberOfTaps == 0) {
										// Record the
										// information of first
										// tap
										// for later comparison
										_startNewTapSequence(this, touchStartEvent);
									}
									// Beginning of a tap (other
									// than the first
									// one) in a tap sequence
									else {
										if (this._currentNumberOfTaps < this._tapsRequired) {
											var distance = _distance(this._firstStartXY, this.globalLocOfTouchPoints());
											var preStartWhen = this._currentStartWhen;

											// If the tap breaks
											// a tap sequence,
											// start a new
											// sequence with it
											if (distance > _maxDistance
													|| (currentTimeStamp - preStartWhen) > (_maxTapTime + _maxTapGap)) {
												_startNewTapSequence(this, touchStartEvent);
											}
										}
									}

									this._currentStartWhen = currentTimeStamp;
								} else { // Fails if touch
									// number doesn't
									// match
									this._setState_(ts.Failed);
								}
							}
						},

						doTouchEnd : function(touchEndEvent) {
							if (this.state() === ts.Possible && this._sequenceStarted) {
								// Fails if the touch ends too
								// far away from
								// where it starts
								if (_distance(this._firstStartXY, this.globalLocOfTouchPoints()) > _maxDistance) {
									this._setState_(ts.Failed);
									return;
								}
								// Fails if the tap is too short
								// or too long
								var tapTime = touchEndEvent.timeStamp - this._currentStartWhen;
								if (tapTime > _maxTapTime || tapTime < _minTapTime) {
									this._setState_(ts.Failed);
									return;
								}
								if (++this._currentNumberOfTaps === this._tapsRequired) {
									this._setState_(ts.Recognized);
								}
							}
						},

						doTouchCancel : function(touchCancelEvent) {
							if (this.state() === ts.Possible) {
								this._setState_(ts.Failed);
							}
						},

						reset : function() {
							this.callParent('reset');
							this._currentNumberOfTaps = 0;
							this._sequenceStarted = false;
							this._firstStartXY = undefined;
							this._firstStartWhen = 0;
							this._currentStartWhen = 0;
						}
					});
	return TapGestureDetector;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.ChartModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.gridLine.GridLine',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Rectangle',
  version : '1.0.0'
}
],
function Setup(ObjUtils, FunctionUtils, TypeUtils, LOG, GridLine, Observable,
		Rect) {
	var chartModule = ObjUtils.derive(Observable, {
		constructor : function(options) {
			this._chart_options = ObjUtils.extend(true, {},
					options);
			this._dataTree = this._chart_options.dataTree;
			this._metaData = this._chart_options.metaData;

			this._xaxes = null;
			this._yaxes = null;
			this._data = null;

			this._defaultSelectionArmed = true;

			this._scrollBar = [];
			this._seriesLayer = null;
			this.addEvents(this.getSupportedAppEvents());
			this._gridLine = new GridLine();
		},

		init : function() {
			this._buildData();
			this.initSeries();
			this.initAxes();
			this.bindSeriesWithAxes();
			this.initScrollBar();
			this.initGridLineProperties();
		},

		_buildData : function() {

			this._data = [];
			var dimensionList = this._dataTree.getSubMembersAt();
			for ( var i = 0, iLen = this._metaData.measureMembers.length; i < iLen; i++) {
				var subData = [];
				var measure = this._metaData.measureMembers[i];
				for ( var j = 0, jLen = dimensionList.length; j < jLen; j++) {
					var d = [ dimensionList[j] ];
					var value = this._dataTree.getMeasuresAt(d)[measure].sum.result;
					subData.push({
						value : (TypeUtils.isNumber(value)) ? value : 'NaN',
						dimensionItemIndex : this._dataTree
								.getMeasuresAt(d)[measure].sum.tags.dimensionItemIndex,
						measureIndex : this._dataTree
								.getMeasuresAt(d)[measure].sum.tags.measureIndex
						});
				}
				this._data.push(subData);
			}
		},

		updateProperties : function(propBag) {
			var options = {};
			options.properties = propBag;
			this._chart_options = ObjUtils.extend(true, {},
					options);
		},

		updateOptions : function(options) {
			this._chart_options = ObjUtils.extend(true, {},
					options);
			this._dataTree = this._chart_options.dataTree;
			this._metaData = this._chart_options.metaData;
			this._hasDrawn = false;
		},

		/*
		 * mandatory functions, should be implemented by sub
		 * classes
		 */

		initAxes : FunctionUtils.unsupported,

		initSeries : FunctionUtils.unsupported,

		initScrollBar : FunctionUtils.noop,

		bindSeriesWithAxes : FunctionUtils.unsupported,

		drawSeries : FunctionUtils.unsupported,

		doChartLayout : FunctionUtils.unsupported,

		bindRenderer : FunctionUtils.unsupported,
		initGridLineProperties : FunctionUtils.unsupported,

		/**
		 * @return events which can be listened by clients
		 */
		getSupportedAppEvents : FunctionUtils.unsupported,

		/* optional functions */

		marqueeOverPoint : FunctionUtils.noop,

		hoverOnPoint : FunctionUtils.noop,

		clickOnPoint : FunctionUtils.noop,

		onblur : FunctionUtils.noop,

		drawViewPort : FunctionUtils.noop,

		/**
		 * only move the series layer
		 */
		position : FunctionUtils.noop,

		scale : FunctionUtils.noop,

		panMove : FunctionUtils.noop,

		pinchingResize : FunctionUtils.noop,

		backUp : FunctionUtils.noop,

		restore : FunctionUtils.noop,
		
		getPlotArea : FunctionUtils.noop,

		/**
		 * move the series layer
		 */
		position : function(xoffset, yoffset) {
			this._seriesLayer.position({
				x : xoffset,
				y : yoffset
			});
		},

		scrollBar : function() {
			var scrollBarRenderer = function() {
				this.SCROLLBARSIZE = 6;
				this._layer = null;
				this._scrollBarRenderer = null;
			};

			scrollBarRenderer.prototype.init = function(
					seriesMasklayer, seriesLayer, direction) {
				this._seriesMasklayer = seriesMasklayer;
				this._seriesLayer = seriesLayer;

				if (this._scrollBarRenderer) {
					this._seriesMasklayer
							.removeShape(this._scrollBarRenderer);
				}

				this._scrollBarRenderer = this._seriesMasklayer
						.addShape(new Rect());
				this._direction = direction;
				var size = this._seriesMasklayer.size();
				var position = this._seriesMasklayer.position();

				if (!direction || direction == 'vertical') {
					this._scrollBarRenderer.width(
							this.SCROLLBARSIZE).height(
							size.height).topLeft(
							[ size.width - this.SCROLLBARSIZE,
									0 ]).cornerRadius(6)
							.visible(true).borderWidth(1);
				} else {
					this._scrollBarRenderer.width(size.width)
							.height(this.SCROLLBARSIZE)
							.topLeft([ 0, 0 ]).cornerRadius(6)
							.visible(true).borderWidth(1);
				}
				this.hidden();
			};

			scrollBarRenderer.prototype.highLight = function() {
				this._scrollBarRenderer.visible(true).color(
						'rgba(51,51,51, 0.6)').borderColor(
						'rgba(255,255,255, 0.15)');
			};

			scrollBarRenderer.prototype.unHighLight = function() {
				this._scrollBarRenderer.visible(true).color(
						'rgba(51,51,51, 0.3)').borderColor(
						'rgba(255,255,255, 0.07)');
			};

			scrollBarRenderer.prototype.hidden = function() {
				this._scrollBarRenderer.visible(false);
			};

			scrollBarRenderer.prototype.update = function() {
				var seriesMasklayer = this._seriesMasklayer
						.size();
				var seriesSize = this._seriesLayer.size();
				var seriesPos = this._seriesLayer.position();

				if (!this._direction
						|| this._direction === 'vertical') {
					var yposition;
					var size;
					if (seriesPos.y <= 0) {
						size = seriesMasklayer.height
								* seriesMasklayer.height
								/ seriesSize.height;
						yposition = Math.abs(seriesPos.y)
								* seriesMasklayer.height
								/ seriesSize.height;
					} else {
						size = (seriesMasklayer.height - seriesPos.y)
								* seriesMasklayer.height
								/ seriesSize.height;
						yposition = -seriesPos.y
								* seriesMasklayer.height
								/ seriesSize.height;
					}
					this._scrollBarRenderer.height(size);
					this._scrollBarRenderer.topLeft([
							seriesMasklayer.width
									- this.SCROLLBARSIZE,
							yposition ]);
				} else {
					var xposition;
					var size;
					if (seriesPos.x <= 0) {
						size = seriesMasklayer.width
								* seriesMasklayer.width
								/ seriesSize.width;
						xposition = Math.abs(seriesPos.x)
								* seriesMasklayer.width
								/ seriesSize.width;
					} else {

					}
					this._scrollBarRenderer.width(size);
					this._scrollBarRenderer.topLeft([
							xposition, 0 ])
				}
			},
			
			scrollBarRenderer.prototype.remove = function(){
				if (this._scrollBarRenderer) {
					this._seriesMasklayer
							.removeShape(this._scrollBarRenderer);
				}
			}
			return new scrollBarRenderer();
		}
	});
	return chartModule;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.PieController',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIController',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.PieComponent',
  version : '1.0.0'
}
],
function Setup(ObjUtils,FunctionUtils, UIController, PieComponent) {
	var Controller = ObjUtils.derive(UIController, {
		constructor : function(options) {
			this._dataset = options.dataset;
			this._pieComponent = undefined;
			this._option = options.option;
		},

		/**
		 * Subclass should overide this method to initialize custom UIComponent
		 * hierarchy and return the root UIComponent. The default implementation
		 * creates an empty UIComponent
		 */
		initUIComponent : function(width, height) {
			this._pieComponent = new PieComponent({
				id : 'rootComponent',
				dataset : this._dataset,
				pieOptions : this._option,
				size : {
					w : width,
					h : height
				}
			});
			return this._pieComponent;
		},

		doThemeApplied : function(theme) {
			this._pieComponent.applyTheme(theme);
		},

		updateProperties : function(propBag) {
			this._pieComponent.updateProperties(propBag);
		},

		getProperties : function() {
			return this._pieComponent.getProperties();
		},

		/**
		 * This method will be called after the managed UIComponent initialized
		 */
		afterUIComponentLoaded : FunctionUtils.noop,

		/**
		 * This method will be called when the managed UIComponent will become
		 * visible via set the hidden property
		 */
		beforeUIComponentAppear : FunctionUtils.noop,

		/**
		 * This method will be called after the managed UIComponent became
		 * visible via set the hidden property
		 */
		afterUIComponentAppear : function() {
			var appEvent = this._pieComponent.getSupportedAppEvents();
        	for(var i= appEvent.length; i--;){
        		this._pieComponent._pieComponent._chartModule.on({
        			 eventName: appEvent[i],
                     listener: this._fireInternalAppEvent,
                     scope: this
        		});
        	}
		},
		/**
		 * This method will be called when the managed UIComponent will become
		 * visible via set the hidden property
		 */
		beforeUIComponentDisappear : FunctionUtils.noop,
		/**
		 * This method will be called after the managed UIComponent became
		 * visible via set the hidden property
		 */
		afterUIComponentDisappear : FunctionUtils.noop,
		
		setDataset : function(dataset) {
			this._dataset = dataset;
			this._pieComponent.setDataset(dataset);
		},
		
		_fireInternalAppEvent : function(evt) {
		    this.fireAppEvent(evt.name, evt);
		}
	});
	return Controller;
});sap.riv.module(
{
  qname : 'sap.riv.viz.AbstractVisualization',
  version : '1.0.0'
},
function Setup() {
    var id = 0;
    var nextId = function() {
        return (id++).toString();
    };
    
	/**
	 * @name sap.riv.viz.AbstractVisualization
	 * @constructor
	 */
	var AbstractVisualization = function(holderElement, properties, dataset) {
		this._viz = null;
		this._id = nextId();
	};

	AbstractVisualization.prototype = 
	/**
	 * @lends sap.riv.viz.AbstractVisualization.prototype
	 */
	{
	    /**
		 * Get unique id of current visualization instance
		 * @name sap.riv.viz.AbstractVisualization#id
		 * @function
		 * 
		 * @returns{id|String}
		*/
	    id : function(){
            return this._id;
        },
        
		/**
		 * Get and set the size of the visualization
		 * @name sap.riv.viz.AbstractVisualization#size
		 * @function
		 * @param {Object}
		 *            size undefined or new size of the application. {width:##,
		 *            height:##}
		 * @returns {this|Object} when set the size the return is this object,
		 *          when get the size the return will be the size
		 * 
		 */
		'size' : function(sizeObj) {
			if (sizeObj) {
				if (this._viz) {
					this._viz.size(sizeObj);
					return this;
				}
			} else {
				if (this._viz) {
					return this._viz.size();
				}
			}
		},

		/**
		 * set a dataset to the viz
		 * @name sap.riv.viz.AbstractVisualization#setDataset
		 * @function
		 * @param {Object}
		 *            dataset dataset instance used by this visualization. see
		 *            sap.riv.viz.shared.dataConverter.* for all supported
		 *            datasets
		 * @returns {this}
		 */
		'setDataset' : function(dataset) {
			if (this._viz) {
				this._viz.setDataset(dataset);
				return this;
			}
		},

		/**
		 * apply a theme to the viz
		 * @name sap.riv.viz.AbstractVisualization#applyTheme
		 * @function
		 * @param theme
		 *            theme name, see theme doc for current supported themes
		 * @returns {this}
		 */
		'applyTheme' : function(theme) {
			if (this._viz) {
				this._viz.applyTheme(theme);
				return this;
			}
		},

		/**
		 * update or get properties of the viz
		 * 
		 * @name sap.riv.viz.AbstractVisualization#properties
		 * @function
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details. empty parameter means get current properties
		 * @returns {this|Object}
		 */
		'properties' : function(properties){
			if(properties){
				if (this._viz) {
					this._viz.properties(properties);
					return this;
				}
			}else{
				if (this._viz) {
					return this._viz.properties(properties);
				}
			}		
		},
		
		//[jy 4/15/2012]to be removed
		'updateProperties' : function(properties) {
			if (this._viz) {
				this._viz.properties(properties);
				return this;
			}
			
		},

		/**
		 * register a new event listener to the viz
		 * 
		 * @name sap.riv.viz.AbstractVisualization#addListener
		 * @function
		 * @param event
		 *            event name supported by this viz
		 * @param listener
		 *            event handler
		 * @returns {this}
		 */
		'addListener' : function(event, listener) {
			if (this._viz) {
				this._viz.addListener(event, listener);
				return this;
			}
		},

		/**
		 * remove a registered event listener from the viz
		 * 
		 * @name sap.riv.viz.AbstractVisualization#removeListener
		 * @function
		 * @param event
		 *            event name supported by this viz
		 * @param listener
		 *            event handler
		 * @returns {this}
		 */
		'removeListener' : function(event, listener) {
			if (this._viz) {
				this._viz.removeListener(event, listener);
				return this;
			}
		},
		
		/**
		 * get event names supported by this viz
		 * @name sap.riv.viz.AbstractVisualization#getSupportedEvents
		 * @function
		 * @returns {Array} event names supported by this viz
		 */
		'getSupportedEvents' : function(){
			if(this._viz){
				//[jy 4/15/2012]change the api in VizApplication to getSupportedEvents?
				return this._viz.getSupportedEvent();
			}
		}
	};
	return AbstractVisualization;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.dataConverter.BaseDataset',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(FuncUtils) {
	var BaseDataset = function() {
	};

	BaseDataset.prototype.exportTree = FuncUtils.noop;
	return BaseDataset;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.ImageManager',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(ObjUtils, LinkedHashMap, FuncUtils) {
	/**
	 * The image object
	 * 
	 * @name sap.riv.vizkit.Image
	 * @constructor
	 */
	var img = function(htmlImageElement) {
		this._imgEl = htmlImageElement;
	};

	/**
	 * Return the underlying htmlImageElement
	 * 
	 * @name sap.riv.vizkit.Image#getBitmap
	 * @function
	 * @returns {HtmlImageElement}
	 */
	img.prototype.getBitmap = function() {
		return this._imgEl;
	};

	/**
	 * Get or set the visual width of the image
	 * 
	 * @name sap.riv.vizkit.Image#width
	 * @param {undefined|Number}
	 *            width the new width of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the width
	 */
	img.prototype.width = function(width) {
		if (width !== undefined) {
			this._imgEl.width = width;
			return this;
		}
		return this._imgEl.width;
	};

	/**
	 * Get or set the visual height of the image
	 * 
	 * @name sap.riv.vizkit.Image#height
	 * @param {undefined|Number}
	 *            height the new height of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the height
	 */
	img.prototype.height = function(height) {
		if (height !== undefined) {
			this._imgEl.height = height;
			return this;
		}
		return this._imgEl.height;
	};

	/**
	 * Get the intrinsic height of the image
	 * 
	 * @name sap.riv.vizkit.Image#intrinsicHeight
	 * @returns {Number}
	 */
	img.prototype.intrinsicHeight = function() {
		return this._imgEl.naturalHeight;
	};

	/**
	 * Get the intrinsic width of the image
	 * 
	 * @name sap.riv.vizkit.Image#intrinsicWidth
	 * @returns {Number}
	 */
	img.prototype.intrinsicWidth = function() {
		return this._imgEl.naturalWidth;
	};

	/**
	 * Get the url of the image
	 * 
	 * @name sap.riv.vizkit.Image#url
	 * @returns {String} the url of the image
	 */
	img.prototype.url = function() {
		return this._imgEl.src;
	};

	var _imageCache = new LinkedHashMap();
	var _id2src = new LinkedHashMap();
	var _src2ids = {};

	/**
	 * This class defines global shared image manager used for loading external
	 * image. The loading process is asynchronously. The loaded images are
	 * indentified by src urls internally, and can shared within the all viz
	 * application. You must assign an id when loading an image. You can
	 * retrieve the loaded image by id only. the same image can be assigned
	 * multiple ids.
	 * 
	 * @name sap.riv.vizkit.ImageManager
	 * @class
	 */
	var ImageManager = {
		/**
		 * Load an image designated by URL. The loading is asynchronized, the
		 * image will be available when the onComplete is called
		 * 
		 * @param {String}
		 *            id the caller-provided Id of the image to be loaded and
		 *            retrieved later.
		 * @param {String}
		 *            url the url of the image to be loaded
		 * @param {Function}
		 *            [onComplete], the on complete callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImage : function(id, url, onComplete) {
			if (id && url) {
				onComplete = onComplete || FuncUtils.noop;
				if (_id2src.has(id)) {
					if (_imageCache.get(_id2src.get(url))) {
						onComplete(true);
					}
				}
				var imgEl = new Image();
				imgEl.onabort = imgEl.onerror = function() {
					onComplete(false, {
						id : id,
						url : url
					});
				};
				imgEl.onload = ObjUtils.proxy(function() {
					var src = imgEl.src;
					if (!_imageCache.has(src)) {
						var imgObj = new img(imgEl);
						_id2src.add(id, src);
						_src2ids[src] = {
							ids : {
								id : id
							},
							length : 1
						};
						_imageCache.add(src, imgObj);
					} else {
						_id2src.add(id, imgEl.src);
						_src2ids[src].ids[id] = id;
						_src2ids[src].length++;
					}
					onComplete(true, {
						id : id,
						url : url
					});
				}, this);
				imgEl.src = url;
			}
		},
		/**
		 * Load an array of images concurrently. The loading is asynchronized,
		 * the images will be available when the onComplete is called
		 * 
		 * @param {Object[]}
		 *            urls the array of the image url to be loaded. The urls
		 *            should follow the format:
		 * 
		 * <pre>
		 * [ {
		 * 	id : 'IMAGE_ID',
		 * 	url : 'IMAGE_URL'
		 * } ]
		 * </pre>
		 * 
		 * @param {Function}
		 *            [onComplete] the on-complete function callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImages : function(urls, onProgress, onComplete) {
			onProgress = onProgress || FuncUtils.noop;
			onComplete = onComplete || FuncUtils.noop;
			var total = urls.length;
			if (total == 0) {
				onComplete(true);
			} else {
				var count = 0;
				var _stepFunction = function(isSuccessful, imgInfo) {
					count++;
					if (count < total) {
						onProgress(count / total, isSuccessful, imgInfo);
					} else {
						onComplete(true, imgInfo);
					}
				};
				for ( var i = 0, len = urls.length; i < len; i++) {
					ImageManager.loadImage(urls[i].id, urls[i].url, _stepFunction);
				}
			}
		},

		/**
		 * Check if the image has been loaded
		 * 
		 * @param {String}
		 *            id the id of the image to be checked
		 * @returns {Boolean}
		 */
		hasImage : function(id) {
			return _id2src.has(id);
		},

		/**
		 * Get the loaded image by its id, the caller has to ensure the image is
		 * loaded
		 * 
		 * @param {String}
		 *            id the id of the image to get
		 * @returns {sap.riv.vizkit.Image}
		 */
		getImage : function(id) {
			if (_id2src.has(id)) {
				return _imageCache.get(_id2src.get(id));
			}
		},

		/**
		 * Remove the loaded image from internal cache
		 * 
		 * @param {String}
		 *            id the id of the image
		 */
		disposeImage : function(id) {
			if (_id2src.has(id)) {
				var src = _id2src.remove(id);
				delete _src2ids[src].ids[id];
				_src2ids[src].length--;
				if (_src2ids[src].length === 0) {
					delete _src2ids[src];
					_imageCache.remove(src);
				}
			}
		}
	};
	return ImageManager;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.TouchEvent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Event',
  version : '1.0.0'
}
],
function Setup(FuncUtils, ObjectUtils, Event) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	/**
	 * Touch class
	 * 
	 * @name sap.riv.vizkit.Touch
	 * @constructor
	 */
	var Touch = function(identifier, target, localXY, pageXY) {
		this._id = identifier;
		this._target = target;
		this._localXY = localXY;
		this._pageXY = pageXY;
	};
	var tp = Touch.prototype;
	/**
	 * Get the identifier of the touch
	 * 
	 * @name sap.riv.vizkit.Touch#identifier
	 * @function
	 * @returns {Number}
	 */
	tp.identifier = function() {
		return this._id;
	};

	/**
	 * Get the target component of the touch
	 * 
	 * @name sap.riv.vizkit.Touch#target
	 * @function
	 * @returns {sap.riv.vizkit.UIComponent}
	 */
	tp.target = function() {
		return this._target;
	};

	/**
	 * Get the local XY of the touch in touch's target component's coordinate
	 * system
	 * 
	 * @name sap.riv.vizkit.Touch#localXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	tp.localXY = function() {
		return {
			x : this._localXY.x,
			y : this._localXY.y
		};
	};

	/**
	 * Get the page XY of the touch in document's coordinate system
	 * 
	 * @name sap.riv.vizkit.Touch#pageXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	tp.pageXY = function() {
		return {
			x : this._pageXY.x,
			y : this._pageXY.y
		};
	};
	/**
	 * Touch List class
	 * 
	 * @name sap.riv.vizkit.TouchList
	 * @constructor
	 */
	var TouchList = function(tArray, tMap) {
		this.tA = tArray, this.tM = tMap;
	};

	var tlp = TouchList.prototype;
	/**
	 * Return the length of the list
	 * 
	 * @name sap.riv.vizkit.TouchList#length
	 * @function
	 * @returns {Number}
	 * 
	 */
	tlp.length = function() {
		return this.tA.length;
	};
	/**
	 * Get the touch at specified index
	 * 
	 * @name sap.riv.vizkit.TouchList#item
	 * @function
	 * @param {Number}
	 *            index
	 * @returns {sap.riv.vizkit.Touch}
	 */
	tlp.item = function(index) {
		if (index >= 0 && (index < this.tA.length)) {
			return this.tA[index];
		}
	};
	/**
	 * Get the touch with specified identifier
	 * 
	 * @name sap.riv.vizkit.TouchList#identifiedTouch
	 * @function
	 * @param {Number}
	 *            identifier
	 * @returns {sap.riv.vizkit.Touch}
	 */
	tlp.identifiedTouch = function(identifier) {
		if (identifier) {
			return this.tM[identifier];
		}
	};
	/**
	 * This class defines Touch Event
	 * 
	 * @name sap.riv.vizkit.TouchEvent
	 * @class
	 * @augments sap.riv.vizkit.Event
	 */
	var TouchEvent = ObjectUtils.derive(Event,
	/**
	 * @lends sap.riv.vizkit.TouchEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, touches, targetTouches, changedTouches) {
			this._relatedTarget = undefined;
			this._touches = touches;
			this._targetTouches = targetTouches;
			this._changedTouches = changedTouches;
		},

		/**
		 * Get the all touches on the screen.
		 * 
		 * @name sap.riv.vizkit.TouchEvent#touches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		touches : function() {
			return this._touches;
		},
		/**
		 * Get the touches initiated from the same target
		 * 
		 * @name sap.riv.vizkit.TouchEvent#targetTouches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		targetTouches : function() {
			return this._targetTouches;
		},
		/**
		 * Get the touches lead to the event
		 * 
		 * @name sap.riv.vizkit.TouchEvent#changedTouches
		 * @function
		 * @returns {sap.riv.vizkit.TouchList}
		 */
		changedTouches : function() {
			return this._changedTouches;
		}
	});
	var _buildTouchListFromTouchList = function(touchlist) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchlist.length; i < len; i++) {
			targetComp = _findTargetComp(touchlist.item(i));
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchlist.item(i), targetComp);
				tArray.push(touch);
				tMap[touch.identifier()] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _buildTouchListFromTouchArray = function(touchArray) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchArray.length; i < len; i++) {
			targetComp = _findTargetComp(touchArray[i]);
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchArray[i], targetComp);
				tArray.push(touch);
				tMap[touch.identifier()] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _findTargetComp = function(touch) {
		var cnode = $(touch.target);
		while (cnode.length && !cnode.data('selfComp')) {
			cnode = cnode.parent();
		}
		return cnode.data('selfComp');
	};

	var _buildTouch = function(touch, targetComp) {
		var targetCompPagePosition = targetComp.pagePosition();
		var localXY = {
			x : touch.pageX - targetCompPagePosition.x,
			y : touch.pageY - targetCompPagePosition.y
		};
		// binding to UIComponent instead of Element
		return new Touch(touch.identifier, targetComp, localXY, {
			x : touch.pageX,
			y : touch.pageY
		});
	};
	TouchEvent.buildFrom3TouchArray = function(type, target, touches, changedTouches, targetTouches, canBubbling) {
		var _touches = _buildTouchListFromTouchArray(touches);
		var _targetTouches = _buildTouchListFromTouchArray(targetTouches);
		var _changedTouches = _buildTouchListFromTouchArray(changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	TouchEvent.buildFromDomTouchEvent = function(type, target, domTouchEvent, canBubbling) {
		var _touches = _buildTouchListFromTouchList(domTouchEvent.touches);
		var _targetTouches = _buildTouchListFromTouchList(domTouchEvent.targetTouches);
		var _changedTouches = _buildTouchListFromTouchList(domTouchEvent.changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	return TouchEvent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.BarRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ColorUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.BaseRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Rectangle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Paths',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
}
],
function Setup(TypeUtils, ColorUtils, Math, BaseRenderer, Rectangle, Paths,
		ObjectUtils, Animator, ThemeManager) {
	var barRenderer = ObjectUtils.derive(BaseRenderer, {
		/**
		 * 
		 * @param layer
		 * @returns {___anonymous198_591}
		 */
		constructor : function(layer, options) {
			this._fillToZero = true;

			this._barStyle = {
				isShowGradient : false,
				isShowInnerBorder : false,
				isShowOutBorder : false,
				isShowShadow : false
			};

			this._seriesPoints = [];
			this._seriesBackUpPoints = [];
			this._seriesColor = [];
			this._parseOptions(options);

			// the tooltip decorative renderer, it should be
			// added to layer before all the shape;
			this._tpDecorativeRenderer = layer
					.addShape(new Rectangle());
		},

		/**
		 * 
		 * @param options
		 *            parse bar renderer options
		 */
		_parseOptions : function(options) {
			this._barStyle.isShowGradient = options.isShowGradient;
			this._barStyle.isShowInnerBorder = options.isShowInnerBorder;
			this._barStyle.isShowOutBorder = options.isShowOutBorder;
			this._barStyle.isShowShadow = options.isShowShadow;
		},

		/**
		 * only draw the first series group of series groups in
		 * bar renderer
		 */
		draw : function() {
			this._resetShapes();
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}

			this._seriesShapes = [];
			this._seriesColor = [];
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				this._seriesColor
						.push(seriesList[i]._seriesColor);
				this._seriesShapes[i] = this
						._initSeries(seriesList[i]._data.length);
			}

			this._update();
		},

		/**
		 * redraw the bar renderer, only draw the first series
		 * group of series groups in bar renderer.
		 */
		redraw : function() {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}
			this._seriesColor = [];
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				this._seriesColor
						.push(seriesList[i]._seriesColor);
			}
			this._update();
			this.refresh();
		},

		_update : function() {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;
			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}

			var yAxis = seriesList[0].getYAxis();
			var yAxisMajorTicks = yAxis.getMajorTicks();
			var tickInterval = yAxis.getTickInterval();

			var markSize = seriesList[0]._barMarkerSize;
			markSize = this._calculateMarkSzie(
					seriesList.length, tickInterval, markSize);

			// draw seriesList
			this._seriesPoints = [];
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				this._seriesPoints.push(this
						._calculateSeriesPoints(i, len,
								seriesList[i], yAxisMajorTicks,
								markSize));
				this._drawSeries(this._seriesShapes[i],
						this._seriesPoints[i], seriesList[i]);
			}

			this._doAnimation();

		},
		/**
		 * 
		 * @param sCount
		 *            series count
		 * @param tickInterval
		 *            tick interval in yAxis
		 * @param defaultMarkSize
		 *            default mark size of bar renderer
		 * 
		 * @return actual mark size
		 */
		_calculateMarkSzie : function(sCount, tickInterval,
				defaultMarkSize) {
			var markerSize;
			if (sCount == 1) {
				// Single Bar Series
				markerSize = 2 * tickInterval / 3;
			} else {
				// Multi Bar Series
				// markerSize = tickInterval / sCount;
				markerSize = Math.round(tickInterval
						/ (1 + sCount + (sCount - 1) / 8));
			}
			if (TypeUtils.isDefined(defaultMarkSize) && (markerSize > defaultMarkSize))
				markerSize = defaultMarkSize;

			return markerSize;
		},

		/**
		 * 
		 * @param sIndex
		 *            series index
		 * @param series
		 *            count
		 * @param series
		 *            sap.riv.viz.shared.series.Series
		 * @param yAxisMajorTicks
		 *            major ticks of yAxis
		 * @Param markSize
		 *            series bar size
		 * 
		 * @return bar point positions Array[{x1,y1, x2,
		 *         y2}....]
		 * 
		 * calculation: points[i] y1 = (sIndex - (sCount/2 )) *
		 * markSize + yAxisMajorTicks[i] if(this._fillToZero){
		 * point.x1 = zeroTick; }else{ point.x1 = baseTick; } y2 =
		 * y1 + markSize x2 = series.getXAxis().u2p(data[i])
		 */
		_calculateSeriesPoints : function(sIndex, sCount,
				series, yAxisMajorTicks, markSize) {
			var data = series.getData();
			var xAxis = series.getXAxis();
			var baseTick = 0;
			var zeroTick = xAxis.u2p(0);
			var points = [];
			var offset = Math.round(markSize / 8);

			for ( var i = 0, len = data.length; i < len; i++) {
				var point = {};

				/*
				 * point.y1 = yAxisMajorTicks[i] - (markSize*sCount + offset(sCount-1))/2 + (markSize+offset)*sIndex;
				 */
				point.y1 = yAxisMajorTicks[i]  - ((sCount - 2*sIndex) * (markSize + offset) - offset)/2;

				if (this._fillToZero) {
					point.x1 = zeroTick;
				} else {
					point.x1 = baseTick;
				}

				point.y2 = point.y1 + markSize;
				point.x2 = xAxis.u2p(data[i].value);

				points.push(point);
			}
			return points;
		},

		_initSeries : function(pointNum) {
			var rects = [];

			for ( var i = pointNum; i--;) {
				rects[i] = this._addBarShape();
			}
			return rects;
		},

		/**
		 * 
		 * @param seriesShape
		 *            series shape array
		 * @param points
		 *            series points
		 * @param series
		 *            sap.riv.viz.shared.series.Series
		 * @param drawedPArray
		 *            point array what we want to draw
		 * 
		 * @return shape Array
		 * 
		 * if drawnPArray is defined, we will only draw the
		 * point which is should drawn else draw all the shapes
		 */
		_drawSeries : function(seriesShape, points, series,
				drawnPArray) {
			var data = series.getData();
			var color = series._seriesColor;
			var point;

			for ( var i = points.length; i--;) {
				point = points[i];
				if (TypeUtils.isExist(drawnPArray)) {
					if (drawnPArray[i] === 1) {
						seriesShape[i].dimensionItemIndex = data[i].dimensionItemIndex;
						seriesShape[i].measureIndex = data[i].measureIndex;
						this._drawBarShape(seriesShape[i],
								point, color);
					}
				} else {
					seriesShape[i].dimensionItemIndex = data[i].dimensionItemIndex;
					seriesShape[i].measureIndex = data[i].measureIndex;
					this._drawBarShape(seriesShape[i], point,
							color);
				}
			}
		},

		/**
		 * 
		 * @param portView
		 */
		_doAnimation : function(portView) {
			var animator = Animator;
			var self = this;

			if (!portView) {
				animator
						.animate({
							values : [ {
								type : 'FLOAT',
								from : 0.0,
								to : 1
							} ],
							duration : 800,
							onStep : function(values) {
								var seriesPoints = self._seriesPoints;
								var seriesShapes = self._seriesShapes;
								for ( var i = 0, len = seriesShapes.length; i < len; i++) {
									var series = seriesShapes[i];
									for ( var j = 0, length = series.length; j < length; j++) {
										var point = seriesPoints[i][j];
										self._updateBarShapeDuringAnimation(seriesShapes[i][j], point, self._seriesColor[i], values[0]);
									}
								}
								//highlight selected bars
								for ( var hi = 0, highlights = self._highlights, hlen = highlights.length; hi < hlen; hi++) {
										self.highlight(highlights[hi]);
								}
								self.getLayer().setNeedsDisplay();
							},
							onComplete : function(){
								var seriesPoints = self._seriesPoints;
								var seriesShapes = self._seriesShapes;
								for ( var i = 0, len = seriesShapes.length; i < len; i++) {
									var series = seriesShapes[i];
									for ( var j = 0, length = series.length; j < length; j++) {
										if (seriesShapes[i][j]) {
											var point = seriesPoints[i][j];
											self._updateBarShape(seriesShapes[i][j], point, self._seriesColor[i], 1);
										}
									}
								}
								//highlight selected bars
								for ( var hi = 0, highlights = self._highlights, hlen = highlights.length; hi < hlen; hi++) {
										self.highlight(highlights[hi]);
								}
								self.getLayer().setNeedsDisplay();
							}
						});

			} else {
				var seriesPoints = self._seriesPoints;
				var seriesShapes = self._seriesShapes;
				for ( var i = 0, len = seriesShapes.length; i < len; i++) {
					var series = seriesShapes[i];
					for ( var j = 0, length = series.length; j < length; j++) {
						if (seriesShapes[i][j]) {
							var point = seriesPoints[i][j];
							self._updateBarShape(seriesShapes[i][j], point, self._seriesColor[i], 1);
						}
					}
				}
				for ( var hi = 0, highlights = self._highlights, hlen = highlights.length; hi < hlen; hi++) {
					self.highlight(highlights[hi]);
				}
				self.getLayer().setNeedsDisplay();
			}
		},

		_resetShapes : function() {
			for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
				for ( var j = 0, seriesShapes = this._seriesShapes[i], jlen = seriesShapes.length; j < jlen; j++) {
					this._removeBarShape(seriesShapes[j]);
				}
			}
			this._seriesShapes = [];
		},

		/**
		 * first we reset all shapes to the normal state, and
		 * then highlight any shapes under the passed in point.
		 * 
		 * @override sap.riv.viz.shared.series.BaseRenderer.highlightOnPoint
		 * @deprecated
		 */
		highlightOnPoint : function(point) {
			// for bar chart, we only have one datacontext on
			// each point
			var dataContextOnPoint = null;
			// do point-in-test through all shapes
			for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
				// we should have seriesList since we have
				// something in seriesShapesArray
				var series = this.getSeriesGroups()[0]
						.getSeriesList()[i];
				for ( var j = 0, seriesShapes = this._seriesShapes[i], jlen = seriesShapes.length; j < jlen; j++) {
					var shape = seriesShapes[j];

					// [jimmy 021612]now we only change color
					// for highlight, reset anything else here
					// if we add more effect for highlight
					shape.rect.color(series._seriesColor);
					if (shape.rect.pointIn(point)) {
						// we find a shape, just highlight it
						shape.rect
								.color(ColorUtils
										.adjust_brightness(
												series._seriesColor,
												50));
						// this._doHighlight(i, j);
						dataContextOnPoint = {
							"measureIndex" : shape.measureIndex,
							"dimensionItemIndex" : shape.dimensionItemIndex,
							"series" : series
						};
					}
				}
			}
			// [jimmy TODO]optimize point, we don't need do
			// refresh if no shape is under point
			// and no shape needs update (previous selected)
			this.refresh();
			return dataContextOnPoint;
		},

		/**
		 * Highlights a bar with given locator as a clue to find
		 * the bar shape. This function cannot handle concurrent
		 * bars highlighting, i.e., only "single highlighting"
		 * is supported. :)
		 * 
		 * @param {Object}
		 *            locator - Specifier or path for finding a
		 *            shape
		 * @returns {Object} dataContext - Contextual data when
		 *          highlighting
		 * @eye
		 */
		highlight : function(locator) {
			if (!locator)
				return;

			var series, dataContext;
			var seriesGroup = this.getSeriesGroups()[0];

			if (TypeUtils.isDefined(locator.measureIndex)) {
				series = seriesGroup.getSeriesList()[locator.measureIndex];
				// var targetShape =
				// this._seriesShapes[locator.measureIndex][locator.dimensionItemIndex];

				this._doHighlight(locator.measureIndex,
						locator.dimensionItemIndex);
				// this._doHighlight(series._seriesColor,
				// targetShape);
				dataContext = {
					"measureIndex" : locator.measureIndex,
					"dimensionItemIndex" : locator.dimensionItemIndex,
					"series" : series
				};
			}

			if (TypeUtils.isDefined(locator.x)) {
				var clickedShape = this.getShape(locator);
				if (clickedShape
						&& clickedShape.measureIndex != null) {
					series = seriesGroup.getSeriesList()[clickedShape.measureIndex];
					this._doHighlight(
							clickedShape.measureIndex,
							clickedShape.dimensionItemIndex);
					// this._doHighlight(series._seriesColor,
					// this._seriesShapes[clickedShape.measureIndex][clickedShape.dimensionItemIndex]);
					dataContext = {
						"measureIndex" : clickedShape.measureIndex,
						"dimensionItemIndex" : clickedShape.dimensionItemIndex,
						"series" : series
					};
				}
			}

			this.refresh();
			return dataContext;
		},

		/**
		 * Simply restores a bar's color.
		 * 
		 * @param {Object}
		 *            locator - Specifier or finder for a bar
		 *            shape
		 */
		restore : function(locator) {
			if (!locator)
				return;

			// Only restores bar's color by its index.
			if (TypeUtils.isDefined(locator.measureIndex)) {
				this._doRestoreHighlight();
				this.refresh();
			}
		},

		/**
		 * Tests if a specified bar shape exists, if true return
		 * necessary information and vice versa.
		 * 
		 * @param {Object}
		 *            locator - Specifier or path for finding a
		 *            shape
		 * @returns {Object} bar shape data
		 */
		getShape : function(locator) {
			if (!locator)
				return;

			var returnObject = {
				"measureIndex" : null,
				"dimensionItemIndex" : null,
				"shape" : null
			};

			if (TypeUtils.isDefined(locator.measureIndex)) {
				return this._seriesShapes[locator.measureIndex][locator.dimensionItemIndex];
			}

			if (TypeUtils.isDefined(locator.x)) {
				for ( var i = 0, rows = this._seriesShapes.length; i < rows; i++) {
					for ( var j = 0, shapeCount = this._seriesShapes[i].length; j < shapeCount; j++) {
						if (this._seriesShapes[i][j].rect
								.pointIn(locator)) {
							returnObject.measureIndex = i;
							returnObject.dimensionItemIndex = j;
							returnObject.shape = this._seriesShapes[i][j];
							return returnObject;
						}
					}
				}
			}
		},

		/**
		 * Quick test for the existence of a bar shape.
		 * 
		 * @param seriesIndex -
		 *            Series index
		 * @param shapeIndex -
		 *            Shape index
		 * @returns {Object} - If bar shape exists, return it or
		 *          vice versa.
		 */
		shapeExists : function(seriesIndex, shapeIndex) {
			return this._seriesShapes[seriesIndex] 
					? this._seriesShapes[seriesIndex][shapeIndex] : undefined;
		},

		_doHighlight : function(selectedMeasureIndex,
				selectedDimensionIndex) {
			var seriesShapes = this._seriesShapes;
			var i, j, seriesShape, shape;
			for (i = 0; i < seriesShapes.length; i++) {
				seriesShape = seriesShapes[i];
				for (j = 0; j < seriesShape.length; j++) {
					shape = seriesShape[j];
					if(shape){
						shape.rect.compositionMode({
							alpha : 0.5
						});
						shape.outerBorder.compositionMode({
							alpha : 0.5
						});
						shape.innerBorder.compositionMode({
							alpha : 0.5
						});
					}
				}
			}
			var selectedShape = seriesShapes[selectedMeasureIndex]? seriesShapes[selectedMeasureIndex][selectedDimensionIndex]: null;
			if(selectedShape){
				selectedShape.rect.compositionMode({
					alpha : 1
				});
				selectedShape.outerBorder.compositionMode({
					alpha : 1
				});
				selectedShape.innerBorder.compositionMode({
					alpha : 1
				});
			}
		},

		_doRestoreHighlight : function() {
			var seriesShapes = this._seriesShapes;
			var i, j, seriesShape, shape;
			for (i = 0; i < seriesShapes.length; i++) {
				seriesShape = seriesShapes[i];
				for (j = 0; j < seriesShape.length; j++) {
					shape = seriesShape[j];
					shape.rect.compositionMode({
						alpha : 1
					});
					shape.outerBorder.compositionMode({
						alpha : 1
					});
					shape.innerBorder.compositionMode({
						alpha : 1
					});
				}
			}
		},

		/**
		 * @param viewPort
		 *            the size should to been drawn
		 * 
		 * if viewPort is defined, we only draw the shape in the
		 * this view, and remove other shape which we do not
		 * want to draw else draw all the shapes
		 */
		drawViewPort : function(scale, viewPort) {
			var offset = this.getLayer().position();

			this._seriesBackUpPoints = ObjectUtils.extend(true,
					[], this._seriesPoints);

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}

			var yAxis = seriesList[0].getYAxis();
			var yAxisMajorTicks = yAxis.getMajorTicks();
			//Ian [2012-4-18] Fix the bug, when there is only one dimension in bar chart, the second major ticks in undefind. 
			var tickInterval = yAxis.getTickInterval();
			//End
			
			var markSize;
			// var markSize = seriesList[0]._zommBarMarkerSize *
			// scale;//[Christy] Bar size is not limited.
			// if(markSize < seriesList[0]._barMarkerSize){
			// markSize = seriesList[0]._barMarkerSize;
			// }
			seriesList[0]._zommBarMarkerSize = markSize = this
					._calculateMarkSzie(seriesList.length,
							tickInterval);

			var layer = this.getLayer();
			this._seriesPoints = [];
			if (viewPort) {
				// draw serieses
				var pointArray = [];
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesShapes = this._seriesShapes[i];
					var seriesPoints = this._seriesPoints[i] = this
							._calculateSeriesPoints(i, len,
									seriesList[i],
									yAxisMajorTicks, markSize);
					for ( var j = 0; j < seriesPoints.length; j++) {

						if (seriesPoints[j].y2 + offset.y < 0
								|| seriesPoints[j].y1
										+ offset.y >= viewPort.height) {
							if (seriesShapes[j]) {
								this
										._removeBarShape(seriesShapes[j]);
							}
							seriesShapes[j] = null;
						} else {
							pointArray[j] = 1;
							if (!seriesShapes[j]) {
								seriesShapes[j] = this
										._addBarShape();
							}
						}
					}

					this._drawSeries(seriesShapes,
							seriesPoints, seriesList[i],
							pointArray);
					pointArray = [];
				}
				this._doAnimation(true);
			} else {
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesShapes = this._seriesShapes[i];
					var seriesPoints = this._seriesPoints[i] = this
							._calculateSeriesPoints(i, len,
									seriesList[i],
									yAxisMajorTicks, markSize);
					for ( var j = 0; j < seriesPoints.length; j++) {
						if (!seriesShapes[j]) {
							seriesShapes[j] = this
									._addBarShape();
						}
					}
					this._drawSeries(seriesShapes,
							seriesPoints, seriesList[i]);
				}
				this._doAnimation(true);
			}

			this.refresh();
		},

		_addBarShape : function() {
			var layer = this.getLayer();
			return {
				'rect' : layer.addShape(new Rectangle()),
				'outerBorder' : layer.addShape(new Paths()),
				'innerBorder' : layer.addShape(new Paths())
			};
		},

		_removeBarShape : function(shape) {
			var layer = this.getLayer();
			layer.removeShape(shape.rect);
			layer.removeShape(shape.outerBorder);
			layer.removeShape(shape.innerBorder);
		},

		_drawBarShape : function(seriesShape, point, basicColor) {
			var barHeight = Math.abs(point.y2 - point.y1);
			var isShowOutBorder = this._barStyle.isShowOutBorder, isShowInnerBorder = this._barStyle.isShowInnerBorder;
			if (barHeight < 8) {
				// Remove Out Border
				isShowOutBorder = false;
			}
			if (barHeight < 5) {
				// Remove Inner Border
				isShowInnerBorder = false;
			}

			var color = ColorUtils
					.getColorSeriesForBar(basicColor);

			// draw rectangle
			seriesShape.rect.color(basicColor);

			if (point.x1 > point.x2) {
				seriesShape.rect
						.topRight([ point.x1, point.y1 ]);
			} else {
				seriesShape.rect
						.topLeft([ point.x1, point.y1 ]);
			}
			// draw inner border
			//Ian [2012-04-11] To fix the bug VISUAL-561, we should reset the inner and outer border because it may keep the last value
			seriesShape.innerBorder.reset();
			seriesShape.outerBorder.reset();
			//End
			
			seriesShape.innerBorder.borderWidth(1).borderColor(
					color[0]).visible(isShowInnerBorder);
			// draw outer border
			seriesShape.outerBorder.borderWidth(1).borderColor(
					color[3]).visible(isShowOutBorder);
		},

		_updateBarShapeDuringAnimation : function(seriesShape, point,
				basicColor, factor){
			var width = Math.abs(point.x1 - point.x2) * factor;
			var height = Math.abs(point.y2 - point.y1);
			if ((width.toString() === 'NaN')
					|| (height.toString() === 'NaN')) {
				return;
			}
			seriesShape.rect.width(width).height(height).shadow({
				offsetX : 0,
				offsetY : 0,
				blur : 0,
				color : 'rgba(0,0,0,0.5)'
			});

			var color = ColorUtils.getColorSeriesForBar(basicColor);

			if (this._barStyle.isShowGradient) {
				if (point.x1 > point.x2) {
					seriesShape.rect.color({
						t : 'lg',
						e : {
							x : 0,
							y : point.y1
						},
						s : {
							x : width,
							y : point.y1
						},
						st : [ {
							o : 1,
							v : color[1]
						}, {
							o : 0,
							v : color[2]
						} ]
					});
				} else {
					seriesShape.rect.color({
						t : 'lg',
						s : {
							x : 0,
							y : point.y1
						},
						e : {
							x : width,
							y : point.y1
						},
						st : [ {
							o : 1,
							v : color[1]
						}, {
							o : 0,
							v : color[2]
						} ]
					});
				}
			} else {
				seriesShape.rect.color(basicColor);
			}
		},
		
		_updateBarShape : function(seriesShape, point,
				basicColor, factor) {
			var width = Math.abs(point.x1 - point.x2) * factor;
			var height = Math.abs(point.y2 - point.y1);
			if ((width.toString() === 'NaN')
					|| (height.toString() === 'NaN')) {
				return;
			}
			seriesShape.rect.width(width).height(height);
			
			// draw rectangle
			if (this._barStyle.isShowShadow) {
				seriesShape.rect.shadow({
					offsetX : 1,
					offsetY : 2,
					blur : 2,
					color : 'rgba(0,0,0,0.5)'
				});
			} else {
				seriesShape.rect.shadow({
					offsetX : 0,
					offsetY : 0,
					blur : 0,
					color : 'rgba(0,0,0,0.5)'
				});
			}

			var color = ColorUtils
					.getColorSeriesForBar(basicColor);

			if (this._barStyle.isShowGradient) {
				if (point.x1 > point.x2) {
					seriesShape.rect.color({
						t : 'lg',
						e : {
							x : 0,
							y : point.y1
						},
						s : {
							x : width,
							y : point.y1
						},
						st : [ {
							o : 1,
							v : color[1]
						}, {
							o : 0,
							v : color[2]
						} ]
					});
				} else {
					seriesShape.rect.color({
						t : 'lg',
						s : {
							x : 0,
							y : point.y1
						},
						e : {
							x : width,
							y : point.y1
						},
						st : [ {
							o : 1,
							v : color[1]
						}, {
							o : 0,
							v : color[2]
						} ]
					});
				}
			} else {
				seriesShape.rect.color(basicColor);
			}

			var offset = 0;
			seriesShape.outerBorder.reset();
			if (seriesShape.outerBorder.visible()) {
				this._drawBorderPath(seriesShape.outerBorder,
						point, width, offset);
				offset = offset + 1;
			}
			seriesShape.innerBorder.reset();
			if (seriesShape.innerBorder.visible()) {
				this._drawBorderPath(seriesShape.innerBorder,
						point, width, offset);
			}
		},

		_drawBorderPath : function(shape, point, distance,
				offset) {
			var barWidth = Math.abs(point.x1 - point.x2);
			if (barWidth < 2)
				return;
			if (point.x1 > point.x2) {
				shape.moveTo(point.x1, point.y1 + offset)
						.lineTo(point.x1 - distance + offset,
								point.y1 + offset);
				if (barWidth < 3) {
					shape.moveTo(point.x1 - distance + offset,
							point.y2 - offset);
				} else {
					shape.lineTo(point.x1 - distance + offset,
							point.y2 - offset);
				}
				shape.lineTo(point.x1, point.y2 - offset);
			} else {
				shape.moveTo(point.x1, point.y1 + offset)
						.lineTo(point.x1 + distance - offset,
								point.y1 + offset);
				if (barWidth < 3) {
					shape.moveTo(point.x1 + distance - offset,
							point.y2 - offset);
				} else {
					shape.lineTo(point.x1 + distance - offset,
							point.y2 - offset);
				}
				shape.lineTo(point.x1, point.y2 - offset);
			}
		},

		applyTheme : function(theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var barStyle = settings.bar;
			this._barStyle.isShowGradient = barStyle.isShowGradient;
			this._barStyle.isShowInnerBorder = barStyle.isShowInnerBorder;
			this._barStyle.isShowOutBorder = barStyle.isShowOutBorder;
			this._barStyle.isShowShadow = barStyle.isShowShadow;
			this.redraw();
		},

		updateProperties : function(propBag) {
			this._parseOptions(propBag);
		},

		hoverOnPoint : function(point) {
			var dataCtxOnpoint = {};

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;
			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}

			var yAxis = seriesList[0].getYAxis();
			var yAxisMajorTicks = yAxis.getMajorTicks();
			var halfTickInterval = yAxis.getTickInterval() / 2;

			var start = 0, end = yAxisMajorTicks.length - 1;
			var found = false;
			var dimensionItemIndex;
			while (!found && start < end) {
				dimensionItemIndex = Math
						.round((start + end) / 2);
				var xPoint = yAxisMajorTicks[dimensionItemIndex]
						- point.y;
				if (Math.abs(xPoint) <= halfTickInterval)
					found = true;
				else if (xPoint >= 0) {
					start = dimensionItemIndex + 1;
				} else {
					end = dimensionItemIndex - 1;
				}
			}
			if (!found)
				dimensionItemIndex = start;
			
			if (this._dataCtxOnPoint
					&& this._dataCtxOnPoint.dimensionItemIndex === dimensionItemIndex) {
				return this._dataCtxOnPoint;
			}
			dataCtxOnpoint['dimensionItemIndex'] = dimensionItemIndex;

			this._tpDecorativeRenderer
					.visible(true)
					.width(this.getLayer().size().width)
					.height(halfTickInterval * 2)
					.color('rgba(133,133,133, 0.4)')
					.topLeft(
							[
									0,
									Math
											.round(yAxisMajorTicks[dimensionItemIndex]
													- halfTickInterval) ]);
			this.refresh();

			this._dataCtxOnPoint = null;
			this._dataCtxOnPoint = dataCtxOnpoint;

			return dataCtxOnpoint;
		},

		onblur : function(point) {
			this._dataCtxOnPoint = null;
			this._tpDecorativeRenderer.visible(false);
			// refresh the chart to remove the decorative
			// renderer
			this.refresh();

		}
	});

	return barRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.LineRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.BaseRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Line',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Polygon',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Circle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Paths',
  version : '1.0.0'
}
],
function Setup(TypeUtils, Math, BaseRenderer, Series, ObjectUtils, Animator, ThemeManager, Line, Polygon, Circle, Paths) {
	var lineRenderer = ObjectUtils.derive(BaseRenderer, {
		constructor : function(layer, options) {
			this._seriesPoints = [];
			this._isShowMarkerShadow = false;
			this._isShowLineShadow = false;

			// the tooltip decorative renderer, it should be
			// added to layer before all the shape;
			this._tpDecorativeRenderer = layer.addShape(new Line());
			this._tpDecorativePathRenderers = [];
			this._parseOptions(options);
		},

		/**
		 * @param options
		 */
		_parseOptions : function(options) {
			this._isShowLineShadow = options.isShowLineShadow;
			this._isShowMarkerShadow = options.isShowMarkerShadow;
		},

		/**
		 * 1. create the marker points 2. draw the marker
		 */
		draw : function() {
			this._resetShape();
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var series = seriesGroups[0].getSeriesList();
			if (series.length == 0) {
				return;
			}

			// draw series
			for ( var i = 0, len = series.length; i < len; i++) {
				this._seriesShapes[i] = this._initSeries(series[i]._data.length, series[i]);
			}
			this._update();
			// register event
			this._regEvent();

		},

		_update : function() {
			var seriesGroups = this.getSeriesGroups();
			var series = seriesGroups[0].getSeriesList();

			var xAxis = series[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();

			// create series points
			this._seriesPoints = [];
			for ( var i = 0, len = series.length; i < len; i++) {
				this._seriesPoints.push(this._calculateSeriesPoints(series[i], xAxisMajorTicks));
			}

			// draw series
			for ( var i = 0, len = series.length; i < len; i++) {
				this._drawSeries(this._seriesShapes[i], this._seriesPoints[i], series[i]);
			}

			this._doAnimation();
		},

		/**
		 * redraw line renderer. 1. clear the shapes 2. reset
		 * the series points 3. call draw function
		 */
		redraw : function() {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var series = seriesGroups[0].getSeriesList();
			if (series.length == 0) {
				return;
			}

			var i, seriesNum = series.length, isRedraw = false;
			for (i = 0; i < seriesNum; i++) {
				if (!(this._seriesShapes[i].marker[0] instanceof this
						._getMarkerObject(series[i]._markerSymbol))) {
					isRedraw = true;
					break;
				}
			}

			if (isRedraw) {
				this._resetShape();
				this._seriesPoints = [];
				this.draw();
			} else {
				this._update();
				this.refresh();
			}
		},

		_getMarkerObject : function(markerSymbol) {
			var shapeObj;
			switch (markerSymbol) {
			case Series.TRIANGLEMARKER:
			case Series.DIAMONDMARKER:
				shapeObj = Polygon;
				break;
			case Series.CIRCLEMARKER:
			default:
				shapeObj = Circle;
				break;
			}
			return shapeObj;
		},

		/**
		 * 
		 * @param series
		 * @param xAxisMajorTicks
		 * @returns {Array} return the center position of every
		 *          mark
		 */
		_calculateSeriesPoints : function(series, xAxisMajorTicks) {
			var data = series.getData();
			var yAxis = series.getYAxis();

			var points = [];

			for ( var i = 0, len = data.length; i < len; i++) {

				var point = {};
				point.x = xAxisMajorTicks[i];
				point.y = yAxis.u2p(data[i].value);
				points.push(point);

			}
			return points;
		},

		_initSeries : function(pointNum, series) {
			var layer = this.getLayer();
			var lineShapes = {
				line : [],
				marker : []
			};
			var markerSymbol = series._markerSymbol;
			for ( var i = 0; i < pointNum; i++) {
				lineShapes.line[i] = layer.addShape(new Line());
			}
			for ( var i = 0; i < pointNum; i++) {
				switch (markerSymbol) {
				case Series.TRIANGLEMARKER:
				case Series.DIAMONDMARKER:
					lineShapes.marker[i] = layer.addShape(new Polygon());
					break;
				case Series.CIRCLEMARKER:
				default:
					lineShapes.marker[i] = layer.addShape(new Circle());
					break;
				}
			}
			return lineShapes;
		},

		_drawSeries : function(shape, points, series, drawnPArray) {
			var markerSymbol = series._markerSymbol;

			for ( var i = 0, len = points.length; i < len; i++) {
				if ((TypeUtils.isExist(drawnPArray)) && (drawnPArray[i] !== 1))
					break;
				
				if ( !series.isVisible() ) {
					if ( shape.marker[i].rect ) {
						shape.marker[i].rect.visible(false);
					} else {
						shape.marker[i].visible(false);
					}
					shape.line[i].visible(false);
				}
				
				// Marker Shadow
				if (this._isShowMarkerShadow) {
					shape.marker[i].shadow({
						offsetX : 1,
						offsetY : 2,
						blur : 2,
						color : 'rgba(0,0,0,0.5)'
					});
				} else {
					shape.marker[i].shadow({
						offsetX : 0,
						offsetY : 0,
						blur : 0,
						color : 'rgba(0,0,0,0.5)'
					});
				}
				// Line Shadow
				if (this._isShowLineShadow) {
					shape.line[i].shadow({
						offsetX : 0,
						offsetY : 2,
						blur : 3,
						color : 'rgba(0,0,0,0.5)'
					});
				} else {
					shape.line[i].shadow({
						offsetX : 0,
						offsetY : 0,
						blur : 0,
						color : 'rgba(0,0,0,0.5)'
					});
				}
			}

			switch (markerSymbol) {
			case Series.CIRCLEMARKER: {
				this._drawCircleMarkAndLine(shape, points, series, drawnPArray);
				break;
			}

			case Series.TRIANGLEMARKER: {
				this._drawTriangleMarkAndLine(shape, points, series, drawnPArray);
				break;
			}

			case Series.DIAMONDMARKER: {
				this._drawDiamondMarkAndLine(shape, points, series, drawnPArray);
				break;
			}

			case Series.PENTAGONMARKER: {
				this._drawPentagonMarkAndLine(shape, points, series, drawnPArray);
				break;
			}

			default: {
				this._drawCircleMarkAndLine(shape, points, series, drawnPArray);
				break;
			}
			}
		},

		/**
		 * 
		 * @param viewPort
		 * 
		 * we only do animation on loading chart now. Every
		 * time, we calculate the marker number we should draw.
		 * we will set the property visible to true to show it,
		 * including marker and line shape. Line shape start
		 * from index of 1.
		 */
		_doAnimation : function(viewPort) {

			var self = this;
			if (!viewPort) {
				var highlights = self._highlights;
				var series = self.getSeriesGroups()[0].getSeriesList();
				for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
					this._doUnHighlight(highlights[hi]);
				}
				for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
					this._doHighlight(highlights[hi], series[highlights[hi].measureIndex]);
				}

				Animator.animate({
					values : [ {
						type : 'FLOAT',
						from : 0.0,
						to : 1
					} ],
					duration : 800,
					onStep : function(values) {
						var seriesPoints = self._seriesPoints;
						var shapes = self._seriesShapes;
						var index = 0;

						var length = self.getLayer().size().width * values[0];
						for ( var i = 0, len = seriesPoints[0].length; i < len; i++) {
							if (seriesPoints[0][i].x >= length) {
								index = i;
								break;
							}
						}

						index++;

						for ( var i = 0; i < shapes.length; i++) {
							var lineShape = shapes[i].line;
							var markers = shapes[i].marker;
							for ( var j = 0; j < index; j++) {
								if (markers[j]) {
									markers[j].visible(true);
								}
								if (j > 0 && lineShape[j]) {
									lineShape[j].visible(true);
								}
							}
						}
						
						var highlights = self._highlights;
						for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
							highlights[hi].crossShape.visible(true);
							highlights[hi].borderShape.visible(true);
						}
						
						self.getLayer().setNeedsDisplay();
					},
					/**
					 * As the performance issue, in IPAD, we may do not have the resource the complement all the animation,
					 * but we should assure that all the line show in the chart area.
					 */
					onComplete: function(){
						var shapes = self._seriesShapes;
						for ( var i = 0, len = shapes.length; i < len; i++) {
							var markers = shapes[i].marker;
							var lines = shapes[i].line;
							for ( var j = 0, jlen = markers.length; j < jlen; j++) {
								if (markers[j]) {
									markers[j].visible(true);
								}
								if (j > 0 && lines[j]) {
									lines[j].visible(true);
								}
							}
						}
					}
				});
			} else {
				var shapes = self._seriesShapes;
				var series = self.getSeriesGroups()[0].getSeriesList();

				var highlights = self._highlights;
				for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
					this._doUnHighlight(highlights[hi]);
				}
				for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
					this._doHighlight(highlights[hi], series[highlights[hi].measureIndex]);
				}

				for ( var i = 0, len = shapes.length; i < len; i++) {
					var markers = shapes[i].marker;
					var lines = shapes[i].line;
					for ( var j = 0, jlen = markers.length; j < jlen; j++) {
						if (markers[j]) {
							markers[j].visible(true);
						}
						if (j > 0 && lines[j]) {
							lines[j].visible(true);
						}
					}
				}
				var highlights = self._highlights;
				for ( var hi = 0, hlen = highlights.length; hi < hlen; hi++) {
					highlights[hi].crossShape.visible(true);
					highlights[hi].borderShape.visible(true);
				}
				self.refresh();
			}
		},

		_drawCircleMarkAndLine : function(lineShapes, points, series, drawnPArray) {
			if ( !series.isVisible() ) return;
			
			var lineMarkerSize = series._lineMarkerSize;
			var lineSize = series._lineSize;
			var color = series._seriesColor;
			var lineColor = series._lineColor;

			for ( var i = 0, len = points.length; i < len; i++) {
				if (TypeUtils.isExist(drawnPArray)) {
					if (drawnPArray[i] === 1) {
						// draw circle marker
						lineShapes.marker[i].fillingColor(color).center({
							x : points[i].x,
							y : points[i].y
						}).radius(lineMarkerSize / 2).visible(false);

						if (i != 0) {
							lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
								x : points[i - 1].x,
								y : points[i - 1].y
							}).to({
								x : points[i].x,
								y : points[i].y
							});
						}
					}
				} else {
					// draw circle marker
					lineShapes.marker[i].fillingColor(color).center({
						x : points[i].x,
						y : points[i].y
					}).radius(lineMarkerSize / 2).visible(false);

					if (i != 0) {
						lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
							x : points[i - 1].x,
							y : points[i - 1].y
						}).to({
							x : points[i].x,
							y : points[i].y
						});
					}
				}
			}
		},

		_drawTriangleMarkAndLine : function(lineShapes, points, series, drawnPArray) {
			if ( !series.isVisible() ) return;
			
			var lineMarkerSize = series._lineMarkerSize;
			var lineSize = series._lineSize;
			var color = series._seriesColor;
			var lineColor = series._lineColor;

			for ( var i = 0, len = points.length; i < len; i++) {
				if (TypeUtils.isExist(drawnPArray)) {
					if (drawnPArray[i] === 1) {
						// draw circle marker
						var plgn = lineShapes.marker[i].visible(false);
						plgn.reset();
						plgn.fillingColor(color);
						this._drawTriangleVertices(plgn, points[i], lineMarkerSize);
						plgn.close();

						if (i != 0) {
							lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
								x : points[i - 1].x,
								y : points[i - 1].y
							}).to({
								x : points[i].x,
								y : points[i].y
							});
						}
					}
				} else {
					// draw circle marker
					var plgn = lineShapes.marker[i].visible(false);
					plgn.reset();
					plgn.fillingColor(color);
					this._drawTriangleVertices(plgn, points[i], lineMarkerSize);
					plgn.close();

					if (i != 0) {
						lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
							x : points[i - 1].x,
							y : points[i - 1].y
						}).to({
							x : points[i].x,
							y : points[i].y
						});
					}
				}

			}

		},

		_drawDiamondMarkAndLine : function(lineShapes, points, series, drawnPArray) {
			if ( !series.isVisible() ) return;
			
			var lineMarkerSize = series._lineMarkerSize;
			var lineSize = series._lineSize;
			var color = series._seriesColor;
			var lineColor = series._lineColor;

			for ( var i = 0, len = points.length; i < len; i++) {
				if (TypeUtils.isExist(drawnPArray)) {
					if (drawnPArray[i] === 1) {
						// draw circle marker
						var plgn = lineShapes.marker[i].visible(false);
						plgn.reset();
						plgn.fillingColor(color);
						this._drawDiamondVertices(plgn, points[i], lineMarkerSize);
						plgn.close();

						if (i != 0) {
							lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
								x : points[i - 1].x,
								y : points[i - 1].y
							}).to({
								x : points[i].x,
								y : points[i].y
							});
						}
					}
				} else {
					// draw circle marker
					var plgn = lineShapes.marker[i].visible(false);
					plgn.reset();
					plgn.fillingColor(color);
					this._drawDiamondVertices(plgn, points[i], lineMarkerSize);
					plgn.close();

					if (i != 0) {
						lineShapes.line[i].visible(false).color(lineColor).width(lineSize).from({
							x : points[i - 1].x,
							y : points[i - 1].y
						}).to({
							x : points[i].x,
							y : points[i].y
						});
					}
				}
			}
		},

		_drawPentagonMarkAndLine : function(points, series) {
			if ( !series.isVisible() ) return;
		},

		/**
		 * remove all the shape created
		 */
		_resetShape : function() {
			var layer = this.getLayer();
			for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
				// remove the marker renderer
				for ( var markers = this._seriesShapes[i].marker, j = markers.length; j--;) {
					layer.removeShape(markers[j]);
				}

				// remove the line renderer
				for ( var lines = this._seriesShapes[i].line, j = lines.length; j--;) {
					layer.removeShape(lines[j]);
				}
			}
			this._seriesShapes = [];
		},

		/**
		 * register event on line renderer
		 */
		_regEvent : function() {

		},

		/** @overrides sap.riv.viz.shared.series.BaseRenderer.highlight */
		highlight : function() {
			if (this._seriesShapes.length === 0)
				return;
			var series = this.getSeriesGroups()[0].getSeriesList();

			if (this._layerPrioritization) {
				// For default selection, we should put the
				// highlighted line at the top layer and reinit
				// the shape
				var highlights = this._highlights;
				if (highlights.length > 0) {
					var firstSeriesIndex = highlights[0]['measureIndex'];
					if (TypeUtils.isExist(firstSeriesIndex) && firstSeriesIndex <= (series.length - 1)) {
						// Here is for the click event, all the
						// shape have been created,
						// we can change the shape's order to
						// put the series at the top position
						if (this._seriesShapes.length > 0) {
							// remove the shapes at current
							// layer, then reinit it and put
							// them at the top position
							var shapes = this._seriesShapes[firstSeriesIndex];
							var layer = this.getLayer();
							for ( var i = 0; i < shapes.marker.length; i++) {
								layer.removeShape(shapes.marker[i]);
								layer.removeShape(shapes.line[i]);
							}

							// remove the shapes
							this._seriesShapes[firstSeriesIndex] = this._initSeries(
									series[firstSeriesIndex]._data.length, series[firstSeriesIndex]);

							var points = [];
							var xAxis = series[0].getXAxis();
							var xAxisMajorTicks = xAxis.getMajorTicks();

							// create series points
							points = this._calculateSeriesPoints(series[firstSeriesIndex],
									xAxisMajorTicks);

							this._drawSeries(this._seriesShapes[firstSeriesIndex], points, series[firstSeriesIndex]);
							
							//show series points
							var markers = this._seriesShapes[firstSeriesIndex].marker;
							var lines = this._seriesShapes[firstSeriesIndex].line;
							for ( var i = 0, len = markers.length; i < len; i++) {
								markers[i].visible(true);
								lines[i].visible(true);
							}
							
							if(this._dataCtxOnPoint){
								//remove highlight shape
								for ( var i = 0, pathRenderers = this._tpDecorativePathRenderers, len = pathRenderers.length; i < len; i++) {
									layer.removeShape(pathRenderers[i]);
								}
								this._tpDecorativePathRenderers = [];
								//add new highlight shape
								var dimensionItemIndex = this._dataCtxOnPoint.dimensionItemIndex;
								var s, shape;
								for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
									s = series[i];
									shape = this._drawBorderShape(s._markerSymbol, i, dimensionItemIndex,
											1.5 * s._lineMarkerSize, s._seriesColor);
									shape.visible(true);
									this._tpDecorativePathRenderers[i] = shape;
								}
							}
						}
					}
				}
			}

			for ( var i = 0; i < this._highlights.length; i++) {
				this._doHighlight(this._highlights[i], series[this._highlights[i].measureIndex]);
				this._highlights[i].crossShape.visible(true);
				this._highlights[i].borderShape.visible(true);
			}
			this.refresh();
		},

		_doHighlight : function(highlightItem, series) {
			var measureIndex = highlightItem.measureIndex;
			var dimensionItemIndex = highlightItem.dimensionItemIndex;

			var borderSize = 1.7 * series._lineMarkerSize;
			var seriesColor = series._seriesColor;

			if(!TypeUtils.isExist(this._seriesShapes[measureIndex].marker[dimensionItemIndex]))
				return;
			
			var borderShape = this._drawBorderShape(series._markerSymbol, measureIndex,
					dimensionItemIndex, borderSize, seriesColor);
			highlightItem.borderShape = borderShape;

			var crossShape = this._drawCrossShape(measureIndex, dimensionItemIndex, borderSize,
					borderShape, seriesColor);
			highlightItem.crossShape = crossShape;
		},

		_doUnHighlight : function(highlightItem) {
			var layer = this.getLayer();
			layer.removeShape(highlightItem.borderShape);
			layer.removeShape(highlightItem.crossShape);
		},

		removeHighlights : function() {
			for ( var i = 0, len = this._highlights.length; i < len; i++) {
				this._doUnHighlight(this._highlights[i]);
			}
			this._highlights.splice(0, this._highlights.length);
			this.refresh();
		},

		/**
		 * 
		 * @param scale
		 *            the scale degree in xaxis direction
		 * @param viewPort
		 *            the size should to been drawn
		 * 
		 * if viewPort is defined, we only draw the shape in the
		 * this view, and remove other shape which we do not
		 * want to draw else draw all the shapes
		 */
		drawViewPort : function(scale, viewPort) {

			var offset = this.getLayer().position();

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) {
				return;
			}

			var xAxis = seriesList[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var tickInterval = xAxis.getTickInterval();
			var layer = this.getLayer();
			this._seriesPoints = [];

			if (viewPort) {
				var pointArray = [];
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesMarkerShapes = this._seriesShapes[i].marker;
					var seriesLineShapes = this._seriesShapes[i].line;

					var seriesPoints = this._calculateSeriesPoints(seriesList[i], xAxisMajorTicks);
					this._seriesPoints.push(seriesPoints);

					for ( var j = 0; j < seriesPoints.length; j++) {
						// Fix the issue, in Line chart, when
						// you zoom in/out the chart, we also
						// should show the line at the right
						// side of the last mark
						if (seriesPoints[j].x + offset.x < 0
								|| seriesPoints[j].x + offset.x > viewPort.width + tickInterval) {
							if (seriesMarkerShapes[j] && seriesLineShapes[j]) {
								layer.removeShape(seriesMarkerShapes[j]);
								layer.removeShape(seriesLineShapes[j]);
							}
							seriesMarkerShapes[j] = null;
							seriesLineShapes[j] = null;
						} else {
							pointArray[j] = 1;
							// we should keep that the marker is
							// added after line
							if (!seriesMarkerShapes[j] && !seriesLineShapes[j]) {
								seriesLineShapes[j] = layer.addShape(new Line());

								switch (seriesList[i]._markerSymbol) {
								case Series.CIRCLEMARKER: {
									seriesMarkerShapes[j] = layer.addShape(new Circle());
									break;
								}

								default: {
									seriesMarkerShapes[j] = layer.addShape(new Polygon());
									break;
								}
								}
							}
						}
					}

					this._drawSeries(this._seriesShapes[i], seriesPoints, seriesList[i], pointArray);
				}

				this._doAnimation(true);
			} else {
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesMarkerShapes = this._seriesShapes[i].marker;
					var seriesLineShapes = this._seriesShapes[i].line;
					var seriesPoints = this._calculateSeriesPoints(seriesList[i], xAxisMajorTicks);
					this._seriesPoints.push(seriesPoints);
					// Here is special code for line render. As
					// in line render, we should keep all the
					// mark and line above the bar side. so we
					// should
					// remove the shape and add the shape again.
					for ( var j = 0, jlen = seriesPoints.length; j < jlen; j++) {
						if (seriesMarkerShapes[j]) {
							layer.removeShape(seriesMarkerShapes[j]);
						}
						if (seriesLineShapes[j]) {
							layer.removeShape(seriesLineShapes[j]);
						}

						seriesLineShapes[j] = null;
						seriesMarkerShapes[j] = null;
					}

					for ( var j = 0; j < seriesPoints.length; j++) {
						if (!seriesLineShapes[j])
							seriesLineShapes[j] = layer.addShape(new Line());
					}

					for ( var j = 0; j < seriesPoints.length; j++) {
						if (!seriesMarkerShapes[j]) {
							switch (seriesList[i]._markerSymbol) {
							case Series.CIRCLEMARKER: {
								seriesMarkerShapes[j] = layer.addShape(new Circle());
								break;
							}
							default: {
								seriesMarkerShapes[j] = layer.addShape(new Polygon());
								break;
							}
							}

						}
					}

					this._drawSeries(this._seriesShapes[i], seriesPoints, seriesList[i]);
				}
				this._doAnimation(true);
			}
			this.refresh();
		},

		applyTheme : function(theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var lineStyle = settings.line;

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var series = seriesGroups[0].getSeriesList();
			if (series.length == 0) {
				return;
			}

			for ( var i = 0, len = series.length; i < len; i++) {
				series[i]._lineMarkerSize = lineStyle.marker.size;
				series[i]._lineSize = lineStyle.line.size;
			}
			this._isShowLineShadow = lineStyle.line.isShowShadow;
			this._isShowMarkerShadow = lineStyle.marker.isShowShadow;

			this._update();
			this.refresh();
		},

		updateProperties : function(propBag) {
			this._parseOptions(propBag);
		},

		hoverOnPoint : function(point, isShowLine) {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var series = seriesGroups[0].getSeriesList();
			if (series.length == 0) {
				alert('rew');
				return;
			}

			var xAxis = series[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var halfTickInterval = xAxis.getTickInterval() / 2;

			var start = 0, end = xAxisMajorTicks.length - 1;
			var found = false;
			var dimensionItemIndex;
			while (!found && start < end) {
				dimensionItemIndex = Math.round((start + end) / 2);
				var xPoint = xAxisMajorTicks[dimensionItemIndex] - point.x;
				if (Math.abs(xPoint) <= halfTickInterval)
					found = true;
				else if (xPoint <= 0) {
					start = dimensionItemIndex + 1;
				} else {
					end = dimensionItemIndex - 1;
				}
			}
			if (!found)
				dimensionItemIndex = start;

			if (isShowLine) {
				this._tpDecorativeRenderer.width(2).visible(true).color('rgb(0,0,0)').from({
					x : point.x,
					// [Ian 2012-3-28]Fix the issue, the
					// back ground line is not align
					// with the aixs
					y : series[0].getYAxis().getLastTickOffset()
				}).to({
					x : point.x,
					y : this.getLayer().size().height
				}).shadow({
					offsetX : 0,
					offsetY : 0,
					blur : 5,
					color : 'rgba(80,80,80,1)'
				});

				this.refresh();
			}

			// If the dimension item index do not change, we can
			// do not refresh the chart.
			if (this._dataCtxOnPoint && this._dataCtxOnPoint.dimensionItemIndex === dimensionItemIndex) {
				return this._dataCtxOnPoint;
			}

			// In Line chart, we should highlight the marker. So
			// we should insert the path renderer before the
			// marker in order to
			// highlight the marker
			var layer = this.getLayer();
			var pathRenderers = this._tpDecorativePathRenderers;
			for ( var i = 0, len = pathRenderers.length; i < len; i++) {
				// remove the path render those are exist, and
				// we must to remove the path shape and can not
				// reuse it, because if the chart area is
				// very small, and the path renderer is behind
				// of all the marker renderer, it will be
				// overridden.
				layer.removeShape(pathRenderers[i]);
			}
			this._tpDecorativePathRenderers = [];

			// show highlighted shape
			var highlights = this._highlights;
			for ( var j = 0, hLen = highlights.length; j < hLen; j++) {
				var highlightedItem = highlights[j];
				highlightedItem.borderShape.visible(true);
				highlightedItem.crossShape.visible(true);
			}

			// readd the path renderers, and we should add them
			// before every marker
			var s, shape;
			for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
				if(this._seriesShapes[i].line.length > 0 || this._seriesShapes[i].marker.length > 0){
					s = series[i];
					shape = this._drawBorderShape(s._markerSymbol, i, dimensionItemIndex,
							1.5 * s._lineMarkerSize, s._seriesColor);
					shape.visible(true);
					this._tpDecorativePathRenderers[i] = shape;
	
					// hide highlighted shape
					var highlights = this._highlights;
					for ( var j = 0, hLen = highlights.length; j < hLen; j++) {
						var highlightedItem = highlights[j];
						if (highlightedItem.measureIndex == i
								&& highlightedItem.dimensionItemIndex == dimensionItemIndex) {
							// Highlight and selected the same
							// shape, hide selected effect
							highlightedItem.borderShape.visible(false);
							highlightedItem.crossShape.visible(false);
						}
					}
				}
			}

			var dataCtxOnpoint = {};
			dataCtxOnpoint['dimensionItemIndex'] = dimensionItemIndex;

			this._dataCtxOnPoint = null;
			this._dataCtxOnPoint = dataCtxOnpoint;

			return dataCtxOnpoint;
		},

		onblur : function(point) {
			if(this._dataCtxOnPoint){
				var dimensionItemIndex = this._dataCtxOnPoint.dimensionItemIndex;
				if (this._isShowMarkerShadow) {
					for ( var i = 0, len = this._seriesShapes.length; i < len; i++) {
						this._seriesShapes[i].marker[dimensionItemIndex].shadow({
							offsetX : 1,
							offsetY : 2,
							blur : 2,
							color : 'rgba(0,0,0,0.5)'
						});
					}
				}
			}

			var highlights = this._highlights, highlightedItem;
			for ( var i = 0, hLen = highlights.length; i < hLen; i++) {
				highlightedItem = highlights[i];
				highlightedItem.borderShape.visible(true);
				highlightedItem.crossShape.visible(true);

				this._seriesShapes[highlightedItem.measureIndex].marker[highlightedItem.dimensionItemIndex]
						.shadow({
							offsetX : 0,
							offsetY : 0,
							blur : 0,
							color : 'rgba(0,0,0,0.5)'
						});
			}

			this._dataCtxOnPoint = null;
			// as we can reuse the decorative renderer, we only
			// make it invisible
			this._tpDecorativeRenderer.visible(false);

			// we can not reuse the decorative path renderers,
			// so we should remove them and readd them agian
			// when we need them.
			var layer = this.getLayer();
			for ( var i = 0, pathRenderers = this._tpDecorativePathRenderers, len = pathRenderers.length; i < len; i++) {
				// remove the path render those are exist, and
				// we must to remove the path shape and can not
				// reuse it, because if the chart area is
				// very small, and the path renderer is behind
				// of all the marker renderer, it will be
				// overridden.
				layer.removeShape(pathRenderers[i]);
			}
			this._tpDecorativePathRenderers = [];

			this.refresh();
		},

		/*
		 * Add border to shape while highlight and selected.
		 */
		_drawBorderShape : function(markerSymbol, measureIndex, dimensionItemIndex, withBorderSize,
				fillingColor) {
			var borderShape = null;
			var baseShape = this._seriesShapes[measureIndex].marker[dimensionItemIndex];
			var layer = this.getLayer();

			// initial shape
			switch (markerSymbol) {
			case Series.CIRCLEMARKER: {
				borderShape = layer.insertShapeBefore(new Circle(), baseShape);
				break;
			}
			default: {
				borderShape = layer.insertShapeBefore(new Polygon(), baseShape);
				break;
			}
			}

			// Add shape style
			borderShape.fillingColor('white').borderWidth(1).borderColor(fillingColor).visible(false);

			// draw shape
			var points = {
				x : this._seriesPoints[measureIndex][dimensionItemIndex].x,
				y : this._seriesPoints[measureIndex][dimensionItemIndex].y
			};
			switch (markerSymbol) {
			case Series.CIRCLEMARKER: {
				this._drawHighlightedCircleMark(borderShape, points, withBorderSize);
				break;
			}

			case Series.TRIANGLEMARKER: {
				this._drawHighlightedTriangleMark(borderShape, points, withBorderSize);
				break;
			}

			case Series.DIAMONDMARKER: {
				this._drawHighlightedDiamondMarkAndLine(borderShape, points, withBorderSize);
				break;
			}

			default: {
				this._drawHighlightedCircleMark(borderShape, points, withBorderSize);
				break;
			}
			}

			// Remove highlighted marker's shadow
			baseShape.shadow({
				offsetX : 0,
				offsetY : 0,
				blur : 0,
				color : 'rgba(0,0,0,0.5)'
			});

			return borderShape;
		},

		/*
		 * Draw Cross Label to selected item
		 */
		_drawCrossShape : function(measureIndex, dimensionItemIndex, borderSize, borderShape,
				fillingColor) {
			var points = {
				x : this._seriesPoints[measureIndex][dimensionItemIndex].x,
				y : this._seriesPoints[measureIndex][dimensionItemIndex].y
			};
			var crossLen = borderSize / 2 + 2;
			var crossShape = this.getLayer().insertShapeAfter(new Paths(), borderShape);
			crossShape.reset();
			crossShape.moveTo(points.x, points.y - crossLen);
			crossShape.lineTo(points.x, points.y + crossLen);
			crossShape.moveTo(points.x - crossLen, points.y);
			crossShape.lineTo(points.x + crossLen, points.y);
			crossShape.borderWidth(1).borderColor(fillingColor).visible(false);
			return crossShape;
		},

		_drawHighlightedCircleMark : function(shape, point, withBorderSize) {
			shape.center({
				x : point.x,
				y : point.y
			}).radius(withBorderSize / 2);
		},

		_drawHighlightedTriangleMark : function(shape, point, withBorderSize) {
			shape.reset();
			this._drawTriangleVertices(shape, point, withBorderSize);
			shape.close();
		},

		_drawHighlightedDiamondMarkAndLine : function(shape, point, withBorderSize) {
			shape.reset();
			this._drawDiamondVertices(shape, point, withBorderSize);
			shape.close();
		},

		_drawTriangleVertices : function(shape, point, size) {
			var radius = size / 2;
			shape.addVertices(point.x, point.y - radius);
			shape.addVertices(point.x + radius * Math.sqrt(3) / 2, point.y + radius / 2);
			shape.addVertices(point.x - radius * Math.sqrt(3) / 2, point.y + radius / 2);
		},

		_drawDiamondVertices : function(shape, point, size) {
			shape.addVertices(point.x, point.y - size / 2);
			shape.addVertices(point.x + size / 2, point.y);
			shape.addVertices(point.x, point.y + size / 2);
			shape.addVertices(point.x - size / 2, point.y);
		}
	});

	return lineRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.tooltip.TooltipRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Paths',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.TextLine',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Line',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Circle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Rectangle',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.shape.Polygon',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TextRuler, Paths, TextLine, Line, Circle, Rect, Polygon, TypeUtils) {
	var TooltipRenderer = function(options, layer) {
		this._layer = layer;

		this._display = {
			singleMeasure : {
				text : {
					font : 'bold 10px Arial',
					color : "#c2c2c2"
				},
				value : {
					font : 'bold 14px Arial',
					color : "#ffffff"
				},
				padding : {
					vertical : 9,
					horizontal : 10
				}
			},
			multipleMeasure : {
				text : {
					font : 'bold 10px Arial',
					color : "#c2c2c2"
				},
				value : {
					font : 'bold 12px Arial',
					color : "#ffffff"
				},
				padding : {
					vertical : 8,
					horizontal : 10,
					inline : 6,
					markerGap : 7,
					defaultSpace : 8
				}
			},
			valueFormat : [],
			textFormat : null,
			maxDimensionLabelWidth : 150,
			maxMeasureLabelWidth : 80
		};

		this._finalWidth = {
			dimension : undefined,
			measure : undefined,
			value : undefined
		};

		this._shapeLayout = {
			padding : 3,
			radius : 4,
			markerWidth : 12,
			markerHeight : 8,
			borderWidth : 2
		};

		this._shapes = {
			tooltip : null,
			dimensionLabel : null,
			separateLine : null,
			measureLabels : [],
			measureMarks : [],
			valueLabels : []
		};

		this._currentValue = {
			dimensionIndex : undefined,
			offset : undefined
		}

		this._parseOptions(options);
	};

	TooltipRenderer.prototype._parseOptions = function(options) {
		this._dataTree = options.dataTree;
		this._metaData = options.metaData;
		this._options = options.properties;

		this._borderColor = "#cdcdcd";
		this._fill = "rgba(0,0,0,0.8)";
		
		var tooltipOptions = this._options.tooltip;
		if (tooltipOptions.text.color != null) {
		    this._display.singleMeasure.text.color = tooltipOptions.text.color;
		    this._display.multipleMeasure.text.color = tooltipOptions.text.color;
		}
		if (tooltipOptions.text.font != null) {
            this._display.singleMeasure.text.font = tooltipOptions.text.font;
            this._display.multipleMeasure.text.font = tooltipOptions.text.font;
        }
        if (tooltipOptions.mainValue.color != null) {
            this._display.singleMeasure.value.color = tooltipOptions.mainValue.color;
            this._display.multipleMeasure.value.color = tooltipOptions.mainValue.color;
        }
        if (tooltipOptions.mainValue.font != null) {
            this._display.singleMeasure.value.font = tooltipOptions.mainValue.font;
            this._display.multipleMeasure.value.font = tooltipOptions.mainValue.font;
        }

        this._display.textFormat = tooltipOptions.text.formatString;
        var lastFormat = null;
        for (var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
            if (TypeUtils.isExist(tooltipOptions.mainValue.formatString[i])) {
                lastFormat = this._display.valueFormat[i] = tooltipOptions.mainValue.formatString[i];
            } else {
                this._display.valueFormat[i] = lastFormat;
            }
        }
        
        this._size = this.getShapeSize();
        this._markerPos = this._getMarkerPos();
	};

	TooltipRenderer.prototype.drawShape = function(offset) {
		if (offset === this._currentValue.offset) {
			return;
		} else {
			this._currentValue.offset = offset;
		}

		var xStart = this._shapeLayout.padding, yStart = this._shapeLayout.padding, radius = this._shapeLayout.radius, markerWidth = this._shapeLayout.markerWidth, markerHeight = this._shapeLayout.markerHeight;

		var width = this._size.width, height = this._size.height;
		if (this._markerPos == 'left') {
			xStart += markerHeight;
		}
		if (this._markerPos == 'top') {
			yStart += markerHeight;
		}

		if (this._shapes.tooltip === null) {
			this._shapes.tooltip = this._layer.addShape(new Paths());
		} else {
			this._shapes.tooltip = this._layer.replaceShape(this._shapes.tooltip, new Paths());
		}
		var tooltipShape = this._shapes.tooltip;

		// start point at the left top corner
		tooltipShape.moveTo(xStart, yStart + radius);
		if (this._markerPos == 'left') {
			tooltipShape.lineTo(xStart, yStart + height / 2 - offset - markerWidth / 2);
			tooltipShape.lineTo(xStart - markerHeight, yStart + height / 2 - offset);
			tooltipShape.lineTo(xStart, yStart + height / 2 - offset + markerWidth / 2);
		}
		tooltipShape.lineTo(xStart, yStart + height - radius);
		tooltipShape.arc({
			x : xStart + radius,
			y : yStart + height - radius
		}, radius, Math.PI, Math.PI / 2, false);

		// bottom border
		if (this._markerPos == 'bottom') {
			tooltipShape.lineTo(xStart + width / 2 + offset - markerWidth / 2, yStart + height);
			tooltipShape.lineTo(xStart + width / 2 + offset, yStart + height + markerHeight);
			tooltipShape.lineTo(xStart + width / 2 + offset + markerWidth / 2, yStart + height);
		}
		tooltipShape.lineTo(xStart + width - radius, yStart + height);
		tooltipShape.arc({
			x : xStart + width - radius,
			y : yStart + height - radius
		}, radius, Math.PI / 2, 0, false);

		// right border
		if (this._markerPos == 'right') {
			tooltipShape.lineTo(xStart + width, yStart + height / 2 - offset + markerWidth / 2);
			tooltipShape.lineTo(xStart + width + markerHeight, yStart + height / 2 - offset);
			tooltipShape.lineTo(xStart + width, yStart + height / 2 - offset - markerWidth / 2);
		}
		tooltipShape.lineTo(xStart + width, yStart + radius);
		tooltipShape.arc({
			x : xStart + width - radius,
			y : yStart + radius
		}, radius, 0, 3 * Math.PI / 2, false);

		// top border
		if (this._markerPos == 'top') {
			tooltipShape.lineTo(xStart + width / 2 + offset + markerWidth / 2, yStart);
			tooltipShape.lineTo(xStart + width / 2 + offset, yStart - markerHeight);
			tooltipShape.lineTo(xStart + width / 2 + offset - markerWidth / 2, yStart);
		}
		tooltipShape.lineTo(xStart + radius, yStart);
		tooltipShape.arc({
			x : xStart + radius,
			y : yStart + radius
		}, radius, 3 * Math.PI / 2, Math.PI, false);
		tooltipShape.fillingColor({
			t : 'css',
			v : 'rgba(0,0,0,0.8)'
		}).borderWidth(this._shapeLayout.borderWidth).borderColor(this._borderColor).shadow({
			offsetX : 1,
			offsetY : 1,
			blur : 5,
			color : 'rgba(0,0,0,0.75)'
		});
	};

	TooltipRenderer.prototype.drawContent = function(index) {
		if (index === this._currentValue.dimensionIndex) {
			return;
		} else {
			this._currentValue.dimensionIndex = index;
		}

		var dimensionLabels = this._dataTree.getSubMemberLabels();
		var measureLabels = this._metaData.measureMembers;
		var xStart = this._shapeLayout.padding;
		var yStart = this._shapeLayout.padding;
		if (this._markerPos === 'left') {
			xStart += this._shapeLayout.markerHeight;
		}
		if (this._markerPos === 'top') {
			yStart += this._shapeLayout.markerHeight;
		}

		var display;
		var textFormat = sap.common.globalization.NumericFormatManager.getFormat(this._display.textFormat);
		var _self = this;
		if (measureLabels.length == 1) {
			// single measure
			display = this._display.singleMeasure;

			if (this._shapes.dimensionLabel === null) {
				this._shapes.dimensionLabel = this._layer.addShape(new TextLine());
			} else {
				this._shapes.dimensionLabel = this._layer.replaceShape(this._shapes.dimensionLabel, new TextLine());
			}

			if (this._shapes.valueLabels.length === 0) {
				this._shapes.valueLabels[0] = this._layer.addShape(new TextLine());
			} else {
				this._shapes.valueLabels[0] = this._layer.replaceShape(this._shapes.valueLabels[0], new TextLine());
			}
            
            var text = TypeUtils.isExist(textFormat) ? textFormat.display(dimensionLabels[index]) : dimensionLabels[index];
			var dimensionWidth = TextRuler.measureText(display.text.font, text).width;
			this._shapes.dimensionLabel.text(text).font(display.text.font).textColor(
					display.text.color).width(
					this._finalWidth.dimension > dimensionWidth ? dimensionWidth : this._finalWidth.dimension).visible(
					true);
			var value = this._dataTree.getMeasuresAt([ index ])[measureLabels[0]].sum.result;
			var valueFormatter = sap.common.globalization.NumericFormatManager.getFormat(this._display.valueFormat[0]);
			value = TypeUtils.isExist(valueFormatter) ? valueFormatter.display(value) : value;
			var valueWidth = TextRuler.measureText(display.value.font, value).width;
			this._shapes.valueLabels[0].text(value).font(display.value.font).textColor(display.value.color).width(
					this._finalWidth.value > valueWidth ? valueWidth : this._finalWidth.value).visible(true);

			var dimensionLabelBottom;
			if (this._markerPos === 'left') {
				this._shapes.dimensionLabel.topLeft([ xStart + display.padding.horizontal,
						yStart + display.padding.vertical ]);
				dimensionLabelBottom = this._shapes.dimensionLabel.bottomLeft().y;
				this._shapes.valueLabels[0].topLeft([ xStart + display.padding.horizontal,
						dimensionLabelBottom + display.padding.vertical ]);
			} else if (this._markerPos === 'top' || this._markerPos === 'bottom') {
				var centerX = xStart + this._size.width / 2;
				this._shapes.dimensionLabel.topCenter([ centerX, yStart + display.padding.vertical ]);
				dimensionLabelBottom = this._shapes.dimensionLabel.bottomLeft().y;
				this._shapes.valueLabels[0].topCenter([ centerX, dimensionLabelBottom + display.padding.vertical ]);
			}

		} else {
			// multiple measure
			display = this._display.multipleMeasure;
			var centerX = xStart + this._size.width / 2;

			if (this._shapes.dimensionLabel != null) {
				this._layer.removeShape(this._shapes.dimensionLabel);
			}
			
            var text = TypeUtils.isExist(textFormat) ? textFormat.display(dimensionLabels[index]) : dimensionLabels[index];
			var dimensionWidth = TextRuler.measureText(display.text.font, text).width;
			this._shapes.dimensionLabel = this._layer.addShape(new TextLine()).text(text).font(
					display.text.font).textColor(display.text.color).width(
					this._finalWidth.dimension > dimensionWidth ? dimensionWidth : this._finalWidth.dimension).visible(
					true).topCenter([ centerX, yStart + display.padding.vertical ]);

			var yOffset = this._shapes.dimensionLabel.bottomLeft().y + display.padding.vertical;
			var xRight = xStart + this._size.width - display.padding.horizontal;
			var xLeft = xStart + display.padding.horizontal;

			this._shapes.separateLine = this._layer.addShape(new Line()).from({
				x : xLeft,
				y : yOffset
			}).to({
				x : xRight,
				y : yOffset
			}).width(1).color({
				t : 'lg',
				s : {
					x : xLeft,
					y : yOffset
				},
				e : {
					x : xRight,
					y : yOffset
				},
				st : [ {
					o : 0,
					v : "#202020"
				}, {
					o : 0.5,
					v : "#ffffff"
				}, {
					o : 1,
					v : "#202020"
				} ]
			}).visible(true);

			yOffset += display.padding.vertical;
			var measureOptions = this._options._additional;
			for ( var i = 0, len = measureLabels.length; i < len; i++) {

				if (this._shapes.valueLabels[i] != undefined) {
					this._layer.removeShape(this._shapes.valueLabels[i]);
				}
				var value = this._dataTree.getMeasuresAt([ index ])[measureLabels[i]].sum.result;
				var valueFormatter = sap.common.globalization.NumericFormatManager.getFormat(this._display.valueFormat[i]);
				value = TypeUtils.isExist(valueFormatter) ? valueFormatter.display(value) : value;
				var valueSize = TextRuler.measureText(display.value.font, value);
				this._shapes.valueLabels[i] = this._layer.addShape(new TextLine()).text(value).font(display.value.font)
						.textColor(display.value.color).width(valueSize.width).visible(true).rightCenter(
								[ xRight, yOffset + valueSize.height / 2 ]);

				var labelSize = TextRuler.measureText(display.text.font, measureLabels[i]);
				if (this._shapes.measureMarks[i] == undefined) {
					// add measure marks once, no need change
					this._shapes.measureMarks[i] = _drawMarkup(measureOptions.legendMarkers[i], {
						x : xLeft,
						y : yOffset + valueSize.height / 2 - labelSize.height / 2
					}, measureOptions.colorList[i], labelSize.height);
				}

				var measureTextX = xLeft + labelSize.height + display.padding.markerGap;
				var measureWidth = labelSize.width > this._finalWidth.measure ? this._finalWidth.measure
						: labelSize.width;
				if (this._shapes.measureLabels[i] == undefined) {
					// add measure labels once, no need change
					this._shapes.measureLabels[i] = this._layer.addShape(new TextLine()).text(measureLabels[i]).font(
							display.text.font).textColor(display.text.color).width(measureWidth).visible(true)
							.leftCenter([ measureTextX, yOffset + valueSize.height / 2 ]);
					;
				}

				yOffset += valueSize.height + display.padding.inline;

			}

		}

		function _drawMarkup(markerType, point, fillColor, size) {
			var markerShape = null;
			var markerSize = size;
			switch (markerType) {
			case "circle":
				markerShape = _self._layer.addShape(new Circle()).fillingColor(fillColor).center({
					x : point.x + markerSize / 2,
					y : point.y + markerSize / 2
				}).radius(markerSize / 2);
				break;
			case "diamond":
				markerShape = _self._layer.addShape(new Polygon());
				markerShape.fillingColor(fillColor);
				markerShape.addVertices(point.x + markerSize / 2, point.y);
				markerShape.addVertices(point.x, point.y + markerSize / 2);
				markerShape.addVertices(point.x + markerSize / 2, point.y + markerSize);
				markerShape.addVertices(point.x + markerSize, point.y + markerSize / 2);
				markerShape.close();
				break;
			case "triangle":
				markerShape = _self._layer.addShape(new Polygon());
				markerShape.fillingColor(fillColor);
				markerShape.addVertices(point.x + markerSize / 2, point.y);
				markerShape.addVertices(point.x, point.y + markerSize);
				markerShape.addVertices(point.x + markerSize, point.y + markerSize);
				markerShape.close();
				break;
			case "rect":
			default:
				markerShape = _self._layer.addShape(new Rect());
				markerShape.topLeft([ point.x, point.y ]).width(markerSize).height(markerSize).color(fillColor);
				break;
			}
			return markerShape;
		}
	};

	TooltipRenderer.prototype.getSize = function() {
		var width = this._size.width + this._shapeLayout.padding * 2;
		var height = this._size.height + this._shapeLayout.padding * 2;
		if (this._markerPos === 'bottom' || this._markerPos === 'top') {
			height += this._shapeLayout.markerHeight;
		} else if (this._markerPos === 'left' || this._markerPos === 'right') {
			width += this._shapeLayout.markerHeight;
		}
		return {
			width : width,
			height : height
		}
	};

	TooltipRenderer.prototype.getShapeSize = function() {
		var width = 0, height = 0;
		var dimensionLabels = this._dataTree.getSubMemberLabels();
		var measureLabels = this._metaData.measureMembers;

		var maxDimensionWidth = 0, maxDimensionHeight = 0, maxMeasureWidth = 0, maxMeasureHeight = 0, maxValueWidth = 0, maxValueHeight = 0;
		var display = measureLabels.length > 1 ? this._display.multipleMeasure : this._display.singleMeasure;
		var textFormat = sap.common.globalization.NumericFormatManager.getFormat(this._display.textFormat);

		var _self = this;
		var getMeasurePartWidth = function() {
			var max = maxMeasureWidth > _self._display.maxMeasureLabelWidth ? _self._display.maxMeasureLabelWidth
					: maxMeasureWidth;
			_self._finalWidth.measure = max;
			return maxMeasureHeight + display.padding.markerGap + display.padding.defaultSpace + max + maxValueWidth;
		};

		// get max size for all text and value
		for ( var i = 0, ilen = measureLabels.length; i < ilen; i++) {
			var labelSize = TextRuler.measureText(display.text.font, measureLabels[i]);
			maxMeasureWidth = labelSize.width > maxMeasureWidth ? labelSize.width : maxMeasureWidth;
			maxMeasureHeight = labelSize.height > maxMeasureHeight ? labelSize.height : maxMeasureHeight;

			for ( var j = 0, jlen = dimensionLabels.length; j < jlen; j++) {
				if (i == 0) {
                    var text = TypeUtils.isExist(textFormat) ? textFormat.display(dimensionLabels[j]) : dimensionLabels[j];
					var labelSize = TextRuler.measureText(display.text.font, text);
					maxDimensionWidth = labelSize.width > maxDimensionWidth ? labelSize.width : maxDimensionWidth;
					maxDimensionHeight = labelSize.height > maxDimensionHeight ? labelSize.height : maxDimensionHeight;
				}

				if(this._dataTree.getMeasuresAt([ j ])){
					var value = this._dataTree.getMeasuresAt([ j ])[measureLabels[i]].sum.result;
					var valueFormatter = sap.common.globalization.NumericFormatManager.getFormat(this._display.valueFormat[i]);
					value = TypeUtils.isExist(valueFormatter) ? valueFormatter.display(value) : value;
					var valueSize = TextRuler.measureText(display.value.font, value);
					maxValueWidth = valueSize.width > maxValueWidth ? valueSize.width : maxValueWidth;
					maxValueHeight = valueSize.height > maxValueHeight ? valueSize.height : maxValueHeight;
				}
			}
		}

		if (measureLabels.length == 1) {
			if (maxValueWidth < maxDimensionWidth && this._display.maxDimensionLabelWidth > maxDimensionWidth) {
				width = maxDimensionWidth + display.padding.horizontal * 2;
				this._finalWidth.dimension = maxDimensionWidth;
			} else {
				width = maxValueWidth + display.padding.horizontal * 2;
				this._finalWidth.dimension = maxValueWidth;
			}
			height = maxValueHeight + maxDimensionHeight + display.padding.vertical * 3;
			this._finalWidth.value = maxValueWidth;
		} else {
			var measurePartWidth = getMeasurePartWidth();
			var dimensionPartWidth = maxDimensionWidth > this._display.maxDimensionLabelWidth ? this._display.maxDimensionLabelWidth
					: maxDimensionWidth;
			width = (measurePartWidth > dimensionPartWidth ? measurePartWidth : dimensionPartWidth) + 2
					* display.padding.horizontal;
			height = maxDimensionHeight + display.padding.vertical * 4 + measureLabels.length * maxValueHeight
					+ (measureLabels.length - 1) * display.padding.inline;
			this._finalWidth.dimension = (measurePartWidth > dimensionPartWidth ? measurePartWidth : dimensionPartWidth);
			this._finalWidth.value = maxValueWidth;
		}

		return {
			width : width,
			height : height
		}
	};

	TooltipRenderer.prototype.reset = function(options) {
		if (this._shapes.tooltip != null) {
			this._layer.removeShape(this._shapes.tooltip);
		}
		if (this._shapes.dimensionLabel != null) {
			this._layer.removeShape(this._shapes.dimensionLabel);
		}
		if (this._shapes.separateLine != null) {
			this._layer.removeShape(this._shapes.separateLine);
		}
		for ( var i = 0, len = this._shapes.measureLabels.length; i < len; i++) {
			this._layer.removeShape(this._shapes.measureLabels[i]);
		}
		for ( var i = 0, len = this._shapes.measureMarks.length; i < len; i++) {
			this._layer.removeShape(this._shapes.measureMarks[i]);
		}
		for ( var i = 0, len = this._shapes.valueLabels.length; i < len; i++) {
			this._layer.removeShape(this._shapes.valueLabels[i]);
		}

		this._dataTree = options.dataTree;
		this._metaData = options.metaData;

		this._finalWidth = {
			dimension : undefined,
			measure : undefined,
			value : undefined
		};

		this._shapes = {
			tooltip : null,
			dimensionLabel : null,
			separateLine : null,
			measureLabels : [],
			measureMarks : [],
			valueLabels : []
		};

		this._currentValue = {
			dimensionIndex : undefined,
			offset : undefined
		}

		this._parseOptions(options);
	};

	TooltipRenderer.prototype._getMarkerPos = function() {
		switch (this._options.type) {
		case 'bar':
			return 'left';
		case 'combination':
			return 'bottom';
		default:
			return;
		}
	};
	
	TooltipRenderer.prototype.getMarkerHeight = function() {
	    // include border
        return this._shapeLayout.markerHeight + this._shapeLayout.borderWidth;
    };
	
	return TooltipRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.tooltip.TooltipComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.tooltip.TooltipRenderer',
  version : '1.0.0'
}
],
function Setup(ObjUtils, Canvas2DSurfaceComponent, PropsMgr, Layer, TextRuler, TooltipRenderer) {
	
	/**
	 * Represents a <code>Canvas2DSurfaceComponent</code> object been used to
	 * draw chart tooltip.
	 */
	var TooltipComponent = ObjUtils.derive(Canvas2DSurfaceComponent, {
		constructor : function(options) {
			this._options = options.tooltip;

			this._canvasSurface = this.getCanvasSurface();
			this._layer = this._canvasSurface.getRootLayer();

			this._initialize();
		},

		_initialize : function() {
			this._renderer = new TooltipRenderer(this._options, this._layer);
		},

		getSize : function() {
			return this._renderer.getSize();
		},

		doContentResize : function(oldSize, newSize) {
			this.callParent('doContentResize', oldSize, newSize);
		},

		draw : function(index, offset) {
			// make sure draw tooltip shape before content
			this._renderer.drawShape(offset);
			this._renderer.drawContent(index);
			this._layer.setNeedsDisplay();
		},

		reset : function(options) {
			this._renderer.reset(options);
		},
		
		getMarkerHeight : function() {
		    return this._renderer.getMarkerHeight();
		}

	});
	return TooltipComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.LinearAxisRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TextRuler',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.BasicAxisRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.FoucsCalculator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.PositionCalculator',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, Math, TextRuler, TypeUtils, BasicAxisRenderer,
		FoucsCalculator, PositionCalculator) {
	var linearAxisRenderer = ObjectUtils
			.derive(
					BasicAxisRenderer,
					{

						constructor : function(options) {
							this._laxr_initialize();
							return this;
						},

						/**
						 * Init the Linear Axis Renderer
						 */
						_laxr_initialize : function() {

							var opts = this._baxr_options;

							this._labels.itemsValue = [];

							var fCalculator = FoucsCalculator;

							var fcl = fCalculator.createFocus('full');

							var bounds = fCalculator.validateBounds(
									opts.minValue, opts.maxValue);

							this._minValue = bounds.min;
							this._maxValue = bounds.max;

							// The value precision
							this.VALUE_LABEL_PRECISION = 10000000;

							var focus = fcl.calculateFocus({
								lineScaling : this._lineScaling,
								minValue : this._minValue,
								maxValue : this._maxValue
							});

							this._minValue = parseFloat(focus.min.toFixed(8));
							this._maxValue = parseFloat(focus.max.toFixed(8));
							this._majorInterval = focus.major;
							this._minorInterval = parseFloat(focus.minor.toFixed(8));

							this._hideOverlappingLabels = true;

							this._valueAxisFT = sap.common.globalization.NumericFormatManager
									.getFormat(this._labels.formatString[0]);
							this._FTminValue = TypeUtils
									.isExist(this._valueAxisFT) ? this._valueAxisFT
									.display(this._minValue)
									: this._minValue;
							this._FTmaxValue = TypeUtils
									.isExist(this._valueAxisFT) ? this._valueAxisFT
									.display(this._maxValue)
									: this._maxValue;
						},

						/**
						 * 
						 * @param distance
						 *            the length of axis
						 * @returns if distance is undefined, return the
						 *          distance.
						 */
						distance : function(distance) {
							if (TypeUtils.isExist(distance)) {
								this._distance = distance;

								this._createLabelsAndPosition();

								if (!this._isLabelHorizontal()) {
									this._direction = 'vertical';
								}

								if (this._hideOverlappingLabels) {
									// Don't remove category labels, or labels
									// that can be rotated but haven't been
									this
											._removeOverlappingLabels(this._labels.itemsPosition.length);
								}

								var tu = TextRuler;

								if (this._position == 'hb'
										|| this._position == 'ht') {
									if (this._direction == 'horizontal') {
										this._axisMatrics.left = tu
												.measureWidth(
														this._labels.font,
														this._labels.itemsValue[0]
																.value()) / 2;
										this._axisMatrics.right = tu
												.measureWidth(
														this._labels.font,
														this._labels.itemsValue[this._labels.itemsValue.length - 1]
																.value()) / 2;
									} else {
										this._axisMatrics.left = this._axisMatrics.right = tu
												.measureHeight(
														this._labels.font,
														this._FTmaxValue) / 2;
									}

								} else {
									this._axisMatrics.bottom = this._axisMatrics.top = tu
											.measureHeight(this._labels.font,
													this._FTmaxValue) / 2;
								}

								return this;
							}
							return this._distance;
						},

						/**
						 * Draws the labels at given intervals
						 * 
						 * @param positionMultiplier
						 *            converts from a value based on the min and
						 *            max bounds to a position in pixels
						 */
						_createLabelsAndPosition : function() {
							if (!this._labels.show) {
								return;
							}

							var majorInterval = this._majorInterval;
							var minorInterval = this._minorInterval;

							var positionMultiplier = this
									._calculatePositionMultiplier(false);

							var positionDelta = 0.0;
							if (this._hideOverlappingLabels) {
								positionDelta = 0.5;
							}

							var numLabels = 0;
							var labelPositions = this._labels.itemsPosition = [];
							this._labels.itemsValue = [];
							var value = this._minValue;
							var position = this._calculatePositionFromValue(
									value, positionMultiplier);
							var i = 0;
							// Fix the bug:VISUAL-935 [Ian 2012-3-4] we should
							// keep the precision when float calculation in
							// javascript
							while ((Math.round(value
									* this.VALUE_LABEL_PRECISION) / this.VALUE_LABEL_PRECISION) < (Math
									.round(this._maxValue
											* this.VALUE_LABEL_PRECISION) / this.VALUE_LABEL_PRECISION)) {
								var label = new this.Label();
								var FTvalue = TypeUtils
										.isExist(this._valueAxisFT) ? this._valueAxisFT
										.display(value)
										: value;
								label.visible(true);
								label.value(FTvalue);
								// Keep the position as a percentage of distance
								// because our multiplier isn't correct yet
								labelPositions.push((position) || 0);
								this._labels.itemsValue.push(label);
								var nextInt = this._calculateNextValidInterval(
										position, positionMultiplier, value,
										majorInterval, positionDelta);
								position = nextInt.position;
								if (value >= nextInt.value)
									break; // make sure we don't get an infinte
								// loop
								value = nextInt.value;
								i++;
							}

							// Always draw the max value
							position = this._calculatePositionFromValue(
									this._maxValue, positionMultiplier);
							label = new this.Label();
							label.visible(true);
							label
									.value(TypeUtils.isExist(this._valueAxisFT) ? this._valueAxisFT
											.display(value)
											: value);
							labelPositions.push((position) || 0); // Keep the
							// position
							// as a
							// percentage
							this._labels.itemsValue.push(label);
						},

						/**
						 * Calculates the next position in an interval that
						 * differs visually from the previous position. Large
						 * ranges with small intervals can cause many values to
						 * occupy the same pixel position. We want to avoid
						 * iterating through large numbers of undrawable
						 * positions.
						 * 
						 * @param lastPos
						 *            the last position that was drawn
						 * @param posMultiplier
						 *            the multiplier to pass to a
						 *            PositionCalculator
						 * @param lastValue
						 *            the last value that was drawn
						 * @param interval
						 *            the interval by which values are
						 *            incremented
						 * @param posDelta
						 *            the minimum amount by which the position
						 *            must change
						 * 
						 * @return the next position in the interval that should
						 *         be drawn and the value it represents.
						 */
						_calculateNextValidInterval : function(lastPos,
								posMultiplier, lastValue, interval, posDelta) {
							if (!TypeUtils.isExist(posDelta)) {
								posDelta = 0.5;
							}

							// Fix the isssue: As the float precision issue, we
							// should control the precision of the value
							var nextValue = this._add(lastValue, interval);
							var position = this._calculatePositionFromValue(
									nextValue, posMultiplier);

							if (Math.abs(position - lastPos) < posDelta) {
								var minNextValue;

								minNextValue = this
										._calculateValueFromPosition(position
												+ posDelta, posMultiplier);

								var numIntervals = Math
										.ceil((minNextValue - nextValue)
												/ interval);
								nextValue += numIntervals * interval;
								position = this._calculatePositionFromValue(
										nextValue, posMultiplier);
							}

							return {
								position : position,
								value : nextValue
							};
						},

						/**
						 * Returns sum of arg1 and arg2.
						 * 
						 * As in javascript, we may get a result
						 * 0.600000000000001 from 0.4 and 0.2. So we should
						 * control the float precision
						 */
						_add : function(arg1, arg2) {
							var r1, r2, m;
							try {
								r1 = arg1.toString().split(".")[1].length;
							} catch (e) {
								r1 = 0;
							}
							try {
								r2 = arg2.toString().split(".")[1].length;
							} catch (e) {
								r2 = 0;
							}
							m = Math.pow(10, Math.max(r1, r2));
							return (arg1 * m + arg2 * m) / m;
						},

						/**
						 * Returns the position of a particular value.
						 * 
						 * @param value
						 *            the value from which to determine the line
						 *            position
						 * @param positionMultiplier
						 *            the multiplier to pass to a
						 *            PositionCalculator
						 * @return the position calculated
						 */
						_calculatePositionFromValue : function(value,
								positionMultiplier) {
							var position = 0;

							if (this._lineScaling == "linear")
								position = PositionCalculator
										.calculateLinearPosition(value,
												positionMultiplier,
												this._minValue);
							else
								position = PositionCalculator
										.calculateLogarithmicPosition(value,
												positionMultiplier,
												this._minValue);

							return position;
						},

						/**
						 * Returns the value of a particular position.
						 * 
						 * @param position
						 *            the line position from which to determine
						 *            the value
						 * @param positionMultiplier
						 *            the multiplier to pass to a
						 *            PositionCalculator
						 * @return the value calculated
						 */
						_calculateValueFromPosition : function(position,
								positionMultiplier) {

							var value = 0;
							if (this._lineScaling == "linear")
								value = PositionCalculator
										.calculateLinearValue(position,
												positionMultiplier,
												this._minValue);
							else
								value = PositionCalculator
										.calculateLogarithmicValue(position,
												positionMultiplier,
												this._minValue);

							return value;
						},

						/**
						 * 
						 * Returns the longest width among all the labels. In
						 * value axis, the longest width is either the min
						 * value's width or the max value's width
						 */
						_getLongestWidth : function() {
							if (!TypeUtils.isExist(this._longestWidth)
									|| this._longestWidth == 0) {
								var tu = TextRuler;

								if (this._FTminValue.toString().length > this._FTmaxValue
										.toString().length) {
									this._longestWidth = tu
											.measureWidth(this._labels.font,
													this._FTminValue);
								} else {
									this._longestWidth = tu
											.measureWidth(this._labels.font,
													this._FTmaxValue);
								}
							}
							return this._longestWidth;
						},

						/**
						 * Loops through the labels and removes some so that
						 * there is no overlap. Leaves a small amount of spacing
						 * between labels. Never removes the first or last
						 * label.
						 */
						_removeOverlappingLabels : function(numUsed) {
							var tu = TextRuler;

							if (numUsed < 3)
								return;

							/*
							 * _________ or a e i abcd| b f j efgh| c g k ijkl|
							 * d h m mnop|
							 */
							/*
							 * if the graphic is the similar with the below
							 * picture, we should calculate the total width or
							 * height is whether can fulfill all the labels
							 */

							var res = (this._position == 'hb' || this._position == 'ht')
									&& this._direction == 'vertical';
							res = res
									| (this._position == 'vl' || this._position == 'vr');

							if (res && this._lineScaling == 'linear') {

								var labelHeight = tu
										.measureHeight(this._labels.font);
								var labelTotalSpace = this._distance;
								var maxLabelsCount = Math.floor(labelTotalSpace
										/ labelHeight);

								this._hideOverlappingLabelsByBestInterval(
										numUsed, maxLabelsCount);
								this._removeLastTwoOverlappedLabel(numUsed);

							} else {
								/*
								 * if the lineScaling is Logarithmic
								 */
								var lastVisbleID = numUsed - 1;
								for ( var i = numUsed - 2; i >= 1; i--) {

									var currentLabel = this._labels.itemsValue[i];

									if (0 == currentLabel.value()) {
										continue;
									}

									// if the label overlaps with the last label
									// that stayed visible
									// or the label overlaps with the origin
									// label

									// to be implemented:

									/*
									 * var lastVisibleID:int = numUsed - 1;
									 * for(var i:int = numUsed - 2; i >= 1; i--) {
									 * var currentLabel:UITextField =
									 * this._labels[i];
									 * 
									 * //always show zero! if(currentLabel.text ==
									 * "0") { continue; }
									 * 
									 * //if the label overlaps with the last
									 * label that stayed visible //or the label
									 * overlaps with the origin label
									 * if(this.invertScale) {
									 * if(this._labels[lastVisibleID].textHeight >
									 * (currentLabel.y -
									 * this._labels[lastVisibleID].y) ||
									 * this._labels[0].y - currentLabel.y <
									 * currentLabel.textHeight) {
									 * currentLabel.visible = false; } else
									 * lastVisibleID = i; } else {
									 * if(currentLabel.textHeight >
									 * (this._labels[lastVisibleID].y -
									 * currentLabel.y) || currentLabel.y -
									 * this._labels[0].y <
									 * this._labels[0].textHeight) {
									 * currentLabel.visible = false; } else
									 * lastVisibleID = i; } }
									 */
								}

							}
						},

						/**
						 * When the user set Manual Scale & Size of Division in
						 * property sheet, some times the overlap happens on the
						 * last two labels. For example: minimun=0, maximum=10,
						 * Size of Division=9.8. The following code is to avoid
						 * the overlap.
						 */
						_removeLastTwoOverlappedLabel : function(numUsed) {
							// to be implements, now focus is the stardand, if
							// the focus is the ManualFocus, please based on the
							// following code to
							// implement our feature;
							/*
							 * if(this.focus is ManualFocus) { var
							 * lastLabel1:FormattedUITextField =
							 * this._labels[numUsed-1]; var
							 * lastLabel2:FormattedUITextField; for(var i:int =
							 * numUsed-2;i>0;i--) { if(this._labels[i].visible) {
							 * lastLabel2 = this._labels[i]; break; } }
							 * 
							 * if(lastLabel2 == null) return;
							 * 
							 * if(this.orientation == "horizontal") {
							 * if(lastLabel1.textHeight>Math.abs(lastLabel2.y -
							 * lastLabel1.y)) lastLabel2.visible = false; } else {
							 * if(lastLabel1.textHeight>Math.abs(lastLabel1.x -
							 * lastLabel2.x)) lastLabel2.visible = false; } }
							 */
						},

						/**
						 * Hide some labels to avoid overlapping.
						 * 
						 * For example:The original labels:
						 * [0,1,2,3,4,5,6,7,8,9], numUsed = 10, maxLabels = 5.
						 * 
						 * The result is: interval = 2, displayed
						 * labels:[0,3,6,9].
						 */
						_hideOverlappingLabelsByBestInterval : function(
								numUsed, maxLabelsCount) {

							if (maxLabelsCount >= numUsed) {
								return;
							}

							// Calculate the best interval to display these
							// labels
							var interval = 0;
							for (; interval <= numUsed - 2; interval++) {
								if ((0 == (numUsed - 1) % (interval + 1))
										&& ((numUsed - 1) / (interval + 1) <= maxLabelsCount)) {
									break;
								}
							}

							for ( var i = numUsed - 2; i >= 1; i--) {
								var currentLabel = this._labels.itemsValue[i];
								if (i % (interval + 1) != 0) {
									currentLabel.visible(false);
								}
							}
						}

					});

	return linearAxisRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.tooltip.BaseTooltip',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.tooltip.TooltipComponent',
  version : '1.0.0'
}
],
function Setup(TypeUtils, TooltipComponent) {
    /**
     * Default options for drawing chart titles. See usage example below:
     * 
     * <pre>
     * {
     *  main : {
     *      text : 'This is the main title',
     *      font : 'bold 16px Arial',
     *      color : '#000000',
     *      horizontalAlign : 'center',
     *      show : false
     *  },
     *  sub : {
     *      text : 'This is the sub title',
     *      font : 'normal 14px Arial',
     *      color : '#000000',
     *      horizontalAlign : 'center',
     *      show : false
     *  }
     * }
     * </pre>
     * 
     * Note that the font size here represents a preferred size, it will be
     * automatically adjusted if the container can't contain such big font.
     */
    var defaultOptions = {
        enable : false,
        customization : null,
        mainValue : {
            color : undefined,
            font : undefined,
            formatString : ['']
        },
        // only for Pie Chart
        subValue : {
            color : undefined,
            font : undefined,
            formatString : ['']
        },
        text : {
            color : undefined,
            font : undefined,
            formatString : ''
        }
    };
    
	var BaseTooltip = function(options) {
		this._init(options);
	};

	var baseTooltipPro = BaseTooltip.prototype;

	baseTooltipPro._init = function(options) {
		this._parent = options.parent;
		this._options = options;
		this._component = new TooltipComponent({
			enable : true,
			hidden : true,
			anchor : {
				x : 0,
				y : 0
			},
			position : {
				x : 0,
				y : 0
			},
			size : {
				w : 0,
				h : 0
			},
			tooltip : {
				metaData : options.metaData,
				dataTree : options.dataTree,
				properties : options.properties
			},
			id : 'tooltipComponent'
		});

		this._parent.addSubComponent(this._component);

		this._size = this._getSize();

		this._component.size(this._size);
	};

	baseTooltipPro.getZone = function() {
		return {
			top : 0,
			left : 0,
			bottom : this._parent.size().height,
			right : this._parent.size().width
		};
	};

	baseTooltipPro.getPlotArea = function() {
		return this._parent._chartComponent.getPlotArea();
	};

	/**
	 * Show tooltip with giving event information
	 */
	baseTooltipPro.show = function(evt) {
		if (!this._options.properties.tooltip.enable) {
	        return;
	    }

		var isShow = false;
		var dimensionIndex = evt.data[0].dimensionItemIndex;
		var measureLabels = this._options.metaData.measureMembers;
		for ( var i = 0, len = measureLabels.length; i < len; i++) {
			var value = this._options.dataTree.getMeasuresAt([ dimensionIndex ]);
			if(TypeUtils.isDefined(value) && TypeUtils.isDefined(value[measureLabels[i]].sum.result) && value[measureLabels[i]].sum.result != 'NaN'){
				isShow = true;
				break;
			}
		}
		var dimensionLabels = this._options.dataTree.getSubMemberLabels();
		if(TypeUtils.isUndefined(dimensionLabels[dimensionIndex])){
			isShow = false;
		}
		if(!isShow) {
			this.hide();
			return; 
		}
	    
		var zone = this.getZone();
		var area = this.getPlotArea();
		var markerHeight = this._component.getMarkerHeight();
		var size = this._size;
		var point = evt.data[0].point;
		var x, y, offset = 0;
		switch (this._options.properties.type) {
		case 'bar':
			x = zone.right > (area.right + size.width - markerHeight) ? area.right - markerHeight : (zone.right - size.width);
			if (zone.top > point.y - size.height / 2) {
				y = zone.top;
				offset = zone.top - (point.y - size.height / 2);
			} else if (zone.bottom < point.y + size.height / 2) {
				y = zone.bottom - size.height;
				offset = zone.bottom - (point.y + size.height / 2);
			} else {
				y = point.y - size.height / 2;
			}
			break;
		case 'combination':
			y = zone.top < (area.top - size.height + markerHeight) ? (area.top - size.height + markerHeight) : zone.top;
			if (zone.left > point.x - size.width / 2) {
				x = zone.left;
				offset = point.x - size.width / 2 - zone.left
			} else if (zone.right < point.x + size.width / 2) {
				x = zone.right - size.width;
				offset = point.x + size.width / 2 - zone.right;
			} else {
				x = point.x - size.width / 2;
			}
			break;
		default:
			break;
		}
		this._component.position({
			x : x,
			y : y
		});
		this._draw(evt.data[0].dimensionItemIndex, offset);
		this._component.markShow();
	};

	/**
	 * Hide tooltip
	 */
	baseTooltipPro.hide = function(evt) {
	    if (!this._options.properties.tooltip.enable) {
            return;
        }
		this._component.markHide();
	};

	/**
	 * Reset exist tooltip status
	 */
	baseTooltipPro.reset = function(options) {
		this._options = options;
		this._component.reset(options);
		this._size = this._getSize();

		this._component.size(this._size);
	};

	baseTooltipPro._getSize = function() {
		return this._component.getSize();
	};

	baseTooltipPro._draw = function(dimensionIndex, offset) {
		return this._component.draw(dimensionIndex, offset);
	};
	
	baseTooltipPro.getCustomization = function() {
	    return this._options.properties.tooltip.customization;
	}
	
	BaseTooltip.getDefaultOption = function() {
	    return defaultOptions;
	};
	return BaseTooltip;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.DataTree',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
}
],
function Setup(ObjUtils) {
	/**
	 * Tree structured data for storing hierarchical aggregated data which
	 * typically comes from OLAP query, you should never create the instance
	 * manually, parsing from json or querying a cube from DataTable instead.
	 * 
	 * @name sap.riv.vizkit.DataTree
	 * @constructor
	 */
	var DataTree = function(groupRoot, stats) {
		this._gr = groupRoot;
		this._stats = stats;
	};
	/**
	 * Instantiate a data tree from its JSON representation. Below is a
	 * recursive definition of a DATANODE of a data tree structure.
	 * 
	 * <pre>
	 * {
	 * 	  &quot;member&quot; : &quot;MEMBER_NAME&quot;,
	 * 	  &quot;measureValues&quot; : {
	 * 	     &quot;MEASURE_Name&quot; : {
	 * 									   &quot;AGGREGATE_TYPE&quot; : {
	 * 																	    &quot;result&quot; : &quot;&quot;,
	 * 																		&quot;tags&quot; : {}
	 * 									  								},
	 * 									   &quot;AGGREGATE_TYPE&quot; : {
	 * 															  			&quot;result&quot; : &quot;&quot;,
	 * 														      			&quot;tags&quot; : {}
	 * 														   			},
	 *                                        ....
	 *                                    },
	 *                     					 ...
	 * 				      				}
	 *    &quot;subNodes&quot; : [
	 *    				DATANODE,
	 *    				...
	 *    			   ]
	 * }
	 * </pre>
	 * 
	 * @function
	 * @name sap.riv.vizkit.DataTree#dataTreeFromJSON
	 * @param json
	 *            the JSON string representation of a
	 *            {@link sap.riv.vizkit.DataTree}.
	 * @returns {sap.riv.vizkit.DataTree}
	 */
	DataTree.dataTreeFromJSON = function(json) {
		var data = JSON.parse(json);
		var stats = [];
		var rootNode = {
			member : 'root',
			subNodes : {},
			subMembers : [],
			subMemberLabels : [],
			leafMemberCount : 0,
			result : {}
		};
		var pStack = [ {
			rNode : rootNode,
			cNode : data,
			traversed : false,
			cIdx : 0
		} ];
		while (pStack.length) {
			var cStackFrame = pStack[pStack.length - 1];
			var cNode = cStackFrame.cNode;
			var rNode = cStackFrame.rNode;
			if (!cStackFrame.traversed) {
				rNode.member = cNode.member;
				for ( var measureName in cNode.measureValues) {
					rNode.result[measureName] = ObjUtils.extend({}, cNode.measureValues[measureName]);
				}
				cStackFrame.traversed = true;
				// update the statistics
				stats[pStack.length - 1] = stats[pStack.length - 1] || {
					longest : cNode.member,
					shortest : cNode.member,
					allMembers : []
				};
				stats[pStack.length - 1].allMembers.push(cNode.member);
				if (stats[pStack.length - 1].longest.length < cNode.member.length) {
					stats[pStack.length - 1].longest = cNode.member;
				}
				if (stats[pStack.length - 1].shortest.length > cNode.member.length) {
					stats[pStack.length - 1].shortest = cNode.member;
				}
			}
			if (cNode.subNodes.length > cStackFrame.cIdx) {
				// down the tree
				rNode.subMembers.push(cNode.subNodes[cStackFrame.cIdx].member);
				rNode.subMemberLabels.push(cNode.subNodes[cStackFrame.cIdx].label);
				var rSubNode = {
					member : '',
					subNodes : {},
					subMembers : [],
					subMemberLabels : [],
					leafMemberCount : 0,
					result : {}
				};
				rNode.subNodes[cNode.subNodes[cStackFrame.cIdx].member] = rSubNode;
				pStack.push({
					rNode : rSubNode,
					cNode : cNode.subNodes[cStackFrame.cIdx],
					traversed : false,
					cIdx : 0
				});
				cStackFrame.cIdx++;
			} else {
				if (cNode.subNodes.length == 0) {
					pStack.pop();
					if (pStack.length) {
						pStack[pStack.length - 1].rNode.leafMemberCount++;
					}
				} else {
					pStack.pop();
					if (pStack.length) {
						pStack[pStack.length - 1].rNode.leafMemberCount += rNode.leafMemberCount;
					}
				}
			}
		}
		stats.shift();// remove the unnecessary root node
		return new DataTree(rootNode, stats);
	};

	var dtp = DataTree.prototype;

	/**
	 * Encode a data tree instance into a JSON representation. It can be used to
	 * recreate the instance later on.
	 * 
	 * @function
	 * @name sap.riv.vizkit.DataTree#dataTreeToJSON
	 * @param dataTree
	 * @returns {String} JSON string
	 */
	dtp.dataTreeToJSON = function() {
		var output = {
			member : '',
			measureValues : {},
			subNodes : []
		};
		var pStack = [ {
			rNode : output,
			cNode : this._gr,
			traversed : false,
			cIdx : 0
		} ];
		while (pStack.length) {
			var cStackFrame = pStack[pStack.length - 1];
			var cNode = cStackFrame.cNode;
			var rNode = cStackFrame.rNode;
			if (!cStackFrame.traversed) {
				rNode.member = cNode.member;
				for ( var measureName in cNode.result) {
					rNode.measureValues[measureName] = ObjUtils.extend({}, cNode.result[measureName]);
				}
				cStackFrame.traversed = true;
			}
			if (cNode.subMembers.length > cStackFrame.cIdx) {
				// down the tree
				var rSubNode = {
					member : '',
					measureValues : {},
					subNodes : []
				};
				rNode.subNodes.push(rSubNode);
				pStack.push({
					rNode : rSubNode,
					cNode : cNode.subNodes[cNode.subMembers[cStackFrame.cIdx]],
					traversed : false,
					cIdx : 0
				});
				cStackFrame.cIdx++;
			} else {
				pStack.pop();
			}
		}
		return JSON.stringify(output);
	};

	/**
	 * Get the tree depth
	 * 
	 * @name sap.riv.vizkit.DataTree#getGroupDepth
	 * @function
	 * @returns {Integer} the depth of the aggregated data
	 */
	dtp.getGroupDepth = function() {
		return this._stats.length;
	};

	/**
	 * Get the given statistics of the given level. Typically contains an array
	 * of all members in the current level(Dimension), the longest and shortest
	 * member.
	 * 
	 * @name sap.riv.vizkit.DataTree#getLevelStatistics
	 * @function
	 * @param groupLevel
	 * 
	 * @returns {Object}
	 */
	dtp.getLevelStatistics = function(groupLevel) {
		return this._stats[groupLevel];
	};

	/**
	 * 
	 * Get the members of a node by given member path. The memberPath should be
	 * an array of member from root level to its parent level.
	 * 
	 * @name sap.riv.vizkit.DataTree#getSubMembersAt
	 * @function
	 * @param {Array}
	 *            [memberPath] if not specify a path, the top level member will
	 *            be returned.
	 * 
	 * @returns {Array} array of members under the given member path
	 */
	dtp.getSubMembersAt = function(memberPath) {
		var subNode = this._gr;
		if (memberPath !== undefined) {
			for ( var i = 0, len = memberPath.length; i < len; i++) {
				subNode = subNode.subNodes[memberPath[i]];
				if (!subNode) {
					return undefined;
				}
			}
		}
		return subNode.subMembers;
	};

	/**
	 * Gets the member labels. Works exactly the same way as the
	 * getSubMembersAt() function does. Suggestion is the path parameter should
	 * only contain indexes which are integers. It's probably a workaround
	 * solution and might be replaced later.
	 * 
	 * @name sap.riv.vizkit.DataTree#getSubMemberLabels
	 * @function
	 * @param {Array}
	 *            [path] The path depicting the where the members locate.
	 * @returns {Array} Array of labels of target members\
	 * @author I069394
	 */
	dtp.getSubMemberLabels = function(path) {
		var node = this._gr;
		if (path !== undefined) {
			for ( var i = 0, len = path.length; i < len; i++) {
				node = node.subNodes[path[i]];
				if (!node) {
					return undefined;
				}
			}
		}
		return node.subMemberLabels;
	};

	/**
	 * Get the measures of a node by given member path. The memberPath should be
	 * an array of member from root level to its parent level.
	 * 
	 * @name sap.riv.vizkit.DataTree#getMeasuresAt
	 * @function
	 * @param {Array}
	 *            [memberPath] if not specify a path, the top level member will
	 *            be returned.
	 * 
	 * @returns {Object} plain object contains all measures of the node
	 */
	dtp.getMeasuresAt = function(memberPath) {
		var subNode = this._gr;
		if (memberPath !== undefined) {
			for ( var i = 0, len = memberPath.length; i < len; i++) {
				subNode = subNode.subNodes[memberPath[i]];
				if (!subNode) {
					return undefined;
				}
			}
		}
		return subNode.result;
	};
	/**
	 * Get the count of the leaf node of a node by given member path. The
	 * memberPath should be an array of member from root level to its parent
	 * level.
	 * 
	 * @name sap.riv.vizkit.DataTree#getLeafMemberCount
	 * @function
	 * @param {Array}
	 *            [memberPath] if not specify a path, the top level member will
	 *            be returned.
	 * 
	 * @returns {Number}
	 */
	dtp.getLeafMemberCount = function(memberPath) {
		var subNode = this._gr;
		if (memberPath !== undefined) {
			for ( var i = 0, len = memberPath.length; i < len; i++) {
				subNode = subNode.subNodes[memberPath[i]];
			}
		}
		return subNode.leafMemberCount;
	};

	dtp.getContriRows = function(memberPath) {
		var subNode = this._gr;
		if (memberPath !== undefined) {
			for ( var i = 0, len = memberPath.length; i < len; i++) {
				subNode = subNode.subNodes[memberPath[i]];
			}
		}
		return subNode.contriRows ? subNode.contriRows.concat() : undefined;
	};
	/**
	 * Set a tag to a measure of a node, the tag can carry some semantic meaning
	 * of the measure, like whether it's a singular.
	 * 
	 * @name sap.riv.vizkit.DataTree#setMeasureTagsAt
	 * @function
	 * @param {Array}
	 *            [memberPath] if not specify a path, the top level member will
	 *            be returned.
	 * 
	 * @returns {Number}
	 */
	dtp.setMeasureTagsAt = function(memberPath, measure, aggrType, tags) {
		var subNode = this._gr;
		if (memberPath !== undefined) {
			for ( var i = 0, len = memberPath.length; i < len; i++) {
				subNode = subNode.subNodes[memberPath[i]];
			}
		}
		for ( var colId in subNode.result) {
			if (colId === measure) {
				if (subNode.result[colId].hasOwnProperty(aggrType)) {
					subNode.result[colId][aggrType].tags = tags;
				}
			}
		}
	};
	return DataTree;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.ColumnBarRenderer',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ColorUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.BarRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
}
],
function Setup(TypeUtils, ColorUtils, BarRenderer, Math, ObjectUtils, Animator) {

	var columnBarRenderer = ObjectUtils.derive(BarRenderer, {
		constructor : function(layer, options) {},

		/**
		 * only draw the first series group of series groups in
		 * bar renderer
		 */
		draw : function() {
			this._resetShapes();
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length === 0) return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length === 0) return;
			
			this._seriesColor = [];
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				this._seriesColor.push(seriesList[i]._seriesColor);
				this._seriesShapes[i] = this._initSeries(seriesList[i]._data.length);
			}
			this._update();

			// register event
			this._regEvent();
		},

		_update : function() {
			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0) return;

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length == 0) return;

			var xAxis = seriesList[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var tickInterval = xAxis.getTickInterval();

			var markSize = seriesList[0]._barMarkerSize;
			markSize = this._calculateMarkSzie(seriesList.length, tickInterval, markSize);

			// draw seriesList
			this._seriesPoints = [];
			for ( var i = 0, len = seriesList.length; i < len; i++) {
				this._seriesPoints.push(this._calculateSeriesPoints(i, len, seriesList[i],
						xAxisMajorTicks, markSize));
				this._drawSeries(this._seriesShapes[i], this._seriesPoints[i], seriesList[i]);
			}

			this._doAnimation();
		},

		/**
		 * 
		 * @param points
		 *            series points
		 * @param series
		 *            sap.riv.viz.shared.series.Series
		 * 
		 * @return shape Array
		 */
		_drawSeries : function(seriesShape, points, series, drawnPArray) {
			// [Ian TODO]change to a function instead of private variable
			var data = series.getData();
			var color = series._seriesColor;

			for ( var i = points.length; i--;) {
				if (TypeUtils.isExist(drawnPArray)) {
					if (drawnPArray[i] === 1) {
						var point = points[i];
						seriesShape[i].dimensionItemIndex = data[i].dimensionItemIndex;
						seriesShape[i].measureIndex = data[i].measureIndex;
						//Fix the bug [2012-04-18] VISUAL-1412, if the series is not visible, we should make the chart rect, outerBorder and innerBorder invisible 
						if ( !series.isVisible() ) {
							seriesShape[i].rect.visible(false);
							seriesShape[i].outerBorder.visible(false);
							seriesShape[i].innerBorder.visible(false);
						}
						//End
						this._drawBarShape(seriesShape[i], point, color);
					}
				} else {
					var point = points[i];
					seriesShape[i].dimensionItemIndex = data[i].dimensionItemIndex;
					seriesShape[i].measureIndex = data[i].measureIndex;
					//Fix the bug [2012-04-18] VISUAL-1412, if the series is not visible, we should make the chart rect, outerBorder and innerBorder invisible 
					if ( !series.isVisible() ) {
						seriesShape[i].rect.visible(false);
						seriesShape[i].outerBorder.visible(false);
						seriesShape[i].innerBorder.visible(false);
					}
					//End
					this._drawBarShape(seriesShape[i], point, color);
				}
			}
		},

		/**
		 * @param viewPort
		 *            if viewPort exist, it means that the
		 *            animation is not in pinch interaction. so
		 *            we should renderer the column bar in
		 *            vertical direction if not, now we do not
		 *            support animation.
		 */
		_doAnimation : function(viewPort) {
			var animator = Animator;
			var self = this;

			if (!viewPort) {
				animator.animate({
					values : [ {
						type : 'FLOAT',
						from : 0.0,
						to : 1
					} ],
					duration : 800,
					onStep : function(values) {
						var seriesPoints = self._seriesPoints;
						var seriesShapes = self._seriesShapes;
						for ( var i = 0, len = seriesShapes.length; i < len; i++) {
							for ( var j = 0; j < seriesShapes[i].length; j++) {
								var point = seriesPoints[i][j];
								self._updateBarShapeDuringAnimation(seriesShapes[i][j], point, self._seriesColor[i], values[0]);
							}
						}
						//Highlight selected shape
						if(self._highlights && self._highlights.length > 0){
							self.highlight();
						}
						self.refresh();
					},
					onComplete : function(){
						var seriesPoints = self._seriesPoints;
						var seriesShapes = self._seriesShapes;
						for ( var i = 0, len = seriesShapes.length; i < len; i++) {
							for ( var j = 0; j < seriesShapes[i].length; j++) {
								if (seriesShapes[i][j]) {
									var point = seriesPoints[i][j];
									self._updateBarShape(seriesShapes[i][j], point, self._seriesColor[i], 1);
								}

							}
						}
						//Highlight selected shape
						if(self._highlights && self._highlights.length > 0){
							self.highlight();
						}
						self.refresh();
					}
				});
			} else {
				var seriesPoints = self._seriesPoints;
				var seriesShapes = self._seriesShapes;
				for ( var i = 0, len = seriesShapes.length; i < len; i++) {
					for ( var j = 0; j < seriesShapes[i].length; j++) {
						if (seriesShapes[i][j]) {
							var point = seriesPoints[i][j];
							self._updateBarShape(seriesShapes[i][j], point, self._seriesColor[i], 1);
						}

					}
				}
				
				//Ian 2012-4-18 In order to keep the highlights, do highlight after update all the shapes
				// [Ian 2012-3-28] To check whether
				// the shape is in highlight status,
				// now we do not do other operation,
				// we only change the color of
				// highlighted shape.
				//Christy 2012-4-18 ColumnBarRender's highlight function is differect from barRender. Highlight all shape at one time.
				if(self._highlights && self._highlights.length > 0){
					self.highlight();
				}
				
				self.refresh();
			}
		},

		/**
		 * 
		 * @param sIndex
		 *            series index
		 * @param series
		 *            count
		 * @param series
		 *            sap.riv.viz.shared.series.Series
		 * @param xAxisMajorTicks
		 *            major ticks of xAxis
		 * @Param markSize
		 *            series bar size
		 * 
		 * @return bar point positions Array[{x1,y1, x2,
		 *         y2}....]
		 * 
		 * calculation: points[i] x1 = ( - (sCount/2 ) + sIndex) *
		 * markSize + xAxisMajorTicks[i] y1 =
		 * series.getYAxis().u2p(data[i]) x2 = x1 + markSize
		 * if(this._fillToZero){ point.y2 = zeroTick; }else{
		 * point.y2 = baseTick; }
		 */
		_calculateSeriesPoints : function(sIndex, sCount, series, xAxisMajorTicks, markSize) {
			var data = series.getData();
			var yAxis = series.getYAxis();
			var baseTick = yAxis.getMajorTicks()[0];
			var zeroTick = yAxis.u2p(0);
			var points = [];
			var offset = Math.round(markSize / 8);

			for ( var i = 0, len = data.length; i < len; i++) {
				var point = {};

				//Similar with BarRender
				point.x1 = xAxisMajorTicks[i]  - ((sCount - 2*sIndex) * (markSize + offset) - offset)/2;

				if (this._fillToZero) {
					point.y2 = zeroTick;
					if ( baseTick < zeroTick ) {
						point.y2 = baseTick;
					}
				} else {
					point.y2 = baseTick;
				}

				point.y1 = yAxis.u2p(data[i].value);
				point.x2 = point.x1 + markSize;

				points.push(point);
			}
			return points;
		},

		_regEvent : function() {

		},

		_drawBarShape : function(seriesShape, point, basicColor) {
			if ( !seriesShape.rect.visible() ) return;
			var barWidth = Math.abs(point.x1 - point.x2);
			var isShowOutBorder = this._barStyle.isShowOutBorder, isShowInnerBorder = this._barStyle.isShowInnerBorder;
			if (barWidth < 8) {
				// Remove Out Border
				isShowOutBorder = false;
			}
			if (barWidth < 5) {
				// Remove Inner Border
				isShowInnerBorder = false;
			}

			var color = ColorUtils.getColorSeriesForBar(basicColor);

			// draw rectangle
			seriesShape.rect.color(basicColor);
			if (point.y1 > point.y2) {
				seriesShape.rect.topRight([ point.x2, point.y2 ]);
			} else {
				seriesShape.rect.bottomRight([ point.x2, point.y2 ]);
			}

			//Ian [2012-04-11] To fix the bug VISUAL-561, we should reset the inner and outer border because it may keep the last value
			seriesShape.innerBorder.reset();
			seriesShape.outerBorder.reset();
			//End
			
			// draw inner border
			seriesShape.innerBorder.borderWidth(1).borderColor(color[0]).visible(isShowInnerBorder);
			// draw outer border
			seriesShape.outerBorder.borderWidth(1).borderColor(color[3]).visible(isShowOutBorder);
		},

		_updateBarShapeDuringAnimation : function(seriesShape, point, basicColor, factor) {
			var width = Math.abs(point.x1 - point.x2);
			var height = Math.abs(point.y2 - point.y1) * factor;
			if ((width.toString() === 'NaN') || (height.toString() === 'NaN')) {
				return;
			}
			seriesShape.rect.width(width).height(height).shadow({
				offsetX : 0,
				offsetY : 0,
				blur : 0,
				color : 'rgba(0,0,0,0.5)'
			});

			var color = ColorUtils.getColorSeriesForBar(basicColor);

			if (this._barStyle.isShowGradient) {
				if (point.y1 > point.y2) {
					seriesShape.rect.color({
						t : 'lg',
						e : {
							x : point.x1,
							y : 0
						},
						s : {
							x : point.x1,
							y : height
						},
						st : [ {
							o : 0,
							v : color[1]
						}, {
							o : 1,
							v : color[2]
						} ]
					});
				} else {
					seriesShape.rect.color({
						t : 'lg',
						s : {
							x : point.x1,
							y : 0
						},
						e : {
							x : point.x1,
							y : height
						},
						st : [ {
							o : 0,
							v : color[1]
						}, {
							o : 1,
							v : color[2]
						} ]
					});
				}
			} else {
				seriesShape.rect.color(basicColor);
			}
		},
		
		_updateBarShape : function(seriesShape, point, basicColor, factor) {
			var width = Math.abs(point.x1 - point.x2);
			var height = Math.abs(point.y2 - point.y1) * factor;
			if ((width.toString() === 'NaN') || (height.toString() === 'NaN')) {
				return;
			}
			seriesShape.rect.width(width).height(height);
			
			if (this._barStyle.isShowShadow) {
				seriesShape.rect.shadow({
					offsetX : 2,
					offsetY : 1,
					blur : 2,
					color : 'rgba(0,0,0,0.5)'
				});
			} else {
				seriesShape.rect.shadow({
					offsetX : 0,
					offsetY : 0,
					blur : 0,
					color : 'rgba(0,0,0,0.5)'
				});
			}

			var color = ColorUtils.getColorSeriesForBar(basicColor);

			if (this._barStyle.isShowGradient) {
				if (point.y1 > point.y2) {
					seriesShape.rect.color({
						t : 'lg',
						e : {
							x : point.x1,
							y : 0
						},
						s : {
							x : point.x1,
							y : height
						},
						st : [ {
							o : 0,
							v : color[1]
						}, {
							o : 1,
							v : color[2]
						} ]
					});
				} else {
					seriesShape.rect.color({
						t : 'lg',
						s : {
							x : point.x1,
							y : 0
						},
						e : {
							x : point.x1,
							y : height
						},
						st : [ {
							o : 0,
							v : color[1]
						}, {
							o : 1,
							v : color[2]
						} ]
					});
				}
			} else {
				seriesShape.rect.color(basicColor);
			}

			var offset = 0;
			seriesShape.outerBorder.reset();
			if (this._barStyle.isShowOutBorder) {
				this._drawBorderPath(seriesShape.outerBorder, point, height, offset);
				offset = offset + 1;
			}
			seriesShape.innerBorder.reset();
			if (this._barStyle.isShowInnerBorder) {
				this._drawBorderPath(seriesShape.innerBorder, point, height, offset);
			}
		},

		_drawBorderPath : function(shape, point, distance, offset) {
			var barHeight = Math.abs(point.y2 - point.y1);
			if (barHeight < 2)
				return;
			if (point.y1 > point.y2) {
				shape.moveTo(point.x2 - offset, point.y2).lineTo(point.x2 - offset,
						point.y2 + distance - offset);
				if (barHeight < 3) {
					shape.moveTo(point.x1 + offset, point.y2 + distance - offset);
				} else {
					shape.lineTo(point.x1 + offset, point.y2 + distance - offset);
				}
				shape.lineTo(point.x1 + offset, point.y2);
			} else {
				shape.moveTo(point.x2 - offset, point.y2).lineTo(point.x2 - offset,
						point.y2 - distance + offset);
				if (barHeight < 3) {
					shape.moveTo(point.x1 + offset, point.y2 - distance + offset);
				} else {
					shape.lineTo(point.x1 + offset, point.y2 - distance + offset);
				}
				shape.lineTo(point.x1 + offset, point.y2);
			}
		},

		/** @overrides sap.riv.viz.shared.series.BaseRenderer.highlight */
		highlight : function() {
			var seriesShapes = this._seriesShapes;
			if (seriesShapes.length === 0)
				return;

			// Adjust all shape color alpha to 0.5
			var i, j, seriesShape, shape;
			for (i = 0; i < seriesShapes.length; i++) {
				seriesShape = seriesShapes[i];
				for (j = 0; j < seriesShape.length; j++) {
					shape = seriesShape[j];
					if(shape){
						shape.rect.compositionMode({
							alpha : 0.5
						});
						shape.outerBorder.compositionMode({
							alpha : 0.5
						});
						shape.innerBorder.compositionMode({
							alpha : 0.5
						});
					}
				}
			}

			// Highlight selected shape
			var highlights = this._highlights, selectedShape;
			for ( var i = 0, len = highlights.length; i < len; i++) {
				selectedShape =  seriesShapes[highlights[i].measureIndex] ? seriesShapes[highlights[i].measureIndex][highlights[i].dimensionItemIndex]: null;
				if(selectedShape){
					selectedShape.rect.compositionMode({
						alpha : 1
					});
					selectedShape.outerBorder.compositionMode({
						alpha : 1
					});
					selectedShape.innerBorder.compositionMode({
						alpha : 1
					});
				}
			}
			this.refresh();
		},

		removeHighlights : function() {
			this._highlights.splice(0, this._highlights.length);
			var seriesShapes = this._seriesShapes;
			var i, j, seriesShape, shape;
			for (i = 0; i < seriesShapes.length; i++) {
				seriesShape = seriesShapes[i];
				for (j = 0; j < seriesShape.length; j++) {
					shape = seriesShape[j];
					shape.rect.compositionMode({
						alpha : 1
					});
					shape.outerBorder.compositionMode({
						alpha : 1
					});
					shape.innerBorder.compositionMode({
						alpha : 1
					});
				}
			}
			this.refresh();
		},

		/**
		 * @param scale
		 *            the scale in xaxis drrection
		 * @param viewPort
		 *            the size should to been drawn
		 * 
		 * if the viewPort is defined, we only draw the shape in
		 * the this view, remove other shape those we do not
		 * want to draw
		 */
		drawViewPort : function(scale, viewPort) {
			var offset = this.getLayer().position();

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length === 0) {
				return;
			}

			var seriesList = seriesGroups[0].getSeriesList();
			if (seriesList.length === 0) {
				return;
			}

			var xAxis = seriesList[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var tickInterval = xAxis.getTickInterval();

			var markerSize;
			// var markerSize = seriesList[0]._zoomBarMarkerSize
			// * scale; //[Christy] Bar size is not limited.
			// if(markerSize < seriesList[0]._barMarkerSize){
			// markerSize = seriesList[0]._barMarkerSize;
			// }

			seriesList[0]._zoomBarMarkerSize = markerSize = this._calculateMarkSzie(seriesList.length,
					tickInterval);

			this._seriesPoints = [];
			if (viewPort) {
				var pointArray = [];
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesShapes = this._seriesShapes[i];
					var seriesPoints = this._seriesPoints[i] = this._calculateSeriesPoints(i, len,
							seriesList[i], xAxisMajorTicks, markerSize);

					for ( var j = 0; j < seriesPoints.length; j++) {
						if (seriesPoints[j].x2 + offset.x < 0
								|| seriesPoints[j].x1 + offset.x > viewPort.width) {
							if (seriesShapes[j]) {
								this._removeBarShape(seriesShapes[j]);
							}
							seriesShapes[j] = null;
						} else {
							pointArray[j] = 1;
							if (!seriesShapes[j]) {
								seriesShapes[j] = this._addBarShape();
							}
						}
					}
					this._drawSeries(seriesShapes, seriesPoints, seriesList[i], pointArray);

					pointArray = [];
				}
				this._doAnimation(true);
			} else {
				for ( var i = 0, len = seriesList.length; i < len; i++) {
					var seriesShapes = this._seriesShapes[i];
					var sereisPoints = this._seriesPoints[i] = this._calculateSeriesPoints(i, len,
							seriesList[i], xAxisMajorTicks, markerSize);
					for ( var j = 0; j < sereisPoints.length; j++) {
						if (!seriesShapes[j]) {
							seriesShapes[j] = this._addBarShape();
						}
					}
					this._drawSeries(seriesShapes, sereisPoints, seriesList[i]);
				}
				this._doAnimation(true);
			}
			this.refresh();
		},

		hoverOnPoint : function(point) {

			var seriesGroups = this.getSeriesGroups();
			if (seriesGroups.length == 0)
				return;

			var seriesList = seriesGroups[0].getSeriesList();

			if (seriesList.length == 0) {
				return;
			}

			var xAxis = seriesList[0].getXAxis();
			var xAxisMajorTicks = xAxis.getMajorTicks();
			var halfTickInterval = xAxis.getTickInterval() / 2;

			var start = 0, end = xAxisMajorTicks.length - 1;
			var found = false;
			var dimensionItemIndex;
			while (!found && start < end) {
				dimensionItemIndex = Math.round((start + end) / 2);
				var xPoint = xAxisMajorTicks[dimensionItemIndex] - point.x;
				if (Math.abs(xPoint) <= halfTickInterval)
					found = true;
				else if (xPoint <= 0) {
					start = dimensionItemIndex + 1;
				} else {
					end = dimensionItemIndex - 1;
				}
			}
			if (!found)
				dimensionItemIndex = start;

			if (this._dataCtxOnPoint && this._dataCtxOnPoint.dimensionItemIndex === dimensionItemIndex) {
				return this._dataCtxOnPoint;
			}

			var dataCtxOnpoint = {};
			dataCtxOnpoint['dimensionItemIndex'] = dimensionItemIndex;

			this._tpDecorativeRenderer.visible(true).width(halfTickInterval * 2).height(
					this.getLayer().size().height - seriesList[0].getYAxis().getLastTickOffset())
					.color('rgba(133,133,133, 0.4)').topLeft(
							[ Math.round(xAxisMajorTicks[dimensionItemIndex] - halfTickInterval),
									seriesList[0].getYAxis().getLastTickOffset() ]);
			this.refresh();

			this._dataCtxOnPoint = null;
			this._dataCtxOnPoint = dataCtxOnpoint;

			return dataCtxOnpoint;
		},
	});
	return columnBarRenderer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.series.SeriesHighlighter',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup ( funcUtils ) {
	var equals = function (obj, other) {
		var prop = null;
		for ( prop in obj ) {
			if ( typeof other[prop] === 'undefined' ) return false;
		}
		
		for ( prop in obj ) {
			if ( obj[prop] ) {
				switch ( typeof obj[prop] ) {
				case 'object':
					if ( !obj[prop].equals(other[prop]) ) return false;
					break;
				case 'function':
					if ( typeof other[prop] === 'undefined' ||
							( prop !== 'equals' && obj[prop].toString() !== other[prop].toString()) ) {
						return false;
					}
					break;
				default:
					if ( obj[prop] !== other[prop] ) return false;
				}
			} else {
				if ( other[prop] ) return false;
			}
		}
		
		for ( prop in obj ) {
			if ( typeof obj[prop] === 'undefined' ) return false;
		}
		
		return true;
	};
	
	var removeArrayItem = function ( array, from, to ) {
		var rest = array.slice((to || from) + 1 || array.length);
		array.length = from < 0 ? array.length + from : from;
		return array.push.apply(array, rest);
	};
	
	/**
	 * Represents an ordered list structure.
	 * 
	 * @returns {sap.riv.viz.shared.series.ArrayList}
	 * @author eye
	 */
	var ArrayList = function () {
		var elementData;
		
		if ( arguments.length === 0 ) {
			elementData = [];
		} else if ( arguments.length > 0 && typeof arguments[0] !== 'number' ) {
			elementData = arguments[0].toArray();
		} else {
			elementData = [];
			elementData.length = arguments[0];
		}
		
		function Iterator( array ) {
			var index = 0;
		
			this.hasNext = function () {
				return index < array.length;
			};
			this.next = function () {
				return array[index++];
			};
			
			this.remove = function () {
				array.splice(index, 1);
			};
			
			this.getIndex = function () {
				return index;
			};
		}
		
		this.add = function ( elem ) {
			elementData.push(elem);
		};
		
		this.addAll = function ( from, array ) {
			if ( typeof from !== 'number' ) return;
			
			if ( from < 0 || from > elementData.length ) return;
			var iterator = new Iterator(array);
			while ( iterator.hasNext() ) {
				elementData.push(iterator.next());
			}
		};
		
		this.insert = function ( index, elem ) {
			elementData.splice(index, 0, elem);
		};
		
		this.indexOf = function ( elem ) {
			for ( var i = 0; i < elementData.length; i++ ) {
				if ( equals(elementData[i], elem) ) {
					return i;
				}
			}
			return -1;
		};
		
		this.get = function ( index ) {
			return elementData[index];
		};
		
		this.size = function () {
			return elementData.length;
		};
		
		this.exchange = function ( first, last ) {
			var temp = elementData[first];
			elementData[first] = elementData[last];
			elementData[last] = temp;
		};
		
		this.contains = function ( item ) {
			for ( var i = 0; i < elementData.length; i++ ) {
				if ( equals(elementData[i], item) ) {
					return true;
				}
			}
			return false;
		};
		
		this.deleteItem = function ( item ) {
			var index = this.indexOf(item);
			if ( index !== -1 ) {
				removeArrayItem(elementData, index);
			}
		};
		
		this.remove = function ( from, to ) {
			removeArrayItem(elementData, from, to);
		};
		
		this.removeAll = function () {
			elementData.splice(0, elementData.length);
		};
		
		this.toArray = function () {
			return elementData.slice(0);
		};
		
		this.iterator = function () {
			return new Iterator(elementData);
		};
	};
	
	/**
	 * Represents a double-ended queue.
	 * @param capacityRestricted
	 * - Whether the queue's capacity can be expanded.
	 * @returns {sap.riv.viz.shared.series.Deque}
	 * @author eye
	 */
	var Deque = function ( capacityRestricted ) {
		var elementData = new ArrayList();
		var maxCapacity = Number.MAX_VALUE;
		var capacity = 16; // Default capacity
		
		this.setCapacity = function ( quantity ) {
			capacity = quantity;
		};
		
		this.offerFirst = function ( item ) {
			if ( this.remainingCapacity() < 1 ) {
				this.removeLast();
			} 
			elementData.insert(0, item);
		};
		
		this.offerLast = function ( item ) {
			if ( this.remainingCapacity() < 1 ) {
				this.removeFirst();
			}
			elementData.add(item);
		};
		
		this.removeFirst = function () {
			elementData.remove(0);
		};
		
		this.removeLast = function () {
			elementData.remove(elementData.size() - 1);
		};
		
		this.pollFirst = function () {
			var firstElem = this.peekFirst();
			elementData.remove(0);
			return firstElem;
		};
		
		this.pollLast = function () {
			var lastElement = this.peekLast();
			elementData.remove(elementData.size() - 1);
			return lastElement;
		};
		
		this.peekFirst = function () {
			if ( elementData.size() > 0 ) {
				return elementData.get(0);
			} else {
				return null;
			}
		};
		
		this.peekLast = function () {
			if ( elementData.size() > 0 ) {
				return elementData.get(elementData.size() - 1);
			} else {
				return null;
			}
		};
		
		this.size = function () {
			return elementData.size();
		};
		
		this.iterator = function () {
			return elementData.iterator();
		};
		
		this.toArrayList = function () {
			return elementData;
		};
		
		this.toArray = function () {
			return elementData.toArray();
		};
		
		this.remainingCapacity = function () {
			if ( capacityRestricted ) {
				return ( capacity - elementData.size() );
			} else {
				return ( maxCapacity - elementData.size() );
			}
		};
	};
	
	/**
	 * Represents a highlight agent for various chart components. The highlight agent
	 * employs the builder design pattern, who collects data step by step and executes
	 * the highlight action on demand on the premise of completion of data settings
	 * and data integrity.
	 * 
	 * @param {Array} graphicsRenderers
	 * - List of graphics renderers who's capable of doing graphical works.
	 * 
	 * @param {Number} thresholdValue
	 * - Maximal value of highlight quantities
	 * 
	 * @param {Boolean} layerPrioritization
	 * - If layer is meant to be prioritized, typically by moving its visual layer. 
	 * 
	 * @returns {sap.riv.viz.shared.series.SeriesHighlighter}
	 * 
	 * @author eye
	 */
	var SeriesHighlighter = function ( graphicsRenderers, threshold, layerPrioritization ) {
		var 
			// Stores references of graphicsRenderers whether they're working or not.
			rendererList = new ArrayList(),
			// Saves current candidates for highlight. 
			candidates = new Deque(true),
			// Saves translated context paths which renderer can understand.
			targets = [],
			// Stores ordered list of series data which represents 
			// current existing and active series entries.
			seriesTuple = new ArrayList(),
			// References actual graphical shapes descriptions.
			// Quantities of the shapes MUST be identical with
			// that of series tuple, but orders of them may vary.
			shapesList = new ArrayList(),
			// Generated data during highlight.
			products = [],
			//disable series index
			disabledSeriesIndex;
		
		candidates.setCapacity(threshold);
		rendererList.addAll(0, graphicsRenderers);
		
		/**
		 * Reloads essential data for operations.
		 */
		this.reload = function () {
			seriesTuple.removeAll();
			shapesList.removeAll();
			
			var iter = rendererList.iterator(), rendererItem;
			while ( iter.hasNext() ) {
				rendererItem = iter.next();
				for ( var i = 0, len = rendererItem.getSeriesGroups()[0].getSeriesList().length; 
						i < len; i++ ) {
					seriesTuple.add(rendererItem.getSeriesGroups()[0].getSeriesList()[i]);
				}
				
				for ( i = 0, len = rendererItem.getSeriesShapes().length; i < len; i++ ) {
					if ( rendererItem.getSeriesShapes()[i].constructor == Array ) {
						shapesList.add(rendererItem.getSeriesShapes()[i]);
					}
					if ( rendererItem.getSeriesShapes()[i].constructor == Object ) {
						shapesList.add(rendererItem.getSeriesShapes()[i].marker);
					}
				}
			}
		};
		this.reload();
		
		/**
		 * Sets target paths for highlight.
		 * 
		 * @param {Array} argument[0]
		 * - Target paths
		 */
		this.setTargets = function () {
			if ( !arguments[0] || arguments[0].constructor !== Array ) return;
			
			for ( var i = 0, len = arguments[0].length; i < len; i++ ) {
				candidates.offerLast(arguments[0][i]);
				products.push(arguments[0][i]);
			}
			
			targets = translatePaths(candidates.toArray());
		};
		
		/**
		 * Tests if the given point coordinate happens to be
		 * located in one of the shapes and returns the path
		 * of the shape if so.
		 * 
		 * @param {Object} pointCoord
		 * - Given point coordinate
		 * 
		 * @returns {Object} path
		 * - Context path which contains the point
		 */
		this.hits = function ( pointCoord ) {
			var iterator = shapesList.iterator(), seriesShapes, seriesNo, path = {};
			while ( iterator.hasNext() ) {
				seriesShapes = iterator.next();
				seriesNo = iterator.getIndex() - 1;
				for ( var i = 0, len = seriesShapes.length; i < len; i++ ) {
					if ( (seriesShapes[i].rect 
							&& seriesShapes[i].rect.doPointInTest(pointCoord))
							|| (seriesShapes[i].doPointInTest 
							&& seriesShapes[i].doPointInTest(pointCoord) ) ) {
						path.measureIndex = seriesNo;
						path.dimensionItemIndex = i;
					}
				}
			}
			return path;
		};
		
		// Converts chart scoped context path(s) to renderer scoped path(s).
		// If no input provided, the function will be returning an empty
		// array. Note that this function is deliberately designed as private
		// which is impossible to be invoked at an outer scope.
		function translatePaths() {
			if ( arguments[0].constructor != Array ) funcUtils.error("Unsupported argument type.");
			var input = new ArrayList(), output = [];
			input.addAll(0, arguments[0]);
			
			var iterator = rendererList.iterator(), 
				seriesIndexMap = [],
				chartSeriesIndex = 0,
				renderer,
				rendererId;
			while ( iterator.hasNext() ) {
				renderer = iterator.next();
				rendererId = iterator.getIndex() - 1;
				
				for ( var i = 0, len = renderer.getSeriesGroups()[0]
						.getSeriesList().length; i < len; i++, chartSeriesIndex++ ) {
					seriesIndexMap.push({
						rendererNo : rendererId,
						chartSeriesNo : chartSeriesIndex,
						rendererSeriesNo : i
					});
				}
			}
			
			iterator = input.iterator();
			var inputItem, outputItem;
			while ( iterator.hasNext() ) {
				inputItem = iterator.next();
				outputItem = new Object();
				outputItem.measureIndex = inputItem.measureIndex;
				outputItem.dimensionItemIndex = inputItem.dimensionItemIndex;
				
				for ( i = 0, len = seriesIndexMap.length; i < len; i++ ) {
					if ( seriesIndexMap[i].chartSeriesNo 
							=== outputItem.measureIndex ) {
						outputItem.rendererNo = seriesIndexMap[i].rendererNo;
						outputItem.rendererSeriesNo = 
							seriesIndexMap[i].rendererSeriesNo;
						output.push(outputItem);
					}
				}
			}
			return output;
		}
		
		/**
		 * Removes the given path if it's enrolled.
		 * 
		 * @param {Object} path
		 * - Given path to test against
		 */
		this.remove = function ( path ) {
			candidates.toArrayList().deleteItem(path);
		};
		
		/**
		 * Removes all set paths.
		 */
		this.erase = function () {
			candidates.toArrayList().removeAll();
			targets.splice(0, targets.length);
		};
		
		/**
		 * Removes everything been changed before
		 * and makes the agent brand new.
		 */
		this.reset = function () {
			seriesTuple.removeAll();
			shapesList.removeAll();
			disabledSeriesIndex = null;
		};
		
		this.ready = function () {
			return shapesList.size();
		};
		
		/**
		 * Returns if the given path has already been
		 * enrolled for highlight.
		 * 
		 * @param path 
		 * - The given path
		 * 
		 * @returns true 
		 * - If the given path has been enrolled and vice versa
		 */
		this.isEnrolled = function ( path ) {
			return candidates.toArrayList().contains(path);
		};
		
		/**
		 * Executes everything.
		 * The method has two working modes. The first is just
		 * inject highlight targets into right renderer(s), and
		 * the other is do the highlight job by itself. This is
		 * determined by judging the <code>manually</code> flag.
		 * 
		 * @param {Boolean} manually
		 * - If the highlight agent will be doing the highlight
		 * directly or only setting highlight targets.
		 * 
		 * @returns {Array} products
		 * - Generated data upon highlights
		 */
		this.run = function ( manually ) {
			targets = translatePaths(candidates.toArray());
			
			for ( var iter = rendererList.iterator(); iter.hasNext(); ) {
				iter.next().removeHighlights();
			}
			
			// Get responsible renderer IDs.
			var targetRendererIDs = [];
			for ( var i = 0, len = targets.length; i < len; i++ ) {
				targetRendererIDs.push(targets[i].rendererNo);
			}
			
			// Merge repetitive renderer numbers.
			for ( i = 0, len = targetRendererIDs.length; i < len; i++ ) {
				if ( (i < targetRendererIDs.length - 1) 
						&& targetRendererIDs[i] === targetRendererIDs[i + 1] ) {
					removeArrayItem(targetRendererIDs, i, i + 1);
				}
			}
			
			var finalTargets = [], targetItem;
			for ( i = 0; i < targetRendererIDs.length; i++ ) {
				targetItem = new Object();
				targetItem.rendererNo = targetRendererIDs[i];
				targetItem.highlights = [];
				for ( var j = 0, len = targets.length; j < len; j++ ) {
					if ( targets[j].rendererNo === targetRendererIDs[i] ) {
						targetItem.highlights.push({
							measureIndex : targets[j].rendererSeriesNo,
							dimensionItemIndex : targets[j].dimensionItemIndex
						});
					}
				}
				finalTargets.push(targetItem);
			}
			
			for ( i = 0; i < targets.length; i++ ) {
				if ( !seriesTuple.get(targets[i].measureIndex).isVisible() ) {
					finalTargets.splice(i, 1);
				}
			}
			
			// Notifies renderer(s) who's responsible of handling
			// highlight request(s).
			for ( i = 0; i < finalTargets.length; i++ ) {
				rendererList.get(finalTargets[i].rendererNo).setHighlights(
						finalTargets[i].highlights, layerPrioritization);
				if ( manually ) {
					rendererList.get(finalTargets[i].rendererNo).highlight();
				}
			}
			
			return products;
		};
	};
	
	return SeriesHighlighter;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.axis.Axis',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.DimensionAxisRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.LinearAxisRenderer',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, TypeUtils, DimensionAxisRenderer,
		LinearAxisRenderer) {

	/**
	 * Axis layout step: 1. getPreferredWidth of yAxis. 2. update the distance
	 * property of xAxis 3. get preferredHeight of xAxis 4. get prefereredWidth
	 * of xAxis 5. update the distance property of yAxis 5. get preferredHeight
	 * of yAxis
	 * 
	 */

	/**
	 * options: { mode: 'numeric', 'dimension' required labels: labels, required
	 * in dimension axis minValue: min value of line axis, required in linear
	 * axis maxValue: max value of line axis, required in linear axis lineColor:
	 * line color, default value is black lineThickness: lint thickness, default
	 * value 1 showMajorTicks : show or hidden major ticks, default value is
	 * false showMinorTicks: show or hidden minor ticks, default value is false }
	 */
	var axis = function(options) {

		this._sax_options = ObjectUtils.extend(true, {}, options);
		this._sax_initialize(this._sax_options);

		return this;
	};

	// static variables
	axis.LINEAR = 'numeric';
	axis.DIMENSION = 'dimension';

	/*
	 * 
	 */
	axis.prototype._sax_initialize = function(options) {
		this._sax_mode = options.mode;
		switch (this._sax_mode) {
		case axis.DIMENSION:
			this._sax_renderer = new DimensionAxisRenderer(
					options);
			break;
		case axis.LINEAR:
		default:
			this._sax_renderer = new LinearAxisRenderer(
					options);
			break;
		}
	};

	/**
	 * @layer sap.riv.graphics.Layer
	 */
	axis.prototype.setLayer = function(layer) {
		this._sax_renderer.setLayer(layer);
	};

	axis.prototype.draw = function() {
		this._sax_renderer.draw();
	};

	/**
	 * @reutrn object {width, height}
	 */
	axis.prototype.getPreferredSize = function() {
		return this._sax_renderer.getPreferredSize();
	};

	axis.prototype.getPreferredWidth = function() {
		return this._sax_renderer.getPreferredWidth();
	};

	axis.prototype.getPreferredHeight = function() {
		return this._sax_renderer.getPreferredHeight();
	};

	/**
	 * @properties Object
	 */
	axis.prototype.updateProperties = function(properties) {
		var needReset = false;

		if (properties && properties.distance
				&& properties.distance !== this._sax_renderer.distance()) {
			needReset = true;
		}

		if (needReset) {
			this._sax_renderer.reset();
		}

		if (properties && properties.distance) {
			this._sax_renderer.distance(properties.distance);
		}

		return this;
	};

	/**
	 * @unitObj, value or number in Dimension axis, the unitObj is number, 0, 1,
	 *           2, 3 in value axis, the unitObj is value, 0, 10, 20
	 */
	axis.prototype.u2p = function(unitObj) {
		return this._sax_renderer.u2p(unitObj);
	};

	axis.prototype.p2u = function(pointObj) {
		return this._sax_renderer.p2u(pointObj);
	};

	axis.prototype.position = function(xoffset, yoffset) {
		this._sax_renderer.position(xoffset, yoffset);
	};

	axis.prototype.zoom = function(xscale, yscale, dscale) {
		this._sax_renderer.zoom(xscale, yscale, dscale);
	};

	axis.prototype.setVisibleRange = function(xscale, yscale, dscale) {
		this._sax_renderer.setVisibleRange(xscale, yscale, dscale);
	};
	/*
	 * @return Array, the positions of major ticks
	 */
	axis.prototype.getMajorTicks = function() {
		return this._sax_renderer.getMajorTicks();
	};

	/*
	 * @return Array, the positions of minor ticks
	 */
	axis.prototype.getMinorTicks = function() {
		return this._sax_renderer.getMinorTicks();
	};

	axis.prototype.getAxisWidth = function() {
		return this._sax_renderer.getAxisWidth();
	};

	axis.prototype.getTickInterval = function() {
		return this._sax_renderer.getTickInterval();
	};

	axis.prototype.getFirstTickOffset = function() {
		return this._sax_renderer.getFirstTickOffset();
	};

	axis.prototype.getLastTickOffset = function() {
		return this._sax_renderer.getLastTickOffset();
	};

	axis.prototype.getLineThickness = function() {
		return this._sax_renderer.getLineThickness();
	};

	axis.prototype.getMajorTickWidth = function() {
		return this._sax_renderer.getMajorTickWidth();
	};
	axis.prototype.applyTheme = function(theme) {
		return this._sax_renderer.applyTheme(theme);
	};

	return axis;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.BarModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.Axis',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.SeriesGroup',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.BarRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.ChartModule',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, FunctionUtils, LOG, UADetector,
		GestureDetector, Animator, Axis, SeriesGroup, Series, BarRenderer,
		ChartModule) {
	var defaultOptions = {
			xAxis :{
				showMajor : true,        
				majorColor :  '#c9c9c9',
				majorThickness : '1',

				showMinor : false,                                 
				minorColor : '#c9c9c9',
				minorThickness : '1',

				showSub : false,
				subColor :'#c9c9c9'
			},
			yAxis :{
				showMajor : false,        
				majorColor :  '#c9c9c9',
				majorThickness : '1',

				showMinor : false,                                 
				minorColor : '#c9c9c9',
				minorThickness : '1',

				showSub : false,
				subColor :'#c9c9c9'
			}
	};
	
	var BarModule = ObjUtils.derive(ChartModule, {
		events : [ 'selectData', 'showTooltip', 'hideTooltip' ],
		constructor : function(options) {
			this._seriesGroup = null;
			this._barRenderer = null;
			this._hasDrawn = false;
			this._hasBacked = false;
			this._valueAxisRange = null;
			this._selections = [];
		},
		initAxes : function() {
			this._xaxes = [];
			var xaxesOption = this._chart_options.properties.xAxis;
			for ( var i = 0, len = xaxesOption.length; i < len; i++) {
				if ( TypeUtils.isExist(xaxesOption[i].showTitle) && xaxesOption[i].showTitle
						&& !TypeUtils.isExist(xaxesOption[i].title) ) {
					xaxesOption[i].title = "X" + (i + 1);
				}
				
				// FIX ISSUE: if there are two axis and more
				// than one series,
				// but it only use the one series. so according
				// to the
				// valueAxisRange
				// to judge whether the axis is to been used.
				// when it is not to
				// been used, set the min and max 0
				var option = {
					mode : Axis.LINEAR,
					position : i == 0 ? 'hb' : 'ht',
					maxValue : TypeUtils
							.isExist(this._valueAxisRange[i]) ? this._valueAxisRange[i].max
							: 0,
					minValue : TypeUtils
							.isExist(this._valueAxisRange[i]) ? this._valueAxisRange[i].min
							: 0
				}
				var x = new Axis(ObjUtils.extend(true, option,
						xaxesOption[i]));
				this._xaxes.push(x);
			}

			this._yaxes = [];
			var yaxesOption = this._chart_options.properties.yAxis;
			var labels = this._dataTree.getSubMemberLabels();
			if(labels.length < 1){
				labels = [];
				labels.push('1');
			}
			for ( var i = 0, len = yaxesOption.length; i < len; i++) {
				if ( TypeUtils.isExist(yaxesOption[i].showTitle) && yaxesOption[i].showTitle
						&& !TypeUtils.isExist(yaxesOption[i].title) ) {
					yaxesOption[i].title = "Y" + (i + 1);
				}
				
				var option = {
					mode : Axis.DIMENSION,
					position : 'vl',
					labels : labels
				}
				var y = new Axis(ObjUtils.extend(true, option,
						yaxesOption[i]));
				this._yaxes.push(y);
			}
		},
		
		initGridLineProperties : function() {
			this._xAxis_gridLine_option = ObjUtils.extend(true, defaultOptions.xAxis,
							this._chart_options.properties.xAxis[0].gridLine);
			this._yAxis_gridLine_option = ObjUtils.extend(true, defaultOptions.yAxis,
							this._chart_options.properties.yAxis[0].gridLine);
			this._gridLine.setXAxisOptions(this._xAxis_gridLine_option);
			this._gridLine.setYAxisOptions(this._yAxis_gridLine_option);
			// Nick - if users have some wrong settings, we do not throw any error, but the behavior is unexpected.
			// be consistent with showMajorticks
			//this.gridLinePropertiesCheck();
		},
		
		gridLinePropertiesCheck : function() {
			// Nick - if users have some wrong settings for the grid line, an error is thrown out
			if((!this._xAxis_gridLine_option.showMajor && this._xAxis_gridLine_option.showSub) || this._yAxis_gridLine_option.showMajor || this._yAxis_gridLine_option.showMinor){
				FunctionUtils.error("Wrong settings for grid line of bar chart");
			}
		},
		
		initSeries : function() {
			this._valueAxisRange = [];
			var barOptions = this._chart_options.properties.bar;
			var seriesOption = this._chart_options.properties.measures;
			var measureMembers = this._metaData.measureMembers;
			var defaultColor = this._chart_options.properties.measureDefault.colors;
			this._seriesGroup = new SeriesGroup();

			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var o = ObjUtils.extend(true, {}, barOptions, seriesOption[i]);
				o.fillColor = TypeUtils.isExist(o.fillColor) ? o.fillColor
						: defaultColor[i % defaultColor.length];
				// [Ian 2012-3-29] To check whether the series
				// is visible, if do not, we will do not create
				// the series, so it will do not be append to
				// the context
				o.visible = TypeUtils.isExist(o.visible) ? o.visible : true;
				if (o.visible) {
					var s = new Series(o);
					s.setName(measureMembers[i]);
					s.setData(this._data[i]);
					s.setVisible(o.visible);
					this._seriesGroup.addSeries(s);

					var valueAxis = o.valueAxis || 0;
					this._updateValueAxisRange(s.getDataRange(), valueAxis);
				}

			}
		},

		/**
		 * in bar chart, the scroll bar is in the right side of
		 * the chart and there is only one scroll bar.
		 */
		initScrollBar : function() {
			//Fix the bug:[Ian] if you update the chart, the scroll bar will show as we do not remove the first scrollBar
			if(this._scrollBar.length > 0){
				for(var i=0; i<this._scrollBar.length; i++){
					this._scrollBar[i].remove();
				}
			}
			
			// init scroll bar layer
			this._scrollBar = [];
			this._scrollBar[0] = this.scrollBar();

		},

		updateValueAxisRange : function() {
			this._valueAxisRange = [];
			var seriesOption = this._chart_options.properties.measures;
			var seriesList = this._seriesGroup.getSeriesList();
			var series;
			var validCount = 0;
			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				// [Ian 2012-3-29] To check whether the series
				// is visible, if do not, we will do not create
				// the series, so it will do not be append to
				// the context
				var o = seriesOption[i] || {};
				o.visible = TypeUtils.isExist(o.visible) ? o.visible : true;
				if ( o.visible ) {
					var valueAxis = o.valueAxis || 0;
					series = seriesList[validCount];
					this._updateValueAxisRange(series.getDataRange(), valueAxis);
					validCount++;
				}
			}
		},

		_updateValueAxisRange : function(range, valueAxis) {
			if (this._valueAxisRange[valueAxis] == undefined) {
				this._valueAxisRange[valueAxis] = {
					max : Number.NEGATIVE_INFINITY,
					min : Number.POSITIVE_INFINITY
				};
			}

			if (range.max > this._valueAxisRange[valueAxis].max) {
				this._valueAxisRange[valueAxis].max = range.max;
			}
			if (range.min < this._valueAxisRange[valueAxis].min) {
				this._valueAxisRange[valueAxis].min = range.min;
			}
		},

		bindSeriesWithAxes : function() {
			var seriesOption = this._chart_options.properties.measures;
			var seriesArray = this._seriesGroup.getSeriesList();
			var validCount = 0;

			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var o = seriesOption[i] || {};
				// [Ian 2012-3-29] To check whether the series
				// is visible, if do not, we will do not create
				// the series, so it will do not be append to
				// the context
				o.visible = TypeUtils.isExist(o.visible) ? o.visible : true;
				if (o.visible) {
					var valueAxis = o.valueAxis || 0;
					seriesArray[validCount].setXAxis(this._xaxes[valueAxis]);
					seriesArray[validCount].setYAxis(this._yaxes[0]);
					validCount++;
				}
			}
		},
		
		bindRenderer : function(layer) {
			if (this._barRenderer == null) {
				this._barRenderer = new BarRenderer(layer,
						this._chart_options.properties.bar);
			} else {
				this._barRenderer.resetSeriesGroup();
			}
			this._barRenderer.addSeriesGroup(this._seriesGroup);
		},
		
		drawSeries : function() {
			if (!this._hasDrawn) {
				this._barRenderer.draw();
				this._hasDrawn = true;
			} else {
				this._barRenderer.redraw();
			}

			if (this._defaultSelectionArmed) {
				// If default selection is armed, let it go.
				var defaultSelections = this._chart_options.properties.selectability.defaultSelectedItems;
				if (defaultSelections
						&& defaultSelections.length > 0) {
					this.doSelect(defaultSelections);
				}
				// Default selection won't get performed more
				// than twice.
				this._defaultSelectionArmed = false;
			} else {
				this.doSelect(this._selections);
			}
		},

		/**
		 * To align the yaxis and xaxis, we should adjust the
		 * position of axis to an integer position. so we do
		 * following adjustment. 1. set the ceiled y position
		 * and floored x position of yaxis[0] 2. set the floor x
		 * position and rounded y position of xaxis[0] 3. set
		 * the ceiled y position and floored x position of
		 * xaxis[1] if it exists 4. set the floored y position
		 * and floored x position of _seriesMaskLayer
		 */
		doChartLayout : function(nsize, yaxisLayers,
				xaxisLayers, seriesMaskLayer, seriesLayer) {
			this._seriesLayer = seriesLayer;

			var xTop = {
				width : 0,
				height : 0
			};
			var xBottom = {
				width : 0,
				height : 0
			};
			var yLeft = {
				width : 0,
				height : 0
			};
			var yRight = {
				width : 0,
				height : 0
			};

			// TODO: currently only left yaxis
			yLeft.width += this._yaxes[0].getPreferredWidth();
			var tempXaxisLength = (nsize.width - yLeft.width) * 0.95;

			this._xaxes[0].updateProperties({
				distance : tempXaxisLength
			});
			xBottom.width += this._xaxes[0].getPreferredWidth();
			xBottom.height += this._xaxes[0]
					.getPreferredHeight();

			// TODO: currently only primary(at bottom) and
			// secondary(at top)
			// xaxis
			if (this._xaxes.length == 2) {
				this._xaxes[1].updateProperties({
					distance : tempXaxisLength
				});
				xTop.width += this._xaxes[1].getPreferredWidth();
				xTop.height += this._xaxes[1].getPreferredHeight();
			}

			var topPadding = xTop.height > 0 ? xTop.height : nsize.height * 0.1;

			var tempYaxisLength = (nsize.height - xBottom.height - topPadding) * 0.95;
			this._yaxes[0].updateProperties({
				distance : tempYaxisLength
			});
			yLeft.height += this._yaxes[0].getPreferredHeight();

			yaxisLayers[0].size({
				width : yLeft.width,
				height : yLeft.height
			});
			yaxisLayers[0].position({
				x : 0,
				y : Math.ceil(topPadding)
			})

			xaxisLayers[0].size({
				width : xBottom.width,
				height : xBottom.height
			});
			// we set y position of xaxis layer according to the
			// y position of yaxis and the height of yaxis.
			// if the sum value of them is between 0 ~ 0.5, we
			// should floor the value of y position of yaxis.
			// if the value is between 0.5 ~ 1, we should ceil
			// the value of y position of yaxis
			xaxisLayers[0]
					.position({
						x : Math.floor(yLeft.width
										- this._xaxes[0].getFirstTickOffset()
										- this._yaxes[0].getLineThickness() / 2),
						y : Math.round(topPadding
								+ yLeft.height
								- this._xaxes[0].getMajorTickWidth() / 2)
					});

			if (xTop.height > 0) {
				// Top X axis is enabled
				xaxisLayers[1].size({
					width : xTop.width,
					height : xTop.height
				});
				xaxisLayers[1].position({
					x : Math.floor(yLeft.width
							- this._xaxes[1].getFirstTickOffset()
							- this._yaxes[0].getLineThickness() / 2),
					y : Math.ceil(this._xaxes[1].getMajorTickWidth() / 2)
				});
			}

			seriesMaskLayer.size({
				width : tempXaxisLength,
				height : tempYaxisLength
			});

			seriesMaskLayer.position({
				x : Math.floor(this._yaxes[0].getAxisWidth()),
				y : Math.ceil(topPadding)
			});

			seriesLayer.size(seriesMaskLayer.size());
			seriesLayer.position({
				x : 0,
				y : 0
			});

			this._scrollBar[0].init(seriesMaskLayer,
					seriesLayer, 'vertical');

			if (!this._hasBacked) {
				// update visible range
				this._updateVisibleRange();
			} else {
				this.restore();
			}
			
			this._rightBound = xaxisLayers[0].position().x + this._xaxes[0].getLastTickOffset();
		},

		/**
		 * scale the series layer according to the user's
		 * visible range option if the start or end is invalid,
		 * it will draw whole dimension
		 */
		_updateVisibleRange : function() {
			var visibleRangeOption = this._chart_options.properties.visibleRange;

			var visibleRangeStart = visibleRangeOption.start;
			var visibleRangeEnd = visibleRangeOption.end;
			if (visibleRangeStart < 0
					|| visibleRangeEnd < 0
					|| visibleRangeStart > this._dataTree.getSubMemberLabels().length - 1
					|| visibleRangeEnd > this._dataTree.getSubMemberLabels().length - 1
					|| visibleRangeStart > visibleRangeEnd) {
				visibleRangeStart = 0;
				visibleRangeEnd = this._dataTree.getSubMemberLabels().length - 1;
			}

			if (visibleRangeStart === 0
					&& visibleRangeEnd === this._dataTree.getSubMemberLabels().length - 1)
				return;

			var range = visibleRangeEnd - visibleRangeStart + 1;
			var scale = this._dataTree.getSubMemberLabels().length / range;
			this._yaxes[0].setVisibleRange(1, scale, scale);

			var interval = this._yaxes[0].getTickInterval();
			this._yaxes[0].position(0, -interval * visibleRangeStart);

			var curSize = this._seriesLayer.size();
			this._seriesLayer.size({
				width : curSize.width,
				height : curSize.height * scale
			});
			this.position(0, -interval * visibleRangeStart);

			// [Ian]Check whether it is in IPad, now we only
			// show the scroll bar in IPad, do not show it in
			// browser and another device.
			if (UADetector.os() === 'iPad') {
				this._scrollBar[0].update();
				this._scrollBar[0].unHighLight();
			}
		},

		updateProperties : function(propBag) {
			this.callParent('updateProperties', propBag);

			var seriesOption = this._chart_options.properties.measures;
			var defaultColor = this._chart_options.properties.measureDefault.colors;
			var barOptions = this._chart_options.properties.bar;
			var barSeriesProperties = [];

			if (TypeUtils.isExist(barOptions)) {
				this._barRenderer.updateProperties(barOptions);
			}

			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var opts = ObjUtils.extend(true, {},barOptions, seriesOption[i]);
				opts.fillColor = TypeUtils.isExist(opts.fillColor) 
									? opts.fillColor
									: defaultColor[i % defaultColor.length];
				
				barSeriesProperties.push(opts);
			}
			
			this._seriesGroup.updateProperties(barSeriesProperties);

			if ( !this._hasDrawn ) {
				this.initSeries();
				this._barRenderer.resetSeriesGroup();
				this._barRenderer.addSeriesGroup(this._seriesGroup);
			}
		},

		/**
		 * @return events 'selectData': {measureIndex,
		 *         dimensionItemIndex}
		 * @return events 'showTooltip': {measureIndex,
		 *         dimensionItemIndex, points }
		 * @override sap.riv.viz.xychart.ChartModule.getSupportedEvents
		 */
		getSupportedAppEvents : function() {
			return [ 'selectData', 'showTooltip', 'hideTooltip' ];
		},

		/**
		 * @param point
		 *            object {x:,y:} in seriesLayer
		 */
		clickOnPoint : function(point) {
			if (this._barRenderer == null) {
				FunctionUtils.error('No renderer to handle event!');
			}

			var dataCtxOnPoint = this.doSelect(point);
			if (dataCtxOnPoint) {
				this.fireEvent('selectData', {
					name : 'selectData',
					data : [ {
						dimensionAxisIndex : 0, // reserved for multiple charts
						dimensionIndex : 0, // reserved for multiple charts
						dimensionItemIndex : dataCtxOnPoint.dimensionItemIndex,
						measureIndex : dataCtxOnPoint.measureIndex,
						dimensionLabel : null, 
						measureValue : null
					} ]
				});
			}
		},
		
		/**
		 * Selects/highlights bar(s) by instruments or programmatically.
		 * 
		 * @param {Object} target
		 * - Specifier for a bar target, which could be a mouse point, 
		 * touch point or a bar path, i.e., dimension-measure pair(s).
		 * @returns {Object} dataContext 
		 * - Contextual data when bar(s) are selected successfully
		 * 
		 * (This method is obsolete and will be deprecated soon.)
		 * @author eye
		 */
		doSelect : function(target) {
			if (!target)
				return;

			// Represents a mouse click, touch or programmatic
			// selection.
			var selection = {
				"measureIndex" : null,
				"dimensionItemIndex" : null
			};

			var selectionOptions = this._chart_options.properties.selectability;
			var series, dataContext;

			if ( selectionOptions.mode === 'single' ) {
				if ( this._selections.length > 1 ) {
					// Erases multiple selections
					this._selections.splice(0, this._selections.length);
				}

				// No bar is selected, so it's safe to highlight
				// a bar straightforwardly.
				if ( this._selections.length === 0 ) {
					// Select by precise indexes.
					// The code snippet here simply implies that
					// it's executed for default selection,
					// programmatic selection is not well
					// supported so we limit its functionalities.
					if ( target[0] && TypeUtils.isDefined(target[0].measureIndex) ) {
						if ( !this._barRenderer.shapeExists(target[0].measureIndex,
								target[0].dimensionItemIndex) ) {
							return;
						}
						this._barRenderer.highlight(target[0]);
						selection.measureIndex = target[0].measureIndex;
						selection.dimensionItemIndex = target[0].dimensionItemIndex;
						this._selections.push(selection);
						var rendererHighlights = this._barRenderer.getHighlights();
						if ( rendererHighlights && rendererHighlights.length !== 0 ) {
							rendererHighlights.splice(0, rendererHighlights.length);
						}
						rendererHighlights.push(selection);
						return dataContext;
					}

					if ( TypeUtils.isDefined(target.x) ) { // Mouse click point exists.
						dataContext = this._barRenderer.highlight(target);
						if ( dataContext != null ) {
							selection.measureIndex = dataContext.measureIndex;
							selection.dimensionItemIndex = dataContext.dimensionItemIndex;
							var rendererHighlights = this._barRenderer.getHighlights();
							if ( rendererHighlights && rendererHighlights.length !== 0 ) {
								rendererHighlights.splice(0, rendererHighlights.length);
							}
							rendererHighlights.push(selection);
							this._selections.push(selection);
						}
						return dataContext;
					}
				}

				// Indicates one of the bars has been selected.
				// So if the deSelectable is set true,
				// clicking on blank area or the selected bar
				// itself DO restore its initial color,
				// otherwise only clicking on another bar will
				// take effect in restoring the selected
				// bar's color.
				if ( this._selections.length === 1 ) {
					var lastSelection = this._selections[0];

					// Test if mouse point has been located on
					// one of the bars.
					var shapeSelection = this._barRenderer.getShape(target);

					if ( selectionOptions.deSelectable ) {
						if ( shapeSelection && shapeSelection.measureIndex != null ) {
							// Hits one of the bars.
							// Just restore the selected bar's color regardless of
							// if it's currently clicked.
							this._barRenderer.restore(lastSelection);
							this._selections.splice(0, 1);

							if ( shapeSelection.measureIndex !== lastSelection.measureIndex
									|| shapeSelection.dimensionItemIndex !== lastSelection.dimensionItemIndex ) {
								// If mouse click was located on
								// another shape, select it.
								selection.measureIndex = shapeSelection.measureIndex;
								selection.dimensionItemIndex = shapeSelection.dimensionItemIndex;
								dataContext = this._barRenderer.highlight(selection);
								this._barRenderer.highlight(selection);
								this._selections.push(selection);
								var rendererHighlights = this._barRenderer.getHighlights();
								if ( rendererHighlights && rendererHighlights.length !== 0 ) {
									rendererHighlights.splice(0, rendererHighlights.length);
								}
								rendererHighlights.push(selection);
							}
						} else {
							if ( TypeUtils.isDefined(target.x) ) { // It's a click on blank area.
								this._barRenderer.restore(lastSelection);
								this._selections.splice(0, 1);
							} else { // It's a component/data/property update, no mouse click detected.
								if ( this._barRenderer.shapeExists(this._selections[0].measureIndex,
											this._selections[0].dimensionItemIndex) ) {
									this._barRenderer.highlight(this._selections[0]);
								}
							}
						}
					} else {
						shapeSelection = this._barRenderer.getShape(target);
						if ( shapeSelection && shapeSelection.measureIndex != null) {
							if (shapeSelection.measureIndex === lastSelection.measureIndex
									&& shapeSelection.dimensionItemIndex === lastSelection.dimensionItemIndex ) {
								return; // Not deSelectable, so ignore it.
							} else {
								// Clicked on another bar so restore the prior
								// and highlight the newly created one.
								this._barRenderer.restore(lastSelection);
								this._selections.splice(0, 1);
								selection.measureIndex = shapeSelection.measureIndex;
								selection.dimensionItemIndex = shapeSelection.dimensionItemIndex;
								dataContext = this._barRenderer.highlight(selection);
								this._selections.push(selection);
								var rendererHighlights = this._barRenderer.getHighlights();
								if ( rendererHighlights && rendererHighlights.length !== 0 ) {
									rendererHighlights.splice(0, rendererHighlights.length);
								}
								rendererHighlights.push(selection);
							}
						} else {
							if ( this._barRenderer.shapeExists(this._selections[0].measureIndex,
										this._selections[0].dimensionItemIndex) ) {
								this._barRenderer.highlight(this._selections[0]);
							}
						}
					}
				}
				return dataContext;
			} else if ( selectionOptions.mode === 'multiple' ) {
				return; // Not supported yet
			} else {
				return; // For malicious values
			}
		},

		/**
		 * As the rangeInXY function only return the x y offset
		 * base on the init status. so the move function is also
		 * based on the init status, we can only pan the bar
		 * chart in vertical direction
		 * 
		 * Begin: store some original value into variable
		 * 
		 * Change: move the yaxis layer and series layer
		 * 
		 * Ended: at the end time, we should support damping
		 * effect. so calculate the distance by h = v* v/(2*g)
		 * and use bezierCurveTiming to render the chart
		 */
		panMove : (function() {
			var ySpeed;
			var panStartTime;
			var yaxisLayerSize;
			var yaxisSubLayerSize;
			var yaxisSubLayerPosition;
			var origSeriesPos;
			var panMove;

			return function(panGestureDetector) {

				var comp = panGestureDetector.attachedComponent();
				var range = panGestureDetector.rangeInXY();

				if (panGestureDetector.state() === GestureDetector.TransitionState.Began) {
					origSeriesPos = comp._seriesLayer.position();
					yaxisSubLayerSize = comp._yaxes[0]._sax_renderer._subLayer.size();
					yaxisSubLayerPosition = comp._yaxes[0]._sax_renderer._subLayer.position();
					yaxisLayerSize = comp._yaxes[0]._sax_renderer._layer.size();

					panStartTime = new Date().getTime();

					// when start to pan, if the chart is in
					// inital statue, we will do not show the
					// scrollbar
					if (yaxisSubLayerSize.height > yaxisLayerSize.height) {
						comp._chartModule._scrollBar[0].highLight();
					}

					panMove = false;
				} else if (panGestureDetector.state() === GestureDetector.TransitionState.Changed) {
					//Ian [2012-04-10] if the gesture is recongizer as a long press, we obly show tooltip 
					//and do not pan the chart
					if(panGestureDetector.attachedComponent().islongPressGesture === true ){
						//Currently, we only disable it. It is a short solution
						/*var globalXY = panGestureDetector.globalLocOfGesture();
						var plotXY = comp.convertPointFromGlobal(globalXY);
						var targetLayer = comp._rootLayer;
						var point = comp._seriesLayer.convertPointFromLayer(plotXY, targetLayer);
						comp._chartModule.hoverOnPoint(point);
						*/
						return;
					}
					//End
					
					panMove = true;

					/*
					if ((origSeriesPos.y + range.y) >= 0
							|| (origSeriesPos.y
									+ range.y
									+ comp._yaxes[0]._sax_renderer._subLayer
											.size().height <= comp._yaxes[0]._sax_renderer._layer
									.size().height)) {
						return;
					}*/
					//Fix the bug[Ian 2012-4-19], when the chart is in the boundary, it is hard to move. 
					var yOffset = 0;

					if((origSeriesPos.y + range.y) > 0){
						yOffset = - origSeriesPos.y;
					}else if (origSeriesPos.y + range.y
									+ comp._seriesLayer.size().height <= comp._seriesMaskLayer
									.size().height){
						yOffset = comp._seriesMaskLayer.size().height - origSeriesPos.y - comp._seriesLayer.size().height ;
					}else{
						yOffset = range.y;
					}
					//End
					
					// move the series layer
					comp._chartModule.position(origSeriesPos.x, origSeriesPos.y + yOffset);
					comp._chartModule._scrollBar[0].update();

					// move yaxis
					var yaxis = comp._yaxes;
					for ( var i = yaxis.length; i--;) {
						yaxis[i].position(0, origSeriesPos.y + yOffset);
					}
					ySpeed = panGestureDetector.velocityInXY().y;
					panStartTime = new Date().getTime();

				} else if (panGestureDetector.state() === GestureDetector.TransitionState.Ended) {
					if ((origSeriesPos.y + range.y) >= 0
							|| (origSeriesPos.y
									+ range.y
									+ comp._yaxes[0]._sax_renderer._subLayer
											.size().height <= comp._yaxes[0]._sax_renderer._layer
									.size().height)) {
						// if the chart is in zoom status, we
						// should show the scrollbar and
						// unhighlight it.
						if (yaxisSubLayerSize.height > yaxisLayerSize.height) {
							comp._chartModule._scrollBar[0].unHighLight();
							comp._rootLayer.setNeedsDisplay();
						}
						panMove = false;
						return;
					}

					if (panMove) {
						// [Ian 2012-2-21] Fix the bug
						// VISUAL-1186, we should comfirm that
						// do the inertia effect only when the
						// ySpeed is large than 0
						if (ySpeed == 0) {
							panMove = false;
							// if you touch the chart and pan
							// the chart at start time and do
							// not pan the chart at later, you
							// should unhighlight the chart
							comp._chartModule._scrollBar[0].unHighLight();
							comp._rootLayer.setNeedsDisplay();
							return;
						}
						// End
						
						var panAcceleration = (ySpeed - 0) / (new Date().getTime() - panStartTime);
						var self = comp;
						var curPos = self._seriesLayer.position();

						// as the distance is so small, we
						// enlarge it 10 times
						var s = ySpeed * ySpeed / (2 * panAcceleration) * 10;
						Animator.animate({
							values : [ {
								type : 'FLOAT',
								from : 0.0,
								to : s
							} ],
							duration : 600,
							easing : 'EaseOut',
							onStep : function(values) {
								if ((curPos.y + values[0]) > 0
										|| curPos.y
												+ values[0]
												+ self._yaxes[0]._sax_renderer._subLayer
														.size().height <= self._yaxes[0]._sax_renderer._layer
														.size().height)
									return;
								self._seriesLayer.position({
									x : curPos.x,
									y : curPos.y + values[0]
								}); 
								self._yaxes[0].position(0, curPos.y	+ values[0]);
								self._chartModule._scrollBar[0].update();
								self._rootLayer.setNeedsDisplay();
							},
							onComplete : function() {
								var pos = comp._yaxes[0]._sax_renderer._subLayer.position().y;
								var overZeroHeight = comp._yaxes[0]._sax_renderer._subLayer.size().height + pos;
								if (pos > 0) {
									Animator.animate({
										values : [ {
											type : 'FLOAT',
											from : pos,
											to : 0
										} ],
										duration : 500,
										easing : 'EaseOut',
										onStep : function ( values ) {
											self._seriesLayer.position({
												x : 0,
												y : values[0]
											});
											self._yaxes[0].position(0, values[0]);
											self._chartModule._scrollBar[0].update();
											self._rootLayer.setNeedsDisplay();
										},
										onComplete : function() {
											self._chartModule._scrollBar[0].unHighLight();
										}
									});
								} else if (overZeroHeight < yaxisLayerSize.height) {
									Animator.animate({
										values : [ {
											type : 'FLOAT',
											from : pos,
											to : (yaxisLayerSize.height - overZeroHeight + pos)
										} ],
										duration : 500,
										easing : 'EaseOut',
										onStep : function ( values ) {
											self._seriesLayer.position({
												x : 0,
												y : values[0]
											});
											self._yaxes[0].position(0, values[0]);
											self._chartModule._scrollBar[0].update();
											self._rootLayer.setNeedsDisplay();
										},
										onComplete : function() {
											self._chartModule._scrollBar[0].unHighLight();
										}
									});
								} else {
									self._chartModule._scrollBar[0].unHighLight();
								}
							}
						});

						panMove = false;
					} else {
						// if you touch the chart and do not pan
						// the chart, you should unhighlight the
						// chart
						comp._chartModule._scrollBar[0].unHighLight();
						comp._rootLayer.setNeedsDisplay();
					}
				} else if (panGestureDetector.state() === GestureDetector.TransitionState.Cancelled) {

				}
			};
		})(),

		/**
		 * @param xscale,
		 *            scale size in xasix direction
		 * @param yscale,
		 *            scale size in yaxis direction
		 * @param viewPort,
		 *            visiable view size
		 * 
		 * if viewPort is exist, we only draw the visiable size
		 */
		scale : function(xscale, yscale, viewPort) {
			var curSize = this._seriesLayer.size();
			this._seriesLayer.size({
				width : curSize.width * xscale,
				height : curSize.height * yscale
			});

			this._barRenderer.drawViewPort(yscale, viewPort);

		},

		/**
		 * when user pinch the chart, we scale the chart
		 * according to the closest bar index to gesture. To
		 * avoid scale to quick, we compute the squre value of
		 * scale.
		 * 
		 * the max scale size: we set the max size is that one
		 * single domension in visible area.
		 * 
		 * the min scale size: we all the min size is that all
		 * the dimension in visible area. when user zoom in the
		 * chart and the chart's size is less than visible size,
		 * then zoom out the size to fulfill visible area.
		 * 
		 * Begin: store the values.
		 * 
		 * Chnaged: only draw the shapes in visible area to
		 * imporve the performance.
		 * 
		 * End: draw all the shapes
		 * 
		 * Cancle: To be implemented
		 */
		pinchingResize : (function() {
			var seriesLayerOldSize;
			var seriesLayerPosition;
			var seriesMaskLayerSize;
			var point;
			var pinchStartTime;
			var majorTicks;
			var closeMark;
			var seriesCount;
			var measureCount;
			var interval;
			var oriScale;
			return function(recognizer) {
				var comp = recognizer.attachedComponent();
				var tscale = recognizer.scale();
				// As the touch event is so sensitive, so we
				// should round the scale value
				// tscale = Math.sqrt(tscale);
				tscale = Math.round(tscale * 100) / 100;

				if (recognizer.state() === GestureDetector.TransitionState.Began) {

					seriesLayerOldSize = comp._seriesLayer.size(); // series layer's size
					seriesLayerPosition = comp._seriesLayer.position(); // series layer's position
					seriesMaskLayerSize = comp._seriesMaskLayer.size();
					point = recognizer.globalLocOfGesture();
					point.y = point.y - comp._seriesMaskLayer.position().y;
					// TODO: find the closed mark Tick
					pinchStartTime = new Date().getTime();

					majorTicks = comp._yaxes[0].getMajorTicks();
					interval = comp._yaxes[0].getTickInterval();
					var halfInterval = interval / 2;
					closeMark = -1;

					// find the close the mark index, if we can
					// find it. set he closeMark to the half
					// value of major size
					for ( var i = 0, len = majorTicks.length; i < len; i++) {
						if (Math.abs(majorTicks[i] - point.y + seriesLayerPosition.y) 
								<= halfInterval) {
							closeMark = i;
							break;
						}
					}
					if (closeMark === -1) {
						closeMark = Math.floor(majorTicks.length / 2);
					}

					seriesCount = comp._metaData.measureMembers.length > 20 ? 20
							: comp._metaData.measureMembers.length;
					measureCount = comp._dataTree.getSubMemberLabels().length;

					// when start to pinch, we should show
					// scroll bar
					comp._chartModule._scrollBar[0].highLight();
					comp._rootLayer.setNeedsDisplay();
					oriScale = tscale;
					
					//Fix the bug, [Ian 2012-04-26] VISUAL-1571 
					//[Bar] pinch without losing long touch cause line data marker and mouse over line show improperly.
					//if the first gesture is long press, clear it when pinch start.
					if(comp.islongPressGesture === true ){
						comp.islongPressGesture = false;
						comp._chartModule.onblur();
					}
					
				} else if (recognizer.state() == GestureDetector.TransitionState.Changed) {
					/**
					 * when touch move, in order to not draw shape
					 * too often, we calculate the size very 30 ms
					 */
					var scale = 0;
					scale = Math.round((tscale / oriScale) * 100) / 100;

					// Fix the bug, if the gesture is not move,
					// we should do not large the chart.
					if (tscale === oriScale) {
						return;
					}

					oriScale = tscale;
					
					var stime = new Date().getTime();
					//To do not draw chart too frequence, we can do pinch action every 0.005 second
					if ((stime - pinchStartTime) > 5) {
						pinchStartTime = stime;

						// To do not enlarge the size unlimited,
						// set the largest size is 4 times of
						// the background series size
						if (scale >= 1 && interval * scale >= seriesMaskLayerSize.height) {
							return;
						}

						// To do not curtail the size unlimited,
						// set the least size
						if (scale < 1 && interval * scale 
								<= seriesMaskLayerSize.height / (2 * measureCount)) {
							return;
						}

						interval *= scale;

						var yaxis = comp._yaxes;
						for ( var i = yaxis.length; i--;) {
							yaxis[i].zoom(1, scale, scale);
						}

						var offset = {
							x : 0,
							y : 0
						}
						var newMajorTicks = comp._yaxes[0].getMajorTicks();
						if (scale >= 1) {
							offset.y = majorTicks[closeMark]
									- newMajorTicks[closeMark]
									+ seriesLayerPosition.y;
						} else {
							offset.y = seriesLayerPosition.y
									- (newMajorTicks[closeMark] - majorTicks[closeMark]);
						}

						seriesLayerOldSize.height = seriesLayerOldSize.height * scale;
						comp._chartModule.position(offset.x, offset.y);

						comp._chartModule.scale(1, scale, seriesMaskLayerSize);
						comp._chartModule._scrollBar[0].update();
						comp._chartModule._gridLine.gestureUpdate();
						yaxis[0].position(0, offset.y);
						comp._rootLayer.setNeedsDisplay();
					}
				} 
				else if ( recognizer.state() == GestureDetector.TransitionState.Ended || recognizer.state() == GestureDetector.TransitionState.Cancelled ) {
					// redraw all the shapes
					comp._chartModule.scale(1, 1);
					comp._chartModule._scrollBar[0].update();
					comp._chartModule._scrollBar[0].unHighLight();
					comp._rootLayer.setNeedsDisplay();

					var size = comp._seriesLayer.size();
					if (size.height <= seriesMaskLayerSize.height) {
						var nscale = seriesMaskLayerSize.height/ size.height;

						var yaxis = comp._yaxes;
						for ( var i = yaxis.length; i--;) {
							yaxis[i].zoom(1, nscale, nscale);
							yaxis[i].position(0, 0);
						}

						comp._chartModule.scale(1, nscale);
						comp._seriesLayer.position({
							x : 0,
							y : 0
						});
						comp._chartModule._scrollBar[0].update();
						comp._chartModule._scrollBar[0].hidden();
						comp._chartModule._gridLine.gestureUpdate();
						comp._rootLayer.setNeedsDisplay();
						
					}
				}
			};
		})(),

		/**
		 * @param recognizer
		 * 
		 * if the gesture is reconginzer as a long press gesture, we will show tooltip.
		 * and set the variable islongPressGesture true.
		 * 
		 */
		longPressHandler:(function() {
			return function(recognizer){
				var comp = recognizer.attachedComponent();
				if (recognizer.state() === GestureDetector.TransitionState.Began) {
					comp.islongPressGesture = true;
					//get the global xy, to convert the point to series layer, we should do two thing.
					//1. convert the global point to plot component point.
					//2. convert the component point to series layer point.
					var globalXY = recognizer.globalLocOfGesture();
					var plotXY = comp.convertPointFromGlobal(globalXY);
					var targetLayer = comp._rootLayer;
					var point = comp._seriesLayer.convertPointFromLayer(plotXY, targetLayer);
					
					//do interaction when point hit.
					comp._chartModule.hoverOnPoint(point);
				}
			};
		})(),
		
		/**
		 * @param recognizer
		 * 
		 * Tap gesture on chart component
		 */
		tapHandler: function(recognizer){
			var comp = recognizer.attachedComponent();
			if (recognizer.state() === GestureDetector.TransitionState.Ended) {
				//get the global xy, to convert the point to series layer, we should do two thing.
				//1. convert the global point to plot component point.
				//2. convert the component point to series layer point.
				var globalXY = recognizer.globalLocOfGesture();
				var plotXY = comp.convertPointFromGlobal(globalXY);
				var targetLayer = comp._rootLayer;
				var point = comp._seriesLayer.convertPointFromLayer(plotXY, targetLayer);
				//do interaction when tap
				comp._chartModule.clickOnPoint(point);
			}
		},
		
		backUp : function() {
			this._hasBacked = true;
			this._backedYScale = this._yaxes[0]._sax_renderer._subLayer
					.size().height / this._yaxes[0]._sax_renderer._layer.size().height;
			this._backedYPoint = this._yaxes[0]._sax_renderer._subLayer.position().y;
		},

		restore : function() {
			if (this._hasBacked
					&& TypeUtils.isExist(this._backedYScale)
					&& TypeUtils.isExist(this._backedYPoint)) {
				
				//Fix the bug: [Ian] even though the chart is in its original size, the scroll bar is still show because we consider the 1 as an scale
				if(this._backedYScale <= 1.00000000001){
					return;
				}
				
				this._yaxes[0].setVisibleRange(1, this._backedYScale, this._backedYScale);
				this._yaxes[0].position(0, this._backedYPoint);

				var curSize = this._seriesLayer.size();
				this._seriesLayer.size({
					width : curSize.width,
					height : curSize.height * this._backedYScale
				});
				this.position(0, this._backedYPoint);

				// [Ian]Check whether it is in IPad, now we only
				// show the scroll bar in IPad, do not show it
				// in browser and another device.
				if (UADetector.os() === 'iPad') {
					this._scrollBar[0].update();
					this._scrollBar[0].unHighLight();
				}

				this._backedYScale = null;
				this._backedYPoint = null;
				this._hasBacked = false;
			}
		},

		applyTheme : function(theme) {
			this._barRenderer.applyTheme(theme);
		},

		hoverOnPoint : function(point) {
			// If do not exist the bar renderer, ignore the
			// hover event
			if (!this._barRenderer) {
				return;
			}

			var dataCtxOnPoint = this._barRenderer
					.hoverOnPoint(point);
			if (dataCtxOnPoint) {
				this.fireEvent('showTooltip', {
					name : 'showTooltip',
					data : [ {
						dimensionItemIndex : dataCtxOnPoint.dimensionItemIndex,
						point : point
					} ]
				});
			}
		},

		onblur : function(point) {
			this._barRenderer.onblur(point);
			// fire hide tooltip event
			this.fireEvent('hideTooltip', {
				name : 'hideTooltip',
				data : [ {} ]
			});
		},
		
		getPlotArea : function() {
		    return {
		        top : 0,
		        left : 0,
		        bottom : 0,
		        right : this._rightBound
		    };
		}

	});
	return BarModule;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.PinchGestureDetector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjUtils, GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	/**
	 * This class defines detector for detecting Pinching gesture.
	 * 
	 * @name sap.riv.vizkit.PinchGestureDetector
	 * @class
	 * @augments sap.riv.vizkit.GestureDetector
	 */
	var PinchGestureDetector = ObjUtils.derive(GestureDetector, {
		constructor : function() {
			this._origDistance = 1;
			this._currDistance = 1;
			this._startWhen = 0;
			this._stopWhen = 0;
		},

		_distance : function() {
			var points = [];
			for ( var tId in this._grTouchTracker) {
				points.push(this._grTouchTracker[tId].globalXY);
			}
			var dx = points[1].x - points[0].x;
			var dy = points[1].y - points[0].y;
			return Math.sqrt(dx * dx + dy * dy);
		},

		doTouchBegin : function(touchStartEvent) {
			var currentNumOfTouches = this.totalTouches();

			if (this.state() === ts.Possible) {
				if (currentNumOfTouches === 2) {
					var twoTouchDistance = this._distance();
					if (twoTouchDistance > 35) {
						this._origDistance = this._currDistance = twoTouchDistance;
						this._startWhen = this._stopWhen = touchStartEvent.timeStamp;
					} else {
						this._setState_(ts.Failed);
						return;
					}
				}
				// If more than 2 touches began, regard it as a failure
				else if (currentNumOfTouches > 2) {
					this._setState_(ts.Failed);
					return;
				}
				// If only one touch began, we can wait for another one to come.
			} else if ((this.state() === ts.Began || this.state() === ts.Changed)) {
				this._stopWhen = touchStartEvent.timeStamp;
				this._currDistance = this._distance();

				this._setState_(ts.Cancelled);
				return;
			}
		},

		doTouchMove : function(touchMoveEvent) {
			switch (this.state()) {
			case ts.Possible:
				if (this.totalTouches() === 2) {
					this._stopWhen = touchMoveEvent.timeStamp;
					this._currDistance = this._distance();

					var scale = this.scale();
					if (scale > 1.1 || scale < 0.9) {
						this._setState_(ts.Began);
					}
				}
				break;
			case ts.Began:
				if (Math.abs(this._origDistance - this._distance()) > 10) {
					this._stopWhen = touchMoveEvent.timeStamp;
					this._currDistance = this._distance();
					this._setState_(ts.Changed);
				}
				break;
			case ts.Changed:
				this._currDistance = this._distance();
				this._stopWhen = touchMoveEvent.timeStamp;
				this._setState_(ts.Changed);
				break;
			}
		},

		doTouchEnd : function(touchEndEvent) {
			if ((this.state() === ts.Began || this.state() === ts.Changed) && this.totalTouches() === 0) {
				this._stopWhen = touchEndEvent.timeStamp;
				this._currDistance = this._distance();
				this._setState_(ts.Ended);
			} else if (this.state() === ts.Possible) {
				this._setState_(ts.Failed);
			}
		},

		doTouchCancel : function(touchCancelEvent) {
			if (this.state() === ts.Began || this.state() === ts.Changed) {
				this._stopWhen = touchCancelEvent.timeStamp;
				this._currDistance = this._distance();
				this._setState_(ts.Cancelled);
			} else if (this.state() === ts.Possible) {
				this._setState_(ts.Failed);
			}
		},
		/**
		 * The current scale of the pinching gesture
		 * 
		 * 
		 * @name sap.riv.vizkit.PinchGestureDetector#scale
		 * @function
		 * @return {Number}
		 */
		scale : function() {
			return this._currDistance / this._origDistance;
		},
		/**
		 * The current velocity of the pinching gesture
		 * 
		 * 
		 * @name sap.riv.vizkit.PinchGestureDetector#velocity
		 * @function
		 * @return {Number}
		 */
		velocity : function() {
			var duration = this._startWhen - this._stopWhen;
			if (duration) {
				return Math.abs((this._currDistance - this._origDistance)) * 1000 / duration;
			} else {
				return 0;
			}
		},
		reset : function() {
			this.callParent('reset');

			this._origDistance = 1;
			this._currDistance = 1;
			this._startWhen = 0;
			this._stopWhen = 0;
		}
	});
	return PinchGestureDetector;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.CombinationModule',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Animator',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.axis.Axis',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.SeriesGroup',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.ColumnBarRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.LineRenderer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.SeriesHighlighter',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.ChartModule',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, FunctionUtils, LOG, UADetector, GestureDetector, Animator,
		Axis, SeriesGroup, Series, ColumnBarRenderer, LineRenderer, SeriesHighlighter, ChartModule) {
	var defaultOptions = {
			xAxis :{
				showMajor : false,        
				majorColor :  '#c9c9c9',
				majorThickness : '1',

				showMinor : false,                                 
				minorColor : '#c9c9c9',
				minorThickness : '1',

				showSub : false,
				subColor :'#c9c9c9'
			},
			yAxis :{
				showMajor : true,        
				majorColor :  '#c9c9c9',
				majorThickness : '1',

				showMinor : false,                                 
				minorColor : '#c9c9c9',
				minorThickness : '1',

				showSub : false,
				subColor :'#c9c9c9'
			}
	};
	
	var CombinationModule = ObjUtils.derive(ChartModule, {
		events : [ 'selectData', 'showTooltip', 'hideTooltip' ],

		constructor : function(options) {
			this._valueAxisRange = [];
			this._barSeriesGroup = null;
			this._lineSeriesGroup = null;
			this._columnBarRenderer = null;
			this._hasDrawn = false;
			this._hasBacked = false;
			this._tooltipEnabled = options.properties.tooltip.enable;
		},

		initGridLineProperties : function() {
			this._xAxis_gridLine_option = ObjUtils
					.extend(
							true,
							defaultOptions.xAxis,
							this._chart_options.properties.xAxis[0].gridLine);
			this._yAxis_gridLine_option = ObjUtils
					.extend(
							true,
							defaultOptions.yAxis,
							this._chart_options.properties.yAxis[0].gridLine);

			this._gridLine.setXAxisOptions(this._xAxis_gridLine_option);
			this._gridLine.setYAxisOptions(this._yAxis_gridLine_option);
			// Nick - if users have some wrong settings, we do not throw any error, but the behavior is unexpected.
			// be consistent with showMajorticks
			//this.gridLinePropertiesCheck();
		},
		
		gridLinePropertiesCheck : function() {
			// Nick - if users have some wrong settings for the grid line, an error is thrown out
			if((!this._yAxis_gridLine_option.showMajor && this._yAxis_gridLine_option.showSub) || this._xAxis_gridLine_option.showMajor || this._xAxis_gridLine_option.showMinor){
				FunctionUtils.error("Wrong settings for grid line of combination chart");
			}
			
		},

		initAxes : function() {
			this._initXAxes();
			this._initYAxes();
		},

		_initXAxes : function() {
			this._xaxes = [];
			var xaxesOption = this._chart_options.properties.xAxis;
			var labels = this._dataTree.getSubMemberLabels();
			if(labels.length < 1){
				labels = [];
				labels.push('1');
			}
			for ( var i = 0, len = xaxesOption.length; i < len; i++) {
				if ( TypeUtils.isExist(xaxesOption[i].showTitle) && xaxesOption[i].showTitle
						&& !TypeUtils.isExist(xaxesOption[i].title) ) {
					xaxesOption[i].title = "X" + (i + 1);
				}
				
				var option = {
					mode : Axis.DIMENSION,
					position : 'hb',
					labels : labels
				}
				var x = new Axis(ObjUtils.extend(true, option, xaxesOption[i]));
				this._xaxes.push(x);
			}
		},

		_initYAxes : function() {
			this._yaxes = [];
			var yaxesOption = this._chart_options.properties.yAxis;
			for ( var i = 0, len = yaxesOption.length; i < len; i++) {
				if ( TypeUtils.isExist(yaxesOption[i].showTitle) && yaxesOption[i].showTitle
						&& !TypeUtils.isExist(yaxesOption[i].title) ) {
					yaxesOption[i].title = "Y" + (i + 1);
				}
				
				// FIX ISSUE: if there are two axis and more
				// than one series, but it only use the one
				// series. so according to the valueAxisRange
				// to judge whether the axis is to been used.
				// when it is not to been used, set the min 0,
				// max 0
				var option = {
					mode : Axis.LINEAR,
					position : i === 0 ? 'vl' : 'vr',
					maxValue : TypeUtils
							.isExist(this._valueAxisRange[i]) ? this._valueAxisRange[i].max
							: 0,
					minValue : TypeUtils
							.isExist(this._valueAxisRange[i]) ? this._valueAxisRange[i].min
							: 0
				}
				var y = new Axis(ObjUtils.extend(true, option, yaxesOption[i]));
				this._yaxes.push(y);
			}
		},

		initSeries : function() {
			this._valueAxisRange = [];
			var seriesOption = this._chart_options.properties.measures;
			var measureMembers = this._metaData.measureMembers;
			var defaultColor = this._chart_options.properties.measureDefault.colors;
			var barOptions = this._chart_options.properties.bar;
			var lineOptions = this._chart_options.properties.line;
			this._barSeriesGroup = new SeriesGroup();
			this._lineSeriesGroup = new SeriesGroup();

			for ( var i = 0, len = measureMembers.length; i < len; i++) {
				var opts = ObjUtils.extend(true, {},
						barOptions, lineOptions,
						seriesOption[i]);
				opts.fillColor = TypeUtils
						.isExist(opts.fillColor) ? opts.fillColor
						: defaultColor[i % defaultColor.length];
				opts.lineColor = TypeUtils
						.isExist(opts.lineColor) ? opts.lineColor
						: defaultColor[i % defaultColor.length];

				var s = new Series(opts);
				s.setName(measureMembers[i]);
				s.setData(this._data[i]);
				if (this._chart_options.properties.measure.type === 'bar' || opts.type === 'bar') {
					this._barSeriesGroup.addSeries(s);
				} else {
					this._lineSeriesGroup.addSeries(s);
				}

				var valueAxis = opts.valueAxis || 0;
				this._updateValueAxisRange(s.getDataRange(), valueAxis);
			}
		},

		/**
		 * in bar chart, the scroll bar is in the right side of
		 * the chart and there is only one scroll bar.
		 */
		initScrollBar : function() {
			//Fix the bug:[Ian] if you update the chart, the scroll bar will show as we do not remove the first scrollBar
			if(this._scrollBar.length > 0){
				for(var i=0; i<this._scrollBar.length; i++){
					this._scrollBar[i].remove();
				}
			}
			
			// init scroll bar layer
			this._scrollBar = [];
			this._scrollBar[0] = this.scrollBar();

		},

		updateValueAxisRange : function() {
			this._valueAxisRange = [];
			var seriesOption = this._chart_options.properties.measures;
			var measureOption =  this._chart_options.properties.measure;
			var barSeriesIndex = 0, lineSeriesIndex = 0;
			var barSeries = this._barSeriesGroup.getSeriesList();
			var lineSeries = this._lineSeriesGroup.getSeriesList();
			
			var series;
			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var o = seriesOption[i] || {};
				// [Ian 2012-3-29] To check whether the series
				// is visible, if do not, we will do not create
				// the series, so it will do not be append to
				// the context
				o.visible = TypeUtils.isExist(o.visible) ? o.visible : true;
				if (o.visible) {
					var valueAxis = o.valueAxis || 0;
					if (o.type === 'bar' || measureOption.type == 'bar') {
						series = barSeries[barSeriesIndex];
						barSeriesIndex++;
					} else {
						series = lineSeries[lineSeriesIndex];
						lineSeriesIndex++;
					}
					this._updateValueAxisRange(series.getDataRange(), valueAxis);
				}
			}
		},
		
		_updateValueAxisRange : function(range, valueAxis) {
			if (this._valueAxisRange[valueAxis] === undefined) {
				this._valueAxisRange[valueAxis] = {
					max : Number.NEGATIVE_INFINITY,
					min : Number.POSITIVE_INFINITY
				};
			}

			if (range.max > this._valueAxisRange[valueAxis].max) {
				this._valueAxisRange[valueAxis].max = range.max;
			}
			if (range.min < this._valueAxisRange[valueAxis].min) {
				this._valueAxisRange[valueAxis].min = range.min;
			}
		},

		bindSeriesWithAxes : function() {
			var seriesOption = this._chart_options.properties.measures;

			var barSeriesIndex = 0, lineSeriesIndex = 0;
			var barSeries = this._barSeriesGroup.getSeriesList();
			var lineSeries = this._lineSeriesGroup.getSeriesList();
			
			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++ ) {
				var o = seriesOption[i] || {};

				var valueAxis = o.valueAxis || 0;
				if ( this._chart_options.properties.measure.type === 'bar' || o.type === 'bar') {
					barSeries[barSeriesIndex].setXAxis(this._xaxes[0]);
					barSeries[barSeriesIndex].setYAxis(this._yaxes[valueAxis]);
					barSeriesIndex++;
				} else {
					lineSeries[lineSeriesIndex].setXAxis(this._xaxes[0]);
					lineSeries[lineSeriesIndex].setYAxis(this._yaxes[valueAxis]);
					lineSeriesIndex++;
				}
			}
		},

		bindRenderer : function(layer) {
			if (this._columnBarRenderer == null
					&& this._lineRenderer == null) {
				this._columnBarRenderer = new ColumnBarRenderer(layer,
						this._chart_options.properties.bar);
				this._lineRenderer = new LineRenderer(layer,
						this._chart_options.properties.line);
			} else {
				this._columnBarRenderer.resetSeriesGroup();
				this._lineRenderer.resetSeriesGroup();
			}
			
			this._columnBarRenderer.addSeriesGroup(this._barSeriesGroup);
			this._lineRenderer.addSeriesGroup(this._lineSeriesGroup);
		},

		drawSeries : function() {
			// =====================================================================
			// Selection specifics 
			var selectionOptions = this._chart_options.properties.selectability;
			var maxSelections = 0;
			if ( selectionOptions.mode === 'single' ) {
				maxSelections = 1;
			}
			if ( selectionOptions.mode === 'multiple' ) {
				maxSelections = 1000;
			}
			
			if ( !this._highlighter ) {
				if ( this._defaultSelectionArmed ) {
					this._highlighter = new SeriesHighlighter(
						[ this._columnBarRenderer, this._lineRenderer ],
						maxSelections, true);
					if ( selectionOptions.mode !== 'none'
							&& selectionOptions.defaultSelectedItems.length !== 0 
							&& TypeUtils.isDefined(selectionOptions.defaultSelectedItems[0].measureIndex) ) {
						this._highlighter.setTargets(selectionOptions.defaultSelectedItems);
						this._highlighter.run();
					}
					this._defaultSelectionArmed = false;
				}
			} else {
				this._highlighter.run();
			}
			// =====================================================================
			
			if (!this._hasDrawn) {
				this._columnBarRenderer.draw();
				this._lineRenderer.draw();
				this._hasDrawn = true;
			} else {
				this._columnBarRenderer.redraw();
				this._lineRenderer.redraw();
			}
			this._highlighter.reload();
		},

		/**
		 * To align the yaxis and xaxis, we should adjust the
		 * position of axis to an integer position. so we do
		 * following adjustment. 1. set the ceiled y position
		 * and floored x position of yaxis[0] 2. set the floored
		 * x position and rounded y position of xaxis[0] 3. set
		 * the floored y position and rounded x position of
		 * xaxis[1] if it exists 4. set the floored y position
		 * and floored x position of seriesMaskLayer
		 */
		doChartLayout : function(nsize, yaxisLayers,
				xaxisLayers, seriesMaskLayer, seriesLayer) {
			this._seriesLayer = seriesLayer;

			var xTop = {
				width : 0,
				height : 0
			};
			var xBottom = {
				width : 0,
				height : 0
			};
			var yLeft = {
				width : 0,
				height : 0
			};
			var yRight = {
				width : 0,
				height : 0
			};

			// TODO: currently only left yaxis
			yLeft.width += this._yaxes[0].getPreferredWidth();
			if (this._yaxes.length === 2) {
				yRight.width += this._yaxes[1].getPreferredWidth();
			}
			var tempXaxisLength = (nsize.width - yLeft.width - yRight.width) * 0.95;

			this._xaxes[0].updateProperties({
				distance : tempXaxisLength
			});
			
			xBottom.width += this._xaxes[0].getPreferredWidth();
			xBottom.height += this._xaxes[0].getPreferredHeight();

			var topPadding = xTop.height > 0 ? xTop.height : nsize.height * 0.1;

			var tempYaxisLength = (nsize.height - xBottom.height - topPadding) * 0.95;
			this._yaxes[0].updateProperties({
				distance : tempYaxisLength
			});
			yLeft.height += this._yaxes[0].getPreferredHeight();

			// TODO: currently only primary(at left) and
			// secondary(at right) yaxis
			if (this._yaxes.length === 2) {
				this._yaxes[1].updateProperties({
					distance : tempYaxisLength
				});
				yRight.height += this._yaxes[1].getPreferredHeight();
			}

			yaxisLayers[0].size({
				width : yLeft.width,
				height : yLeft.height
			});
			yaxisLayers[0].position({
				x : 0,
				y : Math.ceil(topPadding)
			})

			xaxisLayers[0].size({
				width : xBottom.width,
				height : xBottom.height
			});

			xaxisLayers[0].position({
				x : Math.floor(this._yaxes[0].getAxisWidth()),
				y : Math.ceil(topPadding)
						+ Math.round(this._yaxes[0]
								.getFirstTickOffset())// Math.floor(yLeft.height
			// -
			// this._yaxes[0].getLastTickOffset())
			});

			if (yRight.height > 0) {
				// Top X axis is enabled
				yaxisLayers[1].size({
					width : yRight.width,
					height : yRight.height
				});
				yaxisLayers[1].position({
					x : Math.floor(this._yaxes[0].getAxisWidth()
							+ xBottom.width
							- this._yaxes[1].getMajorTickWidth() / 2),
					y : Math.ceil(topPadding)
				});
			}

			seriesMaskLayer.size({
				width : tempXaxisLength,
				height : tempYaxisLength + this._yaxes[0].getLastTickOffset()
			});
			seriesMaskLayer.position({
				x : Math.floor(this._yaxes[0].getAxisWidth()),
				y : Math.floor(xTop.height > 0 ? this._xaxes[1].getAxisWidth() : topPadding)
			});

			seriesLayer.size(seriesMaskLayer.size());
			seriesLayer.position({
				x : 0,
				y : 0
			});

			this._scrollBar[0].init(seriesMaskLayer, seriesLayer, 'horizontal');

			if (!this._hasBacked) {
				this._updateVisibleRange();
			} else {
				this.restore();
			}
			
			this._topBound = topPadding + this._yaxes[0].getLastTickOffset();
		},

		/**
		 * scale the series layer according to the user's
		 * visible range option if the start or end is invalid,
		 * it will draw whole dimension
		 */
		_updateVisibleRange : function() {
			var visibleRangeOption = this._chart_options.properties.visibleRange;

			var visibleRangeStart = visibleRangeOption.start;
			var visibleRangeEnd = visibleRangeOption.end;
			if ( visibleRangeStart < 0
					|| visibleRangeEnd < 0
					|| visibleRangeStart > this._dataTree.getSubMemberLabels().length - 1
					|| visibleRangeEnd > this._dataTree.getSubMemberLabels().length - 1
					|| visibleRangeStart > visibleRangeEnd ) {
				visibleRangeStart = 0;
				visibleRangeEnd = this._dataTree.getSubMemberLabels().length - 1;
			}

			if ( visibleRangeStart === 0
					&& visibleRangeEnd === this._dataTree.getSubMemberLabels().length - 1 )
				return;

			var range = visibleRangeEnd - visibleRangeStart + 1;
			var scale = this._dataTree.getSubMemberLabels().length / range;
			this._xaxes[0].setVisibleRange(scale, 1, scale);

			var interval = this._xaxes[0].getTickInterval();
			this._xaxes[0].position(-interval * visibleRangeStart, 0);

			var curSize = this._seriesLayer.size();
			this._seriesLayer.size({
				width : curSize.width * scale,
				height : curSize.height
			});
			this.position(-interval * visibleRangeStart, 0);
			if (UADetector.os() === 'iPad') {
				this._scrollBar[0].update();
				this._scrollBar[0].unHighLight();
			}

		},

		updateProperties : function(propBag) {
			this.callParent('updateProperties', propBag);

			var seriesOption = this._chart_options.properties.measures;
			var measureOption =  this._chart_options.properties.measure;
			var barSeriesProperties = [], lineSeriesProperties = [];
			var defaultColor = this._chart_options.properties.measureDefault.colors;
			var barOptions = this._chart_options.properties.bar;
			var lineOptions = this._chart_options.properties.line;
			this._tooltipEnabled = this._chart_options.properties.tooltip.enable;

			if (TypeUtils.isExist(barOptions)) {
				this._columnBarRenderer.updateProperties(barOptions);
			}
			if (TypeUtils.isExist(lineOptions)) {
				this._lineRenderer.updateProperties(lineOptions);
			}

			for ( var i = 0, len = this._metaData.measureMembers.length; i < len; i++) {
				var opts = ObjUtils.extend(true, {},
						barOptions, lineOptions,
						seriesOption[i]);
				opts.fillColor = TypeUtils
						.isExist(opts.fillColor) ? opts.fillColor
						: defaultColor[i % defaultColor.length];
				opts.lineColor = TypeUtils
						.isExist(opts.lineColor) ? opts.lineColor
						: defaultColor[i % defaultColor.length];
				if (opts.type === 'bar' || measureOption.type === 'bar') {
					barSeriesProperties.push(opts);
				} else {
					lineSeriesProperties.push(opts);
				}
			}

			this._barSeriesGroup.updateProperties(barSeriesProperties);
			this._lineSeriesGroup.updateProperties(lineSeriesProperties);
			
			// Resets renderer series groups and all previous selections
			// will be removed for now.
			if ( !this._hasDrawn ) {
				this.initSeries();
				this._columnBarRenderer.resetSeriesGroup();
				this._lineRenderer.resetSeriesGroup();
				this._columnBarRenderer.addSeriesGroup(this._barSeriesGroup);
				this._lineRenderer.addSeriesGroup(this._lineSeriesGroup);
			}
		},

		applyTheme : function(theme) {
			if (this._columnBarRenderer) {
				this._columnBarRenderer.applyTheme(theme);
			}
			if (this._lineRenderer) {
				this._lineRenderer.applyTheme(theme);
			}
		},
		/**
		 * @override sap.riv.viz.xychart.ChartModule.getSupportedEvents
		 */
		getSupportedAppEvents : function() {
			return [ 'selectData', 'showTooltip', 'hideTooltip' ];
		},

		clickOnPoint : function ( coord ) {
			var dataContext = this.select(coord);
			if ( TypeUtils.isDefined(dataContext)  && dataContext.length > 0 ) {
				var dataContextItem = dataContext[dataContext.length - 1];
				this.fireEvent("selectData", {
					"name" : "selectData",
					"data" : [{
						dimensionAxisIndex : 0,
						dimensionAxisIndex : 0,
						dimensionIndex : 0,
						dimensionItemIndex : dataContextItem.dimensionItemIndex,
						measureIndex : dataContextItem.measureIndex,
						dimensionLabel : null,
						measureValue : null
					}]
				});
			}
		},
		
		/**
		 * Selects chart element(s) by user action or program commands.
		 * 
		 * @param target 
		 * - Target for locating chart element(s). If it's an object,
		 * then it's a point coordinate and an array of paths otherwise.
		 * 
		 * @returns {Object} dataContext
		 * - Contextual data generated while selection(s)
		 * 
		 * @author eye
		 */
		select : function ( target ) {
			if ( !target ) return;
			
			var selectionOptions = this._chart_options.properties.selectability;
			if ( selectionOptions.mode === 'none' ) return;
			
			if ( !this._highlighter.ready() ) {
				this._highlighter.reload();
			}
			
			if ( target instanceof Array ) {
				this._highlighter.setTargets(target);
				this._highlighter.run();
				return;
			}
			
			if ( TypeUtils.isDefined(target.x) ) {
				var path = this._highlighter.hits(target);
				if ( TypeUtils.isDefined(path.measureIndex) ) {
					if ( this._highlighter.isEnrolled(path) 
							&& selectionOptions.deSelectable ) {
						this._highlighter.remove(path);
					} else {
						this._highlighter.setTargets([path]);
					}
				} else {
					if ( selectionOptions.deSelectable ) {
						this._highlighter.erase();
					}
				}
				
				// Since only single selection is supported right now,
				// only the last element of data context items will be
				// returned. Well, actually, there can be multiple values
				// here.
				return this._highlighter.run(true);
			}
		},
		
		/**
		 * As the rangeInXY function only return the x y offset
		 * base on the init status. so the move function is also
		 * based on the init status, we can only pan the bar
		 * chart in horizontal direction
		 * 
		 * Begin: store some original value into variable
		 * 
		 * Change: move the xaxis layer and series layer in
		 * horizontal direction
		 * 
		 * Ended: at the end time, we should support damping
		 * effect. so calculate the distance by h = v* v/(2*g)
		 * and use bezierCurveTiming to render the chart
		 */
		panMove : (function() {
			var ySpeed;
			var panStartTime;
			var xaxisLayerSize;
			var xaxisSubLayerSize;
			var xaxisSubLayerPosition;
			var origSeriesPos;
			var panMove;

			return function ( panGestureDetector ) {
				var comp = panGestureDetector.attachedComponent();
				var range = panGestureDetector.rangeInXY();

				if ( panGestureDetector.state() === GestureDetector.TransitionState.Began ) {
					origSeriesPos = comp._seriesLayer.position();
					xaxisSubLayerSize = comp._xaxes[0]._sax_renderer._subLayer.size();
					xaxisSubLayerPosition = comp._xaxes[0]._sax_renderer._subLayer.position();
					xaxisLayerSize = comp._xaxes[0]._sax_renderer._layer.size();

					panStartTime = new Date().getTime();

					// when start to pan, if the chart is in
					// inital statue, we will do not show the
					// scrollbar
					if ( xaxisSubLayerSize.width > xaxisLayerSize.width ) {
						comp._chartModule._scrollBar[0].highLight();
					}

					panMove = false;
				} else if ( panGestureDetector.state() 
						=== GestureDetector.TransitionState.Changed ) {
					//Ian [2012-04-10] if the gesture is recongizer as a long press, we obly show tooltip 
					//and do not pan the chart
					if(panGestureDetector.attachedComponent().islongPressGesture === true ){
						/*var globalXY = panGestureDetector.globalLocOfGesture();
						var plotXY = comp.convertPointFromGlobal(globalXY);
						var targetLayer = comp._rootLayer;
						var point = comp._seriesLayer.convertPointFromLayer(plotXY, targetLayer);
						comp._chartModule.hoverOnPoint(point);
						*/
						return;
					}
					//End
					
					panMove = true;
					
					/*
					if ((origSeriesPos.x + range.x) >= 0
							|| (origSeriesPos.x + range.x
									+ comp._seriesLayer.size().width <= comp._seriesMaskLayer
									.size().width)) {
						return;
					}*/
					//Fix the bug[Ian 2012-4-19], when the chart is in the boundary, it is hard to move. 
					var xOffset = 0;

					if((origSeriesPos.x + range.x) > 0){
						xOffset = - origSeriesPos.x;
					}else if (origSeriesPos.x + range.x
									+ comp._seriesLayer.size().width <= comp._seriesMaskLayer
									.size().width){
						xOffset = comp._seriesMaskLayer.size().width - origSeriesPos.x - comp._seriesLayer.size().width ;
					}else{
						xOffset = range.x;
					}
					//End
					
					// move the series layer
					comp._chartModule.position(origSeriesPos.x + xOffset, origSeriesPos.y);
					comp._chartModule._scrollBar[0].update();

					// move yaxis
					var xaxis = comp._xaxes;
					for ( var i = xaxis.length; i--;) {
						xaxis[i].position(origSeriesPos.x + xOffset, 0);
					}
					ySpeed = panGestureDetector.velocityInXY().x;
					panStartTime = new Date().getTime();

				} else if ( panGestureDetector.state() === GestureDetector.TransitionState.Ended ) {
					if ((origSeriesPos.x + range.x) >= 0
							|| (origSeriesPos.x
									+ range.x
									+ comp._seriesLayer.size().width <= comp._seriesMaskLayer
									.size().width)) {
						// if the chart is in zoom status, we
						// should show the scrollbar and
						// unhighlight it.
						if (xaxisSubLayerSize.width > xaxisLayerSize.width) {
							comp._chartModule._scrollBar[0].unHighLight();
							comp._rootLayer.setNeedsDisplay();
						}
						panMove = false;
						return;
					}

					if ( panMove ) {
						// [Ian 2012-2-21] Fix the bug, we
						// should comfirm that do the inertia
						// effect only when the ySpeed is large
						// than 0
						if ( ySpeed === 0 ) {
							panMove = false;
							// if you touch the chart and pan
							// the chart at start time and do
							// not pan the chart at later, you
							// should unhighlight the chart
							comp._chartModule._scrollBar[0].unHighLight();
							comp._rootLayer.setNeedsDisplay();
							return;
						}
						// End

						var panAcceleration = (ySpeed - 0) / (new Date().getTime() - panStartTime);
						var self = comp;
						var curPos = self._seriesLayer.position();

						// as the distance is so small, we
						// enlarge it 10 times
						var s = ySpeed * ySpeed / (2 * panAcceleration) * 10;
						Animator.animate({
							values : [{
								type : 'FLOAT',
								from : 0.0,
								to : s
							}],
							duration : 600,
							easing : 'EaseOut',
							onStep : function ( values ) {
								if ( (curPos.x + values[0]) > 0
											|| curPos.x + values[0] + self._seriesLayer.size().width 
												<= self._seriesMaskLayer.size().width) {
										return;
									}
								self._seriesLayer.position({ x : curPos.x + values[0], y : 0 });
								self._xaxes[0].position(curPos.x + values[0], 0);
								self._chartModule._scrollBar[0].update();
								self._rootLayer.setNeedsDisplay();
							},
							onComplete : function() {
								var pos = comp._seriesLayer.position().x;
								var overZeroWidth = comp._seriesLayer.size().width + pos;
								if (pos > 0) {
									Animator.animate({
										values : [{
											type : 'FLOAT',
											from : pos,
											to : 0
										}],
										duration : 500,
										easing : 'EaseOut',
										onStep : function ( values ) {
											self._seriesLayer.position({
												x : values[0],
												y : 0
											});
											self._xaxes[0].position(values[0], 0);
											self._chartModule._scrollBar[0].update();
											self._rootLayer.setNeedsDisplay();
										},
										onComplete : function() {
											self._chartModule._scrollBar[0].unHighLight();
										}
									});
								} else if ( overZeroWidth < xaxisLayerSize.width ) {
									Animator.animate({
										values : [{
											type : 'FLOAT',
											from : pos,
											to : (xaxisLayerSize.width - overZeroWidth + pos)
										}],
										duration : 500,
										easing : 'EaseOut',
										onStep : function ( values ) {
											self._seriesLayer.position({
												x : values[0],
												y : 0
											});
											self._xaxes[0].position(values[0], 0);
											self._chartModule._scrollBar[0].update();
											self._rootLayer.setNeedsDisplay();
										},
										onComplete : function() {
											self._chartModule._scrollBar[0].unHighLight();
										}
									});
								} else {
									self._chartModule._scrollBar[0].unHighLight();
								}
							}
						});
						panMove = false;
					} else {
						// if you touch the chart and do not pan
						// the chart, you should unhighlight the
						// chart
						comp._chartModule._scrollBar[0].unHighLight();
						comp._rootLayer.setNeedsDisplay();
					}
				} else if (panGestureDetector.state() === GestureDetector.TransitionState.Cancelled) {

				}
			};
		})(),

		/**
		 * when user pinch the chart, we scale the chart
		 * according to the closest bar index to gesture. To
		 * avoid scale to quick, we compute the squre value of
		 * scale.
		 * 
		 * the max scale size: we set the max size is that one
		 * single domension in visible area.
		 * 
		 * the min scale size: we all the min size is that all
		 * the dimension in visible area. when user zoom in the
		 * chart and the chart's size is less than visible size,
		 * then zoom out the size to fulfill visible area.
		 * 
		 * Begin: store the values.
		 * 
		 * Chnaged: only draw the shapes in visible area to
		 * imporve the performance.
		 * 
		 * End: draw all the shapes
		 * 
		 * Cancle: To be implemented
		 */
		pinchingResize : (function() {
			var seriesLayerOldSize;
			var seriesLayerPosition;
			var seriesMaskLayerSize;
			var point;
			var pinchStartTime;
			var majorTicks;
			var closeMark;
			var seriesCount;
			var measureCount;
			var interval;
			var oriScale;
			return function(recognizer) {
				var comp = recognizer.attachedComponent();
				var tscale = recognizer.scale();
				// As the touch event is so sensitive, so we
				// should round the scale value
				// tscale = Math.sqrt(tscale);
				tscale = Math.round(tscale * 100) / 100;

				if (recognizer.state() === GestureDetector.TransitionState.Began) {

					seriesLayerOldSize = comp._seriesLayer.size(); // series
					// layer's size
					seriesLayerPosition = comp._seriesLayer.position(); // series
					// layer's position
					seriesMaskLayerSize = comp._seriesMaskLayer.size();
					point = recognizer.globalLocOfGesture();
					point.x = point.x - comp._seriesMaskLayer.position().x;
					// TODO: find the closed mark Tick
					pinchStartTime = new Date().getTime();

					majorTicks = comp._xaxes[0].getMajorTicks();
					interval = comp._xaxes[0].getTickInterval();
					var halfInterval = interval / 2;
					closeMark = -1;

					// find the close the mark index, if we can
					// find it. set he closeMark to the half
					// value of major size
					for ( var i = 0, len = majorTicks.length; i < len; i++) {
						if (Math.abs(majorTicks[i] - point.x
								+ seriesLayerPosition.x) <= halfInterval) {
							closeMark = i;
							break;
						}
					}
					if (closeMark === -1) {
						closeMark = Math.floor(majorTicks.length / 2);
					}

					seriesCount = comp._metaData.measureMembers.length > 20 ? 20
							: comp._metaData.measureMembers.length;
					measureCount = comp._dataTree.getSubMemberLabels().length;

					// when start to pinch, we should show
					// scroll bar
					comp._chartModule._scrollBar[0].highLight();
					comp._rootLayer.setNeedsDisplay();
					oriScale = tscale;
					
					//Fix the bug, [Ian 2012-04-26] VISUAL-1571 
					//[combination] pinch without losing long touch cause line data marker and mouse over line show improperly.
					//if the first gesture is long press, clear it when pinch start.
					if(comp.islongPressGesture === true ){
						comp.islongPressGesture = false;
						comp._chartModule.onblur();
					}
				}
				/**
				 * when touch move, in order to not draw shape
				 * too often, we calculate the size very 30 ms
				 */
				else if (recognizer.state() == GestureDetector.TransitionState.Changed) {
					var scale = 0;
					scale = Math.round((tscale / oriScale) * 100) / 100;

					// Fix the bug, if the gesture is not move,
					// we should do not large the chart.
					if (tscale === oriScale) {
						return;
					}

					oriScale = tscale;

					var stime = new Date().getTime();

					//To do not draw chart too frequence, we can do pinch action every 0.005 second
					if ((stime - pinchStartTime) > 5) {
						pinchStartTime = stime;

						// To do not enlarge the size unlimited,
						// set the largest size is 4 times of
						// the background series size
						if (scale >= 1 && interval * scale >= seriesMaskLayerSize.width) {
							return;
						}

						// To do not curtail the size unlimited,
						// set the least size
						if (scale < 1 && interval * scale <= seriesMaskLayerSize.width
										/ (2 * measureCount)) {
							return;
						}

						interval *= scale;

						var xaxis = comp._xaxes;
						for ( var i = xaxis.length; i--;) {
							xaxis[i].zoom(scale, 1, scale);
						}

						var offset = {
							x : 0,
							y : 0
						}
						var newMajorTicks = comp._xaxes[0]
								.getMajorTicks();
						if (scale >= 1) {
							offset.x = majorTicks[closeMark]
									- newMajorTicks[closeMark]
									+ seriesLayerPosition.x;
						} else {
							offset.x = seriesLayerPosition.x
									- (newMajorTicks[closeMark] - majorTicks[closeMark]);
						}

						seriesLayerOldSize.width = seriesLayerOldSize.width * scale;
						comp._chartModule.position(offset.x, offset.y);

						comp._chartModule.scale(scale, 1, seriesMaskLayerSize);
						comp._chartModule._scrollBar[0].update();
						comp._chartModule._gridLine.gestureUpdate();
						xaxis[0].position(offset.x, 0);
						comp._rootLayer.setNeedsDisplay();
					}
				}
				/**
				 * redraw all the shapes when pinch end or cancel
				 */
				else if (recognizer.state() == GestureDetector.TransitionState.Ended || recognizer.state() == GestureDetector.TransitionState.Cancelled) {
					comp._chartModule.scale(1, 1);
					comp._chartModule._scrollBar[0].update();
					comp._chartModule._scrollBar[0].unHighLight();
					comp._rootLayer.setNeedsDisplay();

					var size = comp._seriesLayer.size();
					if (size.width <= seriesMaskLayerSize.width) {
						var nscale = seriesMaskLayerSize.width / size.width;

						var xaxis = comp._xaxes;
						for ( var i = xaxis.length; i--;) {
							xaxis[i].zoom(nscale, 1, nscale);
							xaxis[i].position(0, 0);
						}

						comp._chartModule.scale(nscale, 1);
						comp._seriesLayer.position({
							x : 0,
							y : 0
						});
						comp._chartModule._scrollBar[0].update();
						comp._chartModule._scrollBar[0].hidden();
						comp._chartModule._gridLine.gestureUpdate();
						comp._rootLayer.setNeedsDisplay();
						
					}
					
					comp._chartModule._highlighter.reload();
				}
			};
		})(),

		/**
		 * @param recognizer
		 * 
		 * if the gesture is reconginzer as a long press
		 * gesture, we will show tooltip. and set the variable
		 * islongPressGesture true.
		 * 
		 */
		longPressHandler : (function() {
			return function(recognizer) {
				var comp = recognizer.attachedComponent();
				if (recognizer.state() === GestureDetector.TransitionState.Began) {
					comp.islongPressGesture = true;
					// get the global xy, to convert the point
					// to series layer, we should do two thing.
					// 1. convert the global point to plot
					// component point.
					// 2. convert the component point to series
					// layer point.
					var globalXY = recognizer
							.globalLocOfGesture();
					var plotXY = comp
							.convertPointFromGlobal(globalXY);
					var targetLayer = comp._rootLayer;
					var point = comp._seriesLayer
							.convertPointFromLayer(plotXY,
									targetLayer);

					//do interaction when point hit.
					comp._chartModule.hoverOnPoint(point);
				}
			};
		})(),
		
		/**
		 * @param recognizer
		 * 
		 * Tap gesture on chart component
		 */
		tapHandler: function(recognizer){
			var comp = recognizer.attachedComponent();
			if (recognizer.state() === GestureDetector.TransitionState.Ended) {
				//get the global xy, to convert the point to series layer, we should do two thing.
				//1. convert the global point to plot component point.
				//2. convert the component point to series layer point.
				var globalXY = recognizer.globalLocOfGesture();
				var plotXY = comp.convertPointFromGlobal(globalXY);
				var targetLayer = comp._rootLayer;
				var point = comp._seriesLayer.convertPointFromLayer(plotXY, targetLayer);
				//do interaction when tap
				comp._chartModule.clickOnPoint(point);
			}
		},
		
		/**
		 * @param xscale,
		 *            scale size in xasix direction
		 * @param yscale,
		 *            scale size in yaxis direction
		 * @param viewPort,
		 *            visiable view size
		 * 
		 * if viewPort is exist, we only draw the visiable size
		 */
		scale : function(xscale, yscale, viewPort) {
			var curSize = this._seriesLayer.size();
			this._seriesLayer.size({
				width : curSize.width * xscale,
				height : curSize.height * yscale
			});

			this._columnBarRenderer.drawViewPort(xscale,
					viewPort);
			this._lineRenderer.drawViewPort(xscale, viewPort);
		},

		backUp : function() {
			this._hasBacked = true;
			this._backedXScale = this._xaxes[0]._sax_renderer._subLayer.size().width
					/ this._xaxes[0]._sax_renderer._layer.size().width;
			this._backedXPoint = this._xaxes[0]._sax_renderer._subLayer.position().x;
		},

		restore : function() {
			if (this._hasBacked
					&& TypeUtils.isExist(this._backedXScale)
					&& TypeUtils.isExist(this._backedXPoint)) {

				//Fix the bug: [Ian] even though the chart is in its original size, the scroll bar is still show because we consider the 1 as an scale
				if(this._backedXScale <= 1.00000000001){
					return;
				}
				
				this._xaxes[0].setVisibleRange(this._backedXScale, 1, this._backedXScale);
				this._xaxes[0].position(this._backedXPoint, 0);

				var curSize = this._seriesLayer.size();
				this._seriesLayer.size({
					width : curSize.width * this._backedXScale,
					height : curSize.height
				});
				this.position(this._backedXPoint, 0);

				// [Ian]Check whether it is in IPad, now we only
				// show the scroll bar in IPad, do not show it
				// in browser and another device.
				if (UADetector.os() === 'iPad') {
					this._scrollBar[0].update();
					this._scrollBar[0].unHighLight();
				}

				this._backedXScale = null;
				this._backedXPoint = null;
				this._hasBacked = false;
			}

		},

		hoverOnPoint : function(point) {
			// If do not exist the bar renderer, ignore the
			// hover event
			if (!this._columnBarRenderer && !this._lineRenderer) {
				return;
			}

			// In combination chart, if there is column bar, we
			// will do not show the line behind the chart, only
			// show the grey backgournd
			if (this._barSeriesGroup.getSeriesList().length > 0
					&& this._lineSeriesGroup.getSeriesList().length > 0) {
				var dataCtxOnPoint = this._columnBarRenderer.hoverOnPoint(point);
				this._lineRenderer.hoverOnPoint(point, false);
				if (dataCtxOnPoint) {
					this.fireEvent('showTooltip', {
						name : 'showTooltip',
						data : [ {
							dimensionItemIndex : dataCtxOnPoint.dimensionItemIndex,
							point : point
						} ]
					});
				}
			}
			// if only line chart, we will show the background
			// line
			else if (this._lineSeriesGroup.getSeriesList().length > 0) {
				var dataCtxOnPoint = this._lineRenderer
						.hoverOnPoint(point, this._tooltipEnabled);
				if (dataCtxOnPoint) {
					this.fireEvent('showTooltip', {
						name : 'showTooltip',
						data : [ {
							dimensionItemIndex : dataCtxOnPoint.dimensionItemIndex,
							point : point
						} ]
					});
				}
			}
			// if only column bar chart
			else {
				var dataCtxOnPoint = this._columnBarRenderer.hoverOnPoint(point);
				if (dataCtxOnPoint) {
					this.fireEvent('showTooltip', {
						name : 'showTooltip',
						data : [ {
							dimensionItemIndex : dataCtxOnPoint.dimensionItemIndex,
							point : point
						} ]
					});
				}
			}
		},

		onblur : function(point) {
			if (this._barSeriesGroup.getSeriesList().length > 0) {
				this._columnBarRenderer.onblur(point);
				this._lineRenderer.onblur(point);
			} else {
				this._lineRenderer.onblur(point);
			}

			this.fireEvent('hideTooltip', {
				name : 'hideTooltip',
				data : [ {} ]
			});
		},
		
		getPlotArea : function() {
            return {
                top : this._topBound,
                left : 0,
                bottom : 0,
                right : 0
            };
        }
	});
	return CombinationModule;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.LongPressGestureDetector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjUtils, GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	var _distance = function(xy1, xy2) {
		var dx = xy1.x - xy2.x;
		var dy = xy1.y - xy2.y;
		return Math.sqrt(dx * dx + dy * dy);
	};
	/**
	 * This class defines detector for detecting long press gesture. Long press
	 * gesture is detected when required number of fingers touch the screen for
	 * a specified period and the touches don't move beyond the allowable
	 * movement distance.
	 * 
	 * @name sap.riv.vizkit.LongPressGestureDetector
	 * @class
	 * @augments sap.riv.vizkit.GestureDetector
	 */
	var LongPressGestureDetector = ObjUtils.derive(GestureDetector, {

		constructor : function(touchesRequired) {
			this._touchesRequired = (touchesRequired > 0 && touchesRequired < 6) ? touchesRequired : 1;
			this._minimumPressDuration = 500;
			this._allowableMovement = 10;

			this._distanceFromStart = 0;
			this._startXY = undefined;
		},

		/**
		 * The minimum press duration before a long press gesture can be
		 * detected. The duration is in milliseconds. The default duration is
		 * 500 milliseconds.
		 * 
		 * @function
		 * @returns {Number|this}
		 */
		minimumPressDuration : function(duration) {
			if (duration !== undefined) {
				this._minimumPressDuration = duration;
			} else {
				return this._minimumPressDuration;
			}
		},

		/**
		 * The allowable distance the touches can move for a long press gesture
		 * to be detected. The duration is in pixels. The default distance is 10
		 * pixels.
		 * 
		 * @function
		 * @returns {Number|this}
		 */
		allowableMovement : function(distance) {
			if (distance !== undefined) {
				this._allowableMovement = distance;
			} else {
				return this._allowableMovement;
			}
		},

		doTouchBegin : function(touchStartEvent) {
			var currentNumOfTouches = this.totalTouches();
			if (currentNumOfTouches === this._touchesRequired && this.state() === ts.Possible) {
				this._startXY = this.globalLocOfTouchPoints();
				clearTimeout(this._timeoutId);
				this._timeoutId = setTimeout(ObjUtils.proxy(
						function() {
							if (this._startXY && this.state() === ts.Possible
									&& this.totalTouches() === this._touchesRequired) {
								this._setState_(ts.Began);
							}
						}, this), this._minimumPressDuration);
			} else if (currentNumOfTouches > this._touchesRequired) {
				if (this.state() === ts.Began || this.state() === ts.Changed) {
					this._setState_(ts.Cancelled);
				} else if (this.state() === ts.Possible) {
					this._setState_(ts.Failed);
				}
			}
		},

		doTouchMove : function(touchMoveEvent) {
			switch (this.state()) {
			case ts.Possible:
				if (this._startXY) {
					this._distanceFromStart = _distance(this._startXY, this.globalLocOfTouchPoints());
					if (this._distanceFromStart > this._allowableMovement)
						this._setState_(ts.Failed);
				}
				break;
			case ts.Began:
			case ts.Changed:
				if (_distance(this._startXY, this.globalLocOfTouchPoints()) <= this._allowableMovement) {
					this._setState_(ts.Changed);
				} else
					this._setState_(ts.Cancelled);
				break;
			}
		},

		doTouchEnd : function(touchEndEvent) {
			if (this.state() === ts.Began || this.state() === ts.Changed) {
				this._setState_(ts.Ended);
			} else if (this.state() === ts.Possible) {
				this._setState_(ts.Failed);
			}
		},

		doTouchCancel : function(touchCancelEvent) {
			if (this.state() === ts.Began || this.state() === ts.Changed) {
				this._setState_(ts.Cancelled);
			} else if (this.state() === ts.Possible) {
				this._setState_(ts.Failed);
			}
		},

		reset : function() {
			this.callParent('reset');
			this._startXY = undefined;
			this._distanceFromStart = 0;
		}
	});

	return LongPressGestureDetector;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.PanGestureDetector',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(ObjUtils, GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	var _distance = function(xy1, xy2) {
		var dx = xy1.x - xy2.x;
		var dy = xy1.y - xy2.y;
		return Math.sqrt(dx * dx + dy * dy);
	};
	/**
	 * This class defines detector for detecting Panning gesture. Panning
	 * gesture is detected when required number of fingers touch the screen and
	 * move a reasonable distance.
	 * 
	 * @name sap.riv.vizkit.PanGestureDetector
	 * @class
	 * @augments sap.riv.vizkit.GestureDetector
	 */
	var PanGestureDetector = ObjUtils.derive(GestureDetector, {
		constructor : function(touchesRequired) {
			this._touchesRequired = (touchesRequired > 0 && touchesRequired < 6) ? touchesRequired : 1;
			this._startXY = undefined;
			this._lastXY = undefined;
			this._currentXY = undefined;
			this._startWhen = 0;
			this._stopWhen = 0;
		},

		doTouchBegin : function(touchStartEvent) {
			var currentNumOfTouches = this.totalTouches();
			if (currentNumOfTouches === this._touchesRequired && this.state() === ts.Possible) {
				this._startWhen = this._stopWhen = touchStartEvent.timeStamp;
				this._startXY = this._lastXY = this._currentXY = this.globalLocOfTouchPoints();
				this._setState_(ts.Began);
			} else if (currentNumOfTouches > this._touchesRequired) {
				if (this.state() === ts.Began || this.state() === ts.Changed) {
					this._stopWhen = touchStartEvent.timeStamp;
					this._lastXY = this._currentXY;
					this._currentXY = this.globalLocOfTouchPoints();
					this._setState_(ts.Cancelled);
				} else {
					this._setState_(ts.Failed);
				}
			}
		},
		doTouchMove : function(touchMoveEvent) {
			switch (this.state()) {
			case ts.Began:
				if (_distance(this._startXY, this.globalLocOfTouchPoints()) > 10) {
					this._startWhen = this._stopWhen;
					this._stopWhen = touchMoveEvent.timeStamp;
					this._lastXY = this._currentXY;
					this._currentXY = this.globalLocOfTouchPoints();
					this._setState_(ts.Changed);
				}
				break;
			case ts.Changed:
				this._startWhen = this._stopWhen;
				this._stopWhen = touchMoveEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this._setState_(ts.Changed);
				break;
			}
		},
		doTouchEnd : function(touchEndEvent) {
			if ((this.state() === ts.Began || this.state() === ts.Changed) && this.totalTouches() === 0) {
				this._startWhen = this._stopWhen;
				this._stopWhen = touchEndEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this._setState_(ts.Ended);
			}
		},

		doTouchCancel : function(touchCancelEvent) {
			if (this.state() === ts.Began || this.state() === ts.Changed) {
				this._startWhen = this._stopWhen;
				this._stopWhen = touchCancelEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this._setState_(ts.Cancelled);
			}
		},

		/**
		 * The current moving range in X,Y direction of the gesture
		 * 
		 * <pre>
		 * {
		 * 		x : ###,
		 * 		y : ###
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.vizkit.PanGestureDetector#rangeInXY
		 * @function
		 * @return {POINT}
		 */
		rangeInXY : function() {
			return {
				x : this._currentXY.x - this._startXY.x,
				y : this._currentXY.y - this._startXY.y
			};
		},

		/**
		 * The current moving velocity in X,Y direction of the gesture
		 * 
		 * <pre>
		 * {
		 * 		x : ###,
		 * 		y : ###
		 * }
		 * </pre>
		 * 
		 * @name sap.riv.vizkit.PanGestureDetector#velocityInXY
		 * @function
		 * @return {POINT}
		 */
		velocityInXY : function() {
			var duration = this._stopWhen - this._startWhen;
			if (duration) {
				return {
					x : (this._currentXY.x - this._lastXY.x) / duration,
					y : (this._currentXY.y - this._lastXY.y) / duration
				};
			} else {
				return 0;
			}
		},
		reset : function() {
			this.callParent('reset');
			this._startXY = undefined;
			this._lastXY = undefined;
			this._currentXY = undefined;
			this._startWhen = 0;
			this._stopWhen = 0;
		}
	});
	return PanGestureDetector;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.XYChartPlotComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Canvas2DSurfaceComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.Layer',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.PinchGestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.PanGestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.LongPressGestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.gridLine.GridLine',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.BarModule',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.CombinationModule',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.TapGestureDetector',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, FunctionUtils, LOG, Canvas2DSurfaceComponent, Layer, UADetector,
		PinchGestureDetector, PanGestureDetector, LongPressGestureDetector, GridLine, BarModule, CombinationModule, TapGestureDetector) {
	var PlotComponent = ObjUtils.derive(Canvas2DSurfaceComponent,
	{
		constructor : function(options) {
			this._canvasSurface = this.getCanvasSurface();
			this._rootLayer = this._canvasSurface.getRootLayer();

			this._chart_options = ObjUtils.extend(true, {}, options.chart);
			this._metaData = this._chart_options.metaData;
			this._dataTree = this._chart_options.dataTree;

			this._xaxes = [];
			this._yaxes = [];
			this._gridLine = null;

			this._xaxisLayers = [];
			this._yaxisLayers = [];
			this._gridLineLayer = null;
			// the layer we actual drawing on
			this._seriesLayer = null;
			// the layer which controls the visible area and
			// listen on event
			this._seriesMaskLayer = null;

			this._chartModule = null;

			this._init(false);
		},

		_init : function(redraw) {
			if (!redraw) {
				this._initModule();
			}

			this._chartModule.init();

			if (!redraw) {
				this._seriesMaskLayer = new Layer({
					anchor : {
						x : 0,
						y : 0
					}
				});
				this._seriesMaskLayer.clipToBounds(true);
				this._rootLayer.addSubLayer(this._seriesMaskLayer);
				this._seriesLayer = new Layer({
					anchor : {
						x : 0,
						y : 0
					}
				});
				this._seriesMaskLayer.addSubLayer(this._seriesLayer);

			}
			this._initAxesLayer();
			this._chartModule.bindRenderer(this._seriesLayer);
			this._gridLine = this._chartModule._gridLine;
			this._initGridLine();

			if (!redraw) {
				this._registerEvents();
			}
		},

		_initGridLine : function() {
			this._gridLine.setXAxisLayer(this._xaxisLayers);
			this._gridLine.setYAxisLayer(this._yaxisLayers);
			this._gridLine.setSeriesMaskLayer(this._seriesMaskLayer);
			this._gridLine.setSeriesLayer(this._seriesLayer);

			this._gridLine.setXAxis(this._xaxes[0]);
			this._gridLine.setYAxis(this._yaxes[0]);

		},

		_initAxesLayer : function() {
			this._initXAxesLayer();
			this._initYAxesLayer();
		},

		_initXAxesLayer : function() {
			this._xaxes = [];

			for ( var i = 0, len = this._xaxisLayers.length; i < len; i++) {
				this._rootLayer._removeSubLayer(this._xaxisLayers[i]);
			}
			this._xaxisLayers = [];

			this._xaxes = this._chartModule._xaxes;
			for ( var i = 0, len = this._xaxes.length; i < len; i++) {
				var xaxisLayer = new Layer({
					anchor : {
						x : 0,
						y : 0
					}
				});
				this._xaxes[i].setLayer(xaxisLayer);
				this._xaxisLayers.push(xaxisLayer);
				this._rootLayer.addSubLayer(xaxisLayer);
			}
		},

		_initYAxesLayer : function() {
			this._yaxes = [];
			for ( var i = 0, len = this._yaxisLayers.length; i < len; i++) {
				this._rootLayer._removeSubLayer(this._yaxisLayers[i]);
			}
			this._yaxisLayers = [];

			this._yaxes = this._chartModule._yaxes;
			for ( var i = 0, len = this._yaxes.length; i < len; i++) {
				var yaxisLayer = new Layer({
					anchor : {
						x : 0,
						y : 0
					}
				});
				this._yaxes[i].setLayer(yaxisLayer);
				this._yaxisLayers.push(yaxisLayer);
				this._rootLayer.addSubLayer(yaxisLayer);
			}
		},

		_initModule : function() {
			switch (this._chart_options.properties.type) {
			case 'bar':
				this._chartModule = new BarModule(this._chart_options);
				break;
			case 'combination':
				this._chartModule = new CombinationModule(this._chart_options);
				break;
			}
		},

		_chart_layout : function(nsize) {
			this._chartModule.doChartLayout(nsize, this._yaxisLayers, this._xaxisLayers, this._seriesMaskLayer,
					this._seriesLayer);
		},

		_doDraw : function(size) {
			// Fix the bug: visual-1050 [Ian 2012- 2- 31] check
			// whether the axis
			// is defined, if not, we will draw nothing exclude
			// Legend
			if (this._xaxes.length === 0 || this._yaxes.length === 0)
				return;
			// End

			this._chart_layout(size);
			this._gridLine.drawGridLine();
			this._chartModule.drawSeries();
			for ( var i = 0, len = this._xaxes.length; i < len; i++) {
				this._xaxes[i].draw();
			}

			for ( var i = 0, len = this._yaxes.length; i < len; i++) {
				this._yaxes[i].draw();
			}
			this._rootLayer.setNeedsDisplay();
		},

		_resetEventStatusVariables : function() {
			// variables used to store mouse/touch status
			this._mouseAlreadyDown = false;
			this._mouseAlreadyMoved = false;
			// [Jimmy- 021512]we don't want mousemove too
			// sensitive, use this
			// var to track the distance of mouse moving.
			// only when it's large than 1px, we think user is
			// moving the mouse
			this._mouseMoveThreshold = 1;
			// [Jimmy- 021512]make sure you have to give it a
			// value before using
			// it
			this._previousMousePosition = undefined;
			// end of variables
		},

		/**
		 * [jimmy-021512]now the native event handlers are registered on layer,
		 * while gestures handlers are registered on component. please note
		 * touchCancel is required to handle if any other touch related events
		 * are listened.
		 */
		_registerEvents : function() {
			this._resetEventStatusVariables();
			this._seriesMaskLayer.on([ {
				eventName : 'mousemove',
				listener : this._mouseEventHandler,
				scope : this
			}, {
				eventName : 'mouseup',
				listener : this._mouseEventHandler,
				scope : this
			}, {
				eventName : 'mousedown',
				listener : this._mouseEventHandler,
				scope : this
			}, {
				eventName : 'mouseleave',
				listener : this._mouseEventHandler,
				scope : this
			}, {
				eventName : 'touchstart',
				listener : this._touchEventHandler,
				scope : this
			}, {
				eventName : 'touchend',
				listener : this._touchEventHandler,
				scope : this
			}, {
				eventName : 'touchmove',
				listener : this._touchEventHandler,
				scope : this
			}, {
				eventName : 'touchcancel',
				listener : this._touchEventHandler,
				scope : this
			} ]);

			// add Pinch Gesture event on XYChart
			var oPinchGestureDetector = this._oPinchGestureDetector = new PinchGestureDetector();
			oPinchGestureDetector.addGestureAction(this._pinchingResize);
			oPinchGestureDetector.enable(true);
			this.addGestureDetector(oPinchGestureDetector);

			// add pan Gesture event on XYChart
			var oPanGestureDetector = this._oPanGestureDetector = new PanGestureDetector(1);
			oPanGestureDetector.cancelTouches(false).addGestureAction(this._panMove);
			oPanGestureDetector.enable(true);
			this.addGestureDetector(oPanGestureDetector);
			
			var oLongPressGestureDetector = this._oLongPressGestureDetector =  new LongPressGestureDetector();
			oLongPressGestureDetector.addGestureAction(this._longPressHandler);
			oLongPressGestureDetector.enable(true);
			oLongPressGestureDetector.minimumPressDuration(500);
			this.addGestureDetector(oLongPressGestureDetector);
			
			var oTapGestureDetector = this._oTapGestureDetector = new TapGestureDetector();
			oTapGestureDetector.addGestureAction(this._tapHandler);
			oTapGestureDetector.enable(true);
			this.addGestureDetector(oTapGestureDetector);
		},

		/**
		 * in single chart, we directly draw shapes on series layer in the
		 * module, so actually we don't need do this kind of conversion. this is
		 * only for multi chart case or other special case that we create sub
		 * layers on series layer to draw chart shapes or sub charts and we may
		 * not want to specify which layer to handle the event, it's up to
		 * module to determine which layer to handle based on the passed in
		 * point.
		 * 
		 * @param mouseEvent
		 *            an instance of sap.riv.graphics.MouseEvent
		 */
		_convertXYForMouseEvent : function(mouseEvent) {
			// [jimmy-021512] here we'll convert coordinate from
			// target layer to
			// the series layer
			if (this._seriesLayer == null) {
				ObjUtils.error('Series Layer should be initialized before any event handler!')
			}
			var xyOnTargetLayer = mouseEvent.targetLocalXY();
			var targetLayer = mouseEvent.targetLayer();
			var xyOnSeriesLayer = this._seriesLayer.convertPointFromLayer(xyOnTargetLayer, targetLayer);
			return xyOnSeriesLayer;
		},

		/**
		 * in single chart, we directly draw shapes on series layer in the
		 * module, so actually we don't need do this kind of conversion. this is
		 * only for multi chart case or other special case that we create sub
		 * layers on series layer to draw chart shapes or sub charts and we may
		 * not want to specify which layer to handle the event, it's up to
		 * module to determine which layer to handle based on the passed in
		 * point.
		 * 
		 * @param touch
		 *            an instance of sap.riv.graphics.Touch
		 */
		_convertXYForTouch : function(touch) {
			// [jimmy-021512] here we'll convert coordinate from
			// target layer to
			// the series layer
			if (this._seriesLayer == null) {
				TypeUtils.error('Series Layer should be initialized before any event handler!')
			}
			var xyOnTargetLayer = touch.localXY();
			var targetLayer = touch.targetLayer();
			var xyOnSeriesLayer = this._seriesLayer.convertPointFromLayer(xyOnTargetLayer, targetLayer);
			return xyOnSeriesLayer;
		},

		/**
		 * @param mouseEvent
		 *            an instance of sap.riv.graphics.MouseEvent
		 */
		_mouseEventHandler : function(mouseEvent) {
			var eventType = mouseEvent.type();
			switch (eventType) {
			case 'mousedown':
				this._mouseAlreadyDown = true;
				// [jimmy-011512]set it to false so that we can
				// have click after
				// we do mouse move
				this._mouseAlreadyMoved = false;
				break;
			case 'mouseup':
				this._mouseAlreadyDown = false;
				if (!this._mouseAlreadyMoved) {
					this._chartModule.clickOnPoint(this._convertXYForMouseEvent(mouseEvent));
				}
				this._mouseAlreadyMoved = false;
				break;
			case 'mousemove':
				if (this._previousMousePosition) {
					var currentPosition = mouseEvent.targetLocalXY();
					if (Math.abs(currentPosition.x - this._previousMousePosition.x) > this._mouseMoveThreshold
							|| Math.abs(currentPosition.y - this._previousMousePosition.y) > this._mouseMoveThreshold) {
						// we are actually moving
						if (this._mouseAlreadyDown) {
							// marquee selection
							this._chartModule.marqueeOverPoint(mouseEvent.targetLocalXY());
						} else {
							// show tooltip
							this._chartModule.hoverOnPoint(this._convertXYForMouseEvent(mouseEvent));
						}
						// reset the moving tracking
						this._previousMousePosition = undefined;
						// we already move
						this._mouseAlreadyMoved = true;
					}
				} else {
					this._previousMousePosition = mouseEvent.targetLocalXY();
				}
				break;
			case 'mouseleave':
				// LOG.debug('about to leave layer!');
				this._chartModule.onblur(this._convertXYForMouseEvent(mouseEvent));
				this._resetEventStatusVariables();
				break;
			default:
				break;
			}
		},

		_touchEventHandler : function(touchEvent) {
			var eventType = touchEvent.type();
			switch (eventType) {
			case 'touchstart':
				break;
			case 'touchmove':
				break;
			case 'touchend':
				if(this.islongPressGesture){
					this.islongPressGesture = false;
					this._chartModule.onblur();
				}
				break;
			case 'touchcancel':
				if(this.islongPressGesture){
					this.islongPressGesture = false;
					this._chartModule.onblur();
				}
				break;
			default:
				break;
			}
		},

		/**
		 * when touch begin: set the initial value when touch move: we redraw
		 * the yaxis and redraw part of shape which are in viewPort, when touch
		 * end and cancel: redraw the all shapes in series layer
		 * 
		 * @returns function
		 */
		_pinchingResize : function(recognizer) {
			recognizer.attachedComponent()._chartModule.pinchingResize(recognizer);
		},

		_panMove : function(panGestureDetector) {
			panGestureDetector.attachedComponent()._chartModule.panMove(panGestureDetector);
		},

		/**
		 * 
		 */
		_longPressHandler : function(recognizer){
			recognizer.attachedComponent()._chartModule.longPressHandler(recognizer);
		},
		
		_tapHandler : function(recognizer){
			recognizer.attachedComponent()._chartModule.tapHandler(recognizer);
		},
		/**
		 * Resize component's visual content, when the component's size changed,
		 * this method will be invoked before layout sub components
		 */
		doContentResize : function(osize, nsize) {
			this.callParent('doContentResize', osize, nsize);
			this._doDraw(nsize);
		},

		applyTheme : function(theme) {
			this._chartModule.applyTheme(theme);
			for ( var i = 0, len = this._xaxes.length; i < len; i++) {
				this._xaxes[i].applyTheme(theme);
			}

			for ( var i = 0, len = this._yaxes.length; i < len; i++) {
				this._yaxes[i].applyTheme(theme);
			}
			this._gridLine.applyTheme(theme);
		},

		updateProperties : function(propBag) {
			this._chart_options.properties = propBag;
			this._chartModule.updateProperties(propBag);
			// var resetAxis = false;
			// var xAxisOptions =
			// this._chart_options.properties.xAxis;
			// if(this._xaxes.length != xAxisOptions.length){
			// this._chartModule.initXAxes();
			// this._initXAxesLayer();
			// resetAxis = true;
			// }
			// var yAxisOptions =
			// this._chart_options.properties.yAxis;
			// if(this._yaxes.length != yAxisOptions.length){
			// this._chartModule.updateValueAxisRange();
			// this._chartModule.initYAxes();
			// this._initYAxesLayer();
			// resetAxis = true;
			// }
			// if(resetAxis){
			// this._chartModule.bindSeriesWithAxes();
			// }else{
			// for(var i = 0, len = this._xaxes.length; i < len;
			// i++) {
			// this._xaxes[i].updateProperties(this._chart_options.properties.xAxis[i]);
			// this._xaxes[i].draw();
			// }
			// for(var i = 0, len = this._yaxes.length; i < len;
			// i++) {
			// this._yaxes[i].updateProperties(this._chart_options.properties.yAxis[i]);
			// this._yaxes[i].draw();
			// }
			// }
			// [Ian 2012-2-19] Currently, we only back up the
			// scene in IPad and
			// restore it in IPad
			if (UADetector.os() === 'iPad') {
				this._chartModule.backUp();
			}

			// Reset Axis
			this._chartModule.updateValueAxisRange();
			this._chartModule.initAxes();
			this._initAxesLayer();
			this._chartModule.bindSeriesWithAxes();
			this._chartModule.initGridLineProperties();
			this._initGridLine();
			
			this._doDraw(this.size());
		},

		updateOptions : function(options) {
			this._chart_options = options;
			this._metaData = options.metaData;
			this._dataTree = options.dataTree;

			this._xaxes = [];
			this._yaxes = [];

			for ( var i = 0, len = this._xaxisLayers.length; i < len; i++) {
				this._rootLayer._removeSubLayer(this._xaxisLayers[i]);
			}

			for ( var i = 0, len = this._yaxisLayers.length; i < len; i++) {
				this._rootLayer._removeSubLayer(this._yaxisLayers[i]);
			}

			this._xaxisLayers = [];
			this._yaxisLayers = [];

			this._chartModule.updateOptions(this._chart_options);
			this._init(true);
			this._doDraw(this.size());
		},

		/**
		 * Receives chart component command and execute it.
		 * 
		 * @param {Object} args - command value
		 */
		receiveCommand : function ( args ) {
        	switch ( args.commandText ) {
        	case "ChangeSeriesVisibility":
        		if ( TypeUtils.isDefined(
        				this._chart_options.properties.measure.visibilityChangeable) 
        				&& this._chart_options.properties.measure.visibilityChangeable 
        				&& TypeUtils.isDefined(this._chart_options.properties.measures[args.seriesIndex])) {
        			this._chart_options.properties.measures[args.seriesIndex].visible = args.setVisible;
        			this._chartModule._hasDrawn = false;
        			this.updateProperties(this._chart_options.properties);
        		}
        		break;
        	default:
        		return;
        	}
        },
		
		/**
		 * @return events which can be listened by clients
		 */
		getSupportedAppEvents : function() {
			return this._chartModule.getSupportedAppEvents();
		},

		doPrint : function(drawingCtx) {

		},
		
		getPlotArea : function() {
		    var pos = this.position();
		    var area = this._chartModule.getPlotArea();
		    return {
		        top : area.top + pos.y,
		        left : area.left + pos.x,
		        bottom : area.bottom + pos.y,
		        right : area.right + pos.x
            };
		}
	});
	return PlotComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.XYChartComponent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.title.TitleCanvasComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.background.BackgroundComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.legend.LegendCanvasComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.tooltip.BaseTooltip',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.misc.PropsMgr',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.descriptor.Descriptor',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.layout.BasicLayout',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.series.Series',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.XYChartPlotComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, LOG, UIComponent, TitleCanvasComponent, BackgroundComponent, LegendCanvasComponent,
		BaseTooltip, PropsMgr, Descriptor, BasicLayout, ThemeManager, Series, XYChartPlotComponent, LOG) {
	var XYChartComponent = ObjUtils.derive(UIComponent, {
		constructor : function(options) {
			this._dataTree = options.dataset.dataTree;
			this._metaData = options.dataset.metaData;
			this._xychart_options = {
				layout : {
					padding : [ 0, 0, 0, 0 ],
					legendFirst : true
				},
				type : 'bar',
				measure : { visibilityChangeable : false },
				measures : [],
				//Ian [2012-4-18] Fix the bug, if user do not pass chart option, the xAxis's size is zero so that it can not draw chart.
				//So to use an empty object means that we at least have one axis.
				xAxis : [{}],
				yAxis : [{}],
				//End
				selectability : {
					"mode" : "single",
					"deSelectable" : true,
					"defaultSelectedItems" : []
				},
				bar : {
					barMarkerSize : Series.DEFAULTBARMARKERSIZE,
					isShowGradient : false,
					isShowInnerBorder : false,
					isShowOutBorder : false,
					isShowShadow : false
				},
				line : {
					lineThickness : Series.DEFAULTLINESIZE,
					lineMarkerSize : Series.DEFAULTLINEMARKERSIZE,
					isShowMarkerShadow : false,
					isShowLineShadow : false
				},
				measureDefault : {
					colors : [ "#113975", "#e06f00", "#5a92e2", "#624628", "#e03c2f", "#ffbe7f",
							"#96a8c3", "#a9a9a9", "#830b00", "#344b6d", "#e2ce44", "#ff6657" ]
				},
				visibleRange : {
					start : 0,
					end : Number.POSITIVE_INFINITY
				},
				theme : ''
			};
			this._xychart_options.title = ObjUtils.extend(true, {}, TitleCanvasComponent
					.getDefaultOption());
			this._xychart_options.background = ObjUtils.extend(true, {}, BackgroundComponent
					.getDefaultOption());
			this._xychart_options.legend = ObjUtils.extend(true, {}, LegendCanvasComponent
					.getDefaultOption());
		    this._xychart_options.tooltip = ObjUtils.extend(true, {}, BaseTooltip
                    .getDefaultOption());
			
			// default value
			var descriptor;
			if (options.xyChartOptions.type === 'bar') {
			    descriptor = Descriptor.getBarDescriptor();
			} else if (options.xyChartOptions.type === 'combination') {
			    if (options.xyChartOptions.measure.type === 'line') {
			        descriptor = Descriptor.getLineDescriptor();
			    } else if (options.xyChartOptions.measure.type === 'bar') {
			        descriptor = Descriptor.getColumnDescriptor();
			    } else if (options.xyChartOptions.measure.type === 'combination') {
			        descriptor = Descriptor.getCombinationDescriptor();
			    }
			}

			this._propsMgr = new PropsMgr(descriptor);
			var validatedOptions = this._propsMgr.properties(options.xyChartOptions);
			this._xychart_options = ObjUtils.extend(true, this._xychart_options, validatedOptions);
			
			// TODO[Christy/20120423] Check theme propeties.
			if (TypeUtils.isExist(options.xyChartOptions.theme) && options.xyChartOptions.theme !== '') {
				var theme = options.xyChartOptions.theme;
				this._resolveThemeAndProperties(options.xyChartOptions, theme);
			}
			this._xychart_options = ObjUtils.extend(true, this._xychart_options, options.xyChartOptions);
			this._propsMgr.properties(this._xychart_options);
			
			this._attach_additional_properties();

			this._legendComponent = null;
			this._chartComponent = null;
			this._titleComponent = null;
			this._xychart_layout = null;

			this._colorList = null;
			this._initSubComponents(false);

		},

		_resolveThemeAndProperties : function(options, theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var globalStyle = settings.global;

			// Background
			options.background = options.background || {};
			options.background.color = options.background.color || settings.background;

			// Legend Style
			var legendStyle = settings.legend;
			var legendTitleStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.title);
			var legendLabelStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.label);
			options.legend = options.legend || {};
			options.legend.titleFont = options.legend.titleFont
					|| (legendTitleStyle['font-weight'] + ' ' + legendTitleStyle['font-size'] + ' ' + legendTitleStyle['font-family']);
			options.legend.titleColor = options.legend.titleColor
					|| (legendTitleStyle['color']);
			options.legend.labelFont = options.legend.labelFont
					|| (legendLabelStyle['font-weight'] + ' ' + legendLabelStyle['font-size'] + ' ' + legendLabelStyle['font-family']);
			options.legend.labelColor = options.legend.labelColor
					|| (legendLabelStyle['color']);

			// Title Style
			var mainTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.mainTitle);
			var subTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.subTitle);
			options.title = options.title || {};
			options.title.main = options.title.main || {};
			options.title.main.font = options.title.main.font
					|| (mainTitleStyle["font-weight"] + ' ' + mainTitleStyle["font-size"] + ' ' + mainTitleStyle["font-family"]);
			options.title.main.color = options.title.main.color || (mainTitleStyle["color"]);

			options.title.sub = options.title.sub || {};
			options.title.sub.font = options.title.sub.font
					|| (subTitleStyle["font-weight"] + ' ' + subTitleStyle["font-size"] + ' ' + subTitleStyle["font-family"]);
			options.title.sub.color = options.title.sub.color || (subTitleStyle["color"]);

			// Bar or Line style
			var barStyle = settings.bar;
			options.bar = options.bar || {};
			options.bar.isShowGradient = options.bar.isShowGradient || barStyle.isShowGradient;
			options.bar.isShowInnerBorder = options.bar.isShowInnerBorder || barStyle.isShowInnerBorder;
			options.bar.isShowOutBorder = options.bar.isShowOutBorder || barStyle.isShowOutBorder;
			options.bar.isShowShadow = options.bar.isShowShadow || barStyle.isShowShadow;

			var lineStyle = settings.line;
			options.line = options.line || {};
			options.line.isShowLineShadow = (options.line.isShowLineShadow || lineStyle.line.isShowShadow);
			options.line.isShowMarkerShadow = (options.line.isShowMarkerShadow || lineStyle.marker.isShowShadow);
			options.line.lineThickness = (options.line.lineThickness || lineStyle.line.size);
			options.line.lineMarkerSize = (options.line.lineMarkerSize || lineStyle.marker.size);

			// TODO Merge Tooltip properties and theme

			// Axis
			var axisStyle = settings.axis;
			var axisTitleStyle = ObjUtils.extend(true, {}, globalStyle, axisStyle.title);
			var axisLabelStyle = ObjUtils.extend(true, {}, globalStyle, axisStyle.label);
			if (TypeUtils.isUndefined(options.xAxis)) {
				options.xAxis = [{}];
			}
			for ( var i = 0, len = options.xAxis.length; i < len; i++) {
				var axis = options.xAxis[i];
				this._resolveAxisThemeAndProperties(axis, axisTitleStyle, axisLabelStyle,
						axisStyle.lineColor);
				
				axis.gridLine = axis.gridLine || {};
				axis.gridLine.majorColor = axis.gridLine.majorColor || axisStyle.xAxisMajorGridLine.color;
				axis.gridLine.majorThickness = axis.gridLine.majorThickness || axisStyle.xAxisMajorGridLine.thickness;
				axis.gridLine.minorColor = axis.gridLine.minorColor || axisStyle.xAxisMinorGridLine.color;
				axis.gridLine.minorThickness = axis.gridLine.minorThickness || axisStyle.xAxisMinorGridLine.thickness;
				axis.gridLine.subColor = axis.gridLine.subColor || axisStyle.xAxisSubGridLine.color;
			}
			
			if (TypeUtils.isUndefined(options.yAxis)) {
				options.yAxis = [{}];
			}
			for ( var i = 0, len = options.yAxis.length; i < len; i++) {
				var axis = options.yAxis[i];
				this._resolveAxisThemeAndProperties(axis, axisTitleStyle, axisLabelStyle,
						axisStyle.lineColor);
				
				axis.gridLine = axis.gridLine || {};
				axis.gridLine.majorColor = axis.gridLine.majorColor || axisStyle.yAxisMajorGridLine.color;
				axis.gridLine.majorThickness = axis.gridLine.majorThickness || axisStyle.yAxisMajorGridLine.thickness;
				axis.gridLine.minorColor = axis.gridLine.minorColor || axisStyle.yAxisMinorGridLine.color;
				axis.gridLine.minorThickness = axis.gridLine.minorThickness || axisStyle.yAxisMinorGridLine.thickness;
				axis.gridLine.subColor = axis.gridLine.subColor || axisStyle.yAxisSubGridLine.color;
			}
		},

		_resolveAxisThemeAndProperties : function(axis, axisTitleStyle, axisLabelStyle, lineStyle) {
			axis = axis || {};
			axis.titleFont = (axis.titleFont || axisTitleStyle['font-weight'] + " "
					+ axisTitleStyle['font-size'] + " " + axisTitleStyle['font-family']);
			axis.titleColor = (axis.titleColor || axisTitleStyle['color']);
			axis.labelFont = (axis.labelFont || axisLabelStyle['font-weight'] + " "
					+ axisLabelStyle['font-size'] + " " + axisLabelStyle['font-family']);
			axis.labelColor = (axis.labelColor || axisLabelStyle['color']);
			axis.lineColor = (axis.lineColor || lineStyle);
		},

		_initSubComponents : function(redraw) {
			this.autoresizeSubComponents(false);
			var size = this.size();
			if (!redraw) {
				this._xychart_layout = new BasicLayout(size, this._xychart_options);
			}

			if (!redraw) {
				this._backgroundComponent = new BackgroundComponent({
					enable : true,
					anchor : {
						x : 0,
						y : 0
					},
					position : {
						x : 0,
						y : 0
					},
					size : {
						w : size.width,
						h : size.height
					},
					backgroundOptions : this._xychart_options.background,
					id : 'backgroundComponent'
				});
				// background component is always the first
				// component
				this.addSubComponent(this._backgroundComponent);

				// here we give a default size to title(or any
				// other sub)
				// component to ensure
				// sub component has initial size to rely on
				// sap.riv.vizkit.UIComponentAutosizing
				// for auto layout
				this._titleComponent = new TitleCanvasComponent({
					enable : true,
					anchor : {
						x : 0,
						y : 0
					},
					position : {
						x : 0,
						y : 0
					},
					size : {
						w : size.width,
						h : size.height
					},
					titleOptions : this._xychart_options.title,
					id : 'xyChartTitleComponent'
				});

				this._legendComponent = new LegendCanvasComponent({
					enable : true,
					anchor : {
						x : 0,
						y : 0
					},
					position : {
						x : 0,
						y : 0
					},
					size : {
						w : size.width,
						h : size.height
					},
					legendOptions : {
						properties : this._xychart_options
					},
					id : 'xyChartLegendComponent'
				});
				this._legendComponent.addEventObserver(this);
				if ( TypeUtils.isDefined(this._xychart_options.measure.visibilityChangeable)
						&& this._xychart_options.measure.visibilityChangeable ) {
					// Unlock legend state and appearance changeability.
					this._legendComponent.setStateChangeable(true);
				}

				this._chartComponent = new XYChartPlotComponent({
					enable : true,
					anchor : {
						x : 0,
						y : 0
					},
					position : {
						x : 0,
						y : 0
					},
					size : {
						w : size.width,
						h : size.height
					},
					chart : {
						metaData : this._metaData,
						dataTree : this._dataTree,
						properties : this._xychart_options
					},
					id : 'xyChartPlotComponent'
				});

			}

		},

        /**
         * Notification hooking up method in order to
         * receive event broadcasts.
         * 
         * @param {Object} args
         * - Could be anything as broadcasting data package
         * 
         * @author eye
         */
        notify : function ( args ) {
        	this._chartComponent.receiveCommand(args);
        },
		
		/**
		 * Resize component's visual content, when the
		 * component's size changed, this method will be invoked
		 * before layout sub components
		 */
		doContentResize : function(osize, nsize) {
			this.callParent('doContentResize', osize, nsize);
			this._xychart_layout.updateSize(nsize);        	
			this._relayout();
		},

		/**
		 * when we pass properties to the sub components, we may
		 * want to attach some special properties(calculated
		 * properties) for sub components. these properties are
		 * internal and should not be returned to clients
		 */
		_attach_additional_properties : function() {
			if (this._xychart_options) {
				var options = this._xychart_options;
				// reset before we attach
				delete options._additional;
				var _additional = {};
				// attach colorlist
				var colorList = [];
				var legendNumberFormat = [];
				var markerList = [];
				var defaultColors = options.measureDefault.colors;
				var defaultFormat = options.measureDefault.numberFormats;
				var labels = this._getEffectiveLables();

				var barOptions = options.bar;
				var lineOptions = options.line;
				var measureOption = options.measures || {};
				var measure = this._metaData.measureMembers;

				for ( var i = 0, len = labels.length; i < len; i++) {
					var o = measureOption[i] || {};
					if (o.type === 'bar') {
						o = ObjUtils.extend(true, {}, barOptions, o);
					} else {
						o = ObjUtils.extend(true, {}, lineOptions, o);
					}
					colorList.push(TypeUtils.isExist(o.fillColor) ? o.fillColor : defaultColors[i
							% defaultColors.length]);

					if (TypeUtils.isExist(options.type) && options.type === "bar") {
						markerList.push("rect");
					} else {
						// Combination chart
						if (TypeUtils.isExist(o.type) && o.type === "bar") {
							markerList.push("rect");
						} else {
							if (TypeUtils.isExist(o.markerSymbol)) {
								markerList.push(o.markerSymbol);
							} else {
								markerList.push("circle");
							}
						}
					}

				}

				var formats = options.legend.formatString;
				for ( var i = 0, formatsLen = formats.length, len = labels.length; i < len; i++) {
					if (i < formatsLen) {
						legendNumberFormat.push(formats[i]);
					} else {
						legendNumberFormat.push(formats[formatsLen - 1]);
					}
				}

				_additional.colorList = colorList;
				_additional.legendNumberFormat = legendNumberFormat;

				// attach legend title
				// [jyang, 19/3/2012] we can expose a legend
				// title property
				// instead of
				// binding it to data model if we have
				// requirement in the
				// future.
				// [jyang, 4/24/2012] it doesn't make sense to use dimension name as legend title in XYChart
				// as the labels here are measure names. so we remove title for now.
				//_additional.legendTitle = this._metaData.dimension[this._metaData.dimension.length - 1].name;
				
				// attach legend labels
				_additional.legendLabels = labels;
				_additional.legendMarkers = markerList;

				this._xychart_options._additional = _additional;
			}
		},

		_getEffectiveLables : function() {
			var tree = this._dataTree;
			var measure = this._metaData.measureMembers;
			var labels = [], measureIndex;
			var length = measure.length;

			for ( var i = 0; i < length; i++) {
				labels.push({
					category : measure[i]
				});

			}
			return labels;
		},

		_processLayoutOfComponent : function(component, layarr) {
			if (!layarr) {
				component.detachFromSuperComponent();
			} else {
			    LOG.debug("chartComponent["+this.id()+"]"+"subComponent["+component.getCanvasSurface().getRootLayer().id()+"]initialized.", "perf");
				if (!component.superComponent()) {
					// has been detached, re-attach
					this.addSubComponent(component);
				}
				component.position({
					x : layarr[0],
					y : layarr[1],
				});
				component.size({
					width : layarr[2],
					height : layarr[3],
				});
			}
		},

		_relayout : function(force) {
			if (this._xychart_layout.layoutChanged() || force) {
				if (this._xychart_options.layout.legendFirst) {
					var legendSize = this._legendComponent.calMaxLegendSize(this._xychart_options);
					this._xychart_layout.setMaxLegendWidth(legendSize.width);
					this._xychart_layout.setMaxLegendHeight(legendSize.height);
				}

				var titleSize = this._titleComponent.getPreferredSize(this._xychart_layout._size,
						this._xychart_options.title);

				this._xychart_layout.setPreferredTitleWidth(titleSize.width);
				this._xychart_layout.setPreferredTitleHeight(titleSize.height);

				var layoutinfo = this._xychart_layout.getLayoutInfo();
				
				//Ian [2012-4-10] fix the bug:ADAPT01629959, when the chart's width or height is less than 0, we should do nothing.
				//Nick [2012-4-19] move the following code from doContentResize function here.
	        	if(layoutinfo.main[2] <=0 || layoutinfo.main[3] <=0){
	        		return;
	        	}
	        	//End
	        	
				if ( layoutinfo.title ) {
					this._titleComponent.setPreferredSize({
						width : layoutinfo.title[2],
						height : layoutinfo.title[3]
					});
				}
				
				this._processLayoutOfComponent(this._chartComponent, layoutinfo.main);
				this._processLayoutOfComponent(this._titleComponent, layoutinfo.title);
				this._processLayoutOfComponent(this._legendComponent, layoutinfo.legend);
				this._processLayoutOfComponent(this._backgroundComponent, layoutinfo.background);
			}
		},

		applyTheme : function(theme) {
			var options = this._xychart_options;
			this._setThemes(options, theme);
			this.updateProperties(options);
			// this._backgroundComponent.applyTheme(theme);
			// this._titleComponent.applyTheme(theme);
			// this._legendComponent.applyTheme(theme);
			// this._chartComponent.applyTheme(theme);
		},

		_setThemes : function(options, theme) {
			var settings = ThemeManager.getThemeSettings(theme);
			var globalStyle = settings.global;

			// Background
			options.background.color = settings.background;

			// Legend Style
			var legendStyle = settings.legend;
			var legendTitleStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.title);
			var legendLabelStyle = ObjUtils.extend(true, {}, globalStyle, legendStyle.label);
			options.legend.titleFont = (legendTitleStyle['font-weight'] + ' '
					+ legendTitleStyle['font-size'] + ' ' + legendTitleStyle['font-family']);
			options.legend.titleColor = (legendTitleStyle['color']);
			options.legend.labelFont = (legendLabelStyle['font-weight'] + ' '
					+ legendLabelStyle['font-size'] + ' ' + legendLabelStyle['font-family']);
			options.legend.labelColor = (legendLabelStyle['color']);

			// Title Style
			var mainTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.mainTitle);
			var subTitleStyle = ObjUtils.extend(true, {}, globalStyle, settings.title.subTitle);
			options.title.main.font = (mainTitleStyle["font-weight"] + ' '
					+ mainTitleStyle["font-size"] + ' ' + mainTitleStyle["font-family"]);
			options.title.main.color = (mainTitleStyle["color"]);

			options.title.sub.font = (subTitleStyle["font-weight"] + ' ' + subTitleStyle["font-size"]
					+ ' ' + subTitleStyle["font-family"]);
			options.title.sub.color = (subTitleStyle["color"]);

			// Bar or Line style
			var barStyle = settings.bar;
			options.bar.isShowGradient = barStyle.isShowGradient;
			options.bar.isShowInnerBorder = barStyle.isShowInnerBorder;
			options.bar.isShowOutBorder = barStyle.isShowOutBorder;
			options.bar.isShowShadow = barStyle.isShowShadow;

			var lineStyle = settings.line;
			options.line.isShowLineShadow = lineStyle.line.isShowShadow;
			options.line.isShowMarkerShadow = lineStyle.marker.isShowShadow;
			options.line.lineThickness = lineStyle.line.size;
			options.line.lineMarkerSize = lineStyle.marker.size;

			// TODO Merge Tooltip properties and theme

			// Axis
			var axisStyle = settings.axis;
			var axisTitleStyle = ObjUtils.extend(true, {}, globalStyle, axisStyle.title);
			var axisLabelStyle = ObjUtils.extend(true, {}, globalStyle, axisStyle.label);
			if (TypeUtils.isExist(options.xAxis)) {
				for ( var i = 0, len = options.xAxis.length; i < len; i++) {
					var axis = options.xAxis[i];
					this._setAxisThemes(axis, axisTitleStyle, axisLabelStyle, axisStyle.lineColor);
					
					axis.gridLine = axis.gridLine || {};
					axis.gridLine.majorColor = axisStyle.xAxisMajorGridLine.color;
					axis.gridLine.majorThickness = axisStyle.xAxisMajorGridLine.thickness;
					axis.gridLine.minorColor = axisStyle.xAxisMinorGridLine.color;
					axis.gridLine.minorThickness = axisStyle.xAxisMinorGridLine.thickness;
					axis.gridLine.subColor = axisStyle.xAxisSubGridLine.color;
				}
			}
			if (TypeUtils.isExist(options.yAxis)) {
				for ( var i = 0, len = options.yAxis.length; i < len; i++) {
					var axis = options.yAxis[i];
					this._setAxisThemes(axis, axisTitleStyle, axisLabelStyle, axisStyle.lineColor);
					
					axis.gridLine = axis.gridLine || {};
					axis.gridLine.majorColor = axisStyle.yAxisMajorGridLine.color;
					axis.gridLine.majorThickness = axisStyle.yAxisMajorGridLine.thickness;
					axis.gridLine.minorColor = axisStyle.yAxisMinorGridLine.color;
					axis.gridLine.minorThickness = axisStyle.yAxisMinorGridLine.thickness;
					axis.gridLine.subColor = axisStyle.yAxisSubGridLine.color;
				}
			}
		},

		_setAxisThemes : function(axis, axisTitleStyle, axisLabelStyle, lineStyle) {
			axis.titleFont = axisTitleStyle['font-weight'] + " " + axisTitleStyle['font-size'] + " "
					+ axisTitleStyle['font-family'];
			axis.titleColor = axisTitleStyle['color'];
			axis.labelFont = axisLabelStyle['font-weight'] + " " + axisLabelStyle['font-size'] + " "
					+ axisLabelStyle['font-family'];
			axis.labelColor = axisLabelStyle['color'];
			axis.lineColor = lineStyle;
		},

		updateProperties : function(propBag) {
			var validatedOptions = this._propsMgr.properties(propBag);
			this._xychart_options = ObjUtils.extend(true, this._xychart_options, validatedOptions);
			this._attach_additional_properties();
			this._xychart_layout.updateSettings(this._xychart_options);

			this._relayout(false);
			// sub component update properties
			this._backgroundComponent.updateProperties(this._xychart_options);
			this._chartComponent.updateProperties(this._xychart_options);
			this._titleComponent.updateProperties(this._xychart_options);
			this._legendComponent.updateProperties(this._xychart_options);
		},

		getProperties : function() {
			return this._propsMgr.properties();
		},

		setDataset : function(dataset) {
			this._dataTree = dataset.dataTree;
			this._metaData = dataset.metaData;
			this._initSubComponents(true);
			// re_attach additional properties
			this._attach_additional_properties();
			this._relayout(false);
			this._chartComponent.updateOptions({
				metaData : this._metaData,
				dataTree : this._dataTree,
				properties : this._xychart_options
			});

			var colorList = [];
			var defaultColors = this._xychart_options.measureDefault.colors;
			var labels = this._metaData.measureMembers;
			var measureOption = this._xychart_options.measures || {};
			for ( var i = 0, len = labels.length; i < len; i++) {
				var o = measureOption[i] || {};
				colorList.push(TypeUtils.isExist(o.fillColor) ? o.fillColor : defaultColors[i
						% defaultColors.length]);
			}

			this._legendComponent.updateOptions({
				labels : labels,
				legendTitle : this._metaData.dimension[0],
				colorList : colorList,
				properties : this._xychart_options
			});
		},
		
		getOptions : function() {
			return this._xychart_options;
		},

		/**
		 * @return events which can be listened by clients
		 */
		getSupportedAppEvents : function() {
			return this._chartComponent.getSupportedAppEvents();
		},

		doPrint : function(drawingCtx) {

		}
	});
	return XYChartComponent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.pie.AppDelegate',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.VizAppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.DataTree',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.PieController',
  version : '1.0.0'
}
],
function Setup(ObjUtils, VizAppDelegate, DataTree, PieController) {
	var AppDelegate = ObjUtils.derive(VizAppDelegate, {
		constructor : function() {
			this._rootController = undefined;
		},
		appDidFinishLaunching : function(application, launchOptions) {
			var dataset = launchOptions.data.rawData;
			var data = dataset.exportTree();

			var completedDataset = {
				dataTree : DataTree.dataTreeFromJSON(data.dataTree),
				metaData : data.metaData
			}

			this._rootController = new PieController({
				dataset : completedDataset,
				option : launchOptions.option
			});
		},
		rootController : function() {
			return this._rootController;
		},
		getPreloadAssets : function() {
			return [];
		},

		updateProperties : function(propBag) {
			this._rootController.updateProperties(propBag);
		},

		getProperties : function() {
			return this._rootController.getProperties();
		},

		getSupportedEvents : function() {
			return [ 'selectData' ];
		},

		setDataset : function(data) {
			var dataset = data.exportTree();
			var completedDataset = {
				dataTree : DataTree.dataTreeFromJSON(dataset.dataTree),
				metaData : dataset.metaData
			}

			this._rootController.setDataset(completedDataset);
		}
	});
	return AppDelegate;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.MouseEvent',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Event',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, Event) {
	/**
	 * This class defines Mouse Event
	 * 
	 * @name sap.riv.vizkit.MouseEvent
	 * @class
	 * @augments sap.riv.vizkit.Event
	 */
	var MouseEvent = ObjectUtils.derive(Event,
	/**
	 * @lends sap.riv.vizkit.MouseEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, localXY, pageXY) {
			this._relatedTarget = undefined;
			this._currentLocalXY = this._targetLocalXY = localXY;
			this._pageXY = pageXY;
		},

		_setCurrentLocalXY_ : function(currentLocalXY) {
			this._currentLocalXY = currentLocalXY;
		},

		_setRelatedTarget_ : function(relatedTarget) {
			this._relatedTarget = relatedTarget;
		},

		/**
		 * Get the XY according to target component's coordinates system
		 * 
		 * @name sap.riv.vizkit.MouseEvent#targetLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		targetLocalXY : function() {
			return {
				x : this._targetLocalXY.x,
				y : this._targetLocalXY.y
			};
		},

		/**
		 * Get the XY according to current component's coordinates system
		 * 
		 * @name sap.riv.vizkit.MouseEvent#currentLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		currentLocalXY : function() {
			return {
				x : this._currentLocalXY.x,
				y : this._currentLocalXY.y
			};
		},
		/**
		 * Get the page XY of the event
		 * 
		 * @name sap.riv.vizkit.MouseEvent#pageXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		pageXY : function() {
			return {
				x : this._pageXY.x,
				y : this._pageXY.y
			};
		}
	});
	return MouseEvent;
});sap.riv.module(
{
  qname : 'sap.riv.viz.AbstractPieChart',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractVisualization',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, AbstractVisualization) {
	var AbstractPieChart = ObjectUtils.derive(AbstractVisualization,
	/**
	 * @lends sap.riv.viz.AbstractPieChart.prototype
	 */
	{
		/**
		 * this is an abstract pie chart. clients should not use it directly
		 * @augments sap.riv.viz.AbstractVisualization
		 * @constructs
		 */
		constructor : function(holderElement, properties, dataset){
		}
	});

	return AbstractPieChart;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.ArrayUtils',
  version : '1.0.0'
},
function Setup() {
	var ArrayUtils = {
		each : function(array, callback) {
			array = array || [];
			for ( var i = 0, len = array.length; i < len; i++) {
				callback.call(array, i, array[i]);
			}
		},
		unique : function(array) {
			array = array || [];
			array = array.sort();
			for ( var i = 1; i < array.length; i++) {
				if (array[i] === array[i - 1]) {
					array.splice(i--, 1);
				}
			}
			return array;
		}
	};
	return ArrayUtils;
});sap.riv.module(
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractVisualization',
  version : '1.0.0'
}
],
function Setup(ObjUtils, AbstractVisualization) {
	var AbstractXYChart = ObjUtils.derive(AbstractVisualization,
	/**
	 * @lends sap.riv.viz.AbstractXYChart.prototype
	 */
	{
		/**
		 * this is an abstract XY chart, clients should not use it directly
		 * 
		 * @augments sap.riv.viz.AbstractVisualization
		 * @constructs
		 */
		constructor : function(holderElement, options, dataset) {
		}
	});

	return AbstractXYChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.XYChartController',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIController',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.tooltip.BaseTooltip',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.XYChartComponent',
  version : '1.0.0'
}
],
function Setup(ObjUtils, FunctionUtils, UIController, BaseTooltip, XYChartComponent) {
	var Controller = ObjUtils.derive(UIController, {
		constructor : function(options) {
			this._dataset = options.dataset;
			this._chartComponent = undefined;
			this._option = options.option;
			this._tooltip = null;
		},
		/**
		 * Subclass should overide this method to initialize custom UIComponent
		 * hierarchy and return the root UIComponent. The default implementation
		 * creates an empty UIComponent
		 */
		initUIComponent : function(width, height) {
			this._chartComponent = new XYChartComponent({
				id : 'rootComponent',
				dataset : this._dataset,
				xyChartOptions : this._option,
				clipToBound : false,
				size : {
					w : width,
					h : height
				}
			});
			return this._chartComponent;
		},

		doThemeApplied : function(theme) {
			this._chartComponent.applyTheme(theme);
		},

		updateProperties : function(propBag) {
			this._chartComponent.updateProperties(propBag);
			this._tooltip.reset({
				parent : this._chartComponent,
				metaData : this._dataset.metaData,
				dataTree : this._dataset.dataTree,
				properties : this._chartComponent.getOptions()
			});
		},

		getProperties : function() {
			return this._chartComponent.getProperties();
		},

		getSupportedEvents : function() {
			return this._chartComponent.getSupportedEvents();
		},

		getSupportedAppEvents : function() {
			return this._chartComponent.getSupportedAppEvents();
		},

		/**
		 * This method will be called after the managed UIComponent initialized
		 */
		afterUIComponentLoaded : FunctionUtils.noop,

		/**
		 * This method will be called when the managed UIComponent will become
		 * visible via set the hidden property
		 */
		beforeUIComponentAppear : FunctionUtils.noop,

		/**
		 * This method will be called after the managed UIComponent became
		 * visible via set the hidden property
		 */
		afterUIComponentAppear : function() {
			// init tooltip
			this._tooltip = new BaseTooltip({
				parent : this._chartComponent,
				metaData : this._dataset.metaData,
				dataTree : this._dataset.dataTree,
				properties : this._chartComponent.getOptions()
			});
			
			// var customizedTooltip = this._tooltip.getCustomization();
			// if (customizedTooltip != null) {
			//    // TODO use customized tooltip
			// }

			var appEvent = this._chartComponent.getSupportedAppEvents();
			for ( var i = appEvent.length; i-- || i == 0;) {
				this._chartComponent._chartComponent._chartModule.on({
					eventName : appEvent[i],
					listener : this._fireInternalAppEvent,
					scope : this
				});
			}
		},
		/**
		 * This method will be called when the managed UIComponent will become
		 * visible via set the hidden property
		 */
		beforeUIComponentDisappear : FunctionUtils.noop,
		/**
		 * This method will be called after the managed UIComponent became
		 * visible via set the hidden property
		 */
		afterUIComponentDisappear : FunctionUtils.noop,

		setDataset : function(dataset) {
			this._dataset = dataset;
			this._chartComponent.setDataset(dataset);
			this._tooltip.reset({
				parent : this._chartComponent,
				metaData : this._dataset.metaData,
				dataTree : this._dataset.dataTree,
				properties : this._chartComponent.getOptions()
			});
		},

		_fireInternalAppEvent : function(evt) {
			// [Ian] if the event type is showTooltip, we should convert the
			// point to global point based on root component
			if (evt.name === 'showTooltip') {
				var pointOnSeriesLayer = evt.data[0].point;
				// convert point on series layer to root layer
				var pointOnRootLayer = this._chartComponent._chartComponent._rootLayer.convertPointFromLayer(
						pointOnSeriesLayer, this._chartComponent._chartComponent._seriesLayer)
				var pointOnComponent = {};
				var pos = this._chartComponent._chartComponent.position();

				// convert point to root component
				pointOnComponent.x = pointOnRootLayer.x + pos.x;
				pointOnComponent.y = pointOnRootLayer.y + pos.y;

				// reset the point
				evt.data[0].point = pointOnComponent;

				this._tooltip.show(evt);
			} else if (evt.name == 'hideTooltip') {
				this._tooltip.hide(evt);
			}
			this.fireAppEvent(evt.name, evt);
		}
	});
	return Controller;
});sap.riv.module(
{
  qname : 'sap.riv.core.utils.DomWatcher',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.UADetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
}
],
function Setup(UADetector, LinkedHashMap) {
    var watcherId = 0;
    var domId = 1;
    var nextWatcherId = function() {
        return watcherId++;
    };
    var nextDomId = function() {
        return domId++;
    };
    var isEmpty = function(obj) {
        for(var prop in obj) {
            if(obj.hasOwnProperty(prop))
                return false;
        }
        return true;
    };
    var css = function(dom, prop) {
        var val = null;
        if(window.getComputedStyle) {
            val = window.getComputedStyle(dom, null)[prop];
        } else if(dom.currentStyle) {
            val = dom.currentStyle[prop];
        }
        return val;
    };
    var domDataAccessor = function(key, value) {
        if(!this._data)
            this._data = {};
        if(arguments.length === 2) {
            this._data[key] = value;
        } else
            return this._data[key];
    };
    var domTasks = new LinkedHashMap();

    var eventHandler = function(e) {
    	var task;
        var dom = e.srcElement || e.target;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId)
            return;
        var domTaskIt = domTasks.get(domId).getIterator();
        while(domTaskIt.hasMore()) {
            task = domTaskIt.nextValue();
            task.checkChange();
        }
    };
    var addEventHandler = function(id) {
        var task = taskQueue.get(id);
        var dom = task.domElem;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId) {
            domId = nextDomId();
            domDataAccessor.call(dom, 'domId', domId);
            domTasks.add(domId, new LinkedHashMap());
        }
        domTasks.get(domId).add(task.id, task);
        if(!domDataAccessor.call(dom, 'eventHandler')) {
            if( typeof (dom.onpropertychange) == "object") {
                dom.attachEvent("onpropertychange", eventHandler);
            } else if(UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6) {
                dom.addEventListener("DOMAttrModified", eventHandler);
            }
            domDataAccessor.call(dom, 'eventHandler', eventHandler);
        }
    };
    var removeFromEventHandler = function(task) {
        var dom = task.domElem;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId)
            return;

        if(domTasks.get(domId).has(task.id))
            domTasks.get(domId).remove(task.id);

        if(domTasks.get(domId).isEmpty()) {
            var eventHandler = domDataAccessor.call(dom, 'eventHandler');
            if( typeof (dom.onpropertychange) == "object") {
                dom.detachEvent("onpropertychange", eventHandler);
            } else if(UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6) {
                dom.removeEventListener("DOMAttrModified", eventHandler);
            }
            domDataAccessor.call(dom, 'eventHandler', null);
        }
    };
    var scannerInstance = undefined;
    var taskQueue = new LinkedHashMap();
    var scanner = function() {
        var taskItr = taskQueue.getIterator();
        var task;
        while(taskItr.hasMore()) {
            task = taskItr.nextValue();
            task.checkChange();
        }
    };
    var addIntervalTask = function(task) {
        if(!scannerInstance)
            scannerInstance = setInterval(scanner, 100);
        if(!taskQueue.has(task.id))
            taskQueue.add(task.id, task);
    };
    var removeIntervalTask = function(id) {
        if(taskQueue.has(id)) {
            taskQueue.remove(id);
        }
        if(taskQueue.isEmpty()) {
            clearInterval(scannerInstance);
            scannerInstance = undefined;
        }
    };
    var hookChange = function(task) {
        var dom = task.domElem;
        if( typeof (dom.onpropertychange) == "object" || (UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6)) {
            addEventHandler(task.id);
        } else {
            //for browsers not support dom attributes change event, add a iterval task to check properties changes.
            addIntervalTask(task);
        }
    };
    var __watcher = function(id) {
        var task = taskQueue.get(id);
        if(!task)
            return;
        var dom = task.domElem;
        if(!task.callback)
            return;

        var changed = false;
        var i = 0;
        var changedProps = [];
        for(var l = task.cssProps.length; i < l; i++) {
            var newVal = css(dom, task.cssProps[i]);
            if(task.lastestVals[i] != newVal) {
                task.lastestVals[i] = newVal;
                changed = true;
                changedProps.push(task.cssProps[i]);
            }
        }
        if(changed)
            //task.callback.call(caller, changedProps);
            task.callback(changedProps);
    };
    //var caller;
    var DomWatcher = {
        /**
         * watch a dom element on specific css properties, if change, excute callback func,
         * callback parameter is an array of changed properties
         *
         * @param dom element to watch
         * @param props css properties on element to watch, input as a string, properties should be seperated by comma ','
         * @param func function to execute on properties change, when calling DomWatcher.watch,
         *     ObjectUtils.proxy(func, this) is recommend for the callback function. i.e. DomWatcher.watch(dom,props, ObjectUtils.proxy(func, this));
         * @return generated watcher id
         */
        watch : function(dom, props, func) {
            //caller = this.watch.caller;
            var id = nextWatcherId();
            var checkChange = function() {
                __watcher(id);
            };
            var task = {
                id : id,
                domElem : dom,
                cssProps : props.split(","),
                lastestVals : [props.split(",").length],
                callback : func,
                checkChange : checkChange
            };

            for(var i = 0, len = task.cssProps.length; i < len; i++) {
                task.lastestVals[i] = css(dom, task.cssProps[i]);
            }
            if(!taskQueue.has(task.id))
                taskQueue.add(task.id, task);
            hookChange(task);
            return id;
        },
        unwatch : function(id) {
            var task = taskQueue.get(id);
            var dom = task.domElem;
            try {
                if( typeof (dom.onpropertychange) == "object" || (UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6)) {
                    removeFromEventHandler(task);
                } else
                    removeIntervalTask(task.id);
            }
            // ignore if element was already unbound
            catch (e) {
            }
        }
    };
    return (DomWatcher);
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.VizFrame',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.GestureDetector',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.DomWatcher',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.Event',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.MouseEvent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.TouchEvent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Math',
  version : '1.0.0'
}
],
function Setup(FunctionUtils, ObjectUtils, UIComponent, GestureDetector, DomWatcher, Event, MouseEvent, TouchEvent,
		Math) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	var isInDomtree = function(node) {
		var bodyNode = undefined;
		do {
			if (node.nodeName == 'BODY') {
				bodyNode = node;
				break;
			} else {
				node = node.parentNode;
			}
		} while (node)
		return bodyNode;
	};

	var setFrame = function(vframe) {
		// set offset according to parent postion property
		var holder = vframe._holder;
		if (holder.css('position') == "static" || holder.css('position') == "fix") {
			var position = holder.position();
			vframe.frame({
				x : position.left,
				y : position.top,
				width : holder.width(),
				height : holder.height()
			});
		} else {
			vframe.frame({
				x : 0,
				y : 0,
				width : holder.width(),
				height : holder.height()
			});
		}
	};
	// callback on css change
	var func = function(changedProps) {
		for ( var i = 0, len = changedProps.length; i < len; i++) {
			if (changedProps[i] === "position") {
				setFrame(this);
				break;
			}
		}
	};

	var getHittedComponent = function(event) {
		var domEntity = $(event.target);
		while (!domEntity.data('selfComp')) {
			domEntity = domEntity.parent();
		}
		return domEntity.data('selfComp');
	};

	var ts = GestureDetector.TransitionState;
	var VizFrame = ObjectUtils
			.derive(
					UIComponent,
					{
						constructor : function(options) {
							if (options.container) {
								this._holder = $(options.container);
								if (!isInDomtree(this._holder.get(0))) {
									FunctionUtils.error('The holder DIV must be a child of Body element.');
								}
								// VizFrame's logical parent is always visible
								if (this._holder.css('display') === 'none') {
									this.markHide();
								}
								this.clipToBound(false);
								this._regDOMEventHandlers();
								this._holder.append(this._container);
								this.anchorPoint({
									x : 0,
									y : 0
								});
								setFrame(this);
								// watch position changes
								DomWatcher.watch(this._holder.get(0), "position", ObjectUtils.proxy(func, this));
								this._parentVisible = true;
								this._attached = true;
								// structure for event dispatching
								this._msTracking = [];
								this._touchSeqTracking = {};

							} else {
								throw new Error('you have to provide a container for viz frame');
							}
						},

						_regDOMEventHandlers : function() {
							this._container.bind('click', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('dblclick', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focusin', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focusout', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focus', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('blur', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mousedown', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseup', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseenter', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseleave', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mousemove', ObjectUtils.proxy(this._handleDomEvent, this));
							// Below events are supposed to be fired when the
							// element is attached/detached to/from document,
							// it's used to register touch listener correctly in
							// iOS Mobile Safari.
							this._container.bind('DOMNodeInsertedIntoDocument', ObjectUtils.proxy(
									this._registerDOMTouchHandler, this));
							this._container.bind('DOMNodeRemovedFromDocument', ObjectUtils.proxy(
									this._unregisterDOMTouchHandler, this));
						},

						_registerDOMTouchHandler : function() {
							this._container.bind('touchstart', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchmove', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchend', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchcancel', ObjectUtils.proxy(this._handleDomEvent, this));
						},

						_unregisterDOMTouchHandler : function() {
							this._container.unbind('touchstart');
							this._container.unbind('touchmove');
							this._container.unbind('touchend');
							this._container.unbind('touchcancel');
						},

						_handleDomEvent : function(event) {
							event.preventDefault();
							var hittedComp = getHittedComponent(event);
							switch (event.type) {
							case 'mousemove':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									var localPoint = {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									};
									if (this._msTracking.length) {
										if (this._msTracking[this._msTracking.length - 1] !== hittedComp) {
											var enteredComps = [];
											var entered = hittedComp;
											while (entered) {
												enteredComps.push(entered);
												entered = entered.superComponent();
											}
											var inCompCount = 0, checkFinished = false, minLen = Math.min(
													this._msTracking.length, enteredComps.length);
											while (true) {
												var left = undefined;
												if (!checkFinished
														&& this._msTracking[inCompCount] === enteredComps[enteredComps.length
																- 1 - inCompCount]) {
													inCompCount++;
													checkFinished = inCompCount === minLen;
												} else {
													while (this._msTracking.length > inCompCount) {
														left = this._msTracking.pop();
														var mlEvt = new MouseEvent('mouseleave', left, false,
																localPoint, {
																	x : event.pageX,
																	y : event.pageY
																});
														mlEvt._setRelatedTarget_(hittedComp);
														left._fireMouseEvent_(mlEvt);
													}
													while (inCompCount < enteredComps.length) {
														var entered = enteredComps.shift();
														left = this._msTracking[enteredComps.length - 1];
														this._msTracking[enteredComps.length] = entered;
														var mlEvt = new MouseEvent('mouseenter', entered, false,
																localPoint, {
																	x : event.pageX,
																	y : event.pageY
																});
														mlEvt._setRelatedTarget_(left);
														entered._fireMouseEvent_(mlEvt);
													}
													break;
												}
											}
										}
									} else {
										var entered = hittedComp;
										do {
											this._msTracking.push(entered);
											entered._fireMouseEvent_(new MouseEvent('mouseenter', entered, false,
													localPoint, {
														x : event.pageX,
														y : event.pageY
													}));
											entered = entered.superComponent();
										} while (entered)
										this._msTracking.reverse();
									}
									hittedComp._fireMouseEvent_(new MouseEvent('mousemove', hittedComp, true,
											localPoint, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									while (this._msTracking.length) {
										var left = this._msTracking.pop();
										left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, localPoint, {
											x : event.pageX,
											y : event.pageY
										}));
									}
								}
								break;
							case 'mouseleave':
								while (this._msTracking.length) {
									var left = this._msTracking.pop();
									var leftCompPageXY = left.pagePosition();
									left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, {
										x : event.pageX - leftCompPageXY.x,
										y : event.pageY - leftCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'mouseup':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									hittedComp._fireMouseEvent_(new MouseEvent('mouseup', hittedComp, true, {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'mousedown':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									hittedComp._fireMouseEvent_(new MouseEvent('mousedown', hittedComp, true, {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'dblclick':
								if (hittedComp) {
									if (this._focusedComp) {
										if (this._focusedComp.id() !== hittedComp.id()) {
											this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
											this._focusedComp._fireEvent_(new Event('focusout', this._focusedLayer,
													true));
											this._focusedComp = hittedComp;
											this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusin', this._focusedComp, true));
										}
									} else {
										this._focusedComp = hittedComp;
										this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusin', this._focusedComp, true));
									}
									var hittedCompPageXY = hittedComp.pagePosition();
									this._focusedComp._fireMouseEvent_(new MouseEvent('dblclick', this._focusedComp,
											true, {
												x : event.pageX - hittedCompPageXY.x,
												y : event.pageY - hittedCompPageXY.y
											}, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									if (this._focusedComp) {
										this._focusedComp._fireEvent_(new Event('blur', this._focusedLayer, false));
										this._focusedComp._fireEvent_(new Event('focusout', this._focusedLayer, true));
										this._focusedComp = undefined;
									}
								}
								break;
							case 'click':
								if (hittedComp) {
									if (this._focusedComp) {
										if (this._focusedComp.id() !== hittedComp.id()) {
											this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusout', this._focusedComp, true));
											this._focusedComp = hittedComp;
											this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusin', this._focusedComp, true));
										}
									} else {
										this._focusedComp = hittedComp;
										this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusin', this._focusedComp, true));
									}
									var hittedCompPageXY = hittedComp.pagePosition();
									this._focusedComp._fireMouseEvent_(new MouseEvent('click', this._focusedComp, true,
											{
												x : event.pageX - hittedCompPageXY.x,
												y : event.pageY - hittedCompPageXY.y
											}, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									if (this._focusedComp) {
										this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusout', this._focusedComp, true));
										this._focusedComp = undefined;
									}
								}
								break;
							case 'touchstart':
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									// 'false' means the touch hasn't been
									// marked
									// cancelled
									this._touchSeqTracking[touch.identifier] = false;
								}

								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								var touchEvent = TouchEvent.buildFromDomTouchEvent('touchstart', hittedComp,
										event.originalEvent);
								hittedComp._fireTouchEvent_(touchEvent);
								break;
							case 'touchmove':
								// Handle gesture Detection and fire touchmove
								// event when no gesture currently detected
								if (!this._handleGestureDetect(hittedComp, event.originalEvent)) {
									var touchEvent = TouchEvent.buildFromDomTouchEvent('touchmove', hittedComp,
											event.originalEvent);
									hittedComp._fireTouchEvent_(touchEvent);
								}
								break;
							case 'touchend':
								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								var uncancelledTouchesArray = [], cancelledTouchesArray = [], touchesArray = [], targetTouchesArray = [];
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									this._touchSeqTracking[touch.identifier] === true ? cancelledTouchesArray
											.push(touch) : uncancelledTouchesArray.push(touch);
									delete this._touchSeqTracking[touch.identifier];
								}

								if (uncancelledTouchesArray.length) {
									// Some touches are not cancelled, so we
									// have to split the event into two events,
									// one for cancelled touches, one for
									// uncancelled touches
									for ( var i = 0, touch, targetTouches = event.originalEvent.targetTouches, len = targetTouches.length; i < len; i++) {
										touch = targetTouches.item(i);
										targetTouchesArray.push(touch);
									}
									for ( var i = 0, touch, touches = event.originalEvent.touches, len = touches.length; i < len; i++) {
										touch = touches.item(i);
										touchesArray.push(touch);
									}
									var touchCancelEvent = TouchEvent.buildFrom3TouchArray('touchcancel', hittedComp,
											touchesArray, cancelledTouchesArray, targetTouchesArray);
									hittedComp._fireTouchEvent_(touchCancelEvent);
									var touchEndEvent = TouchEvent.buildFrom3TouchArray('touchend', hittedComp,
											touchesArray, uncancelledTouchesArray, targetTouchesArray);
									hittedComp._fireTouchEvent_(touchEndEvent);
								} else {
									// All ended touches are marked as cancelled
									var touchEvent = TouchEvent.buildFromDomTouchEvent('touchcancel', hittedComp,
											event.originalEvent);
									hittedComp._fireTouchEvent_(touchEvent);
								}
								// Fire touch event
								break;

							case 'touchcancel':
								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									delete this._touchSeqTracking[touch.identifier];
								}
								var touchEvent = TouchEvent.buildFromDomTouchEvent('touchcancel', hittedComp,
										event.originalEvent);
								hittedComp._fireTouchEvent_(touchEvent);
								break;
							}
						},

						_handleGestureDetect : function(hittedComponent, origTouchEvent) {
							var grs = [];
							var thisLevel = hittedComponent;
							// find the gesture recognizers responsible for the
							// gesture detection of the component hierarchy
							while (!thisLevel._gestureDetectors.length && thisLevel._superComp) {
								thisLevel = thisLevel._superComp;
							}
							grs = thisLevel._gestureDetectors;
							var someGestureDetected = false, gestureDetected, needToCancelTouches = false;
							for ( var i = 0, state, gd, len = grs.length; i < len; i++) {
								gd = grs[i];
								switch (origTouchEvent.type) {
								case 'touchstart':
									gd.touchBegin(origTouchEvent);
									break;
								case 'touchmove':
									gd.touchMove(origTouchEvent);
									break;
								case 'touchend':
									gd.touchEnd(origTouchEvent);
									break;
								case 'touchcancel':
									gd.touchCancel(origTouchEvent);
									break;
								}
								state = gd.state();
								gestureDetected = (state === ts.Began) || (state === ts.Changed)
										|| (state === ts.Recognized);
								someGestureDetected = someGestureDetected || gestureDetected;
								needToCancelTouches = needToCancelTouches || (gestureDetected && gd.cancelTouches());
							}
							if (needToCancelTouches) {
								for ( var i = 0, touch, changedTouches = origTouchEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									// Mark all changed touch as cancelled
									this._touchSeqTracking[touch.identifier] = true;
								}
							}
							return someGestureDetected;
						},

						hidden : function(hidden) {
							hidden ? this._holder.hide() : this._holder.show();
							if (hidden) {
								this.markHide();
							} else {
								this.markShow();
							}
						}
					});
	return VizFrame;
});sap.riv.module(
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.Observable',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ThemeManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.ImageManager',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.VizFrame',
  version : '1.0.0'
},
{
  qname : 'sap.riv.graphics.CanvasHelper',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.UIComponent',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(Observable, FuncUtils, ObjectUtils, ThemeManager, ImageManager, VizFrame, CanvasHelper, UIComponent, LOG) {
    
    var id = 0;
    function nextId(){
        return id++;
    }
	var Autosizing = UIComponent.Autosizing;
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	/**
	 * The main entry of a given visualization application. It implements most
	 * of the things that need to start a viz application, e.g. bootstrapping,
	 * preload images
	 * 
	 * @name sap.riv.vizkit.VizApplication
	 * @constructor
	 * @param {Object}
	 *            options the options that needs to start the application
	 * @param {String}
	 *            options.wrapperDivEl the wrapper DIV element
	 * @param {Constructor}
	 *            options.delegateClass the constructor of your custom viz app
	 *            delegate
	 * @param {Object}
	 *            [launchOption] the additional option that will pass to the
	 *            {@link sap.riv.vizkit.VizAppDelegate#appDidFinishLaunching}
	 */
	var VizApplication = function(options) {
	    var _nextId = nextId();
        this._id = options.id ? options.id + '_' + _nextId : _nextId;
        LOG.debug("Chart Application["+this._id+"] initializing.","perf");
		if (!options.delegateClass) {
			FuncUtils.error('You have to specify a delegate for visualization custom behavior.');
		}
		if (!options.wrapperDivEl) {
			FuncUtils.error('You have to specify a div element for holding the visualization.');
		}
		this._vizFrame = new VizFrame({
			container : options.wrapperDivEl
		});
		this._canvasForPrinting = CanvasHelper.createCanvasElement(1, 1);
		this._delegate = new options.delegateClass();
		var assets = this._delegate.getPreloadAssets();
		ImageManager.loadImages(assets, undefined, ObjectUtils.proxy(function() {
			this._delegate._afterLaunched(this, options.launchOption);
		}, this));
		var comsItr = this._vizFrame.subComponents().getIterator();
		while(comsItr.hasMore()){
		    LOG.debug("application["+this._id+"]"+"component["+comsItr.nextValue().id()+"] initialized.","perf");
		}
		this._eventBridge = new Observable();
		this._addEvents(this._delegate.getSupportedEvents());
		ThemeManager.on('defaultThemeChanged', this._handleDefaultThemeChanged);
		ThemeManager.on('themeSettingChanged', this._handleThemeSettingChanged);
	};

	var ap = VizApplication.prototype;
	
    ap.id = function(){
        return this._id;
    };
	/**
	 * Print the current state of the running viz application to the given
	 * canvas
	 * 
	 * @name sap.riv.vizkit.VizApplication#printTo
	 * @param {Object}
	 *            options the print option
	 * @param {String}
	 *            options.targetCanvas the id of the target canvas to print to
	 * 
	 */
	ap.printTo = function(options) {
		if (options.targetCanvas) {
			var targetCanvas = CanvasHelper.getCanvasElement($(options.targetCanvas));
			var workingCanvas = this._canvasForPrinting;
			var workingCtx = workingCanvas.getContext('2d');
			var destCtx = targetCanvas.getContext('2d');
			var size = this.size();
			workingCanvas.width(size.width);
			workingCanvas.height(size.height);
			destCtx.clearRect(0, 0, targetCanvas.width(), targetCanvas.height());
			destCtx.save();
			destCtx.scale(targetCanvas.width() / size.width, targetCanvas.height() / size.height);
			destCtx.translate(0, 0);
			destCtx.rect(0, 0, size.width, size.height);
			destCtx.clip();
			var pStack = [ {
				processed : false,
				uiComp : this._vizFrame,
				subCompItr : this._vizFrame.subComponents().getIterator()
			} ], cFrame, cUIComp;
			while (pStack.length) {
				cFrame = pStack[pStack.length - 1];
				cUIComp = cFrame.uiComp;
				if (cUIComp.printable() && !cUIComp.hidden()) {
					if (!cFrame.processed) {
						cUIComp.printTo(workingCtx);
						destCtx.drawImage(workingCanvas, 0, 0);
						cFrame.processed = true;
					}
					if (cFrame.subCompItr.hasMore()) {
						var subComp = cFrame.subCompItr.next().value;
						workingCanvas.width(subComp.width());
						workingCanvas.height(subComp.height());
						var frame = subComp.frame();
						destCtx.save();
						destCtx.translate(frame.x, frame.y);
						destCtx.beginPath();
						destCtx.moveTo(0, 0);
						destCtx.lineTo(frame.width, 0);
						destCtx.lineTo(frame.width, frame.height);
						destCtx.lineTo(0, frame.height);
						destCtx.closePath();
						destCtx.clip();
						pStack.push({
							processed : false,
							uiComp : subComp,
							subCompItr : subComp.subComponents().getIterator()
						});
					} else {
						destCtx.restore();
						pStack.pop();
					}
				} else {
					destCtx.restore();
					pStack.pop();
				}
			}
		}
	};

	/**
	 * Get and set the size of the application
	 * 
	 * @name sap.riv.vizkit.VizApplication#size
	 * @param {undefined|Object}
	 *            size undefined or new size of the application
	 * @returns {this|Object} when set the size the return is this object, when
	 *          get the size the return will be the size
	 * 
	 */
	ap.size = function(size) {
		if (size !== undefined) {
			this._vizFrame.size(size);
			return this;
		} else {
			return this._vizFrame.size();
		}
	};

	/**
	 * Get and set the visibility of the application
	 * 
	 * @name sap.riv.vizkit.VizApplication#hidden
	 * @param {undefined|Boolean}
	 *            hidden undefined or boolean value indicating whether the
	 *            application should be hided.
	 * @returns {this|Object} when set the hidden status the return is this
	 *          object, when get the hidden status the return will be the
	 *          current hidden status.
	 * 
	 */
	ap.hidden = function(hidden) {
		if (hidden !== undefined) {
			if (this._vizFrame.hidden() !== hidden) {
				this._vizFrame.hidden(hidden);
			}
			return this;
		} else {
			return this._vizFrame.hidden();
		}
	};
	/**
	 * Get a list of event names the current visualization instance supports
	 * 
	 * @name sap.riv.vizkit.VizApplication#getSupportedEvent
	 * @returns {Array} an array of event names supported
	 * 
	 */
	ap.getSupportedEvent = function() {
		return this._eventBridge.getSupportedEvents();
	};
	/**
	 * Add a listener to the supported event
	 * 
	 * @name sap.riv.vizkit.VizApplication#addListener
	 * @param {String}
	 *            event the event to listen
	 * @param {Function}
	 *            listener the function to be called back when event occurs
	 * 
	 */
	ap.addListener = function(event, listener) {
		this._eventBridge.addListeners({
			eventName : event,
			listener : listener
		});
	};
	/**
	 * Remove an existing listener
	 * 
	 * @name sap.riv.vizkit.VizApplication#removeListener
	 * @param {String}
	 *            event the event to listen
	 * @param {Function}
	 *            listener the existing function to be removed
	 * 
	 */
	ap.removeListener = function(event, listener) {
		this._eventBridge.removeListener(event, listener);
	};

	ap._addEvents = function(events) {
		for ( var i = 0, len = events.length; i < len; i++) {
			this._eventBridge.addEvents(events[i]);
		}
	};

	ap._fireEvent = function() {
		this._eventBridge.fireEvent.apply(this._eventBridge, arguments);
	};

	/**
	 * Get a list of public method names the current visualization instance
	 * supports
	 * 
	 * @name sap.riv.vizkit.VizApplication#getPublicMethods
	 * @returns {Array} an array of public method names supported
	 * 
	 */
	ap.getPublicMethods = function() {
		this._delegate.getSupportedMethods();
	};
	/**
	 * Invoke the public method of the current visualization with options
	 * 
	 * @name sap.riv.vizkit.VizApplication#invokePublicMethod
	 * @param {String}
	 *            publicMethodName, the name of the public method.
	 * @param {Object}
	 *            [options] the options object is passed as argument.
	 */
	ap.invokePublicMethod = function(publicMethodName, options) {
		this._delegate._invokePublicMethod(publicMethodName, options);
	};
	/**
	 * Apply a new theme to the visualization instance
	 * 
	 * @name sap.riv.vizkit.VizApplication#applyTheme
	 * @param {String}
	 *            theme, the name of the theme.
	 */
	ap.applyTheme = function(theme) {
		this._delegate._applyTheme(theme);
	};

	/**
	 * Get or set the properties of the current visualization instance.
	 * 
	 * @name sap.riv.vizkit.VizApplication#properties
	 * @param {Object}
	 *            [propBag]
	 * @returns {Object}
	 */
	ap.properties = function(propBag) {
		if (propBag !== undefined) {
			this._delegate.updateProperties(propBag);
		}
		return this._delegate.getProperties();
	};

	/**
	 * Update dataset after chart created
	 * 
	 * @name sap.riv.vizkit.VizApplication#setDataset
	 * @param {Object}
	 */
	ap.setDataset = function(dataset) {
		if (dataset) {
			this._delegate.setDataset(dataset);
		}
	};

	ap._setRootController = function(rootController) {
		if (rootController) {
			var rootUIComp = rootController.rootUIComponent();
			rootUIComp.frame(this._vizFrame.bounds());
			rootUIComp.autoresizingMask(Autosizing.FlexibleWidth | Autosizing.FlexibleHeight);
			this._vizFrame.addSubComponent(rootUIComp);
		}
	};

	ap._handleDefaultThemeChanged = function(oldDefault, newDefault) {
		if (this._delegate._currentTheme() === oldDefault) {
			this._delegate._applyTheme(newDefault);
		}
	};

	ap._handleThemeSettingChanged = function(theme, key, oldValue, newValue) {
		this._delegate._updateThemeSetting(theme, key, oldValue, newValue);
	};
	return VizApplication;
});sap.riv.module(
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.VizAppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.vizkit.DataTree',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.XYChartController',
  version : '1.0.0'
}
],
function Setup(ObjUtils, VizAppDelegate, DataTree, XYChartController) {
	var AppDelegate = ObjUtils.derive(VizAppDelegate, {
		constructor : function() {
			this._rootController = undefined;
		},
		appDidFinishLaunching : function(application, launchOptions) {
			var dataset = launchOptions.data.rawData;
			var data = dataset.exportTree();

			var completedDataset = {
				dataTree : DataTree.dataTreeFromJSON(data.dataTree),
				metaData : data.metaData
			}

			this._rootController = new XYChartController({
				dataset : completedDataset,
				option : launchOptions.option
			});
		},
		rootController : function() {
			return this._rootController;
		},
		getPreloadAssets : function() {
			return [];
		},

		updateProperties : function(propBag) {
			this._rootController.updateProperties(propBag);
		},

		getProperties : function() {
			return this._rootController.getProperties();
		},

		getSupportedEvents : function() {
			return [ 'selectData' ];
		},

		setDataset : function(data) {
			var dataset = data.exportTree();
			var completedDataset = {
				dataTree : DataTree.dataTreeFromJSON(dataset.dataTree),
				metaData : dataset.metaData
			}

			this._rootController.setDataset(completedDataset);
		}
	});
	return AppDelegate;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.log.LogAnalyzer',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.core.utils.LinkedHashMap',
  version : '1.0.0'
}
],
function Setup(LinkedHashMap) {

    /*var Node = function(key, value) {
        this.key = key;
        this.value = value;
        this.childs = [];
    };
    Node.prototype = {
        addChild : function(node) {
            this.childs.push(node);
        },
        search : function(key ,value) {
            // var node = this;
            if(this.key === key && this.value === value)
                return this;
            else {
                var nodes = this.childs;
                for(var i = 0, l = nodes.length; i < l; i++) {
                    var ret = nodes[i].search(key);
                    if(ret !== null)
                        return ret;
                }
                return null;
            }
        }
    };

    var Tree = function(node) {
        this.root = node;
    };
    Tree.prototype = {
        searchTree : function(key, value) {
            var p = this.root;
            return p.search(key, value);
        }
    };*/
    
    var chartStartTime = {};
    var chartAppMap={};
    var chartAppComMap={};
    var chartMap = new LinkedHashMap();
    var chartStartP = /Chart\[(.+?)\]\sinitializing\./;
    var chartMapP= /Chart\[(.+?)\]application\[(.+?)\]\sinitialized\./;
    //var chartAppStartP = /Chart\sApplication\[(.+?)\]\sinitializing\./;
    //var chartComStartP = /chart\[(.+?)\]start\sinitialize\sSubComponents\./;
    var chartAppComMapP = /application\[(.+?)\]component\[(.+?)\]\sinitialized\./;
    var chartSubP = /chartComponent\[(.+?)\]subComponent\[(.+?)\]initialized\./;
    // var chartFinishP = /chart\[(.+?)\]all\ssubComponents\sinitialized\./;
    var comP = /layer\[(.+?)\]rendering\send\./;
    //var comSkipP = /chart\[(.+?)\]subComponent\[(.+?)\]skipped\./;
    var timeP = /#(\d+)#/;

    function chartFinished(comItr) {
        while(comItr.hasMore()) {
            if(comItr.nextValue() === -1)
                return false;
        }
        return true;
    }

    function max(nums) {
        var m = nums[0];
        var length = nums.length;
        for(var i = 1; i < length; i++) {
            m = nums[i] > m ? nums[i] : m;
        }
        return m;
    }

    var LogAnalyzer = {
        analyze : function(log) {
            var m = chartStartP.exec(log);
            if(m){
                // chartMainStartTime[m[1]]=timeP.exec(log)[1];
                chartStartTime[m[1]]=timeP.exec(log)[1];
                return;
            }
            m=chartAppComMapP.exec(log);
            if(m){
                chartAppComMap[m[2]]=m[1];
                //chartStartTime[m[2]] = {chart:chartAppTime[m[1]].chart,time:chartAppTime[m[1]].time};
                return;
            }
            m=chartMapP.exec(log);
            if(m){
                chartAppMap[m[2]]=m[1];
                //chartAppTime[m[2]] = {chart:m[1],time:chartMainStartTime[m[1]]};
                return;
            }
            // m = chartComStartP.exec(log);
            // if(m) {
            // chartStartTime[m[1]] = undefined;//timeP.exec(log)[1];
            // return;
            // }
            m = chartSubP.exec(log);
            if(m) {
                if(!chartMap.has(m[1])) {
                    chartMap.add(m[1], new LinkedHashMap());
                }
                chartMap.get(m[1]).add(m[2], -1);
                return;
            }
            // m = comSkipP.exec(log);
            // if(m) {
                // chartMap.get(m[1]).remove(m[2]);
                // return;
            // }
            m = comP.exec(log);
            if(m) {
                var timeStamp = timeP.exec(log)[1];
                var chartItr = chartMap.getIterator();
                while(chartItr.hasMore()) {
                    var chart = chartItr.next();
                    var componentMap = chart.value;
                    if(componentMap.has(m[1]) && componentMap.get(m[1]) === -1) {
                        componentMap.add(m[1], timeStamp);
                        var chartTime = 0;
                        var comItr = componentMap.getIterator();
                        if(chartFinished(comItr)) {
                            comItr.reset();
                            var endTimes = [];
                            while(comItr.hasMore()) {
                                endTimes.push(comItr.nextValue());
                            }
                            var chartKey =chartAppMap[chartAppComMap[chart.key]];
                            chartTime = max(endTimes) - chartStartTime[chartKey];
                            chartMap.remove(chart.key);
                            return ("chart[" + chartKey + "]time consume[" + chartTime + "]");
                        }
                    }
                }
            }
        }
    };
    return LogAnalyzer;
});sap.riv.module(
{
  qname : 'sap.riv.viz.MultiPieChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractPieChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractPieChart, LOG) {
	var multiPieChart = ObjUtils.derive(AbstractPieChart,
	/**
	 * @lends sap.riv.viz.MultiPieChart.prototype
	 */
	{
		/**
		 * @constructs
		 * @augments sap.riv.viz.AbstractPieChart
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'multipie';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return multiPieChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.dataConverter.CrossTableDataset',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ArrayUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.dataConverter.BaseDataset',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, ArrayUtils, TypeUtils, BaseDataset) {
	var crossTableDataset = ObjectUtils
			.derive(
					BaseDataset,
					/**
					 * @lends sap.riv.viz.shared.dataConverter.CrossTableDataset.prototype
					 */
					{
						/**
						 * CrossTableDataset can contain multiple dimensions and multiple measures
						 * in two axes
						 * @constructs
						 */
						constructor : function() {
							// -------------------------------------------
							// Properties
							// -------------------------------------------
							this.metadata = {
								columnAxis : [],
								rowAxis : []
							};

							this.origData = [];
							this.data = [];
							this.aggregation = [];

							this.chartInstances = {};
							// all chart instances which use this dataset

							this._axisCounter = 0;

							this.ERROR_CHAR = "NaN";
							this.AXIS_TYPE_MEASURE = "measure";
							this.AXIS_TYPE_DIMENSION = "dimension";

							this.AXIS_KEY_TYPE = "type";
							this.AXIS_KEY_LEVEL = "level";

							this.AGGREGATION_DEFAULTTYPE = "default";
							this.AGGREGATION_INLINETYPE = "inline";
						},

						_verifyAxesName : function(axes, name) {

							if (TypeUtils.isString(name) && name.length > 0) {
								// check name existance
								for ( var i = 0; i < axes.length; i++)
									if (axes[i].name == name)
										throw new Error(
												"Axis with this name already exists!");

								return name;
							} else {
								return "";
							}
						},

						_updateAxesLevels : function(isRow) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);
							for ( var i = 0; i < axes.length; i++)
								axes[i].level = parseInt(i, 10);
						},

						_addAxis : function(isRow, name, members, type) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							return this._addAxisAt(isRow, axes.length, name,
									members, type);
						},

						_addAxisAt : function(isRow, level, name, members, type) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							// check param validity
							if (!members)
								throw new Error("Invalid params!");
							if (!members.length)
								throw new Error("Invalid params!");
							if (level < 0 || level > axes.length)
								throw new Error(
										"Invalid params! Level out of range!");

							if (typeof type == "undefined")
								type = this.AXIS_TYPE_DIMENSION;
							if (type != this.AXIS_TYPE_MEASURE
									&& type != this.AXIS_TYPE_DIMENSION)
								throw new Error("Invalid params!");
							name = this._verifyAxesName(axes, name);
							var targetMembers = [];
							ObjectUtils.extend(true, targetMembers, members);

							// gen uid
							var uid = (isRow ? "d" : "c") + this._axisCounter;
							this._axisCounter++;

							var newAxis = {
								uid : uid,
								level : level,
								name : name,
								members : targetMembers,
								type : type
							};

							if (level == axes.length)
								axes[axes.length] = newAxis;
							else {
								// insert
								axes.splice(level, 0, newAxis);
								// update level values
								this._updateAxesLevels(isRow);
							}

							this.markDirty();

							return uid;
						},

						_modifyAxis : function(isRow, level, name, members,
								type) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							// check param validity
							if (!members)
								throw new Error("Invalid params!");
							if (!members.length)
								throw new Error("Invalid params!");
							if (level < 0 || level >= axes.length)
								throw new Error(
										"Invalid params! Level out of range!");

							if (name != axes[level].name)
								name = this._verifyAxesName(axes, name);

							if (typeof type == "undefined")
								type = this.AXIS_TYPE_DIMENSION;
							if (type != this.AXIS_TYPE_MEASURE
									&& type != this.AXIS_TYPE_DIMENSION)
								throw new Error("Invalid params!");

							axes[level].name = name;
							axes[level].type = type;
							axes[level].members = [];
							ObjectUtils.extend(true, axes[level].members,
									members);

							this.markDirty();

							return {
								uid : axes[level].uid,
								level : level,
								name : name,
								type : type
							};
						},

						_modifyAxisByUid : function(isRow, uid, name, members,
								type) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							var retval = null;
							for ( var i = 0; i < axes.length; i++)
								if (axes[i].uid == uid) {
									return this._modifyAxis(isRow,
											axes[i].level, name, members, type);
								}

							return retval;
						},

						_getAxesInfo : function(isRow) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							var retval = [];
							ObjectUtils.extend(true, retval, axes);
							ObjectUtils.each(retval, function(index, value) {
								delete value.members;
							});
							return !retval.length ? null : retval;
						},

						_getAxisInfo : function(isRow, level) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							if (level < 0 || level >= axes.length)
								throw new Error("Level out of range!");

							return {
								uid : axes[level].uid,
								level : level,
								name : axes[level].name,
								type : axes[level].type
							};
						},

						_getAxisInfoByUid : function(isRow, uid) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							for ( var i = 0; i < axes.length; i++)
								if (axes[i].uid == uid)
									return {
										uid : uid,
										level : axes[i].level,
										name : axes[i].name,
										type : axes[i].type
									};

							return null;
						},

						_getAxisMembersByUid : function(isRow, uid) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							var targetMembers = [];
							for ( var i = 0; i < axes.length; i++) {
								if (axes[i].uid == uid) {
									ObjectUtils.extend(true, targetMembers,
											axes[i].members);
									return targetMembers;
								}
							}

							return null;
						},

						_getAxisMembers : function(isRow, level) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							if (level < 0 || level >= axes.length)
								throw new Error(
										"Invalid params! Level out of range!");

							var targetMembers = [];
							ObjectUtils.extend(true, targetMembers,
									axes[level].members);

							return targetMembers;
						},

						_removeAxis : function(isRow, level) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							if (level < 0 || level >= axes.length)
								throw new Error(
										"Invalid params! Level out of range!");
							//[tony,18/4/2012],return {uid,level,name,type}
							var retval = {
								uid : axes[level].uid,
								level : level,
								name : axes[level].name,
								type : axes[level].type
							};
							axes.splice(level, 1);

							this._updateAxesLevels(isRow);

							this.markDirty();

							return retval;
						},

						_removeAxisByUid : function(isRow, uid) {

							var axes = (isRow ? this.metadata.rowAxis
									: this.metadata.columnAxis);

							if (!uid)
								throw new Error("Invalid uid!");

							var retval = {};
							for ( var i = 0; i < axes.length; i++) {
								if (axes[i].uid == uid) {
									return this._removeAxis(isRow, i);
								}
							}

							return null;
						},

						_getAxisUniqueMembersByType : function(isRow, type) {
							var axisInfos = this._getAxesInfo(isRow);
							var targetMember = [];
							for ( var item = 0; item < axisInfos.length; item++) {
								if (type == axisInfos[item].type) {
									var uid = axisInfos[item].uid;
									targetMember = this._getAxisMembersByUid(
											isRow, uid);
									return ArrayUtils.unique(targetMember);
								}
							}
							return null;
						},

						_getAxisUniqueMembersByLevel : function(isRow, level) {
							try {
								var targetMember = this._getAxisMembers(isRow,
										level);
								return ArrayUtils.unique(targetMember);
							} catch (e) {
								return null;
							}
						},

						_getAxisUniqueMembers : function(isRow, key, value) {
							switch (key) {
							case this.AXIS_KEY_TYPE:
								return this._getAxisUniqueMembersByType(isRow,
										value);
							case this.AXIS_KEY_LEVEL:
								return this._getAxisUniqueMembersByLevel(isRow,
										value);

							default:
								return null;
							}

						},

						_cleanData : function() {
							this.data = [];
							ObjectUtils.extend(true, this.data, this.origData);
							if (this.metadata.columnAxis.length == 0) {
								throw new Error(
										"There should be at least one column measure axis!");
							}
							if (this.metadata.rowAxis.length == 0) {
								throw new Error(
										"There should be at least one row dimension axis!");
							}
							// we assume the first axis is measure axis, TODO we
							// can do more check
							var col = this.metadata.columnAxis[0].members.length;

							var rowAxisCount = this.metadata.rowAxis.length;
							var row = this.metadata.rowAxis[rowAxisCount - 1].members.length;

							var _col = col;
							var _row = row;
							if (!this.metadata.dataByColumn) {
								_col = row;
								_row = col;
							}

							if (!TypeUtils.isExist(this.data))
								this.data = [];
							for ( var i = 0; i < _col; i++) {
								if (!TypeUtils.isExist(this.data[i]))
									this.data[i] = [];
								for ( var j = 0; j < _row; j++) {
									if (!TypeUtils.isExist(this.data[i][j])) {
										this.data[i][j] = this.ERROR_CHAR;
									} else {
										// verify is number data
										if (!TypeUtils
												.isNumber(this.data[i][j])) {
											var r = /(^-?\d+$)|(^(-?\d+)(\.\d+)?$)/;
											if (!r.test(this.data[i][j])) {
												this.data[i][j] = this.ERROR_CHAR;
											}
										}

									}
								}
								if (this.data[i].length > _row)
									this.data[i].splice(_row,
											this.data[i].length - _row);
							}
						},

						// -------------------------------------------
						// Public Methods
						// -------------------------------------------
						/**
						 * 
						 * @param {String}
						 *            name: The column axis name.
						 * @param {String[]}
						 *            members: The full list of column axis
						 *            members, including all grouped members.
						 * @param (string)
						 *            type: value can be "measure" or
						 *            "dimension". The type of grouped members.
						 * @return {String} return the new added column axis
						 *         uid, level is changing but uid is fixed.
						 */
						addColumnAxis : function(name, members, type) {

							return this._addAxis(false, name, members, type);
						},

						/**
						 * 
						 * @param {Number}
						 *            level: The level to be added, if dataset
						 *            has the same level column axis, we insert
						 *            the new column before that level position.
						 * @param {String}
						 *            name: The column axis name.
						 * @param {String[]}
						 *            members: The full list of column axis
						 *            members, including all grouped members.
						 * @param (string)
						 *            type: value can be "measure" or
						 *            "dimension". The type of grouped members.
						 * @return {String} return the new added column axis
						 *         uid, level is changing but uid is fixed.
						 */
						addColumnAxisAt : function(level, name, members, type) {

							return this._addAxisAt(false, level, name, members,
									type);

						},

						/**
						 * 
						 * @param {Number}
						 *            level
						 * @param {String}
						 *            name
						 * @param {String[]}
						 *            members
						 * @param (string)
						 *            type
						 * @return {uid, level, name, type}
						 */
						modifyColumnAxis : function(level, name, members, type) {

							return this._modifyAxis(false, level, name,
									members, type);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @param {String}
						 *            name
						 * @param {String[]}
						 *            members
						 * @param (string)
						 *            type
						 * @return {uid, level, name, type}
						 */
						modifyColumnAxisByUid : function(uid, name, members,
								type) {

							return this._modifyAxisByUid(false, uid, name,
									members, type);
						},

						/**
						 * 
						 * @return {Object[]} return [{uid, level, name, type},
						 *         ...]
						 */
						getColumnAxesInfo : function() {

							return this._getAxesInfo(false);
						},

						/**
						 * @param {Number}
						 *            level
						 * @return {Object} return {uid, level, name, type}
						 */
						getColumnAxisInfo : function(level) {

							return this._getAxisInfo(false, level);
						},

						/**
						 * @param {String}
						 *            uid
						 * @return {Object} return {uid, level, name, type}
						 */
						getColumnAxisInfoByUid : function(uid) {

							return this._getAxisInfoByUid(false, uid);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @return {String[]} return the column axis members
						 *         cloned Array by level.
						 */
						getColumnAxisMembersByUid : function(uid) {

							return this._getAxisMembersByUid(false, uid);
						},

						/**
						 * 
						 * @param {Object}
						 *            level
						 * @return {String[]} return the column axis members
						 *         cloned Array by level.
						 */
						getColumnAxisMembers : function(level) {

							return this._getAxisMembers(false, level);
						},

						/**
						 * 
						 * @param {String}
						 *            key: AXIS_KEY_TYPE/AXIS_KEY_LEVEL
						 * @param {Object}
						 *            value: the value of specific key
						 * @return {String[]} return the column axis unique
						 *         members with specific type/level value
						 */
						getColumnAxisUniqueMembers : function(key, value) {
							return this
									._getAxisUniqueMembers(false, key, value);
						},

						/**
						 * 
						 * @param {Number}
						 *            level
						 * @return {uid, level, name, type}
						 */
						removeColumnAxis : function(level) {

							return this._removeAxis(false, level);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @return {uid, level, name, type}
						 */
						removeColumnAxisByUid : function(uid) {

							return this._removeAxisByUid(false, uid);
						},

						/**
						 * 
						 * @param {String}
						 *            name: The row axis name.
						 * @param {String[]}
						 *            members: The full list of row axis
						 *            members, including all grouped members.
						 * @param (string)
						 *            type: value can be "measure" or
						 *            "dimension". The type of grouped members.
						 * @return {String} return the new added row axis uid,
						 *         level is changing but uid is fixed.
						 */
						addRowAxis : function(name, members, type) {

							return this._addAxis(true, name, members, type);
						},

						/**
						 * 
						 * @param {Number}
						 *            level: The level to be added, if dataset
						 *            has the same level row axis, we insert the
						 *            new row before that level position.
						 * @param {String}
						 *            name: The row axis name.
						 * @param {String[]}
						 *            members: The full list of row axis
						 *            members, including all grouped members.
						 * @param (string)
						 *            type: value can be "measure" or
						 *            "dimension". The type of grouped members.
						 * @return {String} return the new added row axis uid,
						 *         level is changing but uid is fixed.
						 */
						addRowAxisAt : function(level, name, members, type) {

							return this._addAxisAt(true, level, name, members,
									type);
						},

						/**
						 * 
						 * @param {Object}
						 *            level
						 * @param {Object}
						 *            name
						 * @param {Object}
						 *            members
						 * @return {uid, level, name, type}
						 */
						modifyRowAxis : function(level, name, members, type) {

							return this._modifyAxis(true, level, name, members,
									type);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @param {String}
						 *            name
						 * @param {String[]}
						 *            members
						 * @param {String}
						 *            type
						 * @return {uid, level, name}
						 */
						modifyRowAxisByUid : function(uid, name, members, type) {

							return this._modifyAxisByUid(true, uid, name,
									members, type);
						},

						/**
						 * @return {Object[]} return [{uid, level, name, type},
						 *         ...]
						 */
						getRowAxesInfo : function() {

							return this._getAxesInfo(true);
						},

						/**
						 * @param {Number}
						 *            level
						 * @return {Object} return {uid, level, name, type}
						 */
						getRowAxisInfo : function(level) {

							return this._getAxisInfo(true, level);
						},

						/**
						 * @param {String}
						 *            uid
						 * @return {Object} return {uid, level, name, type}
						 */
						getRowAxisInfoByUid : function(uid) {

							return this._getAxisInfoByUid(true, uid);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @return {String[]} return the row axis members cloned
						 *         Array by level.
						 */
						getRowAxisMembersByUid : function(uid) {

							return this._getAxisMembersByUid(true, uid);
						},

						/**
						 * 
						 * @param {Object}
						 *            level
						 * @return {String[]} return the row axis members cloned
						 *         Array by level.
						 */
						getRowAxisMembers : function(level) {

							return this._getAxisMembers(true, level);
						},

						/**
						 * 
						 * @param {String}
						 *            key: AXIS_KEY_TYPE/AXIS_KEY_LEVEL
						 * @param {Object}
						 *            value: the value of specific key
						 * @return {String[]} return the row axis unique members
						 *         with specific type/level value
						 */
						getRowAxisUniqueMembers : function(key, value) {
							return this._getAxisUniqueMembers(true, key, value);
						},

						/**
						 * 
						 * @param {Number}
						 *            level
						 * @return {uid, level, name, type}
						 */
						removeRowAxis : function(level) {

							return this._removeAxis(true, level);
						},

						/**
						 * 
						 * @param {String}
						 *            uid
						 * @return {uid, level, name, type}
						 */
						removeRowAxisByUid : function(uid) {

							return this._removeAxisByUid(true, uid);
						},

						/**
						 * 
						 * @param {Boolean}
						 *            byColumn: Data in column or row.
						 * @param {[[]]}
						 *            data: The dataset values in 2D array.
						 */
						setData : function(byColumn, data) {
							if (typeof (byColumn) != 'boolean' || !data)
								throw new Error("Invalid params!");
							if (!data.length)
								throw new Error("Invalid params!");
							this.metadata.dataByColumn = byColumn;
							this.origData = [];
							ObjectUtils.extend(true, this.origData, data);
							this._cleanData();

							this.markDirty();
						},

						/**
						 * 
						 * @param {Boolean}
						 *            byColumn: Data in column or row.
						 * @return {[[]]} return the dataset values in 2D array.
						 */
						getData : function(byColumn) {
							var targetDataset = [];
							if (byColumn == this.metadata.dataByColumn) {
								ObjectUtils.extend(true, targetDataset,
										this.data);
							} else {
								for ( var i = 0; i < this.data[0].length; i++) {
									targetDataset[i] = [];
									for ( var j = 0; j < this.data.length; j++)
										targetDataset[i][j] = this.data[j][i];
								}
							}

							return targetDataset;
						},

						getValue : function(colIdx, rowIdx) {
							if (this.metadata.dataByColumn) {
								return this.data[colIdx][rowIdx];
							} else {
								return this.data[rowIdx][colIdx];
							}

						},

						getColumnCount : function() {
							if (this.metadata.dataByColumn) {
								return this.data.length;
							} else {
								if (this.data.length > 0) {
									return this.data[0].length;
								} else {
									return 0;
								}
							}
						},

						getRowCount : function() {
							if (!this.metadata.dataByColumn) {
								return this.data.length;
							} else {
								if (this.data.length > 0) {
									return this.data[0].length;
								} else {
									return 0;
								}
							}
						},

						/**
						 * @ignore
						 * @return {Object} return the JSON object including all
						 *         the metadata and data.
						 */
						exportJsonStr : function() {

							function axisParser(isRow) {
								var axes = (isRow ? this.metadata.rowAxis
										: this.metadata.columnAxis);
								var title = (isRow ? "rowAxis" : "columnAxis");
								var json = [];

								json.push('"' + title + '":[');
								for ( var i = 0; i < axes.length; i++) {
									json.push('{"uid":"' + axes[i].uid
											+ '","level":' + axes[i].level
											+ ',"name":"' + axes[i].name
											+ '","members":[');
									for ( var j = 0; j < axes[i].members.length; j++) {
										json.push('"' + axes[i].members[j]
												+ '"');
										if (j != axes[i].members.length - 1)
											json.push(',');
									}
									json.push(']');
									json
											.push(',"type":"' + axes[i].type
													+ '"}');
									if (i != axes.length - 1)
										json.push(',');
								}
								json.push(']');
								if (!isRow)
									json.push(',');

								return json;
							}
							;

							function aggregationParser() {
								var json = [];
								json.push('"aggregation":[');

								for ( var i = 0; i < this.aggregation.length; i++) {
									if (TypeUtils
											.type(this.aggregation[i].label) == 'string') {
										json.push('{"label":"'
												+ this.aggregation[i].label
												+ '","rowDimension":[');
									} else {
										json.push('{"label":[');

										for ( var j = 0; j < this.aggregation[i].label.length; j++) {
											json
													.push('"'
															+ this.aggregation[i].label[j]
															+ '"');
											if (j != this.aggregation[i].label.length - 1)
												json.push(',');
										}
										json.push('],"rowDimension":[');
									}

									for ( var j = 0; j < this.aggregation[i].rowDimension.length; j++) {
										json
												.push('"'
														+ this.aggregation[i].rowDimension[j]
														+ '"');
										if (j != this.aggregation[i].rowDimension.length - 1)
											json.push(',');
									}
									json.push(']');
									json.push(',"value":[');

									for ( var t = 0; t < this.aggregation[i].value.length; t++) {
										json.push(this.aggregation[i].value[t]);
										if (t != this.aggregation[i].value.length - 1)
											json.push(',');
									}
									json.push('],');
									json.push('"type":"'
											+ this.aggregation[i].type + '"');
									json.push('}');

									if (i != this.aggregation.length - 1)
										json.push(',');
								}

								json.push(']');

								return json;
							}
							;

							var json = new Array();
							json.push('{');

							// convert metadata
							json.push('"metadata":{');
							json = json.concat(axisParser.call(this, false));
							json = json.concat(axisParser.call(this, true));
							json.push(',');
							json
									.push('"dataByColumn":'
											+ (typeof (this.metadata.dataByColumn) == 'boolean' ? this.metadata.dataByColumn
													: null));
							json.push('},');

							// convert data
							json.push('"data":[');
							for ( var i = 0; i < this.data.length; i++) {
								json.push('[');
								for ( var j = 0, jlen = this.data[i].length; j < jlen; j++) {
									var dt = this.data[i][j];
									if (dt == this.ERROR_CHAR) {
										json.push("null");
										// we want the result json can be parsed
										// successfully through JQuery.json
									} else {
										json.push(dt);
									}
									if (j != jlen - 1)
										json.push(',');
								}
								json.push(']');
								if (i != this.data.length - 1)
									json.push(',');
							}
							json.push('],');

							// convert aggregation
							json = json.concat(aggregationParser.call(this));

							json.push('}');

							return json.join('');
						},

						/**
						 * @ignore
						 * @param {Object}
						 *            The exported JSON object including all the
						 *            metadata and data.
						 * @return {void}
						 */
						importJsonStr : function(value) {
							if (typeof (value) != 'string')
								throw new Error("Invalid JSON string!");
							var newDS = ObjectUtils.parseJSON(value);
							if (!newDS.metadata)
								throw new Error(
										"JSON object does not contain metadata!");
							if (!newDS.data)
								throw new Error(
										"JSON object does not contain data!");
							ObjectUtils.extend(true, this.metadata,
									newDS.metadata);
							this.origData = [];
							ObjectUtils.extend(true, this.origData, newDS.data);
							this.aggregation = [];
							ObjectUtils.extend(true, this.aggregation,
									newDS.aggregation);
							this._cleanData();
							this.markDirty();
						},

						/**
						 * @ignore
						 * @return {Object} Clone the dataset.
						 */
						clone : function() {
							var copy = {};

							ObjectUtils.extend(true, copy, this);

							return copy;
						},

						/**
						 * 
						 * Clear all the metadata and data.
						 * 
						 * @return {void}
						 */
						empty : function() {
							this.metadata = {
								columnAxis : [],
								rowAxis : []
							};

							this.data = [];
							this.origData = [];
							this.aggregation = [];
						},

						/**
						 * @ignore
						 * register chart instance which use this dataset.
						 * 
						 * we won't keep chart reference in dataset, as dataset
						 * can be shared between charts, user can set chart
						 * instance to null to trigger memory GC
						 */
						registerChartInstance : function(chartId) {
							if (TypeUtils.isExist(chartId)) {
								var ci = this.chartInstances;
								if (!ci.hasOwnProperty(chartId)) {
									ci[chartId] = {
										dirtyDS : false
									};
									return true;
								} else {
									return true;
								}
							}
							throw new Error(
									"Failed to register chart instance in dataset!");
						},

						/**
						 * @ignore
						 * dataset has been changed
						 */
						markDirty : function() {
							// change needRedraw flag for all registered chart
							// instances
							var ci = this.chartInstances;
							for ( var id in ci) {
								if (ci.hasOwnProperty(id)) {
									ci[id].dirtyDS = true;
								}
							}
						},

						/**
						 * @ignore
						 */
						checkDirty : function(chartId) {
							var ci = this.chartInstances;
							if (TypeUtils.isExist(ci[chartId])) {
								var d = ci[chartId];
								if (d.dirtyDS) {
									d.dirtyDS = false;
									return true;
								} else {
									return false;
								}
							}
							throw new Error(
									"Failed to check dirty for the chart:"
											+ chartId + "!");
						},

						/**
						 * @ignore
						 * @param label
						 *            string of aggregation name
						 * @param value
						 *            array of aggregation value, the order
						 *            following measure
						 * @param rowDimension
						 *            (optional) array of dimension path for the
						 *            aggregation. If not set or set as empty
						 *            array, the aggregation will be treated as
						 *            global
						 */
						addAggregation : function(label, value, rowDimension) {
							// if (TypeUtils.type(label) != 'string'
							if (TypeUtils.isString(label)
									&& !(label instanceof Array)) {
								throw new Error("Invalid params!");
							} else if ('' == label) {
								return;
							}
							if (!TypeUtils.isExist(value)
									|| typeof (value) != 'object') {
								throw new Error("Invalid params!");
							}
							if (TypeUtils.isExist(rowDimension)) {
								if (typeof (rowDimension) != 'object') {
									throw new Error("Invalid params!");
								}
								if (rowDimension.length >= this
										.getRowAxesInfo().length) {
									return;
								}

								var valid = false;
								for ( var i = 0; i < this.getRowCount(); i++) {
									var matchNum = 0;
									for ( var j = 0; j < rowDimension.length; j++) {
										if (rowDimension[j] == this
												.getRowAxisMembers(j)[i]) {
											matchNum++;
										}
									}

									if (matchNum == rowDimension.length) {
										valid = true;
										break;
									}
								}
								if (!valid) {
									throw new Error("Invalid params!");
								}

							}

							var _label = label;
							var _value = value;
							var _rowDimension = TypeUtils.isExist(rowDimension) ? rowDimension
									: [];
							var _type = TypeUtils.isString(label) ? this.AGGREGATION_DEFAULTTYPE
									: this.AGGREGATION_INLINETYPE;
							_value.length = this.getColumnCount();

							this.aggregation.push({
								label : _label,
								value : _value,
								rowDimension : _rowDimension,
								type : _type
							});
						},

						/**
						 * @ignore
						 * @param rowDimension
						 *            (optional) array of dimension path for the
						 *            aggregation
						 * @return array of matched aggregation, some special
						 *         cases: if {rowDimension} is not set, all
						 *         aggregation will be returned if
						 *         {rowDimension} is set as empty array, all
						 *         global aggregation will be returned
						 */
						getAggregation : function(rowDimension) {
							if (!TypeUtils.isExist(rowDimension)) {
								return this.aggregation;
							}
							var ret = [];
							for ( var i = 0; i < this.aggregation.length; i++) {
								var unit = this.aggregation[i];
								if (rowDimension.length == 0
										&& unit.rowDimension.length == 0) {
									ret.push(unit);

								} else if (rowDimension.length > 0) {
									var matchNum = 0;
									for ( var j = 0; j < rowDimension.length; j++) {
										if (j >= unit.rowDimension.length
												|| unit.rowDimension[j] != rowDimension[j]) {
											matchNum = 0;
											break;
										}
										matchNum++;
									}
									if (matchNum == rowDimension.length) {
										ret.push(unit);
									}
								}

							}
							return ret;
						},

						/**
						 * @ignore
						 * @param rowDimension
						 *            (optional) array of dimension path for the
						 *            aggregation
						 * @return object
						 */
						modifyAggregation : function(level, label, value,
								rowDimension) {
							if (TypeUtils.isString(label)
									&& !(label instanceof Array)) {
								throw new Error("Invalid params!");
							} else if ('' == label) {
								return;
							}
							if (!TypeUtils.isExist(value)
									|| typeof (value) != 'object') {
								throw new Error("Invalid params!");
							}
							if (TypeUtils.isExist(rowDimension)) {
								if (typeof (rowDimension) != 'object') {
									throw new Error("Invalid params!");
								}
								if (rowDimension.length >= this
										.getRowAxesInfo().length) {
									return;
								}

								var valid = false;
								for ( var i = 0; i < this.getRowCount(); i++) {
									var matchNum = 0;
									for ( var j = 0; j < rowDimension.length; j++) {
										if (rowDimension[j] == this
												.getRowAxisMembers(j)[i]) {
											matchNum++;
										}
									}

									if (matchNum == rowDimension.length) {
										valid = true;
										break;
									}
								}
								if (!valid) {
									throw new Error("Invalid params!");
								}

							}

							var type = TypeUtils.isString(label) ? this.AGGREGATION_DEFAULTTYPE
									: this.AGGREGATION_INLINETYPE;

							this.aggregation[level].label = label;
							this.aggregation[level].value = value;
							this.aggregation[level].rowDimension = [];

							ObjectUtils.extend(true,
									this.aggregation[level].rowDimension,
									rowDimension);

							this.markDirty();

							return {
								level : level,
								label : label,
								value : value,
								rowDimension : rowDimension,
								type : type
							};
						},
						
						/**
						 * @ignore
						 */
						exportTree : function() {
							var measureMembers = this
									.getColumnAxisUniqueMembers(
											this.AXIS_KEY_TYPE,
											this.AXIS_TYPE_MEASURE);
							// [jyang, 3/14/2012]we require that the first
							// member of column axis is measure
							var measureLabels = this.getColumnAxisMembers(0);
							// [jyang, 3/14/2012]now we support unlimited
							// measure member and one dimension member in column
							// axis
							var columnAxis = this.metadata.columnAxis;
							var rowDimensions = this.metadata.rowAxis;
							var columnDimensions = columnAxis.slice(1);
							var axisNum = 0;
							// [jyang, 3/14/2012] the default path of dimension
							// is rowaxis -> columnaxis
							var dimensionNames = [];
							for ( var j = 0; j < rowDimensions.length; j++) {
								dimensionNames.push({
									'name' : rowDimensions[j].name,
									'analysisAxisIndex' : 0
								});
							}
							if (rowDimensions.length > 0) {
								// we have dimension in row axis
								axisNum++;
							}
							for ( var j = 0; j < columnDimensions.length; j++) {
								dimensionNames.push({
									'name' : columnDimensions[j].name,
									'analysisAxisIndex' : 1
								});
							}
							if (columnDimensions.length > 0) {
								// we have dimension in row axis
								axisNum++;
							}
							var setValue = function(parent, path, depth,
									measureMember, measureIndex, value) {
								var pathObj = path[depth];
								var current = null;
								for ( var i = 0; i < parent.subNodes.length; i++) {
									if (pathObj.name === parent.subNodes[i].label) {
										current = parent.subNodes[i];
										break;
									}
								}

								if (current == null) {
									current = {};
									current.member = i;
									current.label = pathObj.name;
									current.measureValues = {};
									current.subNodes = [];
									for ( var i = 0; i < measureMembers.length; i++) {
										// [jyang 3/15/2012] if we have
										// aggregation info, we can
										// add measure values for each level
										current.measureValues[measureMembers[i]] = {};
									}
									parent.subNodes.push(current);
								}

								if (depth == path.length - 1) {
									// [jyang 3/15/2012] if we have aggregation
									// info, we can
									// add measure values for each level
									var dimensionPath = [];
									for ( var i = 0, len = path.length; i < len; i++) {
										var p = path[i];
										dimensionPath
												.push({
													'analysisAxisIndex' : p.analysisAxisIndex,
													'dimensionIndex' : p.dimensionIndex,
													'dimensionItemIndex' : p.dimensionItemIndex
												});
									}
									// FIXME JYANG 3/15/2012 we may duplicate
									// too much data if we have too many
									// measures.
									// it's better if tree can have metadata
									// also for node.
									// and we can use less characters to save
									// memory?
									current.measureValues[measureMember] = {
										'sum' : {
											result : value,
											tags : {
												'dimensionPath' : dimensionPath,
												// [jyang 3/15/2012]be noted
												// that measureIndex doesn't
												// mean the unique
												// index of measure members,
												// clients can use this index to
												// fetch measure
												// member in the crosstable
												// dataset columnaxis measure.
												'measureIndex' : measureIndex
											}
										}
									};
								} else {
									setValue(current, path, depth + 1,
											measureMember, measureIndex, value);
								}
							};

							var columnPath = [];
							for ( var i = 0, len = this.getColumnCount(); i < len; i++) {
								columnPath[i] = [];
								for ( var j = 0; j < columnDimensions.length; j++) {
									var pathObj = {
										'name' : columnDimensions[j].members[i],
										'analysisAxisIndex' : 1,
										'dimensionIndex' : j,
										// [jyang, 3/15/2012] note the
										// dimensionItemIndex doesn't
										// mean the index in the unique members
										// array. it's the index
										// in the crosstable. clients can use it
										// to fetch dimensionItem
										// in crosstabledataset
										'dimensionItemIndex' : i
									};
									columnPath[i].push(pathObj);
								}
							}

							var rowPath = [];
							for ( var i = 0, len = this.getRowCount(); i < len; i++) {
								rowPath[i] = [];
								for ( var j = 0; j < rowDimensions.length; j++) {
									var pathObj = {
										'name' : rowDimensions[j].members[i],
										'analysisAxisIndex' : 0,
										'dimensionIndex' : j,
										'dimensionItemIndex' : i
									};
									rowPath[i].push(pathObj);
								}
							}

							var root = {};
							root.member = "root";
							root.measureValues = {};
							root.subNodes = [];
							// TODO jyang 3.15.2012 we can add aggreation for
							// each node level
							// currently we only have data for the last level
							for ( var i = 0; i < measureMembers.length; i++) {
								root.measureValues[measureMembers[i]] = {};
							}
							// jyang 3/15/2012 we need dimensionAxisIndex,
							// dimensionIndex, dimensionItemIndex and
							// measureIndex
							// to composite a path in datacontext
							for ( var i = 0, len = this.getColumnCount(); i < len; i++) {
								for ( var j = 0, jlen = this.getRowCount(); j < jlen; j++) {
									var data = this.getValue(i, j);
									var path = rowPath[j].concat(columnPath[i]);
									var measureMember = measureLabels[i];
									// function(parent, path, depth,
									// measureMember, value)
									setValue(root, path, 0, measureMember, i,
											data);
								}
							}

							var result = {
								dataTree : JSON.stringify(root),
								metaData : {
									// FIXME JYANG 3/15/2012 what if we have
									// different measure members for different
									// dimension?
									measureMembers : measureMembers,
									// TODO JYANG 3/15/2012 change the name to
									// dimensions
									dimension : dimensionNames,
									axisNum : axisNum
								}
							};
							return result;

						}

					});

	return crossTableDataset;
});sap.riv.module(
{
  qname : 'sap.riv.viz.shared.dataConverter.SimpleDMDataset',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.shared.dataConverter.BaseDataset',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(ObjUtils, TypeUtils, BaseDataset, fnUtils) {
	var undefined = void (0);
	var SimpleDMDataset = ObjUtils.derive(BaseDataset,
	/**
	 * @lends sap.riv.viz.shared.dataConverter.SimpleDMDataset.prototype
	 */
	{
		/**
		 * SimpleDMDataset contains only one dimension and several measures
		 * 
		 * @constructs
		 */
		constructor : function() {
			this._measureNames = [ '' ];
			this._dimensionLabels = [];
			this._dimensionName = [ '' ];
			this._data = null;
			this._inValidData = null;
			this.ERROR_CHAR = "NaN";
		},

		/**
		 * get or set measure names of SimpleDMDataset
		 * 
		 * @param {StringArray}names
		 *            measure names to be set. empty parameter means get current
		 *            measure names
		 * @returns {this|Array}
		 */
		measureNames : function(names) {
			if (arguments.length == 1) {
				if (TypeUtils.isExist(arguments[0])) {
					this._measureNames = names;
					return this;
				} else {
					fnUtils.error("Measure Name doesn't exist");
				}
			}
			return this._measureNames;
		},

		/**
		 * get or set dimension labels of SimpleDMDataset
		 * 
		 * @param {StringArray}dmLabels
		 *            dimension labels to be set. empty parameter means get
		 *            current dimension labels
		 * @returns {this|Array}
		 */
		dimensionLabels : function(dmLabels) {
			if (arguments.length == 1) {
				if (TypeUtils.isExist(arguments[0])) {
					this._dimensionLabels = dmLabels;
					return this;
				} else {
					throw "Dimension Label isn't exist";
				}
			}
			return this._dimensionLabels;
		},
		
		/**
		 * get or set dimension name of SimpleDMDataset
		 * 
		 * @param {String}dmName
		 *            dimension name to be set. empty parameter means get
		 *            current dimension name
		 * @returns {this|String}
		 */
		dimensionName : function(dmName) {
			if (arguments.length == 1) {
				if (TypeUtils.isExist(arguments[0])) {
					this._dimensionName = dmName;
					return this;
				} else {
					throw "Dimension Name isn't exist";
				}
			}
			return this._dimensionName;
		},
		
		/**
		 * get or set data of SimpleDMDataset
		 * 
		 * @param {[[]]} data
		 *            data to be set. empty parameter means get
		 *            current data. 
		 * @returns {this|Array}
		 */
		data : function(data) {
			if (arguments.length > 0) {
				if ((TypeUtils.isExist(data)) && (TypeUtils.isExist(data.length))) {
					this._data = data;
				} else {
					throw "Data is invalid.";
				}
			}
			return this._data;
		},
		
		/**
		 * @ignore
		 * 
		 */
		exportTree : function() {
			var root = {};

			root.member = "root";
			root.measureValues = {};
			root.subNodes = [];

			this._cleanData();

			for ( var i = 0, len = this._measureNames.length; i < len; i++) {
				root.measureValues[this._measureNames[i]] = {};
			}

			for ( var i = 0, ilen = this._dimensionLabels.length; i < ilen; i++) {
				root.subNodes[i] = {
					member : i,
					label : TypeUtils.isExist(this._dimensionLabels[i]) ? this._dimensionLabels[i] : '',
					subNodes : [],
					measureValues : {}
				};

				for ( var j = 0, jlen = this._measureNames.length; j < jlen; j++) {
					var value;
					if ((this._inValidData[j] !== undefined) && (this._inValidData[j][i] !== undefined)
							&& (this._inValidData[j][i] === this.ERROR_CHAR)) {
						value = this.ERROR_CHAR;
					} else {
						value = this._data[j][i];
					}

					root.subNodes[i].measureValues[this._measureNames[j]] = {
						sum : {
							result : value, // this._data[j][i]
							tags : {
								// [jyang, 20/3/2012] we make it consistent with
								// hierarchy dataset
								'dimensionPath' : [ {
									'analysisAxisIndex' : 0,
									'dimensionIndex' : 0,
									'dimensionItemIndex' : i
								} ],
								measureIndex : j
							}
						}
					};

				}
			}

			var result = {
				dataTree : JSON.stringify(root),
				metaData : {
					measureMembers : this._measureNames,
					dimension : [ {
						'name' : this._dimensionName,
						'analysisAxisIndex' : 0
					} ],
					axisNum : 1
				}
			};

			return result;
		},

		/**
		 * @ignore
		 */
		_cleanData : function() {
			var data = this._data;
			this._inValidData = [];
			var noDimensionFlag = false;

			var _col = this._measureNames.length;
			var _row = this._dimensionLabels.length;
			if (_row === 0) {
				// [Christy.Fei|2012/3/9]No dimension labels
				noDimensionFlag = true;
			} else {
				var maxDataLength = 0;
				var labelTmp = '';
				for ( var i = 0; i < data.length; i++) {
					if ((TypeUtils.isExist(data[i])) && (TypeUtils.isExist(data[i].length))
							&& (data[i].length > maxDataLength)) {
						maxDataLength = data[i].length;
					}
				}
				if (maxDataLength < _row) {
					// [Christy.Fei|2012/3/9]More Dimension Name, less data
					for ( var i = maxDataLength; i < _row; i++) {
						// [Christy.Fei|2012/3/9]If have more dimension labels,
						// remove the redundance dimension labels.
						labelTmp = this._dimensionLabels.pop();
					}
					_row = this._dimensionLabels.length;
					if (_row === 0) {
						// [Christy.Fei|2012/3/9]If no data, but have dimension
						// label. Save the first dimension labels and draw it in
						// legend.
						this._dimensionLabels.push(labelTmp);
					}
				}
			}
			if (!TypeUtils.isExist(data))
				data = this._data = [];
			for ( var i = 0; i < _col; i++) {
				if (!TypeUtils.isExist(data[i]))
					data[i] = [];
				for ( var j = 0; j < _row || j < data[i].length; j++) {
					if (noDimensionFlag) {
						this._dimensionLabels.push(j + 1);
					} else {
						if (!(j < _row)) {
							this._dimensionLabels.push('');
						}
					}
					_row = this._dimensionLabels.length;
					if (!TypeUtils.isExist(data[i][j])) {
						this._inValidData[i] = this._inValidData[i] || [];
						this._inValidData[i][j] = this.ERROR_CHAR;
					} else {
						// verify is number data
						if (!TypeUtils.isNumber(data[i][j])) {
							var r = /(^-?\d+$)|(^(-?\d+)(\.\d+)?$)/;
							if (!r.test(data[i][j])) {
								this._inValidData[i] = this._inValidData[i] || [];
								this._inValidData[i][j] = this.ERROR_CHAR;
							}
						}
					}
				}
				noDimensionFlag = false;
			}
		}
	});
	return SimpleDMDataset;
});sap.riv.module(
{
  qname : 'sap.riv.viz.Environment',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(TypeUtils, LOG) {
    var _locale = 'en_US';

    var _setLocale = function(_loc) {
        if(TypeUtils.isExist(_loc)) {
            _locale = _loc;
            sap.common.globalization.NumericFormatManager.setPVL(_loc);
        }
    };
    var _setLogLevel = function(_level) {
        if(TypeUtils.isExist(_level)) {
            LOG.setLevel(_level);
        }
    };
    var _initLogger = function(options) {
        if(!options)
            return;
        if(options.enable)
            LOG.enable();
        if(!options.appenders)
            return;
        for(var i = 0, l = options.appenders.length; i < l; i++) {
            var appender = options.appenders[i];
            if(appender.appenderKey)
                LOG.addAppender(appender.appenderKey, appender.appender);
            else
                LOG.addAppender(appender.appender);
        }
        // LOG.addAppender('analyzerAppender', new AnalyzerAppender());
        // LOG.addAppender("ajaxApp", new LOG.AjaxAppender("http://localhost:8800"));
        // LOG.getAppender("ajaxApp").setLevel(LOG.LEVEL.DEBUG);
        //LOG.getAppender("[default]").setLevel(_level);
    };
    var env =
    /**
     * @lends sap.riv.viz.Environment
     */
    {
        /**
         * @constructs
         */
        constructor : function() {

        },
        /**
         * initialize visualization environment
         * @param {Object}
         *            option {locale:'en_US'}
         *
         */
        initialize : function(option) {
            _setLocale(option.locale);
            _initLogger(option.log);
            // _setLogLevel(option.log);
        },
        
        /**
         * set locale of visualization environment
         * @param locale locale string
         */
        setLocale : function(locale) {
            _setLocale(locale);
        },
        
        /**
         * get current locale string
         * @returns {String}
         */
        getLocale : function() {
            return _locale;
        },
        
        /**
         * @ignore
         * @param enable
         */
        setLoggerEnable : function(enable) {
            if(enable === true)
                LOG.enable();
            else if(enable === false)
                LOG.disable();
        },
        
        /**
         * @ignore
         * @returns
         */
        addLogAppender : function() {
            if(arguments.length === 1)
                return LOG.addAppender(arguments[0]);
            else if(arguments.length === 2)
                return LOG.addAppender(arguments[0], arguments[1]);
        },
        
        /**
         * @ignore
         * @param key
         * @returns
         */
        removeLogAppender : function(key) {
            return LOG.removeAppender(key);
        },
    };

    return env;
});sap.riv.module(
{
  qname : 'sap.riv.viz.BarChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var BarChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.BarChart.prototype
	 */
	{
		/**
		 * class for clients to create Bar Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'bar';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'bar';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return BarChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.CombinationChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var ComChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.CombinationChart.prototype
	 */
	{
		/**
		 * class for clients to create Combination Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'combination';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'combination';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return ComChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.PieChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractPieChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractPieChart, LOG) {

    var pieChart = ObjUtils.derive(AbstractPieChart,
    /**
     * @lends sap.riv.viz.PieChart.prototype
     */
    {
        /**
         * @constructs
         * @augments sap.riv.viz.AbstractPieChart
         * @param holderElement
         *            a div container returned from jQuery selection.
         * @param properties
         *            a json object for chart properties. refer to properties
         *            doc for details
         * @param dataset
         *            one of supported sap.riv.viz.shared.dataConverter
         */
        constructor : function(holderElement, properties, dataset) {
        	var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'pie';
            LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
            this._viz = new VizApplication({
                id : "PieApplication",
                wrapperDivEl : holderElement,
                delegateClass : AppDelegate,
                launchOption : {
                    option : props,
                    data : {
                        rawData : dataset
                    }
                }
            });
            LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
        },
    });

    return pieChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.LineChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var LineChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.LineChart.prototype
	 */
	{
		/**
		 * class for clients to create Line Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'combination';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'line';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return LineChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.ColumnChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var ColChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.ColumnChart.prototype
	 */
	{
		/**
		 * class for clients to create Column Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'combination';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'bar';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return ColChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.Visualization',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractVisualization',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.PieChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.MultiPieChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.BarChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.LineChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.ColumnChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.CombinationChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.FunctionUtils',
  version : '1.0.0'
}
],
function Setup(ObjectUtils, AbstractVisualization, PieChart, MultiPieChart, BarChart, LineChart, ColumnChart,
		CombinationChart, fnUtils) {
	var Visualization = ObjectUtils.derive(AbstractVisualization,
	/**
	 * @lends sap.riv.viz.Visualization.prototype
	 */
	{
		/**
		 * a generic API which can be used to create a certain viz
		 * 
		 * @constructs
		 * @augments sap.riv.viz.AbstractVisualization
		 * 
		 * @param typeString
		 *            currently we support 'riv/pie', 'riv/multipie', 'riv/bar',
		 *            'riv/column', 'riv/line', 'riv/combination'
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(typeString, holderElement, properties, dataset) {
			switch (typeString) {
			case 'riv/pie':
				this._viz = new PieChart(holderElement, properties, dataset);
				break;
			case 'riv/multipie':
				this._viz = new MultiPieChart(holderElement, properties, dataset);
				break;
			case 'riv/bar':
				this._viz = new BarChart(holderElement, properties, dataset);
				break;
			case 'riv/column':
				this._viz = new ColumnChart(holderElement, properties, dataset);
				break;
			case 'riv/line':
				this._viz = new LineChart(holderElement, properties, dataset);
				break;
			case 'riv/combination':
				this._viz = new CombinationChart(holderElement, properties, dataset);
				break;
			default:
				fnUtils.error('Unsupported chart type');
				break;
			}
		}
	});

	return Visualization;
});sap.riv.module(
{
  qname : 'sap.riv.viz.PieChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.pie.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractPieChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractPieChart, LOG) {

    var pieChart = ObjUtils.derive(AbstractPieChart,
    /**
     * @lends sap.riv.viz.PieChart.prototype
     */
    {
        /**
         * @constructs
         * @augments sap.riv.viz.AbstractPieChart
         * @param holderElement
         *            a div container returned from jQuery selection.
         * @param properties
         *            a json object for chart properties. refer to properties
         *            doc for details
         * @param dataset
         *            one of supported sap.riv.viz.shared.dataConverter
         */
        constructor : function(holderElement, properties, dataset) {
        	var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'pie';
            LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
            this._viz = new VizApplication({
                id : "PieApplication",
                wrapperDivEl : holderElement,
                delegateClass : AppDelegate,
                launchOption : {
                    option : props,
                    data : {
                        rawData : dataset
                    }
                }
            });
            LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
        },
    });

    return pieChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.LineChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var LineChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.LineChart.prototype
	 */
	{
		/**
		 * class for clients to create Line Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'combination';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'line';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return LineChart;
});sap.riv.module(
{
  qname : 'sap.riv.viz.ColumnChart',
  version : '1.0.0',
  exported : true

},
[
{
  qname : 'sap.riv.vizkit.VizApplication',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.xychart.AppDelegate',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.ObjectUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.utils.TypeUtils',
  version : '1.0.0'
},
{
  qname : 'sap.riv.viz.AbstractXYChart',
  version : '1.0.0'
},
{
  qname : 'sap.riv.core.Logger',
  version : '1.0.0'
}
],
function Setup(VizApplication, AppDelegate, ObjUtils, TypeUtils, AbstractXYChart, LOG) {
	var ColChart = ObjUtils.derive(AbstractXYChart,
	/**
	 * @lends sap.riv.viz.ColumnChart.prototype
	 */
	{
		/**
		 * class for clients to create Column Chart
		 * 
		 * @augments sap.riv.viz.AbstractXYChart
		 * @constructs
		 * @param holderElement
		 *            a div container returned from jQuery selection.
		 * @param properties
		 *            a json object for chart properties. refer to properties
		 *            doc for details
		 * @param dataset
		 *            one of supported sap.riv.viz.shared.dataConverter
		 */
		constructor : function(holderElement, properties, dataset) {
			var props;
			TypeUtils.isExist(properties) ? props = properties : props = {};
			props.type = 'combination';
			if ( !TypeUtils.isExist(props.measure) ) {
				props.measure = {};
			}
			props.measure.type = 'bar';
			LOG.debug("Chart[" + this._id+ "] initializing.", "perf");
			this._viz = new VizApplication({
				wrapperDivEl : holderElement,
				delegateClass : AppDelegate,
				launchOption : {
					option : props,
					data : {
						rawData : dataset
					}
				}
			});
			LOG.debug("Chart["+this.id()+ "]application[" + this._viz.id() + "] initialized.", "perf");
		}
	});

	return ColChart;
});