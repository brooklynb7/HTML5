/* BuildVersion: 4.0.0.67 */(function() {
	if (!Array.prototype.indexOf) {
		Array.prototype.indexOf = function(searchElement /* , fromIndex */) {
			"use strict";
			if (this == null) {
				throw new TypeError();
			}
			var t = Object(this);
			var len = t.length >>> 0;
			if (len === 0) {
				return -1;
			}
			var n = 0;
			if (arguments.length > 0) {
				n = Number(arguments[1]);
				if (n != n) { // shortcut for verifying if it's NaN
					n = 0;
				} else if (n != 0 && n != Infinity && n != -Infinity) {
					n = (n > 0 || -1) * Math.floor(Math.abs(n));
				}
			}
			if (n >= len) {
				return -1;
			}
			var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
			for (; k < len; k++) {
				if (k in t && t[k] === searchElement) {
					return k;
				}
			}
			return -1;
		}
	}

	if (!Array.prototype.lastIndexOf) {
		Array.prototype.lastIndexOf = function(searchElement /* , fromIndex */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (len === 0)
				return -1;

			var n = len;
			if (arguments.length > 1) {
				n = Number(arguments[1]);
				if (n != n)
					n = 0;
				else if (n != 0 && n != (1 / 0) && n != -(1 / 0))
					n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}

			var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);

			for (; k >= 0; k--) {
				if (k in t && t[k] === searchElement)
					return k;
			}
			return -1;
		};
	}

	if (!Array.prototype.filter) {
		Array.prototype.filter = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var res = [];
			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t) {
					var val = t[i]; // in case fun mutates this
					if (fun.call(thisp, val, i, t))
						res.push(val);
				}
			}

			return res;
		};
	}

	// Production steps of ECMA-262, Edition 5, 15.4.4.18
	// Reference: http://es5.github.com/#x15.4.4.18
	if (!Array.prototype.forEach) {

		Array.prototype.forEach = function(callback, thisArg) {

			var T, k;

			if (this == null) {
				throw new TypeError("this is null or not defined");
			}

			// 1. Let O be the result of calling ToObject passing the |this|
			// value as the argument.
			var O = Object(this);

			// 2. Let lenValue be the result of calling the Get internal method
			// of O with the argument "length".
			// 3. Let len be ToUint32(lenValue).
			var len = O.length >>> 0; // Hack to convert O.length to a UInt32

			// 4. If IsCallable(callback) is false, throw a TypeError exception.
			// See: http://es5.github.com/#x9.11
			if ({}.toString.call(callback) != "[object Function]") {
				throw new TypeError(callback + " is not a function");
			}

			// 5. If thisArg was supplied, let T be thisArg; else let T be
			// undefined.
			if (thisArg) {
				T = thisArg;
			}

			// 6. Let k be 0
			k = 0;

			// 7. Repeat, while k < len
			while (k < len) {

				var kValue;

				// a. Let Pk be ToString(k).
				// This is implicit for LHS operands of the in operator
				// b. Let kPresent be the result of calling the HasProperty
				// internal method of O with argument Pk.
				// This step can be combined with c
				// c. If kPresent is true, then
				if (k in O) {

					// i. Let kValue be the result of calling the Get internal
					// method of O with argument Pk.
					kValue = O[k];

					// ii. Call the Call internal method of callback with T as
					// the this value and
					// argument list containing kValue, k, and O.
					callback.call(T, kValue, k, O);
				}
				// d. Increase k by 1.
				k++;
			}
			// 8. return undefined
		};
	}

	if (!Array.prototype.every) {
		Array.prototype.every = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t && !fun.call(thisp, t[i], i, t))
					return false;
			}

			return true;
		};
	}

	// Production steps of ECMA-262, Edition 5, 15.4.4.19
	// Reference: http://es5.github.com/#x15.4.4.19
	if (!Array.prototype.map) {
		Array.prototype.map = function(callback, thisArg) {

			var T, A, k;

			if (this == null) {
				throw new TypeError(" this is null or not defined");
			}

			// 1. Let O be the result of calling ToObject passing the |this|
			// value as the argument.
			var O = Object(this);

			// 2. Let lenValue be the result of calling the Get internal method
			// of O with the argument "length".
			// 3. Let len be ToUint32(lenValue).
			var len = O.length >>> 0;

			// 4. If IsCallable(callback) is false, throw a TypeError exception.
			// See: http://es5.github.com/#x9.11
			if ({}.toString.call(callback) != "[object Function]") {
				throw new TypeError(callback + " is not a function");
			}

			// 5. If thisArg was supplied, let T be thisArg; else let T be
			// undefined.
			if (thisArg) {
				T = thisArg;
			}

			// 6. Let A be a new array created as if by the expression new
			// Array(len) where Array is
			// the standard built-in constructor with that name and len is the
			// value of len.
			A = new Array(len);

			// 7. Let k be 0
			k = 0;

			// 8. Repeat, while k < len
			while (k < len) {

				var kValue, mappedValue;

				// a. Let Pk be ToString(k).
				// This is implicit for LHS operands of the in operator
				// b. Let kPresent be the result of calling the HasProperty
				// internal method of O with argument Pk.
				// This step can be combined with c
				// c. If kPresent is true, then
				if (k in O) {

					// i. Let kValue be the result of calling the Get internal
					// method of O with argument Pk.
					kValue = O[k];

					// ii. Let mappedValue be the result of calling the Call
					// internal method of callback
					// with T as the this value and argument list containing
					// kValue, k, and O.
					mappedValue = callback.call(T, kValue, k, O);

					// iii. Call the DefineOwnProperty internal method of A with
					// arguments
					// Pk, Property Descriptor {Value: mappedValue, Writable:
					// true, Enumerable: true, Configurable: true},
					// and false.

					// In browsers that support Object.defineProperty, use the
					// following:
					// Object.defineProperty(A, Pk, { value: mappedValue,
					// writable: true, enumerable: true, configurable: true });

					// For best browser support, use the following:
					A[k] = mappedValue;
				}
				// d. Increase k by 1.
				k++;
			}

			// 9. return A
			return A;
		};
	}

	if (!Array.prototype.some) {
		Array.prototype.some = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t && fun.call(thisp, t[i], i, t))
					return true;
			}

			return false;
		};
	}

	if (!Array.prototype.reduce) {
		Array.prototype.reduce = function reduce(accumulator) {
			if (this === null || this === undefined)
				throw new TypeError("Object is null or undefined");
			var i = 0, l = this.length >> 0, curr;

			if (typeof accumulator !== "function") // ES5 : "If
				// IsCallable(callbackfn) is
				// false, throw a TypeError
				// exception."
				throw new TypeError("First argument is not callable");

			if (arguments.length < 2) {
				if (l === 0)
					throw new TypeError("Array length is 0 and no second argument");
				curr = this[0];
				i = 1; // start accumulating at the second element
			} else
				curr = arguments[1];

			while (i < l) {
				if (i in this)
					curr = accumulator.call(undefined, curr, this[i], i, this);
				++i;
			}

			return curr;
		};
	}

	if (!Array.prototype.reduceRight) {
		Array.prototype.reduceRight = function(callbackfn /* , initialValue */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof callbackfn != "function")
				throw new TypeError();

			// no value to return if no initial value, empty array
			if (len === 0 && arguments.length === 1)
				throw new TypeError();

			var k = len - 1;
			var accumulator;
			if (arguments.length >= 2) {
				accumulator = arguments[1];
			} else {
				do {
					if (k in this) {
						accumulator = this[k--];
						break;
					}

					// if array contains no values, no initial value to return
					if (--k < 0)
						throw new TypeError();
				} while (true);
			}

			while (k >= 0) {
				if (k in t)
					accumulator = callbackfn.call(undefined, accumulator, t[k], k, t);
				k--;
			}

			return accumulator;
		};
	}

	if (!Function.prototype.bind) {
		Function.prototype.bind = function(oThis) {
			if (typeof this !== "function") {
				// closest thing possible to the ECMAScript 5 internal
				// IsCallable function
				throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
			}

			var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() {
			}, fBound = function() {
				return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice
						.call(arguments)));
			};

			fNOP.prototype = this.prototype;
			fBound.prototype = new fNOP();

			return fBound;
		};
	}

	if (!Object.create) {
		// this is the polyfill implementation covers the main use case
		Object.create = function(o) {
			if (arguments.length > 1) {
				throw new Error('Object.create implementation only accepts the first parameter.');
			}
			function F() {
			}
			F.prototype = o;
			return new F();
		};
	}

	function defineProperties(obj, properties) {
		// this is the polyfill implementation covers the main use case
		function convertToDescriptor(desc) {
			function hasProperty(obj, prop) {
				return Object.prototype.hasOwnProperty.call(obj, prop);
			}

			function isCallable(v) {
				// NB: modify as necessary if other values than functions are
				// callable.
				return typeof v === "function";
			}

			if (typeof desc !== "object" || desc === null)
				throw new TypeError("bad desc");

			var d = {};
			if (hasProperty(desc, "enumerable"))
				d.enumerable = !!obj.enumerable;
			if (hasProperty(desc, "configurable"))
				d.configurable = !!obj.configurable;
			if (hasProperty(desc, "value"))
				d.value = obj.value;
			if (hasProperty(desc, "writable"))
				d.writable = !!desc.writable;
			if (hasProperty(desc, "get")) {
				var g = desc.get;
				if (!isCallable(g) && g !== "undefined")
					throw new TypeError("bad get");
				d.get = g;
			}
			if (hasProperty(desc, "set")) {
				var s = desc.set;
				if (!isCallable(s) && s !== "undefined")
					throw new TypeError("bad set");
				d.set = s;
			}

			if (("get" in d || "set" in d) && ("value" in d || "writable" in d))
				throw new TypeError("identity-confused descriptor");

			return d;
		}

		if (typeof obj !== "object" || obj === null)
			throw new TypeError("bad obj");

		properties = Object(properties);
		var keys = Object.keys(properties);
		var descs = [];
		for ( var i = 0; i < keys.length; i++)
			descs.push([ keys[i], convertToDescriptor(properties[keys[i]]) ]);
		for ( var i = 0; i < descs.length; i++)
			Object.defineProperty(obj, descs[i][0], descs[i][1]);

		return obj;
	}

	if (!Object.keys) {
		Object.keys = (function() {
			var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !({
				toString : null
			}).propertyIsEnumerable('toString'), dontEnums = [ 'toString', 'toLocaleString', 'valueOf',
					'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor' ], dontEnumsLength = dontEnums.length

			return function(obj) {
				if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null)
					throw new TypeError('Object.keys called on non-object')

				var result = []

				for ( var prop in obj) {
					if (hasOwnProperty.call(obj, prop))
						result.push(prop)
				}

				if (hasDontEnumBug) {
					for ( var i = 0; i < dontEnumsLength; i++) {
						if (hasOwnProperty.call(obj, dontEnums[i]))
							result.push(dontEnums[i])
					}
				}
				return result
			}
		})()
	}

	if (typeof Object.getPrototypeOf !== "function") {
		if (typeof "test".__proto__ === "object") {
			Object.getPrototypeOf = function(object) {
				return object.__proto__;
			};
		} else {
			Object.getPrototypeOf = function(object) {
				// May break if the constructor has been tampered with
				return object.constructor.prototype;
			};
		}
	}

	if (!String.prototype.trim) {
		String.prototype.trim = function() {
			return this.replace(/^\s+|\s+$/g, '');
		};
	}

	var undefined = void (0);
	if (window.sap !== undefined && window.sap.riv !== undefined && window.sap.riv.module !== undefined) {
		// In case of already defined
		return;
	}

	var isJQueryUsed = jQuery !== undefined ? true : false

	var jQueryHoldReady = function(shouldHold) {
		if (isJQueryUsed) {
			if (jQuery.holdReady) {
				jQuery.holdReady(shouldHold);
			} else if (shouldHold) {
				jQuery.readyWait += 1;
			} else {
				jQuery.ready(true);
			}
		}
	}
	var curScript = undefined;
	var context_path = '/';
	var scripts = document.getElementsByTagName("script");
	var trace = function() {
	};
	// A ugly way to determine whether the script tag is used for
	// loading sap.viz.base.js
	// Sometimes the base js is not loaded via script tag
	if (scripts.length && scripts[scripts.length - 1].getAttribute('src')
			&& scripts[scripts.length - 1].getAttribute('src').lastIndexOf('sap.viz.base.js')) {
		curScript = scripts[scripts.length - 1];
		if (((curScript.getAttribute('trace') || '').toLowerCase() === 'true') && (typeof console !== undefined)) {
			trace = function(traceLog) {
				console.log(traceLog);
			};
		}

		var context_path = curScript.getAttribute('base-url');

		if (!context_path) {
			var src = curScript.getAttribute('src');
			context_path = src.substring(0, src.lastIndexOf('/'));
		}
		if (context_path.charAt(context_path.length - 1) !== '/')
			context_path = context_path + '/';
	}

	window.sap = window.sap || {};
	window.sap.riv = window.sap.riv || {};

	var ENTRY_CREATED = 0, IN_LOADING = 1, DEFINED = 2, ERROR = 3;

	var hasOwn = Object.prototype.hasOwnProperty;

	var class2type = {
		'[object Boolean]' : 'boolean',
		'[object Number]' : 'number',
		'[object String]' : 'string',
		'[object Function]' : 'function',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object RegExp]' : 'regexp',
		'[object Object]' : 'object'
	};

	var type = function(obj) {
		return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
	};

	var isFunction = function(obj) {
		return type(obj) === "function";
	};

	var isArray = Array.isArray || function(obj) {
		return type(obj) === "array";
	};

	var isString = function(obj) {
		return type(obj) === "string";
	};

	// A crude way of determining if an object is a window
	var isWindow = function(obj) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	};

	var isNaN = function(obj) {
		return obj == null || !/\d/.test(obj) || isNaN(obj);
	};

	var isNumber = function(n) {
		return !isNaN(parseFloat(n)) && isFinite(n);
	};

	var isDefined = function(v) {
		return typeof (v) !== 'undefined';
	};

	var isUndefined = function(v) {
		return typeof (v) === 'undefined';
	};

	var isPlainObject = function(obj) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the
		// constructor property.
		// Make sure that DOM nodes and window objects don't pass through,
		// as well
		if (!obj || type(obj) !== "object" || obj.nodeType || isWindow(obj)) {
			return false;
		}

		// Not own constructor property must be Object
		if (obj.constructor && !hasOwn.call(obj, "constructor")
				&& !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for (key in obj) {
		}

		return key === undefined || hasOwn.call(obj, key);
	};

	var isEmptyObject = function(obj) {
		for ( var name in obj) {
			return false;
		}
		return true;
	};

	var ModuleEntry = function(qname, version) {
		this._qname = qname;
		this._version = version;
		this._moduleSetupFunc = undefined;
		this._status = ENTRY_CREATED;
		this._moduleObject = undefined;
		this._exportToGlobal = false;
		this._depList = [];
		this._pendingDefTaskList = [];
		jQueryHoldReady(true);
	};
	ModuleEntry.prototype.moduleObject = function(moduleObj) {
		return this._moduleObject;
	};
	ModuleEntry.prototype.setupFunction = function(setupFunction) {
		if (isDefined(setupFunction)) {
			this._moduleSetupFunc = setupFunction;
			return this;
		} else {
			return this._moduleSetupFunc;
		}
	};
	ModuleEntry.prototype.setModuleObject = function(moduleObj) {
		this._moduleObject = moduleObj;
	};
	ModuleEntry.prototype.qname = function() {
		return this._qname;
	};
	ModuleEntry.prototype.version = function() {
		return this._version;
	};
	ModuleEntry.prototype.status = function(status) {
		if (status !== undefined) {
			this._status = status;
			return this;
		} else {
			return this._status;
		}
	};
	ModuleEntry.prototype.dependentModules = function(depList) {
		if (isDefined(depList)) {
			this._depList = depList;
			return this;
		} else {
			return this._depList;
		}
	};
	ModuleEntry.prototype.exportToGlobal = function(exportToGlobal) {
		if (isDefined(exportToGlobal)) {
			this._exportToGlobal = exportToGlobal;
			return this;
		} else {
			return this._exportToGlobal;
		}

	};

	ModuleEntry.prototype.waitUntilDefined = function(pendingDefTask) {
		this._pendingDefTaskList.push(pendingDefTask);
	};
	ModuleEntry.prototype.getPendingDefTasks = function() {
		return this._pendingDefTaskList;
	};

	// A global pool for containing all of the managed modules
	var modulesPool = {};
	// Register loaded url
	var loadedURLs = {};

	var loader = function(url) {
		if (!loadedURLs.hasOwnProperty(url)) {
			loadedURLs[url] = false;
			var head = document.getElementsByTagName("head")[0] || document.documentElement;
			var script = document.createElement("script");
			script.type = 'text/javascript';
			script.src = url;
			// Handle Script loading
			var done = false;
			// Attach handlers for all browsers
			script.onload = script.onreadystatechange = function() {
				if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
					done = true;
					// Handle memory leak in IE
					script.onload = script.onreadystatechange = null;
					if (head && script.parentNode) {
						head.removeChild(script);
					}
					loadedURLs[url] = true;
				}
			};
			if (script.addEventListener) {
				script.addEventListener('error', function() {
					throw new Error('Loading ' + url + ' failed.')
				}, true);
			}
			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709 and #4378).
			head.insertBefore(script, head.firstChild);
			// We handle everything using the script element injection
		}

		return undefined;
	};

	var isValidSemanticVersion = function(semver) {
		if (semver === undefined || typeof semver !== 'string') {
			return false;
		}
		var components = semver.split('.');
		if (components.length > 3) {
			return false;
		}
		for ( var i = 0, len = components.length; i < len; i++) {
			if (parseInt(components[i]) === NaN) {
				return false;
			}
		}
		return true;
	};

	var buildModuleURL = function(qname, version) {
		var paths = qname.split('.');
		var fileName = paths.splice(paths.length - 1, 1);
		return context_path + paths.join('/') + '/' + fileName + '.' + version + '.js';
	};

	var setupModule = function(moduleEntry) {
		var moduleObject;
		if (isFunction(moduleEntry.setupFunction())) {
			var args = [];
			for ( var i = 0, depModule, depModuleList = moduleEntry.dependentModules(), len = depModuleList.length; i < len; i++) {
				depModule = depModuleList[i];
				args.push(modulesPool[depModule.qname][depModule.version].moduleObject());
			}
			moduleObject = moduleEntry.setupFunction().apply(window, args);
		} else {
			moduleObject = moduleEntry.moduleObject();
		}
		if (moduleEntry.exportToGlobal()) {
			var qnameComps = moduleEntry.qname().split('.');
			var attachTo = window;
			for ( var i = 0, part, len = qnameComps.length; i < len; i++) {
				part = qnameComps[i];
				if (i === len - 1) {
					attachTo[part] = moduleObject;
				} else {
					attachTo[part] = attachTo[part] || {};
					attachTo = attachTo[part];
				}
			}
		}
		moduleEntry.setModuleObject(moduleObject);
		moduleEntry.status(DEFINED);
		trace(moduleEntry.qname() + ' ' + moduleEntry.version() + ' loaded')
		// Resume the definition tasks that are blocked on this module
		var pendingTasks = moduleEntry.getPendingDefTasks();
		while (pendingTasks.length) {
			var pendingTask = pendingTasks.pop();
			pendingTask(moduleEntry);
		}
		jQueryHoldReady(false)
	};

	var createPendingDefTask = function(waitedModules, moduleEntry) {
		return (function(availableModuleEntry) {
			// remove the available module from the waited modules
			delete waitedModules[availableModuleEntry.qname()][availableModuleEntry.version()];
			if (isEmptyObject(waitedModules[availableModuleEntry.qname()])) {
				delete waitedModules[availableModuleEntry.qname()];
			}
			if (isEmptyObject(waitedModules)) {
				setupModule(moduleEntry);
			}
		});
	};

	sap.riv.module = function(moduleCfg, dependencies, moduleSetupFunc) {
		if (isUndefined(moduleCfg) || isUndefined(moduleCfg.qname) || isUndefined(moduleCfg.version)) {
			throw new Error('Bad Arguments: you have to specify the qname and version for the module.');
		}
		if (!isString(moduleCfg.qname) || !isValidSemanticVersion(moduleCfg.version)) {
			throw new Error('Invalid qname or version string');
		}
		if (arguments.length === 2) {
			if (!isPlainObject(dependencies) && !isFunction(dependencies)) {
				throw new Error('You must specify a plain object or a module setup function');
			}
			moduleSetupFunc = dependencies;
			dependencies = [];
		}
		if (arguments.length === 3) {
			if (!isArray(dependencies) || (!isPlainObject(moduleSetupFunc) && !isFunction(moduleSetupFunc))) {
				throw new Error(
						'Dependencies must be array, and you must specify an plain object or a module setup function');
			}
		}
		var qname = moduleCfg.qname, version = moduleCfg.version, exportToGlobal = isUndefined(moduleCfg.exported) ? false
				: moduleCfg.exported, moduleEntry;

		if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool, version)) {
			modulesPool[qname] = modulesPool[qname] || {};
			modulesPool[qname][version] = modulesPool[qname][version] || new ModuleEntry(qname, version);
		}
		moduleEntry = modulesPool[qname][version];

		if (moduleEntry.status() === ENTRY_CREATED) {
			// The depending module is just created for the loading
			if (typeof moduleSetupFunc === 'object') {
				// Module is just a plain object
				moduleEntry.exportToGlobal(exportToGlobal).setModuleObject(moduleSetupFunc);
			} else {
				var depList = [];
				for ( var i = 0, depModule, len = dependencies.length; i < len; i++) {
					depModule = dependencies[i];
					if (!isString(depModule.qname) || !isValidSemanticVersion(depModule.version)) {
						throw new Error('You must specify qname and version for the depending module');
					}
					depList.push({
						qname : depModule.qname,
						version : depModule.version
					});
				}
				moduleEntry.exportToGlobal(exportToGlobal).dependentModules(depList).setupFunction(moduleSetupFunc);
			}
		}

		if (moduleEntry.status() === DEFINED || moduleEntry.status() === IN_LOADING) {
			return;
		}
		moduleEntry.status(IN_LOADING);

		if (moduleEntry.dependentModules().length === 0) {
			setupModule(moduleEntry);
			return;
		} else {
			var waitedModules = {};
			for ( var i = 0, dep, depList = moduleEntry.dependentModules(), len = depList.length; i < len; i++) {
				dep = depList[i];
				if (!(hasOwn.call(modulesPool, dep.qname) && hasOwn.call(modulesPool[dep.qname], dep.version))
						|| (modulesPool[dep.qname][dep.version].status() !== DEFINED)) {
					// The depending module is not ready, either because of not
					// loaded yet or because of pending on defining
					waitedModules[dep.qname] = waitedModules[dep.qname] || {};
					waitedModules[dep.qname][dep.version] = waitedModules[dep.qname][dep.version] || {
						qname : dep.qname,
						version : dep.version,
						url : dep.url || buildModuleURL(dep.qname, dep.version)
					};
				}
			}
			if (isEmptyObject(waitedModules)) {
				// All the depending modules are ready
				setupModule(moduleEntry);
				return;
			} else {
				// Some of the depending modules are not ready, either because
				// of not loaded yet or because of pending on defining
				for ( var qname in waitedModules) {
					for ( var version in waitedModules[qname]) {
						if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool[qname], version)) {
							// if it's a brand new module, then create a entry
							// for it
							modulesPool[qname] = modulesPool[qname] || {};
							modulesPool[qname][version] = modulesPool[qname][version]
									|| new ModuleEntry(qname, version);
							// TODO check circular dependencies
							modulesPool[qname][version].waitUntilDefined(createPendingDefTask(waitedModules,
									moduleEntry));
							// TODO handle loading error
							loader(waitedModules[qname][version].url);
						} else {
							// if it's not ready(either is loading or not), wait
							// until it's done
							modulesPool[qname][version].waitUntilDefined(createPendingDefTask(waitedModules,
									moduleEntry));
						}
					}
				}
			}
		}
	};

	var executeRequiredFunction = function(requiredFunction, requiredModules) {
		var args = [];
		for ( var i = 0, requiredModule, len = requiredModules.length; i < len; i++) {
			requiredModule = requiredModules[i];
			args.push(modulesPool[requiredModule.qname][requiredModule.version].moduleObject());
		}
		requiredFunction.apply(window, args);
	};

	var createPendingRequireTask = function(waitedModules, requiredFunc, requiredModules) {
		return (function(availableModuleEntry) {
			// remove the available module from the waited modules
			delete waitedModules[availableModuleEntry.qname()][availableModuleEntry.version()];
			if (isEmptyObject(waitedModules[availableModuleEntry.qname()])) {
				delete waitedModules[availableModuleEntry.qname()];
			}
			if (isEmptyObject(waitedModules)) {
				executeRequiredFunction(requiredFunc, requiredModules);
			}
		});
	};

	sap.riv.require = function(dependencies, requireFunc) {
		if (arguments.length === 1) {
			if (!isFunction(dependencies)) {
				throw new Error('You have to specify a function to run');
			}
			requireFunc = dependencies;
			dependencies = [];
		}
		if (arguments.length === 2) {
			if (!isArray(dependencies) || !isFunction(requireFunc)) {
				throw new Error(
						'the first argument has to be array of depending modules, the second argument should be function type');
			}
		}

		if (!dependencies.length) {
			// No dependencies specified, execute it right away.
			executeRequiredFunction(requireFunc, dependencies);
			return;
		}

		var waitedModules = {};
		for ( var i = 0, dep, len = dependencies.length; i < len; i++) {
			dep = dependencies[i];
			if (!(hasOwn.call(modulesPool, dep.qname) && hasOwn.call(modulesPool[dep.qname], dep.version))
					|| (modulesPool[dep.qname][dep.version].status() !== DEFINED)) {
				// The depending module is not ready, either because of not
				// loaded yet or because of pending on defining
				waitedModules[dep.qname] = waitedModules[dep.qname] || {};
				waitedModules[dep.qname][dep.version] = waitedModules[dep.qname][dep.version] || {
					qname : dep.qname,
					version : dep.version,
					url : dep.url || buildModuleURL(dep.qname, dep.version)
				};
			}
		}
		if (isEmptyObject(waitedModules)) {
			// All the depending modules are ready
			executeRequiredFunction(requireFunc, dependencies);
			return;
		} else {
			// Some of the depending modules are not ready, either because
			// of not loaded yet or because of pending on defining
			for ( var qname in waitedModules) {
				for ( var version in waitedModules[qname]) {
					if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool[qname], version)) {
						// if it's a brand new module, then create a entry
						// for it
						modulesPool[qname] = modulesPool[qname] || {};
						modulesPool[qname][version] = modulesPool[qname][version] || new ModuleEntry(qname, version);
						// TODO check circular dependencies
						modulesPool[qname][version].waitUntilDefined(createPendingRequireTask(waitedModules,
								requireFunc, dependencies));
						// TODO handle loading error
						loader(waitedModules[qname][version].url);
					} else {
						// if it's not ready(either is loading or not), wait
						// until it's done
						modulesPool[qname][version].waitUntilDefined(createPendingRequireTask(waitedModules,
								requireFunc, dependencies));
					}
				}
			}
		}
	};

	// Evalulates a script in a global context
	var globalEval = function(data) {
		if (data && /\S/.test(data)) {
			// Inspired by code by Andrea Giammarchi
			// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
			var head = document.getElementsByTagName("head")[0] || document.documentElement, script = document
					.createElement("script");

			script.type = "text/javascript";

			try {
				script.appendChild(document.createTextNode(data));
			} catch (e) {
				script.text = data;
			}

			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709).
			head.insertBefore(script, head.firstChild);
			head.removeChild(script);
		}
	};

	sap.riv.setBaseUrl = function(url) {
		context_path = url;
	};
	// if the base js is not loaded via script tag, skip the evaluating of
	// embeded script.
	if (curScript) {
		var script = curScript.innerHTML;
		if (script) {
			globalEval(script);
		}
	}
})();sap.riv.module(
{
  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'},
[

],
function Setup() 
{
  var BoundUtil = {
      drawBound : function(selection, width, height ){
          if(selection.select('.bound').node() == null){
            selection.insert('rect', ':first-child').attr('class', 'bound').attr('width', width).attr('height', height).attr('visibility', 'hidden');
          }else{
            selection.select('.bound').attr('width', width).attr('height', height);
          }
      }
  };
  
  return BoundUtil;
});sap.riv.module(
{
  qname : 'sap.viz.Locale',
  version : '4.0.0',
  exported : true
},
[

],
function Setup(LangManager, FormatManager) {
  var locale = 'en',  listeners = [];
	  
  function onLocaleChanged(locale) {
    listeners.forEach(function(listener) {
      listener.fn.apply(listener.scope, [locale]);
    });
  }
	
  var Locale = 
	  /** @lends sap.viz.Locale */
	{		/**
		       * @constructs
		       */
		      constructor : function(){
		        return;
		      },
		      
		      /**
		       * 
		       * @param {String}
		       * 			locale
		       * 
		       * @returns {Object} {@link sap.viz.Locale}
		       */
		      locale : function(loc){
		    	  if(!arguments.length){
		    		  return locale;
		    	  }
		    	  locale = loc;
		    	  onLocaleChanged(locale);
		    	  return Locale;
		      },
		      
		      /**
		       * Add a listener which will be executed when current language is changed.
		       * 
		       * @param {Object}
		       *          listener
		       * @param {Function}
		       *          listener.fn the listener function
		       * @param {Object}
		       *          listener.scope the "this" object in the listener function
		       * 
		       * @returns {Object} {@link sap.viz.Locale}
		       */
		      addListener : function(listener) {
		          listeners.push(listener);
		          return Locale;
		       },
		       
		       /**
		        * Remove the listener.
		        * 
		        * @param {Object} listener
		        *          the listener reference
		        * 
		        * @returns {Object} {@link sap.viz.Locale}
		        */
		       removeListener : function(listener) {
		         var index = listeners.indexOf(listener);
		         if (index != -1)
		           listeners.splice(index, 1);
		         return Locale;
		       }
	};
	
	return Locale;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'},
[

],
function Setup() {
	var class2type = {
		'[object Boolean]' : 'boolean',
		'[object Number]' : 'number',
		'[object String]' : 'string',
		'[object Function]' : 'function',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object RegExp]' : 'regexp',
		'[object Object]' : 'object'
	};

	var hasOwn = Object.prototype.hasOwnProperty;
	// Used for trimming whitespace
	var rdigit = /\d/;

	var type = function(obj) {
		return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
	};

	/**
	 * Type Utilities for common variable type related tasks
	 * 
	 * @name sap.viz.base.utils.TypeUtils
	 * @class
	 */
	var typeUtils = {

		/**
	     * Returns a boolean value indicating whether the parameter is of type function
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		// See test/unit/core.js for details concerning isFunction.
		// Since version 1.3, DOM methods and functions like alert
		// aren't supported. They return false on IE (#2968).
		isFunction : function(obj) {
			return type(obj) === "function";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is of type array
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isArray : Array.isArray || function(obj) {
			return type(obj) === "array";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is of type string
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isString : function(obj) {
			return type(obj) === "string";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a non-empty string
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isNonEmptyString : function(obj) {
			return this.isString(obj) && obj.length !== 0;
		},

		/**
	     * Returns a boolean value indicating whether the parameter is an empty string
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isEmptyString : function(obj) {
			return this.isString(obj) && obj.length === 0;
		},

		/**
	     * Returns a boolean value indicating whether the parameter is NaN
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isNaN : function(obj) {
			return obj === null || obj === undefined || !rdigit.test(obj) || isNaN(obj);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a number
	     *
	     * @param {object}
	     * @returns {boolean} Caution: isNumber(Infinity) returns false.
	     */
		isNumber : function(n) {
			return !this.isNaN(parseFloat(n)) && isFinite(n);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is defined
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isDefined : function(v) {
			return typeof (v) !== 'undefined';
		},

		/**
	     * Returns a boolean value indicating whether the parameter is undefined
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isUndefined : function(v) {
			return typeof (v) === 'undefined';
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a plain object
	     *
	     * @param {object}
	     * @returns {boolean}
	     * Caution: A plain object is an object that has no prototype method and
	     *  no parent class. Null, undefined, DOM nodes and window object are not considered as plain object.
	     */
		isPlainObject : function(obj) {
			// Must be an Object.
			// Because of IE, we also have to check the presence of the
			// constructor property.
			// Make sure that DOM nodes and window objects don't pass through,
			// as well
			if (!obj || type(obj) !== "object" || obj.nodeType
					|| (obj && typeof obj === "object" && "setInterval" in obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor && !hasOwn.call(obj, "constructor")
					&& !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own.

			var key;
			for (key in obj) {
			}

			return key === undefined || hasOwn.call(obj, key);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is an empty object
	     *
	     * @param {object}
	     * @returns {boolean}
	     * Caution: An empty is a plain object without any properties.
	     */
		isEmptyObject : function(obj) {
			for ( var name in obj) {
				return false;
			}
			return this.isPlainObject(obj);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is undefined or null
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isExist : function(o) {
			if ((typeof (o) === 'undefined') || (o === null)) {
				return false;
			}
			return true;
		}
	};

	return typeUtils;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils) {
	var msgparas = /\{(\d+)\}/g;

	var emptyFn = function() {
	};

	var funcUtils = {
		/**
		 * empty function
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#noop
		 * @function
		 */
		noop : emptyFn,

		/**
		 * function throwing unsupported exception
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#unsupported
		 * @function
		 */
		unsupported : function() {
			throw new Error('Unsupported function!');
		},

		/**
		 * function throwing unimplemented exception
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#unimplemented
		 * @function
		 */
		unimplemented : function() {
			throw new Error('Unimplemented function!');
		},

		/**
		 * function throwing error
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#error
		 * @param {String}
		 *            msg the error message
		 * @function
		 */
		error : function(msg) {
			var args = arguments;
			if (args[0]) {
				var msg = args[0].replace(msgparas, function(m, n) {
					return args[parseInt(n) + 1];
				});
				throw msg;
			} else {
				throw 'unknown error!';
			}
		},

		createCallChain : function() {
			var len = arguments.length;
			if (len > 1) {
				var callChain = [];
				for ( var i = 0; i < len; i++) {
					if (TypeUtils.isFunction(arguments[i])) {
						callChain.push(arguments[i]);
					} else {
						funcUtils.error('Could not create call chain for non-function object');
					}
				}
				return (function() {
					for ( var i = 0; i < len; i++) {
						callChain[i].apply(this, arguments);
					}
				});
			} else {
				return TypeUtils.isFunction(arguments[0]) ? arguments[0] : emptyFn;
			}
		}
	};

	return funcUtils;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils, FuncUtils) {
	var emptyFn = function(){};
	var trimLeft = /^\s+/, trimRight = /\s+$/,
	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/, rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;

	var trim = trim ? function(text) {
		return text == null ? "" : trim.call(text);
	} :
	// Otherwise use our own trimming functionality
	function(text) {
		return text == null ? "" : text.toString().replace(trimLeft, "").replace(trimRight, "");
	};

	/**
	 * OO static utilities
	 * 
	 * @name sap.viz.base.utils.ObjectUtils
	 * @class
	 */
	var objUtils = {
		uuid : function() {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {var r = Math.random()*16|0,v=c=='x'?r:r&0x3|0x8;return v.toString(16);});
		},
		
		proxy : function(fn, proxy, thisObject) {
			if (arguments.length === 2) {
				if (typeof proxy === "string") {
					thisObject = fn;
					fn = thisObject[proxy];
					proxy = undefined;

				} else if (proxy && !TypeUtils.isFunction(proxy)) {
					thisObject = proxy;
					proxy = undefined;
				}
			}

			if (!proxy && fn) {
				proxy = function() {
					return fn.apply(thisObject || this, arguments);
				};
			}
			// So proxy can be declared as an argument
			return proxy;
		},

		// Copy from jQuery
		extend : function() {
			var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;

			// Handle a deep copy situation
			if (typeof target === "boolean") {
				deep = target;
				target = arguments[1] || {};
				// skip the boolean and the target
				i = 2;
			}

			// Handle case when target is a string or something (possible in
			// deep
			// copy)
			if (typeof target !== "object" && !TypeUtils.isFunction(target)) {
				target = {};
			}

			// extend jQuery itself if only one argument is passed
			if (length === i) {
				target = this;
				--i;
			}

			for (; i < length; i++) {
				// Only deal with non-null/undefined values
				if ((options = arguments[i]) != null) {
					// Extend the base object
					for (name in options) {
						src = target[name];
						copy = options[name];

						// Prevent never-ending loop
						if (target === copy) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (TypeUtils.isPlainObject(copy) || (copyIsArray = TypeUtils.isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && TypeUtils.isArray(src) ? src : [];

							} else {
								clone = src && TypeUtils.isPlainObject(src) ? src : {};
							}
							// Never move original objects, clone them
							target[name] = objUtils.extend(deep, clone, copy);
							// Don't bring in undefined values
						} else if (copy !== undefined) {
							target[name] = copy;
						}
					}
				}
			}
			// Return the modified object
			return target;
		},

		// args is for internal usage only
		each : function(object, callback, args) {
			var name, i = 0, length = object.length, isObj = length === undefined || TypeUtils.isFunction(object);

			if (args) {
				if (isObj) {
					for (name in object) {
						if (callback.apply(object[name], args) === false) {
							break;
						}
					}
				} else {
					for (; i < length;) {
						if (callback.apply(object[i++], args) === false) {
							break;
						}
					}
				}

				// A special, fast, case for the most common use of each
			} else {
				if (isObj) {
					for (name in object) {
						if (callback.call(object[name], name, object[name]) === false) {
							break;
						}
					}
				} else {
					for ( var value = object[0]; i < length && callback.call(value, i, value) !== false; value = object[++i]) {
					}
				}
			}
			return object;
		},

		parseJSON : function(data) {
			if (typeof data !== "string" || !data) {
				return null;
			}

			// Make sure leading/trailing whitespace is removed (IE can't handle
			// it)
			data = trim(data);

			// Make sure the incoming data is actual JSON
			// Logic borrowed from http://json.org/json2.js
			if (rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, ""))) {

				// Try to use the native JSON parser first
				return window && window.JSON && window.JSON.parse ? window.JSON.parse(data) : (new Function("return "
						+ data))();

			} else {
				TypeUtils.error("Invalid JSON: " + data);
			}
		},

		/**
		 * make the subclass derived from passed-in superclass, the superclass's
		 * constructor will be automatically called.
		 * 
		 * @name sap.viz.base.utils.ObjectUtils.derive
		 * @function
		 * @param {Function}
		 *            subcls constructor of subclass or baseclass to extend
		 * @param {Function}
		 *            supercls or overide constructor of superclass, or object
		 *            literals to overide
		 * @return {Function} the constructor of the derived class with some
		 *         additional field: 'clazz' points to current constructor,
		 *         superclazz points to superclass' constructor. superclass in
		 *         prototype points to superclass's prototype
		 */
		derive : function(subcls, supercls) {
			var ret;
			var retp;
			if (typeof subcls === 'function') {
				if (typeof supercls === 'function') {
					if (supercls.prototype.constructor == Object.prototype.constructor) {
						supercls.prototype.constructor = supercls;
					}
					emptyFn.prototype = supercls.prototype;
					var h = new emptyFn();
					var sbp = subcls.prototype;
					for (var p in sbp) {
						if (sbp.hasOwnProperty(p)) {
							h[p] = sbp[p];
						}
					}
					ret = FuncUtils.createCallChain(supercls, subcls);
					retp = ret.prototype = h;
					retp.constructor = ret;
					retp.superclass = supercls.prototype;
					retp.callParent = (function() {
						var stack = [];
						return function() {
							var funcName = arguments[0];
							if (!stack.length) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							} else if (stack[stack.length - 1].funcName !== funcName
									|| stack[stack.length - 1].thisObj !== this) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							}

							var skip = stack[stack.length - 1].level;
							var currentProto = this.superclass;
							while (skip--) {
								currentProto = currentProto.superclass;
							}
							stack[stack.length - 1].level++;
							var args = [];
							for ( var i = 1; i < arguments.length; i++) {
								args.push(arguments[i]);
							}
							currentProto[funcName].apply(stack[stack.length - 1].thisObj, args);
							stack[stack.length - 1].level--;
							if (!stack[stack.length - 1].level) {
								stack.pop();
							}
						};
					})();
					ret.superclazz = supercls;
					return ret;
				} else if (typeof supercls === 'object') {
					var basecls = subcls;
					var mixin = supercls;
					var bcp = basecls.prototype;

					emptyFn.prototype = bcp;
					var h = new emptyFn();
					ret = FuncUtils.createCallChain(basecls, mixin.constructor);
					retp = ret.prototype = h;
					for (p in mixin) {
						if (mixin.hasOwnProperty(p)) {
							retp[p] = mixin[p];
						}
					}
					retp.constructor = ret;
					retp.superclass = basecls.prototype;
					retp.callParent = (function() {
						var stack = [];
						return function() {
							var funcName = arguments[0];
							if (!stack.length) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							} else if (stack[stack.length - 1].funcName !== funcName
									|| stack[stack.length - 1].thisObj !== this) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							}

							var skip = stack[stack.length - 1].level;
							var currentProto = this.superclass;
							while (skip--) {
								currentProto = currentProto.superclass;
							}
							stack[stack.length - 1].level++;
							var args = [];
							for ( var i = 1; i < arguments.length; i++) {
								args.push(arguments[i]);
							}
							currentProto[funcName].apply(stack[stack.length - 1].thisObj, args);
							stack[stack.length - 1].level--;
							if (!stack[stack.length - 1].level) {
								stack.pop();
							}
						};
					})();
					ret.superclazz = basecls;
				}
			}
			return ret;
		}
	};
	return objUtils;
});sap.riv.module(
{
  qname : 'sap.viz.lang.langManager',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.Locale',
  version : '4.0.0'
}
],
function Setup(FunctionUtils, ObjectUtils, TypeUtils, Locale) {

  function loadResource(url,  cb, onError) {
    var head = document.getElementsByTagName("head")[0]
        || document.documentElement;
    var script = document.createElement("script");
    script.type = 'text/javascript';
    script.src = url;

    var done = false;
    script.onload = script.onreadystatechange = function() {
      if (!done
          && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
        done = true;
        script.onload = script.onreadystatechange = null;
        if (head && script.parentNode) {
          head.removeChild(script);
        }
        cb();
      }
    };
    if (script.addEventListener) {
      script.addEventListener('error', function() {
        //clear script
        script.onload = script.onreadystatechange = null;
        script.parentNode.removeChild(script);
        //call error callback
        onError();
      }, true);
    }

    head.insertBefore(script, head.firstChild);
  }
  
  function loadResources(loadPath, index, id, cb, onError ){
    if(index < loadPath.length){
      var url = loadPath[index] + 'language_' + id + '.js';
      var done = function(){
        loadResources(loadPath, index+1, id, cb, onError);
      };
      loadResource(url, done, done);
    }else{
      var c_language = get(id);
      if(c_language){ cb(c_language);}
      else onError();
    }
  }
  function initialLanguageMap(){
	  	
	  	var map = d3.map();
	  	//3 for ar
	  	map.set("ar_AE","ar");
	  	map.set("ar_EG","ar");
	  	map.set("ar_SA","ar");
	  	//1 for bg
	  	map.set("bg_BG","bg");
	  	//1 for ca
	  	map.set("ca_ES","ca");
	  	//1 for cs
	  	map.set("cs_CZ","cs");
	  	//1 for da
	  	map.set("da_DK","da");
	  	//5 for de
	  	map.set("de_CH","de");
	  	map.set("de_AT","de");
	  	map.set("de_BE","de");
	  	map.set("de_LU","de");
	  	map.set("de_DE","de");
	  	//2 for el
	  	map.set("el_CY","el");
	  	map.set("el_GR","el");
	  	//14 for en
	  	map.set("en_AU","en");
	  	map.set("en_CA","en");
	  	map.set("en_GB","en");
	  	map.set("en_HK","en");
	  	map.set("en_ID","en");
	  	map.set("en_IE","en");
	  	map.set("en_IN","en");
	  	map.set("en_IS","en");
	  	map.set("en_MY","en");
	  	map.set("en_NZ","en");
	  	map.set("en_PH","en");
	  	map.set("en_SG","en");
	  	map.set("en_US","en");
	  	map.set("en_ZA","en");
	  	//9 for es
	  	map.set("es_AR","es");
	  	map.set("es_BO","es");
	  	map.set("es_CL","es");
	  	map.set("es_CO","es");
	  	map.set("es_ES","es");
	  	map.set("es_MX","es");
	  	map.set("es_PE","es");
	  	map.set("es_UY","es");
	  	map.set("es_VE","es");
	  	//1 for et
	  	map.set("et_EE","et");
	  	//1 for fa
	  	map.set("fa_IR","fa");
	  	//1 for fi
		map.set("fi_FI","fi");
		//5 for fr
		map.set("fr_BE","fr");
		map.set("fr_CA","fr");
		map.set("fr_CH","fr");
		map.set("fr_FR","fr");
		map.set("fr_LU","fr");
		//1 for iw
		map.set("he_IL","iw");
		//1for hr
		map.set("hr_HR","hr");
		//1 for hu
		map.set("hu_HU","hu");
		//2 for it
		map.set("it_CH","it");
	  	map.set("it_IT","it");
	  	//1 for ja
		map.set("ja_JP","ja");
		//1 for ko
		map.set("ko_KR","ko");
		//1 for lt
		map.set("lt_LT","lt");
		//1 for lv
		map.set("lv_LV","lv");
		//2 for nl
		map.set("nl_BE","nl");
	  	map.set("nl_NL","nl");
	  	//1 for no
	  	map.set("nn_NO","no");
	  	//1 for pl
	  	map.set("pl_PL","pl");
	  	//2 for pt
	  	map.set("pt_BR","pt");
	  	map.set("pt_PT","pt");
	  	//1 for ro
	  	map.set("ro_RO","ro");
	  	//3 for ru
	  	map.set("ru_KZ","ru");
	  	map.set("ru_RU","ru");
	  	map.set("ru_UA","ru");
	  	//2 for sr
	  	map.set("sh_ME","sr");
	  	map.set("sh_RS","sr");
	  	//1 for sk
	  	map.set("sk_SK","sk");
	  	//1 for sl
	  	map.set("sl_SL","sl");
	  	//1 for sv
	  	map.set("sv_SE","sv");
	  	//1 for th 
	  	map.set("th_TH","th");
	  	//1 for tk
	  	map.set("tr_CY","tk");
	  	map.set("tr_TR","tk");
	  	//1 for uk
	  	map.set("uk_UA","uk");
	  	//1 for vi
	  	map.set("vi_VI","vi");
	  	//1 for zh_TW
	  	map.set("zf_TW","zh_TW");
	  	//2 for zh_Cn
	  	map.set("zh_CN","zh_CN");
	  	map.set("zh_HK","zh_CN");

	  	//
	  	map.set("ar","ar");
	  	map.set("bg","bg");
	  	map.set("ca","ca");
	  	map.set("cs","cs");
	  	map.set("da","da");
	  	map.set("de","de");
	  	map.set("el","el");
	  	map.set("en","en");
	  	map.set("es","es");
	  	map.set("et","et");
	  	map.set("fi","fi");
	  	map.set("fr","fr");
	  	map.set("iw","iw");
	  	map.set("hr","hr");
	  	map.set("hu","hu");
	  	map.set("it","it");
	  	map.set("ja","ja");
	  	map.set("ko","ko");
	  	map.set("lt","lt");
	  	map.set("lv","lv");
	  	map.set("nl","nl");
	  	map.set("no","no");
	  	map.set("pl","pl");
	  	map.set("pt","pt");
	  	map.set("ro","ro");
	  	map.set("ru","ru");
	  	map.set("sr","sr");
	  	map.set("sk","sk");
	  	map.set("sl","sl");
	  	map.set("sv","sv");
	  	map.set("th","th");
	  	map.set("tk","tk");
		map.set("uk","uk");
		map.set("vi","vi");
		map.set("zh_TW","zh_TW");
		//
	  	return map;
	     
  }
  var listeners = [];
  var languageMap = initialLanguageMap();
  
  function onLocaleChanged(cb) {
    listeners.forEach(function(listener) {
      listener.fn.apply(listener.scope, [ currentLanguage ]);
    });
    
    if(cb) cb();
  }
  
  function get(id){
    return languageSetting[id];
  }
  
  var languageSetting = {};
  

  var currentLanguage = languageSetting['dev'] = {IDS_DEFAULTMND:'All Measures',IDS_DEFAULTCHARTTITLE:'Title of Chart',IDS_ISNOVALUE:'No value',IDS_BARCHART:'Bar Chart',IDS_COMBINATIONCHART:'Combined Column Line Chart',IDS_DUALBARCHART:'Bar Chart with 2 X-Axes',IDS_DUALCOMBINATIONCHART:'Combined Column Line Chart with 2 Y-Axes',IDS_DUALHORIZONTALCOMBINATIONCHART:'Combined Bar Line Chart with 2 X-Axes',IDS_DUALHORIZONTALLINECHART:'Horizontal Line Chart with 2 X-Axes',IDS_DIUALLINECHART:'Line Chart with 2 Y-Axes',IDS_DUALPERCENTAGESTACKEDBARCHART:'100% Stacked Bar Chart with 2 X-Axes',IDS_DUALSTACKEDVERTICALBARCHART:'Stacked Column Chart with 2 Y-Axes',IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART:'100% Stacked Column Chart with 2 Y-Axes',IDS_DUALSTACKEDBARCHART:'Stacked Bar Chart with 2 X-Axes',IDS_DUALVERTICALBARCHART:'Column Chart with 2 Y-Axes',IDS_HORIZONTALBOXPLOTCHART:'Horizontal Box Plot',IDS_HORIZONTALCOMBINATIONCHART:'Combined Bar Line Chart',IDS_HORIZONTALLINECHART:'Horizontal Line Chart',IDS_HORIZONTALWATERFALLCHART:'Horizontal Waterfall Chart',IDS_LINECHART:'Line Chart',IDS_PERCENTAGESTACKEDBARCHART:'100% Stacked Bar Chart',IDS_PERCENTAGESTACKEDVERTICALBARCHART:'100% Stacked Column Chart',IDS_SPARKLINECHART:'Spark Line Chart (POC)',IDS_STACKEDBARCHART:'Stacked Bar Chart',IDS_STACKEDVERTICALBARCHART:'Stacked Column Chart',IDS_VARIANTBARCHART:'Variant Bar Chart (POC)',IDS_VERTICALBARCHART:'Column Chart',IDS_VERTICALBOXPLOTCHART:'Box Plot',IDS_WATERFALLCHART:'Waterfall Chart',IDS_DONUTCHART:'Donut Chart',IDS_PIECHART:'Pie Chart',IDS_BASEBUBBLECHART:'Base Scatter Chart',IDS_BUBBLECHART:'Bubble Chart',IDS_SCATTERCHART:'Scatter Plot',IDS_BASECHART:'Base Chart',IDS_BASEHORIZONTALCHART:'Base horizontal XY Chart',IDS_BASEVERTICALCHART:'Base Vertical XY Chart',IDS_BASEMULTIPLECHART:'Base Multiple Chart',IDS_BASEMULTIPLEXYCHART:'Base Multiple XY Chart',IDS_BASESINGLECHART:'Base Single Chart',IDS_HEATMAPCHART:'Heat Map',IDS_TREEMAPCHART:'Tree Map',IDS_MULTIBARCHART:'Multiple Bar Chart',IDS_MULTIBUBBLECHART:'Multiple Bubble Chart',IDS_MULTIDONUTCHART:'Multiple Donut Chart',IDS_MULTIDUALBARCHART:'Multiple Bar Chart with 2 X-Axes',IDS_MULTIDUALHORIZONTALLINECHART:'Multiple Horizontal Line Chart with 2 X-Axes',IDS_MULTIDUALLINECHART:'Multiple Line Chart with 2 Y-Axes',IDS_MULTIDUALPERCENTAGESTACKEDBARCHART:'Multiple 100% Stacked Bar Chart with 2 X-Axes',IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART:'Multiple 100% Stacked Column Chart with 2 Y-Axes',IDS_MULTIDUALSTACKEDBARCHART:'Multiple Stacked Bar Chart with 2 X-Axes',IDS_MULTIDUALSTACKEDVERTICALBARCHART:'Multiple Stacked Column Chart with 2 Y-Axes',IDS_MULTIDUALVERTICALBARCHART:'Multiple Column Chart with 2 Y-Axes',IDS_MULTIHORIZONTALLINECHART:'Multiple Horizontal Line Chart',IDS_MULTILINECHART:'Multiple Line Chart',IDS_MULTIPERCENTAGESTACKEDBARCHART:'Multiple 100% Stacked Bar Chart',IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART:'Multiple 100% Stacked Column Chart',IDS_MULTIPIECHART:'Multiple Pie Chart',IDS_MULTISCATTERCHART:'Multiple Scatter Plot',IDS_MULTISTACKEDBARCHART:'Multiple Stacked Bar Chart',IDS_MULTISTACKEDVERTICALBARCHART:'Multiple Stacked Column Chart',IDS_MULTIVERTICALBARCHART:'Multiple Column Chart',IDS_MULTIRADARCHART:'Multiple Radar Chart',IDS_RADARCHART:'Radar Chart',IDS_SCATTERMATRIXCHART:'Scatter Matrix Chart',IDS_TAGCLOUDCHART:'Tag Cloud',IDS_TREEMAPCHART:'Tree Map',IDS_GEOBUBBLE:'Geo Bubble Chart',IDS_GEOPIE:'Geo Pie Chart',IDS_CHOROPLETH:'Geo Choropleth Chart',IDS_MULTIGEOBUBBLE:'Multiple Geo Bubble Chart',IDS_MULTICHOROPLETH:'Multiple Geo Choropleth Chart',IDS_REGIONCOLOR:'Region Color',IDS_PRIMARYVALUES:'Primary Values',IDS_SECONDARYVALUES:'Secondary Values',IDS_AXISLABELS:'Axis Labels',IDS_RECTANGLETITLE:'Rectangle Title',IDS_RECTANGLEWEIGHT:'Rectangle Weight',IDS_RECTANGLECOLOR:'Rectangle Color',IDS_TAGNAME:'Tag Name',IDS_TAGWEIGHT:'Tags Weight',IDS_TAGFAMILY:'Tags Family',IDS_CATEGORYAXIS:'Axis Labels Category',IDS_REGIONSHAPE:'Region Shape',IDS_BUBBLEWIDTH:'Bubble Width',IDS_BUBBLEHEIGHT:'Bubble Height',IDS_RADARAXES:'Radar Axes',  IDS_RADARAXESVALUE:'Radar Axes Values',IDS_PIESECTORCOLORNAME:'Sector Color',IDS_PIESECTORSIZE:'Sector Size',IDS_MAINLABELAXISNAME:'Main Category Axis',IDS_SECONDARYAXISLABELNAME:'Secondary Category Axis',IDS_SELECTABILITY:'selectability',IDS_PRIMARYVALUECOLORPALETTE:'primaryValuesColorPalette',IDS_SECONDARYVALUESCOLORPALETTE:'secondaryValuesColorPalette',IDS_DRAWINGEFFECT:'drawingEffect',IDS_TOOLTIPVISIBLE:'tooltipVisible',IDS_ENABLEROUNDCORNER:'enableRoundCorner',IDS_ANIMATION:'animation',IDS_DATALOADING:'dataLoading',IDS_DATAUPDATING:'dataUpdating',IDS_BAR:'bar',IDS_LINE:'line',IDS_WIDTH:'width',IDS_HOVERLINEVISIBLE:'hoverlineVisible',IDS_MARKER:'marker',IDS_VISIBLE:'visible',IDS_SHAPE:'shape',IDS_SIZE:'size',IDS_HEADERVISIBLE:'headerVisible',IDS_AXISVISIBLE:'axisVisible',IDS_GRIDVISIBLE:'gridVisible',IDS_COLUMNSEQUENCE:'columnSequence',IDS_COLUMNCONFIG:'columnConfig',IDS_STARTCOLUMN:'startColumn',IDS_LABEL:'label',IDS_VALUEFORMAT:'valueFormat',IDS_ENDCOLUMN:'endColumn',IDS_HIGHCOLUMN:'highColumn',IDS_LOWCOLUMN:'lowColumn',IDS_LINECONFIG:'lineConfig',IDS_MARKERS:'markers',IDS_FILLVISIBLE:'fillVisible',IDS_REFINEVISIBLE:'reflineVisible',IDS_MODE:'mode',IDS_TITLE:'title',IDS_TEXT:'text',IDS_GRIDLINE:'gridline',IDS_SHOWFIRSTLINE:'showFirstLine',IDS_TYPE:'type',IDS_FORMAT:'format',IDS_POSITION:'position',IDS_BORDER:'border',IDS_STARTCOLOR:'startcolor',IDS_ENDCOLOR:'endcolor',
      IDS_MEKKOCHART:'Mekko Chart', IDS_HORIZONTALMEKKOCHART: 'Horizontal Mekko Chart', IDS_PERCENTAGEMEKKOCHART: '100% Mekko Chart', IDS_PERCENTAGEHORIZONTALMEKKOCHART: '100% Horizontal Mekko Chart', 
      IDS_AREACHART:'Area Chart', IDS_PERCENTAGEAREACHART: '100% Area Chart', IDS_HORIZONTALAREACHART:'Horizontal Area Chart', IDS_PERCENTAGEHORIZONTALAREACHART: '100% Horizontal Area Chart', IDS_MULTIAREACHART:'Multi Area Chart', IDS_MULTIHORIZONTALAREACHART:'Multi Horizontal Area Chart', IDS_MULTIPERCENTAGEAREACHART:'Multi 100% Area Chart', IDS_MULTIPERCENTAGEHORIZONTALAREACHART:'Multi 100% Horizontal Area Chart',IDS_HORIZONTALSTACKEDWATERFALL:'Horizontal Stacked Waterfall Chart', IDS_STACKEDWATERFALLCHART: 'Stacked Waterfall Chart'};
  var currentId = 'dev', defaultLanguage = 'en';
  var manager = 
    /** @lends sap.viz.lang.langManager */
  {    /**
       * @constructs
       */
      constructor : function(){
        return;
      },
      /**
       * The file paths of language folder. 
       * 
       * @default ["../../../resources/langs/"]
       */
      loadPath : ["../../../resources/langs/"],
       /**
       * Return current applied language Id.
       * 
       * @returns {String}
       */
      current : function() {
          return currentId;
      },
      
      /**
       * Register new language.
       * 
       * @param {Object...}
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      register : function(obj) {
            currentId = obj.id;
          currentLanguage = languageSetting[obj.id] = ObjectUtils.extend(true, languageSetting[obj.id], obj.value);
          return manager;
      },
      
       /**
       * Apply(switch) language.
       * 
       * @param {String}
       *          id the language id
       * @param {Function}
       *          [cb] the call back function. It will be executed after language
       *          is applied successfully with current language as parameter. *
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      apply : function(id, callback) {
        if(id){
          id = languageMap.get(id);
          loadResources(manager.loadPath, 0, id, function(){
            onLocaleChanged(callback);
          }, function(){
            loadResources(manager.loadPath, 0, defaultLanguage, function(){
              onLocaleChanged(callback);
              FunctionUtils.error('Loading language {0} failed.', id);
            }, function(){
               currentId = 'dev', currentLanguage = languageSetting['dev'];
               onLocaleChanged(callback);
               FunctionUtils.error('Loading language {0}, {1} failed.', id, defaultLanguage);
            });
            
          });
        }
         return manager;
      },
      
      /**
       * Get globalization value.
       * 
       * @param {String} 
       *       id of labels
       * 
       * @returns {String}  globalization value
       */
      get: function(ids){
        if(currentLanguage[ids])
          return currentLanguage[ids];
        return languageSetting['dev'][ids];
      },
      
      /**
       * Add a listener which will be executed when current language is changed.
       * 
       * @param {Object}
       *          listener
       * @param {Function}
       *          listener.fn the listener function
       * @param {Object}
       *          listener.scope the "this" object in the listener function
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      addListener : function(listener) {
          listeners.push(listener);
          return manager;
       },
       
       /**
       * Remove the listener.
       * 
       * @param {Object} listener
       *          the listener reference
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      removeListener : function(listener) {
        var index = listeners.indexOf(listener);
        if (index != -1)
          listeners.splice(index, 1);
        return manager;
      }
  };
  
  Locale.addListener({
	  fn:function(locale, callback){
		  manager.apply(locale, callback);
	  },
	  scope:manager
  });
  return manager;
});sap.riv.module(
{
  qname : 'sap.viz.util.Objects',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils) {

  var objects = {
    // copy from sap.viz.base.utils.ObjectUtils.extend
    // in this version, when target is array, just use src replace target
    extend : function() {
      var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;

      // Handle a deep copy situation
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
      }

      // Handle case when target is a string or something (possible in
      // deep
      // copy)
      if (typeof target !== "object" && !TypeUtils.isFunction(target)) {
        target = {};
      }

      // extend jQuery itself if only one argument is passed
      if (length === i) {
        target = this;
        --i;
      }

      for (; i < length; i++) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) !== null) {
          // Extend the base object
          for (name in options) {
            if (options.hasOwnProperty(name)){
              src = target[name];
              copy = options[name];

              // Prevent never-ending loop
              if (target === copy) {
                continue;
              }

              // Recurse if we're merging plain objects or arrays
              // in this version, when target is array, just src replace target
              if (deep && copy && (TypeUtils.isPlainObject(copy))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && TypeUtils.isArray(src) ? src : [];

                } else {
                  clone = src && TypeUtils.isPlainObject(src) ? src : {};
                }
                // Never move original objects, clone them
                target[name] = objects.extend(deep, clone, copy);
                // Don't bring in undefined values
              } else if (copy !== undefined) {
                target[name] = copy;
              }              
            }
          }
        }
      }
      // Return the modified object
      return target;
    },    
    equal: function (objA, objB){
      if(typeof arguments[0] !== typeof arguments[1]){
        return false;
      }
      if (objA === undefined){
        if (objB !== undefined){
          return false;
        }
      }
      if (objA === null){
        if (objB !== null){
          return false;
        }
      }
      if(objA instanceof Array){
        if (!(objB instanceof Array)){
          return false;
        }
        if(objA.length !== objB.length){
          return false;
        }
        var arrayEqualResult = true;
        for(var i = 0; i < objA.length; i++){
          if(typeof objA[i] !== typeof objB[i]){
            return false;
          }
          if(typeof objA[i] === 'boolean' || typeof objA[i] === 'number' || typeof objA[i] === 'string' || typeof objA[i] === 'undefined' || objA[i] === null){
            arrayEqualResult = (objA[i] === objB[i]);
          }
          else if(objA[i] instanceof Object){
            arrayEqualResult = this.equal(objA[i] , objB[i]);
          }
          else{
            return false;
          }
          if(!arrayEqualResult){
            return false;
          }
        }
        return true;
      }
      if(objA instanceof Object && objB instanceof Object && typeof objA !== 'function' && typeof objB !== 'function'){
        if (objB === null || objB instanceof Array){
          return false;
        }
        var attrLenA = 0, attrLenB = 0;
        var attr;
        for(attr in objA){
          if (objA.hasOwnProperty(attr)){
            if(typeof objA[attr] === 'boolean' || typeof objA[attr] === 'number' || typeof objB[attr] === 'string' || typeof objA[attr] === 'undefined' || objA[attr] === null){
              if(objA[attr] !== objB[attr]){
                return false;
              }
            }
            else{
              if(!this.equal(objA[attr], objB[attr])){
                return false;
              }
            }
            attrLenA++;
          }
        }
        for(attr in objB){
         if(objB.hasOwnProperty(attr)){
           attrLenB++;
         }
        }
        if(attrLenA !== attrLenB){
          return false;
        }
        return true;
      }
      return objA === objB;
    }

  };
  return objects;
});sap.riv.module(
{
  qname : 'sap.viz.Constants',
  version : '4.0.0'},
[

],
function Setup() {
  var constants = {
    SAPColorSingleAxis : [ "#748CB2", "#9CC677", "#EACF5E", "#F9AD79",
        "#D16A7C", "#8873A2", "#3A95B3", "#B6D949", "#FDD36C", "#F47958",
        "#A65084", "#0063B1", "#0DA841", "#FCB71D", "#F05620", "#B22D6E",
        "#3C368E", "#8FB2CF", "#95D4AB", "#EAE98F", "#F9BE92", "#EC9A99",
        "#BC98BD", "#1EB7B2", "#73C03C", "#F48323", "#EB271B", "#D9B5CA",
        "#AED1DA", "#DFECB2", "#FCDAB0", "#F5BCB4" ],

    SAPColorDualAxis1 : [ "#8FBADD", "#B8D4E9", "#7AAED6", '#A3C7E3',
        '#3D88C4', '#66A1D0', '#297CBE', '#5295CA', '#005BA3', '#146FB7',
        '#005395', '#0063B1' ],

    SAPColorDualAxis2 : [ "#F6A09B", "#F9C3C0", "#F58E88", '#F8B1AD',
        '#F05B52', '#F37D76', '#EE4A40', '#F16C64', '#D92419', '#ED382D',
        '#C52117', '#EB271B' ]
  };

  constants.SAPColor = constants.SAPColorSingleAxis;

  return constants;
});sap.riv.module(
{
  qname : 'sap.viz.data.description.DataContainer',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
}
],
 function Setup(ObjUtils){
   
   var DataContainer = function(uid){
     this._uId = uid; 
     this._isFake = false;
     this._infos = null;
   };
        
  
   DataContainer.prototype.getId = function(){
           return this._uId;
     };
     
     DataContainer.prototype.fake = function(_){
       if (!arguments.length){
           return this._isFake;
       }
       
       this._isFake = _;
     };
       
     DataContainer.prototype.infos = function(_){
         if (!arguments.length){
             return this._infos;
         }
           
         this._infos = _;
     };

     return DataContainer;
 });sap.riv.module(
{
  qname : 'sap.viz.data.description.DimensionLabels',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.description.DataContainer',
  version : '4.0.0'
}
],
function Setup(ObjUtils, DataContainer){
   
  
     var DimensionLabels = ObjUtils.derive(DataContainer, {
      
       /**
          * @name sap.viz.data.description.DimensionLabels
          * @param   uid    identifier of dimension labels, usually name 
        */
      
       constructor : function ( uid, type, values ) {
           this._type = type;
           this._values = values;
       },
       
       getValues : function(){
           return this._values;
       },
         
       getType : function(){
           return this._type;
       }
       
    });
     
     
     return DimensionLabels;
  });sap.riv.module(
{
  qname : 'sap.viz.data.feed.feed',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
 function Setup(FunctionUtils){
   
   return function(feedId, feedName, type, min, max, aaIndex, acceptMND, mgIndex, maxStackedDims){
     
         var _feedId = feedId;
         var _feedName = feedName;
         var _type = type;
         var _min = min;
         var _max = max;
         var _aaIndex = aaIndex;
         var _acceptMND = acceptMND;
         var _mgIndex = mgIndex;
         var _maxStackedDims = maxStackedDims;
         
         var _data = [];
     
       function feed() {
         return feed;
       }
       
       feed.feedId = function(_){  
         if (!arguments.length){
             return _feedId;
         }
        
         _feedId = _;
         
         return feed;
       };
       
       feed.feedName = function(_){
         if (!arguments.length){
             return _feedName;
         }
         
         _feedName = _; 
         
         return feed;
       };
       
       feed.type = function(_){
         if (!arguments.length){
             return _type;
         }
         
        _type = _;
        
        return feed;
       };
       
       feed.min = function(_){    
         if (!arguments.length){
            return _min;     
         }
     
         _min =  _;
         return feed;
       };
       
       feed.max = function(_){
         if (!arguments.length){
             return _max;
         }
         
         
         _max = _;
         
         return feed; 
       };
       
       feed.analysisAxisIndex = function(_){
         if (!arguments.length){
             return _aaIndex;  
         }
         
         
         _aaIndex = _;
         
         return feed;
       };
      
       feed.measureGroupIndex = function(_){
         if (!arguments.length){
             return _mgIndex;
         }
         
         _mgIndex = _;
         
         return feed;
       };
       
       feed.acceptMND = function(_){
         if (!arguments.length){
             return _acceptMND;  
         }
         
         
         _acceptMND = _;
         
         return feed;
       };
       
       feed.maxStackedDims = function(_){
         if (!arguments.length){
             return _maxStackedDims;
         }
         
         _maxStackedDims = _;
         
         return feed;
       };
       
       feed.data = function(_){
         if (!arguments.length){
             return _data;
         }
         
         _data = _;
         
         return feed;
       };
       
       
       feed.addData = function(_){
         _data.push(_);
         return feed;
       };
       
       feed.getMeasureNames = function(){
         
         var mgIndex  =  _mgIndex - 1;
         var measureNames = [];
         for(var i = 0; i < _data.length; i++){
             measureNames.push({'val':_data[i]['name'],'ctx': {'mg': mgIndex, 'mi': i}});
         }
         
         return measureNames;
       };
       
         feed.getMeasureValues = function(){
         var values = [];
         if(_data.length > 0){
            return _data[0].getMeasureValues();
         }
         
         return values;
           
       };
       
         feed.getMeasureCount = function(){
            return _data.length;
       };
     
       /**
        * @returns check if the feed has been feeded MND
        */
       feed.hasMNDFeeded = function(){
          
          var data = feed.data();
          for(var i = 0; i < data.length; i++){
            if(data[i].getType() === "measureNamesDimension"){
               return true;
            }
          }
          
          return false;
       };
       
       feed.hasFeeded = function(){
          return feed.data().length > 0 ?  true : false;
       };
       
       feed.getIndex = function(){
          return feed.analysisAxisIndex() ? feed.analysisAxisIndex() : feed.measureGroupIndex();
       };
       
       feed.getDataCount = function(){
         if(feed.type() === "Dimension"){
            return feed.data().length;
         }
         else{
            return feed.data().length > 0 ? feed.data()[0].getMeasureValues().length : 0; 
         }
          
       };
       
     return feed;
   };
  
 });sap.riv.module(
{
  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.data.feed.feed',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.description.DimensionLabels',
  version : '4.0.0'
}
],
 function Setup(Feed, FunctionUtils, TypeUtils, DimensionLabels){
   
   return function(feedDefs, crossTableDS, feedingInfo){
    
     var FEED_D = 'Dimension';
     var FEED_M = 'Measure';
     
     var FEEDID = "feedId";
     
     var BINDTO = "binding";
     var TYPE = "type";
     var INDEX = "index";
     
     var _aaMap = []; // analysis axis index to feed map, _aamap[0] point to feed of axis 1 
     var _mgMap = []; // measure group index to feed map, _mgMap[0] point to feed of measure value group 1
     var _feeds = [];
     var _feedsMap = {};
     
     var _aaBindingInfo = [];
     
       function feeder() {
     
           return feeder;
       }
       
       feeder.init = function(){
         initFeeds(feedDefs);
         
         //TODO separate validation and init
         if(crossTableDS){
           if(feedingInfo){
             manualFeed(crossTableDS, feedingInfo);
           }else{
             autoFeed(crossTableDS);
           }
           
           feeder.checkValid();
         }
       };
       
       /**
        * @returns {feed}
        */
       feeder.getFeeds = function(){
         return _feeds;
       };
       
       /**
        * @param feedId
        *        feed id
        *        
        * @returns {feed}
        *           undefined if no feed matched
        * 
        */
       feeder.findFeed = function(feedId){
           return _feedsMap[feedId];
       };
       
      
       feeder.getAnalysisAxisIndex = function(feed){
        
         for(var i = 0; i < _aaMap.length; i++){
           if(_aaMap[i] === feed){
              return i;
           }
         }
         
       };
       
       feeder.getMeasureValuesGroupIndex = function(feed){
          
         for(var i = 0; i < _mgMap.length; i++){
           if(_mgMap[i] === feed){
              return i;
           }
         }
         
       };
       
       /**
        * TODO: add description
        */
       feeder.getMeasureValuesGroupFeeds = function(){
        
         return _mgMap;
       };
       
       /**
        * Check if meta data and raw data are matched. If not match, throw exception 
        */
       feeder.checkValid = function(){
         for(var i = 0; i < _feeds.length; i++){
           var feed = _feeds[i];
           var dataLength;
           if(feed.type() === "Dimension"){
            dataLength = feed.getDataCount();
            if(dataLength < feed.min() || (feed.max() !== Number.POSITIVE_INFINITY && dataLength > feed.max())){ 
               FunctionUtils.error(feed.feedId() + ": does not meet min or max number of feed definition");
            }
                
           }else if(feed.type() === "Measure"){
             dataLength = feed.getDataCount();
             if(dataLength < feed.min() || (feed.max() !== Number.POSITIVE_INFINITY && dataLength > feed.max())){ 
                FunctionUtils.error(feed.feedId() + ": does not meet min or max number of feed definition");
             }
             
           }else{
             FunctionUtils.error(feed.feedId() + ": wrong feed type");
           }
             
           
         }
         
        
       };
       
       feeder.getBindingInfo = function(){
        
         return _aaBindingInfo;
       };
       
       /**
        * TODO: add desc
        */
       function initFeeds(feedDefinitions){
           if( TypeUtils.isArray(feedDefinitions) ){
             
             var dimensonNumber  = 0;
             
             for(var i = 0; i < feedDefinitions.length; i++){
               
               var feedType = feedDefinitions[i]['type'];
               var aaIndex = feedDefinitions[i]['aaIndex'];
               var feedId = feedDefinitions[i]['id'];
                 
               if(feedType !== FEED_D && feedType !== FEED_M ){
                 FunctionUtils.error('wrong feed type in feed definition: ' + feedDefinitions[i]['id']); 
               }
               
                if(feedDefinitions[i]['type'] === FEED_D){
                 if(feedDefinitions[i]['aaIndex'] <= 0){
                    FunctionUtils.error('wrong analysis axis index in feed definition: ' + feedDefinitions[i]['id']);
                 }
                 
                 dimensonNumber++;
               }
                
                if(feedDefinitions[i]['type'] === FEED_M){
                 if(feedDefinitions[i]['mgIndex'] <= 0){
                    FunctionUtils.error('wrong  measure axis index in feed definition: ' + feedDefinitions[i]['id']);
                 }
                 
               }
              
               
               var arrayLength = _feeds.push(Feed(feedId, feedDefinitions[i]['name'],
                                         feedType, feedDefinitions[i]['min'],
                                         feedDefinitions[i]['max'], aaIndex,
                                         feedDefinitions[i]['acceptMND'], feedDefinitions[i]['mgIndex'],
                                         feedDefinitions[i]['maxStackedDims']));
               
               _feedsMap[feedId] = _feeds[arrayLength - 1];
               
               }
             
             for(i = 0; i < dimensonNumber; i++){
               _aaBindingInfo[i] = false; 
             }
           }
           
       }
       
             
       function autoFeed(crosstableDS){
         var axes = crosstableDS.getAnalysisAxisCount();
         var feed;
         for(var i = 0; i < axes; i++){
           feed = searchFeed(_feeds, FEED_D, i + 1);
           if(feed){
              var axis = crosstableDS.getAnalysisAxisByIdx(i);
              if(TypeUtils.isExist(feed.maxStackedDims()) && axis.getDimensionLabels().length > feed.maxStackedDims()){
                 FunctionUtils.error("Invalid Feeding: exceed max stacked dimension number " + feed.feedId() + " feed");
              }
             
              _aaMap[i] = feed;
              _aaBindingInfo[i] = true;
              feed.addData(axis);
           }
         }
         
         var mvgs = crosstableDS.getMeasureValuesGroupCount();
         for(i = 0; i < mvgs; i++){
           feed = searchFeed(_feeds, FEED_M, i + 1);
           if(feed){
              _mgMap[i] = feed;
              feed.addData(crosstableDS.getMeasureValuesGroupByIdx(i));
           }
           
         }
       }
       
       function searchFeed(feeds, type, index){
          for(var i = 0; i < feeds.length; i++){
            if(feeds[i].type() === type && feeds[i].getIndex() === index){
               return feeds[i];
            }
          }
      
          return null;
       }
       
       function manualFeed(crosstableDS, feedList){
         var dataLength;
         for(var i = 0; i < feedList.length; i++){
           var feeding = feedList[i];
           var feedId = feeding[FEEDID];
           if(!feedId){
              FunctionUtils.error("Invalid Feeding: no feed id");
           }
              
           var feed = _feedsMap[feedId];
           if(!feed){
              FunctionUtils.error("Invalid Feeding: no " + feedId + " feed");
           }
           
           var bindings = feeding[BINDTO];
           for(var j = 0; j < bindings.length; j++){
             var type = bindings[j][TYPE];
             var index = bindings[j][INDEX];
             
             if( type === "analysisAxis"){
               var aa =  crosstableDS.getAnalysisAxisByIdx(index - 1);
               if(!aa){
                  FunctionUtils.error("could not find axis " + index +  " in data set" + feedId + " feed");
               }
               
               if(TypeUtils.isExist(feed.maxStackedDims()) && aa.getDimensionLabels().length > feed.maxStackedDims()){
                  FunctionUtils.error("Invalid Feeding: exceed max stacked dimension number " + feedId + " feed");
               }
               
               dataLength = feed.getDataCount();
               if(feed.max() !== Number.POSITIVE_INFINITY && dataLength >= feed.max()){
                  FunctionUtils.error(feedId + " feed could not accept more data containers");
               }
               
               feed.addData(aa);  
               _aaMap[index - 1] = feed;
               _aaBindingInfo[feed.getIndex() - 1] = true;
               
             }else if(type === "measureValuesGroup"){
               
               var mvg = crosstableDS.getMeasureValuesGroupByIdx(index - 1);
               if(!mvg){
                  FunctionUtils.error("could not find measure values group " + index +  " in data set" + feedId + " feed");
               }
               
               dataLength = feed.getDataCount();
               if(feed.max() !== Number.POSITIVE_INFINITY && dataLength >= feed.max()){
                  FunctionUtils.error(feedId + " feed could not accept more data containers");
               }
               
               feed.addData(mvg);
               _mgMap[index-1] = feed;
               
             }else if(type === "measureNamesDimension"){
               if(feed.acceptMND() < 0){
                  FunctionUtils.error("could not accpet MeasureNamesDimension " + feedId + " feed");
               }
               
               dataLength = feed.getDataCount();
               if(feed.max() !== Number.POSITIVE_INFINITY && dataLength >= feed.max()){
                  FunctionUtils.error(feedId + " feed could not accept more data containers");
               }
               
               feed.addData(new DimensionLabels("", "measureNamesDimension", ""));
               
             }else{
               FunctionUtils.error("Invalid Binding");
             }
           }
           
         }
         
       }
       
       feeder.init();
       
       return feeder;
   };
   
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(feeder, langManager, Constants) {
  var tooltipDataHandler = function() {
    var _buffer = [];

    var my = {};

    var defaultString = langManager.get('IDS_ISNOVALUE');

    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };

    /**
     * 
     * @param data
     * @param seriesData
     * @param aai1
     * @param colorPalette
     * @param shapePalette
     * @param postProcess
     *          {Function} you can round the data or other thing.
     * @returns TOOD: add desc
     */
    my.generateTooltipData = function(data, seriesData, aai1, colorPalette,
        shapePalette, postProcess) {

      var parseFeedsData = function(data) {
        var barGroupValue;
        var isStacked = false;
        if (seriesData[aai1][0] !== undefined && seriesData[aai1][0].length > 0) {
          barGroupValue = d3.merge([ seriesData[aai1][0], seriesData[aai1][1] ]);
          isStacked = true;
        } else {
          barGroupValue = seriesData[aai1];
        }

        var tooltipData = {
          'body' : [],
          'footer' : []
        };
        var valueLength = barGroupValue.length;
        var isDual = false;
        var division = 0;
        var mvgData = [data.getMeasureValuesGroupDataByIdx(0), data.getMeasureValuesGroupDataByIdx(1)];
        var aaData = [data.getAnalysisAxisDataByIdx(0), data.getAnalysisAxisDataByIdx(1)];
        var MNDHandler = mndHandler(aaData);
        
        if (mvgData[0] && mvgData[1]) {
          isDual = true;
          division = mvgData[0].values.length;
        }
        var isMNDbeforeCate = false;
        var MNDLength;
        var i = 0, j = 0, k = 0,len;
        var measureIndex;
        var body;
        var valueIndex;
        var itemLabel;
        var item;
        var footer;

        if (!MNDHandler.hasMNDonCate && !MNDHandler.hasMNDonColor) {
          // MND does not feed on either category or color

          if (aaData[1]) {
            measureIndex = 0;
            if (mvgData[0]) {
              for ( i = 0; i < mvgData[0].values.length; ++i) {
                body = {
                  'name' : handleNull(mvgData[0].values[i].col),
                  'val' : []
                };
                for ( j = 0, len = mvgData[0].values[i].rows.length; j < len; ++j) {
                  valueIndex = measureIndex * len + j;
                  itemLabel = [];
                  for ( k = 0; k < aaData[1].values.length; ++k) {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                  item = {
                    'shape' : shapePalette[valueIndex % shapePalette.length],
                    'color' : colorPalette[valueIndex % colorPalette.length],
                    'label' : itemLabel,
                    'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                        : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                            : postProcess(barGroupValue[valueIndex].val),
                     'valueAxis' : 0
                  };
                  body.val.push(item);
                }
                tooltipData.body.push(body);
                ++measureIndex;
              }
            }
            // for dual chart
            if (mvgData[1]) {
              for ( i = 0; i < mvgData[1].values.length; ++i) {
                body = {
                  'name' : handleNull(mvgData[1].values[i].col),
                  'val' : []
                };
                for ( j = 0, len = mvgData[1].values[i].rows.length; j < len; ++j) {
                  valueIndex = measureIndex * len + j;
                  itemLabel = [];
                  for ( k = 0; k < aaData[1].values.length; ++k) {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                  item = {
                    'shape' : shapePalette[valueIndex % shapePalette.length],
                    'color' : colorPalette[valueIndex % colorPalette.length],
                    'label' : itemLabel,
                    'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                        : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                            : postProcess(barGroupValue[valueIndex].val),
                     'valueAxis' : 1
                  };
                  body.val.push(item);
                }
                tooltipData.body.push(body);
                ++measureIndex;
              }
            }
          } else {
            body = {
              'name' : handleNull(mvgData[0].values[0].col),
              'val' : []
            };
            item = {
              'shape' : shapePalette[0 % shapePalette.length],
              'color' : colorPalette[0 % colorPalette.length],
              'label' : null,
              'value' : barGroupValue[0].val === ' ' ? defaultString
                  : postProcess === undefined ? handleNull(barGroupValue[0].val)
                      : postProcess(barGroupValue[0].val),
               'valueAxis' : 0
            };
            body.val.push(item);
            tooltipData.body.push(body);
          }
          for (i = 0, len = aaData[0].values.length; i < len; ++i) {
            footer = {
              'label' : aaData[0].values[i].col,
              'value' : aaData[0].values[i].rows[aai1]
            };
            tooltipData.footer.unshift(footer);
          }

        } else if (MNDHandler.hasMNDonColor) {
          // MND feeds on color
          for (i = 0; i < aaData[1].values.length; ++i) {
            if (aaData[1].values[i].type === 'MND') {
              MNDLength = aaData[1].values[i].rows.length;
              if (i === 0) {
                isMNDbeforeCate = true;
              }
              break;
            }
          }

          measureIndex = 0;
          var colorIndex;
          if (mvgData[0]) {
            for (i = 0; i < mvgData[0].values.length; ++i) {
              body = {
                'name' : handleNull(mvgData[0].values[i].col),
                'val' : []
              };
              for (j = 0, len = mvgData[0].values[i].rows.length; j < len; ++j) {
                colorIndex = undefined;
                if (isMNDbeforeCate){
                  valueIndex = measureIndex * len + j;
                }
                else if (!isStacked || !isDual){
                  valueIndex = j * MNDLength + measureIndex;
                }
                else {
                  valueIndex = j * division + measureIndex;
                  colorIndex = j * MNDLength + measureIndex;
                }
                itemLabel = [];
                for (k = 0; k < aaData[1].values.length; ++k) {
                  if (aaData[1].values[k].type !== 'MND') {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                }
                item = {
                  'shape' : colorIndex !== undefined ? shapePalette[colorIndex  % shapePalette.length] 
                : shapePalette[valueIndex % shapePalette.length],
                  'color' : colorIndex !== undefined ? colorPalette[colorIndex % colorPalette.length] 
                  : colorPalette[valueIndex % colorPalette.length],
                  'label' : itemLabel,
                  'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                      : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                          : postProcess(barGroupValue[valueIndex].val),
                   'valueAxis' : 0
                };
                body.val.push(item);
              }
              tooltipData.body.push(body);
              ++measureIndex;
            }
          }
          // for dual chart
          if (mvgData[1]) {
            for (i = 0; i < mvgData[1].values.length; ++i) {
              body = {
                'name' : handleNull(mvgData[1].values[i].col),
                'val' : []
              };
              for (j = 0, len = mvgData[1].values[i].rows.length; j < len; ++j) {
                colorIndex = undefined;
                if (isMNDbeforeCate){
                  valueIndex = measureIndex * len + j;
                }
                else if (!isStacked || !isDual){
                  valueIndex = j * MNDLength + measureIndex;
                }
                else {
                  valueIndex = j * (MNDLength - division) + measureIndex - division + parseInt(valueLength * division / MNDLength, 10);
                  colorIndex = j * MNDLength + measureIndex;
                }

                itemLabel = [];
                for (k = 0; k < aaData[1].values.length; ++k) {
                  if (aaData[1].values[k].type !== 'MND') {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                }
                item = {
                  'shape' : colorIndex !== undefined ? shapePalette[colorIndex % shapePalette.length] 
                : shapePalette[valueIndex  % shapePalette.length],
                  'color' : colorIndex !== undefined ? colorPalette[colorIndex % colorPalette.length] 
                  : colorPalette[valueIndex % colorPalette.length],
                  'label' : itemLabel,
                  'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                      : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                          : postProcess(barGroupValue[valueIndex].val),
                   'valueAxis' : 1
                };
                body.val.push(item);
              }
              tooltipData.body.push(body);
              ++measureIndex;
            }
          }
          for (i = 0, len = aaData[0].values.length; i < len; ++i) {
            footer = {
              'label' : aaData[0].values[i].col,
              'value' : aaData[0].values[i].rows[aai1]
            };
            tooltipData.footer.unshift(footer);
          }

        } else {
          // MND feeds on category axis
          var bodyName = null;
          var categoryLength;
          for (i = 0; i < aaData[0].values.length; ++i) {
            if (aaData[0].values[i].type === 'MND') {
              MNDLength = aaData[0].values[i].rows.length;
              var groupCount = 0;
              if (seriesData.length !== undefined) {
                groupCount = seriesData.length;
              } else {
                for (j in seriesData) {
                  if (seriesData.hasOwnProperty(j)){
                    ++groupCount;
                  }
                }
              }

              categoryLength = groupCount / MNDLength;
              if (i === 0) {
                isMNDbeforeCate = true;
                bodyName = aaData[0].values[i].rows[parseInt(aai1 / categoryLength, 10)];
              } else {
                // isMNDbeforeCate = false;
                bodyName = aaData[0].values[i].rows[aai1 % MNDLength];
              }
              break;
            }
          }
          body = {
            'name' : bodyName,
            'val' : []
          };

          if (aaData[1]) {
            // there exists color feeds.
            // var measureIndex = 0;
            if (mvgData[0]) {
              for (j = 0, len = mvgData[0].values[0].rows.length; j < len; ++j) {
                valueIndex = j;
                itemLabel = [];
                for (k = 0; k < aaData[1].values.length; ++k) {
                  itemLabel.push(aaData[1].values[k].rows[j]);
                }
                item = {
                  'shape' : shapePalette[valueIndex % shapePalette.length],
                  'color' : colorPalette[valueIndex % colorPalette.length],
                  'label' : itemLabel,
                  'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                      : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                          : postProcess(barGroupValue[valueIndex].val),
                   'valueAxis' : 0
                };
                body.val.push(item);
              }
            }
          } else {
            // otherwise...
            item = {
              'shape' : shapePalette[0 % shapePalette.length],
              'color' : colorPalette[0 % colorPalette.length],
              'label' : null,
              'value' : barGroupValue[0].val === ' ' ? defaultString
                  : postProcess === undefined ? handleNull(barGroupValue[0].val)
                      : postProcess(barGroupValue[0].val),
               'valueAxis' : 0
            };
            body.val.push(item);
          }
          tooltipData.body.push(body);
          for (i = 0, len = aaData[0].values.length; i < len; ++i) {
            if (aaData[0].values[i].type !== 'MND') {
              footer = {
                'label' : aaData[0].values[i].col,
                'value' : null
              };
              if (isMNDbeforeCate) {
                footer.value = aaData[0].values[i].rows[aai1  % categoryLength];
              } else {
                footer.value = aaData[0].values[i].rows[parseInt(aai1 / MNDLength, 10)];
              }
              tooltipData.footer.unshift(footer);
            }
          }

        }
        return tooltipData;
      };

      var help = function(index) {
        if (_buffer[index] === undefined) {
          _buffer[index] = parseFeedsData(data);
        }
        return _buffer[index];
      };

      return help(aai1);
    };
    return my;
  };

  function mndHandler(aaData) {
    var hasMNDonCate = false;
    var j, len;
    if (aaData[0]){
      for (j = 0, len = aaData[0].values.length; j < len; ++j){
        if (aaData[0].values[j].type && aaData[0].values[j].type === 'MND'){
          hasMNDonCate = true;
        }
      }
    }
     var hasMNDonColor = false;
    if (!hasMNDonCate) {
      if (aaData[1]){
        for (j = 0, len = aaData[1].values.length; j < len; ++j){
          if (aaData[1].values[j].type && aaData[1].values[j].type === 'MND'){
            hasMNDonColor = true;
          }
        }
      }
    }
    return {
      hasMNDonCate : hasMNDonCate,
      hasMNDonColor : hasMNDonColor
    };
  }

  tooltipDataHandler.formatTooltipData = function(data) {
    var tooltipEventData = {
      name : Constants.Module.Event.TooltipShow.name,
      data : data
    };
    return tooltipEventData;
  };

  tooltipDataHandler.dataTransform = function(obj) {
    var data1 = obj['MG1'];
    var data2 = obj['MG2'];

    var transferredDataSet = [];
    var i, j;
    if (obj.hasMND && obj.MNDOnColor && obj.MNDInner) {
      var mg1mnum = 0, mg2mnum = 0, colorAxisDataNum = 0;
      if (obj['MG1Number']) {
        mg1mnum = obj['MG1Number'];
        colorAxisDataNum = data1.length / mg1mnum;
      }
      if (obj['MG2Number']) {
        mg2mnum = obj['MG2Number'];
        colorAxisDataNum = data2.length / mg2mnum;
      }

      for (i = 0; i < colorAxisDataNum; i++) {
        for (j = 0; j < mg1mnum; j++) {
          transferredDataSet.push(data1[i * mg1mnum + j]);
        }
        for (j = 0; j < mg2mnum; j++) {
          transferredDataSet.push(data2[i * mg2mnum + j]);
        }
      }
    } else {
      if (data1) {
        for (i = 0; i < data1.length; i++) {
          transferredDataSet.push(data1[i]);
        }
      }
      if (data2) {
        for (i = 0; i < data2.length; i++) {
          transferredDataSet.push(data2[i]);
        }
      }
    }

    var stackedBarGroup = [];
    // the number of bar in each group
    var barGroupNumber;
    if (data1.length !== 0) {
      barGroupNumber = data1[0].length;
    } else {
      barGroupNumber = data2[0].length;
    }
    for ( j = 0; j < barGroupNumber; j++) {
      var ds = [];
      for (i = 0; i < transferredDataSet.length; i++) {
        ds.push(transferredDataSet[i][j]);
      }
      stackedBarGroup.push(ds);
    }

    return stackedBarGroup;
  };

  return tooltipDataHandler;
});sap.riv.module(
{
  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils) {
  var NumberUtils = {
    isNoValue: function(n) {
      return TypeUtils.isNaN(n);
    }
  };
  return NumberUtils;
});sap.riv.module(
{
  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'},
[

],

function Setup() {
    
    var Scaler = {
        /**
         * @param _scale
         *        d3 quantitative scale
         *                
         * @param _roughTickNum
         *        rough tick number
         *                
         * @param _accurateTickNum
         *        accurate tick number
         *
         * @returns d3 quantitative scale which can be divided by ticks perfectly
         */
        perfect : function(_scale, _roughTickNum, _accurateTickNum)
        {
            //the function may change the domain, but never change the range.
            var const_minTickNum = 2;
            var const_extendNum = 100;

            var domainArray = _scale.domain();

            var originalDomainBegin = domainArray[0];
            var originalDomainEnd = domainArray[domainArray.length-1];

            //if the domain is [0,0], we change it to [0,100]
            //if the domain is [-x,-x], we change it to [-x,0]
            //if the domain is [x,x], we change it to [x,0]
            //we do this in modules
            
            var roughTickNum = -1;
            var accurateTickNum = -1;

            if(!_accurateTickNum || _accurateTickNum < const_minTickNum)
            {
                if(!_roughTickNum || _roughTickNum < const_minTickNum)
                {
                    var rangeArray = _scale.range();
                    var rangeLen = Math.abs(rangeArray[0] - rangeArray[rangeArray.length-1]);
                    if(rangeLen > 10)
                    {
                        roughTickNum = const_minTickNum + Math.round(rangeLen/100);
                    }
                    else
                    {
                        roughTickNum = const_minTickNum;
                    }
                }
                else
                {
                    roughTickNum = _roughTickNum;
                }
            }
            else
            {
                accurateTickNum = _accurateTickNum;
            }

            var qScale = _scale.nice();
            if(accurateTickNum < 0)
            {
                var ticks = qScale.ticks(roughTickNum);
                
                var adjustDomain = true;
                var distance;
                if(ticks.length == 0)
                {
                    adjustDomain = false;
                }
                else if(ticks.length > 1)
                {
                    distance = ticks[1] - ticks[0];//>0
                }
                else//ticks.length==1
                {
                    var beginDis = Math.abs(domainArray[0] - ticks[0]);//>0
                    var endDis = Math.abs(domainArray[domainArray.length - 1] - ticks[0]);//>0
                    if(beginDis > endDis)
                    {
                        distance = beginDis;
                    }
                    else
                    {
                        distance = endDis;
                    }
                }
                
                var realTickNum = const_minTickNum;
                if(adjustDomain)
                {
                    realTickNum = ticks.length;
                    if(domainArray[0] < domainArray[1])
                    {
                        if(ticks[0] != domainArray[0])
                        {
                            domainArray[0] = ticks[0] - distance;
                            realTickNum++;
                        }

                        if(ticks[ticks.length -1] != domainArray[domainArray.length - 1])
                        {
                            domainArray[domainArray.length - 1] = ticks[ticks.length - 1] + distance;
                            realTickNum++;
                        }
                    }
                    else
                    {
                        if(ticks[0] != domainArray[domainArray.length - 1])
                        {
                            domainArray[domainArray.length - 1] = ticks[0] - distance;
                            realTickNum++;
                        }

                        if(ticks[ticks.length -1] != domainArray[0])
                        {
                            domainArray[0] = ticks[ticks.length - 1] + distance;
                            realTickNum++;
                        }
                    }
                }

                qScale.tickNum = realTickNum;
                qScale.distance = distance;
                qScale.tickHint = realTickNum - 1;

                //to nice the domainArray, avoid the domain contains 0.00060000001
                domainArray[0] = parseFloat(domainArray[0].toFixed(8));
                domainArray[domainArray.length - 1] = parseFloat(domainArray[domainArray.length - 1].toFixed(8));
                qScale.domain(domainArray);
                
            }
            else
            {
                //accurateTickNum:
                //1. use it as roughTickNum. 
                //2. adjust the ticNum or not
                this.perfect(qScale, accurateTickNum);
                if(qScale.tickNum > accurateTickNum)
                {
                    //try to make sure qScale.tickNum < accurateTickNum
                    var tempNum = accurateTickNum;
                    for(;tempNum >= const_minTickNum;)
                    {
                        tempNum--;
                        this.perfect(qScale, tempNum);
                        if(qScale.tickNum <= accurateTickNum)
                        {
                            break;
                        }
                    }
                }
                
                //adjust the domain
                if(qScale.tickNum < accurateTickNum)
                {
                    var tickNumToAdd = (accurateTickNum - qScale.tickNum);
                    var domainArray = qScale.domain();
                    //var originalDomainBegin 
                    //var originalDomainEnd

                    for(;tickNumToAdd > 0;)
                    {
                        if(domainArray[0] < domainArray[1])
                        {
                            if(Math.abs(domainArray[1] - originalDomainEnd) > Math.abs(originalDomainBegin - domainArray[0]))
                            {
                                domainArray[0] -= qScale.distance;
                            }
                            else
                            {
                                domainArray[1] += qScale.distance;
                            }
                            tickNumToAdd--;
                            qScale.tickNum++;
                        }
                        else
                        {
                            if(Math.abs(domainArray[1] - originalDomainEnd) > Math.abs(originalDomainBegin - domainArray[0]))
                            {
                                domainArray[0] += qScale.distance;
                            }
                            else
                            {
                                domainArray[1] -= qScale.distance;
                            }
                            tickNumToAdd--;
                            qScale.tickNum++;
                        }
                    }
                    
                    qScale.tickHint = qScale.tickNum - 1;
                    //to nice the domainArray, avoid the domain contains 0.00060000001
                    domainArray[0] = parseFloat(domainArray[0].toFixed(8));
                    domainArray[domainArray.length - 1] = parseFloat(domainArray[domainArray.length - 1].toFixed(8));
                    qScale.domain(domainArray);
                    
                }
            }

            return qScale;
        },
        
        /**
         * @param _scaleA
         *        d3 linear scale
         *                
         * @param _scaleB
         *        d3 linear scale
         */
        perfectDual : function(_scaleA, _scaleB) {

            this.perfect(_scaleA);
            this.perfect(_scaleB);
            
            var domainArrayA = _scaleA.domain();
            var domainArrayB = _scaleB.domain();

            var rangeArrayA = _scaleA.range();
            var rangeArrayB = _scaleB.range();

            if( (domainArrayA[0] > domainArrayA[domainArrayA.length-1]
                && domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                ||
                (domainArrayA[0] < domainArrayA[domainArrayA.length-1]
                && domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                ||
                (domainArrayA[0] < 0
                && domainArrayA[domainArrayA.length-1] < 0)
                ||
                (domainArrayB[0] < 0
                && domainArrayB[domainArrayB.length-1] < 0)
                ||
                (domainArrayA[0] > 0
                && domainArrayA[domainArrayA.length-1] > 0)
                ||
                (domainArrayB[0] > 0
                && domainArrayB[domainArrayB.length-1] > 0)
                || 
                ( Math.abs(rangeArrayA[0] - rangeArrayA[rangeArrayA.length-1])
                != Math.abs(rangeArrayB[0] - rangeArrayB[rangeArrayB.length-1]) )
              )
            {
                //we do not need to do anythings to support this "dual"
                return;
            }

            //now make sure 
            //1. same tickNum before 0
            //2. same tickNum after 0
            var positiveTickNumA = 0;
            var negativeTickNumA = 0;

            var positiveTickNumB = 0;
            var negativeTickNumB = 0;

            var tickNumA = _scaleA.tickNum; //tickNumA >= const_minTickNum
            var tickNumB = _scaleB.tickNum; //tickNumB >= const_minTickNum

            var intervalA = (domainArrayA[domainArrayA.length-1] - domainArrayA[0])/(tickNumA-1);
            intervalA = parseFloat(intervalA.toFixed(8));

            for(var i = 0; i < tickNumA; i++)
            {
                var tickValue = domainArrayA[0] + i * intervalA;
                if(tickValue > 0)
                {
                    positiveTickNumA++;
                }
                else if(tickValue < 0)
                {
                    negativeTickNumA++;
                }
            }

            var intervalB = (domainArrayB[domainArrayB.length-1] - domainArrayB[0])/(tickNumB-1);
            intervalB = parseFloat(intervalB.toFixed(8));

            for(var i = 0; i < tickNumB; i++)
            {
                var tickValue = domainArrayB[0] + i * intervalB;
                if(tickValue > 0)
                {
                    positiveTickNumB++;
                }
                else if(tickValue < 0)
                {
                    negativeTickNumB++;
                }
            }

            if(positiveTickNumA > positiveTickNumB)
            {
                var moreInterNum = positiveTickNumA - positiveTickNumB;
                if(domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[domainArrayB.length-1] += (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
                else if(domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[0] += (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
            }
            else if(positiveTickNumA < positiveTickNumB)
            {
                var moreInterNum = positiveTickNumB - positiveTickNumA;
                if(domainArrayA[0] < domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[domainArrayA.length-1] += (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
                else if(domainArrayA[0] > domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[0] += (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
            }

            //negative values
            if(negativeTickNumA > negativeTickNumB)
            {
                var moreInterNum = negativeTickNumA - negativeTickNumB;
                if(domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[0] -= (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
                else if(domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[domainArrayB.length-1] -= (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
            }
            else if(negativeTickNumA < negativeTickNumB)
            {
                var moreInterNum = negativeTickNumB - negativeTickNumA;
                if(domainArrayA[0] < domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[0] -= (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
                else if(domainArrayA[0] > domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[domainArrayA.length-1] -= (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
            }

            //to nice the domainArray, avoid the domain contains 0.00060000001
            domainArrayA[0] = parseFloat(domainArrayA[0].toFixed(8));
            domainArrayA[1] = parseFloat(domainArrayA[1].toFixed(8));
            domainArrayB[0] = parseFloat(domainArrayB[0].toFixed(8));
            domainArrayB[1] = parseFloat(domainArrayB[1].toFixed(8));
            
            _scaleA.domain(domainArrayA);
            _scaleB.domain(domainArrayB);

            _scaleA.tickHint = _scaleA.tickNum -1;
            _scaleB.tickHint = _scaleB.tickNum -1;
        }
    };
    
    return Scaler;
});sap.riv.module(
{
  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(constants) {
    var ColorSeriesGenerator = {
      /**
       * return d3 ordinal scale of sap standard color palette 
       */
      sap32 : function(){
      return d3.scale.ordinal().range(constants.SAPColorSingleAxis);
      },
      sap32dualaxis1 : function(){
            return d3.scale.ordinal().range(constants.SAPColorDualAxis1);
        },
        sap32dualaxis2 : function(){
            return d3.scale.ordinal().range(constants.SAPColorDualAxis2);
        },      
    }

    return ColorSeriesGenerator;
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'},
[

],
function Setup() 
{

  return function(data) 
  {
    var dataset1;
    var dataset2;
    var hasMND = false;
    var bMNDOnColor = true;
    var bMNDInner = false; 
    var bDualAxis = false;
    var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
    var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
    var regionColorFeed = data.getAnalysisAxisDataByIdx(1);
    var categoryFeed = data.getAnalysisAxisDataByIdx(0);

    if((measureFeed2 && measureFeed2.values && measureFeed2.values.length > 0))
    {
      bDualAxis = true;
    }
    if(categoryFeed && categoryFeed.values && categoryFeed.values.length > 0)
    {
      if (categoryFeed.values[0].type === 'MND')
      {
        hasMND = true;
        bMNDOnColor = false;
        bMNDInner = false;
      }else if(categoryFeed.values[categoryFeed.values.length - 1].type === 'MND')
      {
        hasMND = true;
        bMNDOnColor = false;
        bMNDInner = true;
      }
    }

    if(regionColorFeed && regionColorFeed.values && regionColorFeed.values.length > 0)
    {
      if(regionColorFeed.values[0].type === 'MND')
      {
        hasMND = true;
        bMNDInner = false;
      }else if(regionColorFeed.values[regionColorFeed.values.length - 1].type === 'MND')
      {
        hasMND = true;
        bMNDInner = true;
      }
    }

    // MND on axis label
    function processOneAxisValue(feed)
    {
      var dataset = [];
      var i, j, k;
      var measureData;
      if (feed.values.length <= 0){
        return dataset;
      }
      if (hasMND && !bMNDOnColor)
      {
        for(j = 0; j < feed.values[0].rows.length; ++j)
        {    
          measureData = new Array(feed.values.length * feed.values[0].rows[0].length);
          for(k = 0; k < feed.values[0].rows[0].length; ++k)
          {
            for(i = 0 ; i < feed.values.length; ++i)
            {
              var dataPoint = {};
              dataPoint.val = feed.values[i].rows[j][k].val;
              dataPoint.ctx = feed.values[i].rows[j][k].ctx;
              if(bMNDInner){
                measureData[k * feed.values.length + i] = dataPoint;
              } else {
                measureData[i * feed.values[0].rows[0].length + k] = dataPoint; 
              }
            }
          }
          dataset.push(measureData);
        }  
      }
      else // MND on Region color or no MND
      {
        dataset = new Array(feed.values.length * feed.values[0].rows.length);

        for(i = 0 ; i < feed.values.length; ++i)
        {
          for(j = 0; j < feed.values[0].rows.length; ++j)
          {    
            measureData = feed.values[i].rows[j];
            if(!hasMND || !bMNDInner){
              dataset[i * feed.values[0].rows.length + j] = measureData;
            } else {
              dataset[j * feed.values.length + i] = measureData;
            }
          }
        }
      }

      return dataset;
    }

    function addOneMeasure(dataset, measure)
    {
      for(var i = 0; i < measure.length; ++i)
      {
        dataset[i] = dataset[i].concat(measure[i]);
      }
    }

    function mergeTwoAxis(result)
    {
      var colors = [];
      var measure1Num = measureFeed1.values.length;
      var measure2Num = measureFeed2.values.length;
      var columnNum  = measureFeed1.values[0].rows[0].length;
      var dataset = new Array(measureFeed1.values[0].rows.length); 
      var curColumn = 0;
      var i,j,k;
      for(i = 0; i < dataset.length; ++i){
        dataset[i] = [];
      }
      if(bMNDInner){
        var rowNum = measureFeed1.values[0].rows.length;
        for(i = 0; i < columnNum; ++i)
        {

          for(j = 0; j < measure1Num; ++j)
          {
            for(k = 0; k < rowNum; ++k){
              dataset[k][curColumn] = measureFeed1.values[j].rows[k][i];
            }
            colors[curColumn] = 0;
            ++curColumn;
          }
          for(j = 0; j < measure2Num; ++j)
          {
            for(k = 0; k < rowNum; ++k){
              dataset[k][curColumn] = measureFeed2.values[j].rows[k][i];
            }
            colors[curColumn] = 1;
            ++curColumn;
          }
        }
      }else{
        for(i = 0; i < measure1Num; ++i)
        {
          for(j = 0; j < columnNum; ++j)
          {
            colors[curColumn++] = 0; 
          }
          addOneMeasure(dataset, measureFeed1.values[i].rows);
        }
        for(i = 0; i < measure2Num; ++i)
        {
          for(j = 0; j < columnNum; ++j)
          {
            colors[curColumn++] = 1; 
          }
          addOneMeasure(dataset, measureFeed2.values[i].rows);
        }
      }
      result['MG1'] = dataset;
      result["MG1Number"] = measureFeed1.values.length;
      result['color'] = colors;
    }

    var result = {};

    if(bDualAxis && !bMNDOnColor)
    {
      mergeTwoAxis(result);
    }else{
      dataset1 = processOneAxisValue(measureFeed1);
      result["MG1Number"] = measureFeed1.values.length;
      if(bDualAxis){
        dataset2 = processOneAxisValue(measureFeed2);
        result["MG2Number"] = measureFeed2.values.length;
      }
      result["MG1"] = dataset1;
      result["MG2"] = dataset2;
    }
    result["hasMND"] = hasMND;
    result["MNDOnColor"] = bMNDOnColor;
    result['MNDInner'] = bMNDInner;
    return result;

  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0',
  exported : true
},
[

],
function Setup() {
  return d3.dispatch;
});sap.riv.module(
{
  qname : 'sap.viz.modules.horizontalboxplot',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, Scaler, NumberUtils,tooltipDataHandler,Objects, langManager, BoundUtil) {
  var boxplot = function(manifest, ctx) {

    var sWrapper = null, 
      dimensionGroup = [], 
      dimensionDomain = [], 
      seriesData = [], 
      legendData = [], 
      regionData = [], 
      dimensionData = [], 
      boxplotData = [],
      colorPalette = [],
      boxColorPalette = [],
      _data = null; 
    var  dimensions = {
        'sap.viz.modules.horizontalboxplot.dimension' : {
                'key' : 'sap.viz.modules.horizontalboxplot.dimension',
                'values' : null
        }
      };

    var width = undefined, 
      height = undefined, 
        yScale = d3.scale.ordinal(),
          xScale = d3.scale.linear(),
      yDimensionScale = d3.scale.ordinal(),
      decorativeShape,
      boxWidth,
      boxHeight,
      lastHovered = null,
      tooltipVisible = true,
      scaleMinMax = {
          min: 0,
          max: 0
      },
      effectManager = ctx.effectManager,
      drawingEffect = 'normal';
    
        var _properties = {},
        eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    
    var outLierLayout = {
      width : '1',
      color : '#000000'
    };

    var quartileLayout = {
      width: '0',
      midLineColor: '#000000'
    };
    
    var lowOutLiersObj = [], highOutLiersObj = [], whiskersObj = [], lowWhiskerObj = [], highWhiskerObj = [], quartilesObj = [], outLiersObj = [];
    
    var makeScales = function() {
      var domain = [];
      for ( var i = 0; i < seriesData.length; i++) {
        domain.push(i);
      }
      yScale.domain(domain).rangeBands([0, height]);
      yDimensionScale.domain(dimensionDomain).rangeBands([0, height]); 
      //when all data is 0 or null, we make xScale.domain(0,1)
      if(!scaleMinMax || ( scaleMinMax.min === 0 && scaleMinMax.max === 0)){
        xScale.domain([ 0, 1 ]).range([ 0, width]).nice();
      }else{
        xScale.domain([ scaleMinMax.min, scaleMinMax.max ]).range([ 0, width]).nice();        
      }   
      Scaler.perfect(xScale);

    };
    chart.dimensionData = function(_)
    {
      if (!arguments.length){
        return dimensions;
      }
      dimensions = _;
      return chart;    
    };
    
    function locateBoundary(data) {
      
      if (TypeUtils.isExist(data)) {
        length = data.length;
        var firstLoop = false;
        for (var i = 0; i < length; i++) {
          
          if (data[i].length > 0) {
            if (!firstLoop) {
              scaleMinMax = findMinMax(data[i]);
              firstLoop = true;
            } else {
              var tmp = findMinMax(data[i]);
              if (tmp) {
                if (tmp.min < scaleMinMax.min) {
                  scaleMinMax.min = tmp.min;
                }
                if (tmp.max > scaleMinMax.max) {
                  scaleMinMax.max = tmp.max;
                }
              }
              
            }
          }
        }
      }
      
    }
    
    function findMinMax(range) {
      var minMax = {min:0, max:0};
      if (TypeUtils.isExist(range)) {
        range.sort( function(aObj, bObj) { return aObj.val - bObj.val; });
        
        minMax = {min: range[0].val, max: range[range.length - 1].val};
      }
      return minMax;
    }

    function clearBoxData() {
      lowOutLiersObj = [];
      highOutLiersObj = [];
      whiskersObj = [];
      lowWhiskerObj = [];
      highWhiskerObj = [];
      quartilesObj = [];
      outLiersObj = [];
    }
    
    function clearGlobalData() {
      dimensionGroup = []; 
      dimensionDomain = []; 
      seriesData = []; 
      legendData = []; 
      regionData = []; 
      dimensionData = []; 
      boxplotData = []; 
    }

    function even(n) {
      return (n & 1) == 0;
    }

    function median(distribution, start, end) {
      var n = end - start + 1;
      if (n <= 0)
        return -1;

      var ret;
      var ctxValue = distribution[start + Math.floor((n + 1) / 2) - 1].ctx;

      if (even(n)) {
        ret = (distribution[start + Math.floor((n + 1) / 2) - 1].val + distribution[start
            + Math.floor((n + 1) / 2)].val) / 2;
      } else {
        ret = distribution[start + Math.floor((n + 1) / 2) - 1].val;
      }
      return {
        'ctx' : ctxValue,
        'val' : ret
      };
    }

    function setDistribution(distribution) {

      if (distribution && distribution.length > 0) {
        var n = distribution.length,
          box = {
            'Maximum:': null,
            '3rd Quartile:': null,
            'Median:': null,
            '1st Quartile:': null,
            'Minimum:': null  
          };
        
            midLine = median(distribution,  0,  n - 1);
            box['Median:'] = midLine;
            
          // Q1 is the median of the first half of the set; we add the median to
            // it if the whole set length is even
            var bak = distribution[Math.floor(n / 2)];
            distribution[Math.floor(n / 2)] = midLine;
            var boxBottom = median(distribution, 0, Math.floor(n / 2));
            distribution[Math.floor(n / 2)] = bak;
            
            // Q3 is the median of the second half of the set; we add the median to
            // it if the whole set length is even
            bak = distribution[Math.floor((n - 1) / 2)];
            distribution[Math.floor((n - 1) / 2)] = midLine;
            var boxTop  = median(distribution, Math.floor((n - 1) / 2), n - 1);
            distribution[Math.floor((n - 1) / 2)] = bak;
            box['3rd Quartile:'] = boxTop;
            box['1st Quartile:'] = boxBottom;
            
        // inter-quartile range
        var iqr = boxTop.val - boxBottom.val;
        // lower adjacent limit
        var lal = boxBottom.val - 1.5 * iqr;
        // upper adjacent limit
        var ual = boxTop.val + 1.5 * iqr;

        // search for the lowest non outlier
        var i = 0;
        while (distribution[i].val < lal)
          i++;
        lowWhisker = distribution[i];
        box['Minimum:'] = lowWhisker;

        if (lowWhisker) {
          if (boxBottom) {
            if (boxBottom.val != lowWhisker.val) {
              lowWhiskerObj.push({
                'pair' : [boxBottom, lowWhisker],
                'ctx' : [boxBottom.ctx, lowWhisker.ctx],
                'val' : [boxBottom.val, lowWhisker.val]
              });
            }
          }
        }

        // low outliers are all the values lower than lowest non outlier
        for ( var k = 0; k < i; k++)
          outLiersObj.push(distribution[k]);

        // search for the largest non outlier
        var j = n - 1;
        while (distribution[j].val > ual)
          j--;
        highWhisker = distribution[j];
        box['Maximum:'] = highWhisker;

        for ( var k = 0; k < n - j - 1; k++)
          outLiersObj.push(distribution[j + 1 + k]);

        if (outLiersObj.length > 0)
          box['outLiers(s)'] = outLiersObj.length;
        // if (lowWhiskerObj.length == 1) {
        // whiskersObj.push(lowWhiskerObj[0]);
        // }

        // if (highWhiskerObj.length == 1) {
        // whiskersObj.push(highWhiskerObj[0]);
        // }

        if (highWhisker) {
          if (boxTop) {
            if (boxTop.val != highWhisker.val) {
              highWhiskerObj.push({
                'pair' : [highWhisker, boxTop],
                'ctx' : [highWhisker.ctx, boxTop.ctx],
                'val' : [highWhisker.val, boxTop.val]
              });
            }
          }
        }

        if (boxBottom && boxTop && midLine) {
          if (boxBottom.val == boxTop.val) {
            quartilesObj.push({
              'pair' : [boxBottom, boxBottom],
              'midLine': null,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val]
            });
          } else if (midLine.val == boxTop.val || midLine.val == boxBottom.val) {
            quartilesObj.push({
              'pair' : [boxTop, boxBottom],
              'midLine': null,
              'ctx' : [boxTop.ctx, boxBottom.ctx],
              'val' : [boxTop.val, boxBottom.val]
            });
          } else {
            quartilesObj.push({
              'pair' : [boxTop, midLine],
              'midLine': midLine,
              'ctx' : [boxTop.ctx],
              'val' : [boxTop.val]
            });
            quartilesObj.push({
              'pair' : [midLine, boxBottom],
              'midLine': midLine,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val]
            });
          }
        }
        
        boxplotData.push(box);
      }
    }
      
    function chart(selection) { 
      BoundUtil.drawBound(selection, width, height);
      selection.each(function() {
          
        boxNumber = 1, boxGroupNumber = seriesData.length, boxHeight = 8 * (yScale.rangeBand()) / (9 * boxNumber + 7);
  
          var svg = sWrapper = d3.select(this);
          svg.selectAll('g.box').remove();
          
          if(decorativeShape == null){
            decorativeShape = svg.append('rect').attr('width', width).attr('height', yScale.rangeBand() - boxHeight/2).style('visibility', 'hidden').attr('fill', 'rgba(133,133,133, 0.2)');
          }else{
            decorativeShape.attr('width', width).attr('height', yScale.rangeBand() - boxHeight/2).style('visibility', 'hidden');
          }
          
          var boxGroup = svg.selectAll('g.box').data(seriesData);

          boxGroup.enter().append('g');
        boxGroup.attr('class', 'box').each( function(boxData, outerIndex) {
              
            if (boxData.length == 0) {
              boxplotData.push({});
              return;
            }
            
            boxData = boxData.sort(function(aObj, bObj) { return aObj.val - bObj.val; });
    
                var arrLength = boxData.length, min = boxData[0], max = boxData[arrLength - 1];
    
                setDistribution(boxData);
    
                var outLiersSelector = d3.select(this).selectAll('circle.outliers').data(outLiersObj);
                outLiersSelector.enter().append('circle');
                outLiersSelector.attr('cy', function(outLier) {
                  var y = yScale(outerIndex) + boxHeight;
                  return y;
                })
                .attr('cx', function(outLier, num) {
                  var x = xScale(outLier.val);
                  return x;
                })
                .attr('r', '2')
                //.attr('shape-rendering', 'crispEdges')
                .attr('stroke', effectManager.register(
                                                    {
                                                  drawingEffect : 'normal',
                                                  fillColor : outLierLayout.color
                                                  }
                                                      )
             )
                .attr('stroke-width', outLierLayout.width)
                .attr('fill', 'none')
                .attr('class', 'datapoint outliers');
                
                outLiersSelector.exit().remove();
    
                var quartileSelector = d3.select(this).selectAll('rect.quartile').data(quartilesObj);
                quartileSelector.enter().append('rect');
                quartileSelector.attr('y', function(quartile) {
                  var y = yScale(outerIndex) + boxHeight / 2;
                  return y;
                })
                .attr('x', function(quartile, num) {
                  var x = xScale(quartile.pair[1].val);
                  return x;
                })
                .attr('height', boxHeight)
                .attr('width', function(quartile, num) {
                  var width = 0;
                  var pairDiff = quartile.pair[0].val - quartile.pair[1].val;
                  if (pairDiff == 0) {
                    width = 1;
                  } else {
                    width = xScale(quartile.pair[0].val) - xScale(quartile.pair[1].val);
                  }
  
                  return width;
                })
                .attr('shape-rendering', 'crispEdges')
                .attr( 'fill', function(d){
                  var parameter = {
                      drawingEffect : drawingEffect,
                      fillColor : boxColorPalette[outerIndex % boxColorPalette.length],
                      direction : 'vertical'
                    };
            return effectManager.register(parameter);                
                })
                .attr('stroke-width', quartileLayout.width)
                //.attr('stroke', '#000000')
                .attr('class', 'datapoint quartile');
                
                if (quartilesObj.length == 2) {
                  var midLineYStart = yScale(outerIndex) + boxHeight / 2;
                  var midLineYEnd = midLineYStart + boxHeight;
                  var midLineXStart = midLineXEnd = xScale(quartilesObj[0].midLine.val);
                  var lineSelector = d3.select(this);
                  lineSelector.append('line')
                  .attr('x1', midLineXStart)
                  .attr('y1', midLineYStart)
                  .attr('x2', midLineXEnd)
                  .attr('y2', midLineYEnd)
                  .attr('stroke', '#ffffff')
                  .attr('stroke-width', 1)
                  .attr('shape-rendering', 'crispEdges')
                  .attr('class', 'midline');
                }
                
                quartileSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.rectlowwhisker').data(lowWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector.attr('y', function(whisker) {
                  var y = yScale(outerIndex) + boxHeight / 2;
                  horizontalLineYStart = horizontalLineYEnd = y + boxHeight / 2 ;
                  verticalLineYStart = y;
                  verticalLineYEnd = y + boxHeight;
                  return y;
                  })
                  .attr('x', function(whisker) {
                    var x = xScale(whisker.pair[1].val);
                    horizontalLineXStart = x;
                    verticalLineXStart = verticalLineXEnd = x;
                    return x;
                   })
                  .attr('height', boxHeight)
                    .attr('width', function(whisker) {
                      var width = xScale(whisker.pair[0].val) - xScale(whisker.pair[1].val);
                      horizontalLineXEnd = xScale(whisker.pair[1].val) + width;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke', function(d){
                           var parameter = {
                                 drawingEffect : 'normal',
                                 fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                                };
                         return effectManager.register(parameter);  
                             }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'lineverticallowwhisker');
                    
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', horizontalLineXStart)
                    .attr('y1', horizontalLineYStart)
              .attr('x2', horizontalLineXEnd)
                    .attr('y2', horizontalLineYEnd)
                    .attr('stroke', effectManager.register(
                                            {
                                              drawingEffect : 'normal',
                                              fillColor : '#000000'
                                            }
                                          )
                               )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'linehorizontallowwhisker');
                    return width;
                    })
                .attr('shape-rendering', 'crispEdges')
                .attr('fill-opacity', '0')
                .attr('stroke-width', '0')
                .attr('class', 'datapoint rectlowwhisker');
                
                whiskerSelector.exit().remove();
                
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.recthighwhisker').data(highWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector
                    .attr('y', function(whisker) {
                      var y = yScale(outerIndex) + boxHeight / 2;
              horizontalLineYStart = horizontalLineYEnd = y + boxHeight / 2;
              verticalLineYStart = y;
              verticalLineYEnd = y + boxHeight;
                      return y;
                      })
                    .attr('x', function(whisker, num) {
                      var x = xScale(whisker.pair[1].val);
                    horizontalLineXStart = x;
                    verticalLineXStart = verticalLineXEnd = xScale(whisker.pair[0].val);
                      return x;
                      })
                    .attr('height', boxHeight)
                    .attr('width', function(whisker, num) {
                      var width = xScale(whisker.pair[0].val) - xScale(whisker.pair[1].val);
                      horizontalLineXEnd = xScale(whisker.pair[1].val) + width;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke',  function(d){
                              var parameter = {
                           drawingEffect : 'normal',
                           fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                          };
                              
                                    return effectManager.register(parameter);  
                                }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'lineverticalhighwhisker');
  
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', horizontalLineXStart)
                      .attr('y1', horizontalLineYStart)
                      .attr('x2', horizontalLineXEnd)
                      .attr('y2', horizontalLineYEnd)
                      .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'linehorizontalhighwhisker');
                       
                      return width;
                      })
                      .attr('shape-rendering', 'crispEdges')
                      .attr('fill-opacity', '0')
                      .attr('stroke-width', '0')
                      .attr('class', 'datapoint recthighwhisker');
                
                whiskerSelector.exit().remove();
                
                clearBoxData();
          eDispatch.initialized();
          
          });
          boxGroup.exit().remove();
      });
    return chart;
    };
  
    chart.width = function(value) {
      if (!arguments.length) {
        return width;
      }
      
      width = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };
      
    chart.height = function(value) {
      if (!arguments.length) {
        return height;
      }

      height = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };  
    
    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };
  
    function getTooltipData(index) {
      
      var tooltipData =  {
          'body': [],
          'footer': []
        },
        internalIndex = 0;
      
      if (regionData) {

        var body = {
          'name': null,
          'val': []
        };
        
        internalIndex = index % regionData.length;
        body.name = regionData[internalIndex].name;
  
        if (regionData[internalIndex].label != null && regionData[internalIndex].shape != null && boxColorPalette[internalIndex] != null) {
          var item = {
              'shape': null,
              'color': null,
              'label': null,
              'value': null
            };
          
          item.shape = regionData[internalIndex].shape;
          item.color = boxColorPalette[internalIndex];
          item.label = regionData[internalIndex].label;
          body.val.push(item);
        }
        
        if (boxplotData) {
          
          if (boxplotData[index]) {

            for (var i in boxplotData[index]) {
              var item = {
                  'shape': null,
                  'color': null,
                  'label': null,
                  'value': null
                };
              item.label = i;
              if (boxplotData[index][i]) {
                if (i == 'outLiers(s)') {
                  item.value = boxplotData[index][i];
                } else {
                  item.value = boxplotData[index][i].val;
                }
              }
              body.val.push(item);
            }
          }
        }
        
        tooltipData.body.push(body);
      }
      
      if (dimensionData) {
        internalIndex = Math.floor(index / regionData.length);
        for (var i = 0; i < dimensionData.length; i++) {
          
          if (dimensionData[i].rows.length > 0) {
            var footer = {
                'label': null,
                'value': null
              };
            footer.label = dimensionData[i].col;
            footer.value = dimensionData[i].rows[internalIndex];
            
            tooltipData.footer.push(footer);
          }
        }
      }
      
      return tooltipData;
    }
    
    function generateTooltipData() {
      
      if (dimensions) {
        for (var i in dimensions) {
          dimensionData = dimensions[i].values;
        }
      }
      
      if (legendData) {
        var legendList = legendData.values;
        if (legendList.length > 1) {
          if (legendList[0].type == 'MND') {
            //mnd scan
            for (var mndIndex = 0; mndIndex < legendList[0].rows.length; mndIndex++) {

              //vertical scan
              for (var m = 0; m < legendList[1].rows.length; m++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.name = legendList[0].rows[mndIndex];
                var label = [];
                
                //horizontal scan
                for (var n = 1; n < legendList.length; n++) {
                  label.push(legendList[n].rows[m]);
                }
                legendObj.label = label;
                regionData.push(legendObj);
              }    

            }
          } else if (legendList[legendList.length - 1].type == 'MND') {

            for (var m = 0; m < legendList[0].rows.length; m++) {

              var label = [];
              for (var n = 0; n < legendList.length - 1; n++) {
                label.push(legendList[n].rows[m]);              
              }
              

              for (var mndIndex = 0; mndIndex < legendList[legendList.length - 1].rows.length; mndIndex++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.label = label;
                legendObj.name = legendList[legendList.length - 1].rows[mndIndex];
                regionData.push(legendObj);
              }
            }
          } 
        } else {
          for (var m = 0; m < legendList[0].rows.length; m++) {
            var legendObj = {
                'name': null,
                'shape': null,
                'color': null,
                'label': null
              };
            legendObj.name = legendList[0].rows[m];
            regionData.push(legendObj);
          }
        }
      }
      
      for (var k = 0; k < regionData.length; k++) {
        //regionData[k].color = boxColorPalette[k % boxColorPalette.length];
        regionData[k].shape = 'squareWithRadius';
      }
    }

    function setElementAttribute(element, attribute, value) {
      if (element) {
        var className = element.getAttribute('class');
        if(className.indexOf('recthighwhisker') == -1 && className.indexOf('rectlowwhisker') == -1
           && className.indexOf('linehorizontalhighwhisker') == -1 && className.indexOf('lineverticalhighwhisker') == -1
           && className.indexOf('linehorizontallowwhisker') == -1 && className.indexOf('lineverticallowwhisker') == -1) {
          element.setAttribute(attribute, value);
        }else if (className.indexOf('recthighwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('linehorizontalhighwhisker') != -1 || nodeClassName.indexOf('lineverticalhighwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }
        } else if(className.indexOf('rectlowwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('linehorizontallowwhisker') != -1 || nodeClassName.indexOf('lineverticallowwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }        
        }      
      }
    }
    
      chart.parent = function(){
        return sWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, elemsLen = elems.length; i < elemsLen; i++) {
          var item = elems[i];
          setElementAttribute(item, 'opacity', 1);
          }
        }else{
        setElementAttribute(elems, 'opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
          var item = elems[i];
          setElementAttribute(item, 'opacity', 0.2);
          }
        }else{
        setElementAttribute(elems, 'opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          sWrapper.selectAll('.datapoint').attr('opacity', 1);
          sWrapper.selectAll('.lineverticallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.lineverticalhighwhisker').attr('opacity', 1);
          sWrapper.selectAll('.linehorizontallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.linehorizontalhighwhisker').attr('opacity', 1);
        }else{
          sWrapper.selectAll('.datapoint').attr('opacity', 0.2);
          sWrapper.selectAll('.lineverticallowwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.lineverticalhighwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.linehorizontallowwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.linehorizontalhighwhisker').attr('opacity', 0.2);
        }
        
        sWrapper.selectAll('.recthighwhisker').attr('opacity', 0);
        sWrapper.selectAll('.rectlowwhisker').attr('opacity', 0);
      };
  
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(yOnModule - yScale.rangeBand()*i - 0.5 * yScale.rangeBand() ) <= 0.5 * yScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1)
          || i < 0) {
        decorativeShape.style(
            'visibility', 'hidden');
        return;
      }
      
      decorativeShape.attr(
          'y',
          yScale.rangeBand() * i + boxHeight/4).style(
          'visibility', 'visible');
      
      if(lastHovered !== i){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element.
          var transform = sWrapper[0][0].getTransformToElement(sWrapper[0][0].ownerSVGElement);
          var yoffset = transform.f;
          
          var tooltipData = getTooltipData(i);
          
          tooltipData.point = {
              x: d3.event.layerX,
              y: yScale.rangeBand()*i + 0.5 * yScale.rangeBand() + yoffset
          };
          tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : width,
                        height : height
                    };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
      }
      
      };
  
      chart.blurOut = function(){
        decorativeShape.style('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
          eDispatch.hideTooltip();
      }
      };
      
      function makeSubGroup(row, start, end, groups, parentGroupIndex) {
      if (row && start <= end && end < row.length) {
        var subStart = subEnd = pos = start;
        while (pos <= end) {
          while (((pos+1) <= end) && (row[pos + 1].val == row[pos].val)) {
            subEnd++;
            pos++;
          }
            
          groups.push({
            'val': row[subStart],
            'parentGroupIndex': parentGroupIndex,
            'start': subStart,
            'end': subEnd
          });
          pos++;
          subStart = subEnd = pos;
        }          
      }
    }

    
    function generateGroup(row) {
      var curGroups = [];
      if (row) {
        var mapLen = dimensionGroup.length;
        var preGroups = mapLen > 0?dimensionGroup[mapLen - 1].val : null;
        if (preGroups) {
          for (var i = 0, len = preGroups.length; i < len; i++) {
            var preGroup = preGroups[i];
            var start = preGroup.start;
            var end = preGroup.end;
            makeSubGroup(row, start, end, curGroups, i );
          }
        } else {
          makeSubGroup(row, 0, row.length - 1, curGroups, null);
        }
      }
      return curGroups;
    }

    function dataTransform(originalData) {
      if (originalData) {
        var originalDimension = originalData.getAnalysisAxisDataByIdx(0);
        legendData = originalData.getAnalysisAxisDataByIdx(1);
        if (originalDimension) {
          var len = originalDimension.values.length;
          if (len == 1) {
            dimensionGroup.push({'col': originalDimension.values[0].col.val, 'val': []});
          } else {
            for (var i = 0; i < len - 1; i++) {
              var row = originalDimension.values[i].rows;
              dimensionGroup.push({'col': originalDimension.values[i].col.val, 'val': generateGroup(row)});
            }
          }
        }
      }
    }
    
    function caculateLeavesNum(start, end) {
      
      var len = dimensionGroup.length, num = 0, index = 0, leavesGroups = dimensionGroup[len - 1].val;
      while (leavesGroups[index].start != start) {
        index++;
      }      
      while (leavesGroups[index].end != end) {
        num++;
        index++;
      }
      num++;
      return num;
    }

    function generateDimensions() {
      if (dimensionGroup) {
        var len = dimensionGroup.length, groups = null;
        
        groups = dimensionGroup[len - 1].val;
        if (groups.length == 0) {
          dimensionDomain.push(0);
          dimensionDomain.push(1);
        } else {
          for (var i = 0, lenScale = groups.length; i < lenScale; i++) {
            dimensionDomain.push(i);
          }
        }
        
        if (groups.length == 0) {
          dimensions['sap.viz.modules.horizontalboxplot.dimension'].values = [{'col': {'val': dimensionGroup[len - 1].col}, 'rows': []}];
        } else {
          
          var scaleValues = [];
          for (var j = 0; j < len; j++) {
            var obj = {
              'col': {'val': ''},
              'rows': []
            };
            obj.col.val = dimensionGroup[j].col;
            var rowGroups = dimensionGroup[j].val;
            for (var k = 0,  lenRowGroups =  rowGroups.length; k < lenRowGroups; k++) {
              var start = rowGroups[k].start, end = rowGroups[k].end, num = caculateLeavesNum(start, end);
              for (var m = 0; m < num; m++) {
                obj.rows.push({
                  'val': handleNull(rowGroups[k].val.val),
                  'info' : rowGroups[k].val.info
                });
              }
            }
            
            scaleValues.push(obj);
          }
              
          dimensions['sap.viz.modules.horizontalboxplot.dimension'].values = scaleValues;
        }        
      }      
    }
  
    function createColorPalette(length) {
      boxColorPalette = [];
      if (colorPalette.length > 0) {
        for( var i = 0; i < length; ++i) {
          boxColorPalette.push(colorPalette[i % colorPalette.length]);
        }
      }
    }
      function parseOptions(){
      tooltipVisible = _properties.tooltip.enabled ;
        colorPalette = _properties.colorPalette;
        drawingEffect = _properties.drawingEffect;
      }
      
    chart.data = function(value) {
      if (!arguments.length) {
        return _data;
      }
      
      clearGlobalData();
      parseOptions();
      
      _data = value;
        var obj = MNDHandler(_data);
        dataTransform(_data);
        dataMG1 = obj["MG1"];
        
      var len = dataMG1.length;
      var groups = dimensionGroup[dimensionGroup.length - 1].val;
      if (groups.length != 0) {
        for (var i = 0, groupsLen = groups.length; i < groupsLen; i++) {
          var start = groups[i].start, end = groups[i].end;
          for (var j = 0; j < len; j++) {
            var row = [], left = start, right = end;
            for (;left <= right; left++) {
              if (!NumberUtils.isNoValue(dataMG1[j][left].val))
                row.push(dataMG1[j][left]);
            }
            seriesData.push(row);
          }
        }
      } else {
        for (var j = 0; j < len; j++) {
          var row = [];
          for (var m = 0; m < dataMG1[j].length; m++) {
            if (!NumberUtils.isNoValue(dataMG1[j][m].val)) {
              row.push(dataMG1[j][m]);
            } 
          }
          seriesData.push(row);
        }
      }
        
      locateBoundary(seriesData);
      generateDimensions();
      
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
        makeScales();
      }
      
      generateTooltipData();
            createColorPalette(regionData.length);
      
      return chart;
    };
    
    chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
    chart.properties = function(props){

        if (!arguments.length){
          return _properties;
         }
      
      Objects.extend(true, _properties, props);
            parseOptions();
            createColorPalette(regionData.length);
            
         return chart;        
      };
    
    chart.categoryScale = function(scale){
      if (!arguments.length){
        return yDimensionScale;
      }
      yDimensionScale = scale;
      return chart;
     };
     
     chart.primaryScale = function(scale){
       if (!arguments.length){
         return xScale;
       }
       xScale = scale;
       return chart;
     };
  
    chart.colorPalette = function(Palette){
      if (!arguments.length){
        return colorPalette;
      }
      colorPalette = Palette;
      return chart;
     };
  
     chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };
    _properties = manifest.props(null);
    return chart;
  };

  return boxplot;
});sap.riv.module(
{
  qname : 'sap.viz.format.XCFormat',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
}
],
function Setup(Objects) {
	
	var NF = {
			format: function(value){
				return value;
			},
			locale: function(){
				
			},
			DEFAULT_FORMAT_DATE_TIME : '',
			DEFAULT_FORMAT_TIME : '',
			DEFAULT_FORMAT_SHORT_DATE : '',
			DEFAULT_FORMAT_LONG_DATE : '',
			DEFAULT_FORMAT_NUMBER : '',
			DEFAULT_FORMAT_BOOLEAN : ''
	}, snf = null, locale = 'en';
	
	if(sap && sap.common && sap.common.globalization && sap.common.globalization.NumericFormatManager){
		snf = sap.common.globalization.NumericFormatManager;
		
		NF = Objects.extend( true, NF, {
			
			format : function(value, pattern){
				return snf.formatToText(value, pattern, true); // we always try to convert number to string
			},
			
			locale : function(_){
				if(!arguments.length){
					return locale;
				}
				locale = _;
				snf.setPVL(locale);
				
				//reset default format string
				NF.DEFAULT_FORMAT_DATE_TIME = snf.DEFAULT_FORMAT_DATE_TIME;
				NF.DEFAULT_FORMAT_TIME = snf.DEFAULT_FORMAT_TIME;
				NF.DEFAULT_FORMAT_SHORT_DATE = snf.DEFAULT_FORMAT_SHORT_DATE;
				NF.DEFAULT_FORMAT_LONG_DATE = snf.DEFAULT_FORMAT_LONG_DATE;
				NF.DEFAULT_FORMAT_NUMBER = snf.DEFAULT_FORMAT_NUMBER;
				NF.DEFAULT_FORMAT_BOOLEAN = snf.DEFAULT_FORMAT_BOOLEAN;
			},
			
			DEFAULT_FORMAT_DATE_TIME : snf.DEFAULT_FORMAT_DATE_TIME,
			DEFAULT_FORMAT_TIME : snf.DEFAULT_FORMAT_TIME,
			DEFAULT_FORMAT_SHORT_DATE : snf.DEFAULT_FORMAT_SHORT_DATE,
			DEFAULT_FORMAT_LONG_DATE : snf.DEFAULT_FORMAT_LONG_DATE,
			DEFAULT_FORMAT_NUMBER : snf.DEFAULT_FORMAT_NUMBER,
			DEFAULT_FORMAT_BOOLEAN : snf.DEFAULT_FORMAT_BOOLEAN
			
		});
	}
	
	return NF;
});sap.riv.module(
{
  qname : 'sap.viz.format.FormatManager',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.format.XCFormat',
  version : '4.0.0'
},
{  qname : 'sap.viz.Locale',
  version : '4.0.0'
}
],
function Setup(TypeUtil, XCFormat, Locale) {

	var locale = 'en', formatUtil = XCFormat, props = null;
	
	var FM = 
		 /** @lends sap.viz.format.FormatManager */
	{
			 /**
		       * @constructs
		      */
			constructor : function(){
				return;
			},
			
			/**
		       * Apply a locale
		       * 
		       * @param {String}
		       * 			locale
		       * 
		       * @returns {Object} {@link sap.viz.format.FormatManager}
		       */
			apply : function(_){
				locale = _;
				formatUtil.locale(locale);
			},
			
			/**
		       * format a string
		       * 
		       * @param {String}
		       * 			value
		       * 
		       * @param {String}
		       * 			pattern
		       * 
		       * @returns {Object} {@link sap.viz.format.FormatManager}
		       */
			format : function(value, pattern){
				return formatUtil.format(value, pattern);
			},
			
			/**
		       * set/get format function
		       * 
		       * @param {Function}
		       * 			func
		       * 
		       * @returns {Object} {@link sap.viz.format.FormatManager}
		       */
			formatFunc : function(_){
				if(!arguments.length){
					return formatUtil;
				}
				formatUtil = _;
			},
			
			/**
		     * default data time format. It will changed by locale. 
		    */
			DEFAULT_FORMAT_DATE_TIME : formatUtil.DEFAULT_FORMAT_DATE_TIME,
			/**
		     * default time format. It will changed by locale. 
		    */
			DEFAULT_FORMAT_TIME : formatUtil.DEFAULT_FORMAT_TIME,
			/**
		     * default short data format. It will changed by locale. 
		    */
			DEFAULT_FORMAT_SHORT_DATE : formatUtil.DEFAULT_FORMAT_SHORT_DATE,
			/**
		     * default long data format. It will changed by locale. 
		    */
			DEFAULT_FORMAT_LONG_DATE : formatUtil.DEFAULT_FORMAT_LONG_DATE,
			/**
		     * default number format. It will changed by locale. 
		    */
			DEFAULT_FORMAT_NUMBER : formatUtil.DEFAULT_FORMAT_NUMBER,
			/**
		     * default boolean format. It will changed by locale. 
		    */
			DEFAULT_FORMAT_BOOLEAN : formatUtil.DEFAULT_FORMAT_BOOLEAN
	};
	
	Locale.addListener({
		fn:function(locale){
			FM.apply(locale);
		},
		scope: FM
	});
	
	return FM;
});sap.riv.module(
{
  qname : 'sap.viz.base.Repository',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(){
	var generateId = function() {//guid generator
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {var r = Math.random()*16|0,v=c=='x'?r:r&0x3|0x8;return v.toString(16);});
	};
	var ExType = {
		ID_REGISTERED 		: 1,
		OBJ_REGISTERED 		: 2,
		ID_NEEDED			: 3,
		ID_NOT_REGISTERED 	: 4,
		OBJ_NULL			: 5
	}
	var createEx = function(type, param1) {
		var ex = {};
		ex.type = type;
		switch (type) {
			case ExType.ID_REGISTERED:
				ex.message = "ID '" + param1 + "' has been registered.";
				break;
			case ExType.OBJ_REGISTERED:
				ex.message = "The vizObj has been registered, its Id is '" + param1 + "'.";
				break;
			case ExType.ID_NEEDED:
				ex.message = "Please specify Id";
				break;
			case ExType.ID_NOT_REGISTERED:
				ex.message = "No vizObj was registered with Id '" + param1 + "'";
				break;
			case ExType.OBJ_NULL:
				ex.message = "Null object is not allowed";
				break;
		}
		return ex;
	}
	
	var registry = {};
	/*member functions of Repository*/
	/*
	 * register a viz object with its ID 
	 * @param id optional, id of vizObj, if null a new id will be generated
	 * @param vizObj
	 * @return id of vizObj
	 * @throws id is registered; vizObj is registered;
	 */
	var registerFunc = function(id, vizObj) {
		if (!vizObj) {
			throw createEx(ExType.OBJ_NULL);
		}
		id = id ? id : generateId();
		//check Id
		if (registry[id]) {
			throw createEx(ExType.ID_REGISTERED, id);
		}
		//check vizObj
		for (var x in registry) {
			if (vizObj == registry[x]) {
				throw createEx(ExType.OBJ_REGISTERED, x);
			}
		}
		registry[id] = vizObj;
		return id;
	};
	/*
	 * unregister a viz object with its ID
	 * @param id id of vizObj
	 * @return
	 * @throws id is null; No vizObj is registered with id;
	 */
	var unregisterFunc = function(id) {
		if (!id) {
			throw createEx(ExType.ID_NEEDED);
		}
		if (!registry[id]) {
			throw createEx(ExType.ID_NOT_REGISTERED, id);
		}
		delete registry[id];
	};
	/*
	 * get a viz object by its ID
	 * @param id id of vizObj
	 * @return vizObj
	 * @throws id is null;
	 */
	var getFunc = function(id) {
		if (!id) {
			throw createEx(ExType.ID_NEEDED, id);
		}
		return registry[id];
	};
	/*
	 * get Ids of all viz objects in repository
	 * @return Id array
	 */
	var getAllFunc = function() {
		var ids = [];
		for (var x in registry) {
			ids.push(x);
		}
		return ids;
	};
	/*
	 * generate a new unique ID beginning with prefix. 
	 * @param prefix
	 * @return id
	 */
	var newIdFunc = function(prefix) {
		var id = generateId();
		return prefix ? prefix + "_" + id : id;
	};
	var Repository = {
		register 	: registerFunc,
		unregister 	: unregisterFunc,
		get 		: getFunc,
		getAll 		: getAllFunc,
		newId 		: newIdFunc
	};
	return Repository;
});sap.riv.module(
{
  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'},
[

],

function Setup() {
	var devicePixRatio = window.devicePixelRatio || 1;
	var versionSearchString;
	var searchString = function(data) {
		for ( var i = 0; i < data.length; i++) {
			var dataString = data[i].string;
			var dataProp = data[i].prop;
			versionSearchString = data[i].versionSearch || data[i].identity;
			if (dataString) {
				if (dataString.indexOf(data[i].subString) != -1) {
					return data[i].identity;
				}
			} else if (dataProp) {
				return data[i].identity;
			}
		}
	};
	var seps = [ ';', ' ' ];
	var searchVersion = function(dataString) {
		var index = dataString.indexOf(versionSearchString);
		if (index == -1)
			return;
		var versionStr = dataString.substring(index + versionSearchString.length + 1);
		var i = 0, l = seps.length, sepIndex = -1;
		while (sepIndex === -1 && i < l)
			sepIndex = versionStr.indexOf(seps[i++]);
		if (sepIndex !== -1)
			versionStr = versionStr.slice(0, sepIndex);
		return versionStr;
	};
	var dataBrowser = [ {
		string : navigator.userAgent,
		subString : "Chrome",
		identity : "Chrome"
	}, {
		string : navigator.userAgent,
		subString : "OmniWeb",
		versionSearch : "OmniWeb/",
		identity : "OmniWeb"
	}, {
		string : navigator.userAgent,
		subString : "RIV",
		versionSearch : "RIV/",
		identity : "RIV"
	}, {
		string : navigator.userAgent,
		subString : "Safari",
		identity : "Safari",
		versionSearch : "Version"
	}, {
		string : navigator.userAgent,
		subString : "Apple",
		identity : "UIWebView",
		versionSearch : "AppleWebKit"
	}, {
		prop : window.opera,
		identity : "Opera",
		versionSearch : "Version"
	}, {
		string : navigator.vendor,
		subString : "iCab",
		identity : "iCab"
	}, {
		string : navigator.vendor,
		subString : "KDE",
		identity : "Konqueror"
	}, {
		string : navigator.userAgent,
		subString : "Firefox",
		identity : "Firefox"
	}, {
		string : navigator.vendor,
		subString : "Camino",
		identity : "Camino"
	}, {// for newer Netscapes (6+)
		string : navigator.userAgent,
		subString : "Netscape",
		identity : "Netscape"
	}, {
		string : navigator.userAgent,
		subString : "MSIE",
		identity : "Explorer",
		versionSearch : "MSIE"
	}, {
		string : navigator.userAgent,
		subString : "Gecko",
		identity : "Mozilla",
		versionSearch : "rv"
	}, {// for older Netscapes (4-)
		string : navigator.userAgent,
		subString : "Mozilla",
		identity : "Netscape",
		versionSearch : "Mozilla"
	} ];

	var dataOS = [ {
		string : navigator.platform,
		subString : "Win",
		identity : "Windows"
	}, {
		string : navigator.platform,
		subString : "Mac",
		identity : "Mac"
	}, {
		string : navigator.userAgent,
		subString : "iPhone",
		identity : "iPhone/iPod"
	}, {
		string : navigator.userAgent,
		subString : "iPad",
		identity : "iPad"
	}, {
		string : navigator.platform,
		subString : "Linux",
		identity : "Linux"
	} ];

	var dataRenderEngine = [ {
		string : navigator.userAgent,
		subString : "Presto",
		identity : "Presto"
	}, {
		string : navigator.userAgent,
		subString : "KHTML",
		identity : "KHTML"
	}, {
		string : navigator.userAgent,
		subString : "Gecko",
		identity : "Gecko"
	}, {
		string : navigator.userAgent,
		subString : "Trident",
		identity : "Trident"
	}, {
		string : navigator.userAgent,
		subString : "RivKit",
		identity : "RivKit"
	} ];
	var _userAgent = searchString(dataBrowser) || "An unknown browser", _version = searchVersion(navigator.userAgent)
			|| searchVersion(navigator.appVersion) || "an unknown version", _isIE = searchString(dataBrowser) === "Explorer", _isFirefox = searchString(dataBrowser) === 'Firefox', _isChrome = searchString(dataBrowser) === 'Chrome', _isSafari = searchString(dataBrowser) === 'Safari', _isUIWebView = searchString(dataBrowser) === 'UIWebView', _os = searchString(dataOS)
			|| "an unknown OS", _renderEngine = searchString(dataRenderEngine) || "An unknown RenderEngine";
	var UADetector = {
		userAgent : function() {
			return _userAgent;
		},
		version : function() {
			return _version;
		},
		isIE : function() {
			return _isIE;
		},
		isFirefox : function() {
			return _isFirefox;
		},
		isChrome : function() {
			return _isChrome;
		},
		isSafari : function() {
			return _isSafari;
		},
		isUIWebView : function() {
			return _isUIWebView;
		},
		os : function() {
			return _os;
		},
		devicePixelRatio : function() {
			return devicePixRatio;
		},
		renderEngine : function() {
			return _renderEngine;
		}
	};
	return (UADetector);
});sap.riv.module(
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
}
],
function Setup(TypeUtils, UADetector) {
  var ns = "http://www.w3.org/2000/svg";
  var node;
  var sensitiveStyle = [ "font", "font-family", "font-size",
      "font-size-adjust", "font-stretch", "font-style", "font-variant",
      "font-weight", "letter-spacing", "word-spacing", "alignment-baseline",
      "baseline-shift", "dominant-baseline" ];
  var textSizeCache = [];

  function getNode() {
    if (!node) {
      var svg = document.body.appendChild(document.createElementNS(ns, "svg"));
      svg.style.cssText = "position:absolute;left:-1000px;top:-1000px;z-index:-9000;width:1px;height:1px";
      node = svg.appendChild(document.createElementNS(ns, "text"));
    }

    return node;
  }

  function applyText(text, style) {
    var node = getNode();

    if (!style)
      node.removeAttribute("style");
    else {
      if (!TypeUtils.isString(style)) {
        var computedStyle = UADetector.isIE() ? style.ownerSVGElement
            .getComputedStyle(style) : getComputedStyle(style);

        var cssText = "";
        sensitiveStyle.forEach(function(i) {
          var s = computedStyle.getPropertyValue(i);
          if (s != null)
            cssText += i + ":" + s + ";";
        });
        style = cssText;
      }
      node.style.cssText = style;
    }
    if (text == null)
      text = "";

    node.textContent = text;
    return node;
  }
  
  function ellipsis(text, textNode, expectedLength, cssStyle, textApplied) {
    if (expectedLength > 0) {
      var node = textApplied ? getNode() : applyText(text, (cssStyle != null ? cssStyle : textNode));
      if (node.getComputedTextLength() <= expectedLength) {
        if (textNode) {
          textNode.textContent = text;
        }
        return text;
      }

      node.textContent = "...";
      expectedLength -= node.getComputedTextLength();
      node.textContent = text;

      if (expectedLength > 0) {
        var charNumber = text.length;
        var i = 0;
        while (++i < charNumber) {
          if (node.getSubStringLength(0, charNumber - i) <= expectedLength) {
            var reText = text.substring(0, charNumber - i) + "...";
            if (textNode) {
              textNode.textContent = reText;
              textNode.appendChild(document.createElementNS(
                  textNode.namespaceURI, "title")).textContent = text;
            }
            return reText;
          }
        }
      }
    }
    if (textNode) {
      textNode.textContent = "";
    }
    return "";
  }  

  return {
    /**
     * Measure the dimension of the text in given style
     * 
     * @param {String}
     *          text the text to be measured
     * @param style
     *          the style definition text or a DOM node. If it is a node, its
     *          style will be used to measure text.
     * @returns {Object}
     */
    measure : function(text, style) {
        if (text === '') {
            return {
                width : 0,
                  height : 0,
                  x : 0,
                  y : 0
            };
        }
      var box = applyText(text, style).getBBox();
      return {
        width : box.width,
        height : box.height,
        x : box.x,
        y : box.y
      };
    },

    /**
     * Fast measure the dimension of the text in given fontSize, fontWeight and
     * fontFamily
     * 
     * @param {String}
     *          text the text to be measured
     * @param {String}
     *          fontSize
     * @param {String}
     *          fontWeight
     * @param {String}
     *          fontFamily
     * @returns {Object}
     */
    fastMeasure : function(text, tFontSize, tFontWeight, tFontFamily) {
      var index = text + tFontSize + tFontWeight + tFontFamily;
      var cachedSize = textSizeCache[index];
      if (!cachedSize) {
        textSizeCache[index] = this.measure(text, "font-size:" + tFontSize
            + "; font-weight:" + tFontWeight + "; font-family:" + tFontFamily);

        cachedSize = textSizeCache[index];
      }
      return cachedSize;
    },

    /**
     * Ellipsis long text.
     * 
     * @param {String}
     *          text the text to be processed
     * @param {Node}
     *          textNode the svg:text which will be display text
     * @param {Number}
     *          maxLength the max text length
     */
    ellipsis : function(text, textNode, maxLength, cssStyle) {
      return ellipsis(text, textNode, maxLength, cssStyle, false);
    },
   
    /**
     * Ellipsis long text in a circle area.
     * 
     * @param {String}
     *          text the text to be processed
     * @param {Node}
     *          textNode the svg:text which will be display text
     * @param {Number}
     *          r the radius of circle
     * @param {Number}
     *          h the offset from center of circle
     */
    ellipsisInCircle : function(text, textNode, r, h) {
      var node = applyText(text, textNode);

      var maxLength = Math.sqrt(Math.pow(r, 2)
          - Math.pow(h + node.getBBox().height / 2, 2)) * 2;
      ellipsis(text, textNode, maxLength, null, true);
    },

    verticalCentralOffset : function(text, textNode) {
      var tmpNode = applyText(text, textNode);
      var box = tmpNode.getBBox();
      var actualHeight = -box.y;
      var fontSize = parseInt(tmpNode.ownerSVGElement.getComputedStyle(tmpNode)["fontSize"]);
      return (actualHeight - (box.height - fontSize)) / 2;
    }
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie.tooltip',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
}
],
function Setup(TextUtils, UADetector, Repository) {
  var wrapperClass = "tooltip", caretClass = "caret", minRadius = 8.9 * 14 / 2;
  var caretAngle = 60, textsVSpacing = 8;
  // alistar zhu
  var randomSuffix = Repository.newId();
  var shadowFilterId = "tooltip-caret-shadow-" + randomSuffix;
  var textClassNamesInTheme = [ "viz-pie-tooltip-label-dimensions",
      "viz-pie-tooltip-label-value", "viz-pie-tooltip-label-percentage" ];

  function renderCaret(p) {
    return p.append("svg:path").attr("class", caretClass).attr("d", "M 0 0 Z");
  }

  function createShadowFilterDef(defs) {
    var ns = defs.namespaceURI;
    var shadowFilter = defs.appendChild(document.createElementNS(ns, "filter"));
    shadowFilter.id = shadowFilterId;

    var feGaussianBlur = shadowFilter.appendChild(document.createElementNS(ns,
        "feGaussianBlur"));
    feGaussianBlur.setAttribute("in", "SourceAlpha");
    feGaussianBlur.setAttribute("stdDeviation", 3);
    feGaussianBlur.setAttribute("result", "blur");

    var feMerges = shadowFilter.appendChild(document.createElementNS(ns,
        "feMerge"));
    feMerges.appendChild(document.createElementNS(ns, "feMergeNode"))
        .setAttribute("in", "blur");
    feMerges.appendChild(document.createElementNS(ns, "feMergeNode"))
        .setAttribute("in", "SourceGraphic");
  }

  function renderTexts(p) {
    var texts = [];
    for ( var i = 0; i < 3; i++) {
      texts[i] = p.append("svg:text").attr("class", textClass(i)).datum(
          function(d) {
            return {
              text : ""
            };
          });
    }
  }

  function texts(p) {
    return p.selectAll("text");
  }

  function applyTextStyles(texts, styleManager) {
    texts.attr("style", function(d, i) {
      var className = textClassNamesInTheme[i];
      return styleManager.cssText(className);
    });
  }

  function textClass(i) {
    return "label" + (i + 1);
  }

  function adjustTexts(texts) {
    var textClass1 = textClass(1);
    var text1Height;
    texts.each(function(d) {
      d.r = d3.select(this.parentNode).datum().r;
    }).filter("." + textClass1).attr("dy", function(d) {
      var dy = 0, txt = d.text;
      if (UADetector.isIE()) {
        dy = TextUtils.verticalCentralOffset(txt, this);
      }

      TextUtils.ellipsisInCircle(txt, this, d.r, 0);
      text1Height = this.getBBox().height;

      return dy;
    });
    texts.filter(":not(." + textClass1 + ")").attr(
        "dy",
        function(d, i) {
          var txt = d.text;
          var txtHeight = TextUtils.measure(txt, this).height;

          var dy = (UADetector.isIE() ? (i === 0 ? 0 : txtHeight)
              : (txtHeight / 2)) +
              text1Height / 2 + textsVSpacing;

          var maxLength = Math.sqrt(Math.pow(d.r, 2) -
              Math.pow(txtHeight + text1Height / 2 + textsVSpacing, 2)) * 2;

          TextUtils.ellipsis(txt, this, maxLength);
          if (i === 0) {
            dy = -dy;
          }

          return dy;
        });
  }

  function normalizeAngle(a) {
    a %= 360;

    if (a < 0) {
      a += 360;
    }
    return a;
  }

  function caretRotateTween(el, endAngle) {
    var transformList = el.transform.baseVal;
    var startAngle = transformList.numberOfItems === 0 ? 0
        : normalizeAngle(transformList.getItem(0).angle);

    var endAngles = [];
    endAngles[0] = normalizeAngle(endAngle);
    endAngles[1] = endAngles[0] - 360;
    endAngles[2] = endAngles[0] + 360;

    var minRange = 360, index = null;
    for ( var i = 0; i < endAngles.length; i++) {
      var range = Math.abs(endAngles[i] - startAngle);
      if (range < minRange) {
        minRange = range;
        index = i;
      }
    }

    var interpolator = d3.interpolateNumber(startAngle, endAngles[index]);
    return function(t) {
      return "rotate(" + interpolator(t) + ")";
    };
  }

  function computeCaretSize(or) {
    if (or >= 12 * 14) {
      return 14;
    }

    if (or >= 8 * 14) {
      return 0.8 * 14;
    }

    return 0.5 * 14;
  }

  return function() {
    function tooltip(p, styleManager) {
      var wrapper = p.selectAll("g." + wrapperClass).data(function(d, i) {
        var data;
        if (d.or > minRadius) {
          data = [ {
            r : d.ir,
            caretSize : computeCaretSize(d.or)
          } ];
        } else {
          data = new Array(0);
        }
        return data;
      });
      wrapper.exit().remove();

      texts(wrapper).call(applyTextStyles, styleManager).call(adjustTexts);

      var enterWrapper = wrapper.enter().append("svg:g").attr("class",
          wrapperClass).style("opacity", 0).attr("visibility", "hidden").attr(
          "pointer-events", "none").call(renderCaret).call(renderTexts);

      texts(enterWrapper).call(applyTextStyles, styleManager);
    }

    tooltip.createShadowFilterDef = createShadowFilterDef;

    tooltip.defaultStyle = function(parentClass) {
      return "." +
          parentClass +
          " ." +
          wrapperClass +
          " text{dominant-baseline:central}." +
          parentClass +
          " ." +
          wrapperClass +
          " ." +
          caretClass +
          "{fill:#fff;" +
          (UADetector.isSafari() ? "-webkit-svg-shadow: 0 0 10px rgba(0, 0, 0, 0.25)"
              : "filter:url(#" + shadowFilterId + ")") + "}";
    };

    tooltip.select = function(p) {
      var wrapper = p.selectAll("g." + wrapperClass);
      if (wrapper.empty()) {
        return null;
      }

      return {
        show : function() {
          wrapper.attr("visibility", null).transition().duration(200).style(
              "opacity", 1);
          return this;
        },
        hide : function() {
          wrapper.transition().each("end", function() {
            wrapper.attr("visibility", "hidden");
          }).duration(200).style("opacity", 0);
          return this;
        },
        texts : function() {
          var values = arguments;
          texts(wrapper).each(function(d, i) {
            d.text = values[i];
          }).call(adjustTexts);
          return this;
        },
        caret : function() {
          var caret = wrapper.select("." + caretClass);

          return {
            show : function() {
              caret.attr("d", function(d) {
                var x = Math.tan(caretAngle * Math.PI / 360) * d.caretSize;
                var y = Math.sqrt(d.r * d.r - x * x);
                return "M 0 " + -(y + d.caretSize) + " L " + x + " " + -y +
                    " A " + d.r + " " + d.r + " 0 1 1 " + -x + " " + -y + " Z";
              });
              return this;
            },
            hide : function() {
              caret.attr("d", function(d) {
                return "M 0 " + d.r + " A " + d.r + " " + d.r + " 0 1 1 0 " +
                    -d.r + " A " + d.r + " " + d.r + " 0 1 1 0 " + d.r + " Z";
              });
              return this;
            },
            rotateTo : function(angle) {
              caret.transition().duration(200).attrTween("transform",
                  function() {
                    return caretRotateTween(this, angle * 180 / Math.PI);
                  });

              return this;
            }
          };
        }
      };
    };

    return tooltip;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.Constants',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(constants) {
  var moduleConstants = {
    Type : {
      Chart : 'CHART',
      Container : 'CONTAINER',
      Supplementary : 'SUPPLEMENTARY',
      Controller : 'CONTROLLER',
      ThirdParty : 'THIRDPARTY'
    },
    CSS : {
      CLASS : {
        DATAPOINT : "datapoint"
      }
    },
    Event : {
      SelectData : {
        name: 'selectData',
        desc : 'Event fired when certain data point(s) is(are) selected, data context of selected item(s) would be passed in accordance with the following format.'
          + '<code>{name: "selectData",'
          + 'data:[{\n//selected element\'s detail\n'
          + 'target:"Dom Element",//an object pointed to corresponding dom element\n'
          + 'data:[{val: "...",//value of this element\n'
          + 'ctx:{type:"Dimension"||"Measure"||"MND",\n'
          + '//for Dimension\n'
          + 'path:{aa:"...",di:"...",dii:"..."},\n'
          + '//for Measure\n'
          + 'path:{mg:"...",mi:"...",dii_a1:"...",dii_a2:"..."},\n'
          + '//for MND\n'
          + 'path:{mg:"...",mi:"..."}\n'
          + '//path: analysis path\n'
          + '//aa: analysis axis index // 0 for analysis axis 1,  1 for analysis 2\n'
          + '//di: dimension index //zero based\n'
          + '//dii: dimension item index //zero based\n'
          + '//mg: measure group index // 0 for measure group 1,1 for measure group 2\n'
          + '//mi: measure index // measure index in measure group zero based\n'
          + '//dii_a1: each dii of di in analysis axis 1 index\n'
          + '//dii_a2: each dii of di in analysis axis 2 index\n'
          + '}},{\n//for bubble, tagcloud and scatter, there will be more than one values in one selected element.\n'
          + 'var:"...",ctx:"..."}]},{\n//if under multi selection, there will be more than one selected elements\n'
          + 'target:"...",data:["..."]}]}'
      },
      DeSelectData : {
        name: 'deselectData',
        desc : 'Event fired when certain data point(s) is(are) deselected, data context of deselected item(s) would be passed in accordance with the following format.'
          + '<code>{name: "deselectData",'
          + 'data:["---the same as selectedData---"]}'
      },
      TooltipShow : {
        name: 'showTooltip',
        desc : 'Event fired when the mouse hover onto the specific part of chart, data context of tooltip would be passed in accordance with the following format.'
          + '<code>{name:"showTooltip",data:{body:[{\n//data of one group\n'
          + 'name:"...",val:[{\n//data of one row\n'
          + 'color:"...",label:"...",shape:"...",value:"..."},"..."]},"..."],footer:[{label:"...",value:"..."},"..."],'
          + 'plotArea:{\n//this object specifies the plot area of the chart\n'
          + 'height:"...",width:"...",x:"...",y:"..."},point:{\n//this object specifies a point which affects the position of tooltip\n'
          + 'x:"...",y:"..."}}}'
      },
      TooltipHide : {
        name: 'hideTooltip',
        desc : 'Event fired when the mouse hover out of the specific part of chart, no data is passed.'
      },
      Initialized : {
        name: 'initialized',
        desc : 'Event fired when the loading ends.'
      },
      highlightedByLegend : {
        desc : "Event fired when legend item is clicked, which contains its data context."
      }   
    }
  };

  constants.Module = moduleConstants;

  return moduleConstants;
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie.sector',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(Constants, NumberUtils) {
  var CSSCLASS_SECTOR = 'viz-pie-sector';
  var pieLayout = d3.layout.pie().sort(null).value(function(d) {
    return d.v;
  });

  function SectorData(mvObject, dimValueObjects, color, r, value, startAngle,
      endAngle, p) {
    this.dimValueObjects = dimValueObjects;
    this.color = color;
    this.r = r;
    this._value = value;
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.p = p;
    this.decoras = [];

    for ( var i in mvObject) {
      if (mvObject.hasOwnProperty(i)) {
        this[i] = mvObject[i];
      }
    }
  }

  SectorData.prototype = {
    midAngle : function() {
      return (this.endAngle + this.startAngle) / 2;
    },

    dimValues : function() {
      return this.dimValueObjects.map(function(o) {
        var ret;
        if(o.info){
          var clobj = o.info.customlabel;
          if(clobj){
            if(clobj.type === 'url'){
              ret = o.val;
            }else if(clobj.type === 'string'){
              ret = clobj.val;
            }
          }else{
            ret = o.val;
          }
        }else{
          ret = o.val;
        }
        return ret;
      });
    },

    value : function(format) {
      var v = this._value;
      if (format) {
        return d3.format(format)(v);
      }
      return v;
    },

    proportion : function(format) {
      var v = (this.endAngle - this.startAngle) / (2 * Math.PI);
      if (format) {
        return d3.format(format)(v);
      }
      return v;
    }
  };

  function sectorDatas(d, effectManager) {
    var mvs = d.measure.rows[0];
    var dimensions = d.dimensions;

    var domain = [];
    var datas = mvs.map(function(mv, i) {
      domain.push(i);
      return {
        v : mv.val,
        i : i
      };
    }).filter(function(o) {
      var v = o.v;
      return (!NumberUtils.isNoValue(v)) && v > 0;
    });

    var color = d.color.domain(domain);
    var r = d.or;
    var result = pieLayout(datas).map(function(data) {
      var index = data.data.i;
      var fillID = effectManager.register({
        drawingEffect : d.drawingEffect,
        graphType : 'sector',
        fillColor : color(index),
        direction : 'vertical',
        radius : r
      });
      return new SectorData(mvs[index], dimensions.map(function(dimVs) {
        return dimVs.rows[index];
      }), fillID, r, data.value, data.startAngle, data.endAngle, d.p);
    });
    return result;
  }

  var module = function() {
    function sector(sectorGroup, effectManager) {
      var sectors = module.all(sectorGroup).data(function(d) {
        return sectorDatas(d, effectManager);
      });
      sectors.exit().remove();
      sectors.enter().append('svg:g').attr('class', 'datashape').append(
          'svg:path').attr("class",
          Constants.CSS.CLASS.DATAPOINT + ' ' + CSSCLASS_SECTOR);
      sectors.select('g.datashape path').attr("fill", function(d) {
        return d.color;
      }).attr("d", d3.svg.arc().outerRadius(function(d) {
        return d.r;
      }));
    }

    return sector;
  };

  module.all = function(sectorGroup) {
    return sectorGroup.selectAll("g.datashape");
  };

  module.cssText = function(styleManager) {
    return '.' + CSSCLASS_SECTOR + '{' + styleManager.cssText(CSSCLASS_SECTOR) +
        '}';
  };

  return module;
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie.selection',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.pie.sector',
  version : '4.0.0'
}
],
function Setup(sectorModule) {
  var selectedSectorClass = "selectedSector";
  var selectedClass = "selected";
  var selectedDataLabel;
  function select(sect, flag, noAnimation) {
    sect.classed(selectedSectorClass, flag);
    var dx = 0, dy = 0;
    if (!noAnimation) {
      sect = sect.transition().duration(200);
    }
    sect.each(function(d) {
      dx = 0, dy = 0;
      if (flag) {
        if (this.parentNode.parentNode.childNodes.length !== 1) {
          var a = d.midAngle();
          var r = d.r;
          var sectorMoveOffset;
          if (r >= 96) {
            sectorMoveOffset = 6;
          } else if (r >= 24) {
            sectorMoveOffset = 4;
          } else {
            sectorMoveOffset = 2;
          }
          dx = sectorMoveOffset * Math.sin(a);
          dy = -sectorMoveOffset * Math.cos(a);
        }
      }

      d3.select(this.parentNode).attr('transform', "translate(" + dx + "," + dy + ")");
    });
    sect.each('start', function(d){
      var transformStr = d3.select(this.parentNode).attr('transform');
      d.decoras.forEach(function(element, index, array){
          selectedDataLabel = d3.select(element);
          selectedDataLabel.transition().attr('transform', /** we can't get the value in the start of the animation d3.select(this).attr('transform')*/transformStr);    
          if(selectedDataLabel[0][0] !== null){
            if(dx === 0 && dy === 0){
              selectedDataLabel.attr('fill-opacity', null);
            }else{
              selectedDataLabel.attr('fill-opacity', '1');
            }
           }else{
            selectedDataLabel.attr('fill-opacity', '1');
           }
          }, this);   
    });
  }

  function selected(sect) {
    return sect.classed(selectedSectorClass);
  }

  return function() {
    return {
      allSelected : function(sectorGroup) {
        return sectorGroup.selectAll("." + selectedSectorClass);
      },

      select : function(s, flag) {
        select(s, flag);
      },

      clear : function(g, flag) {
        g.classed(selectedClass, flag);
      },

      defaultStyle : function(hoverSectorClass, sectorGroupClass) {
        var selectedGroupClass = "." + sectorGroupClass + "." + selectedClass;
        return selectedGroupClass + "{fill-opacity:0.4}" + " ." +
            selectedSectorClass + "," + selectedGroupClass + " ." +
            hoverSectorClass + "{fill-opacity:1}";
      },

      clearAll : function(sectorGroup) {
        sectorGroup.classed(selectedClass, false);
        this.allSelected(sectorGroup).call(select, false, true);
      }
    };
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.pie.sector',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.pie.selection',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.pie.tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(sectorModule, selectionModule, tooltip, TextUtils,
    ColorSeriesGenerator, dispatch, UADetector, FunctionUtils, TypeUtils,
    Repository, Objects, formatManager, langManager, BoundUtil) {
  var horizontalMarginRatio = 2.414;
  // Alistar zhu
  var randomSuffix = Repository.newId();
  var innerRadiusRatio = function(outerRadius) {
    // 12em
    // return outerRadius >= 12 * 14 ? horizontalMarginRatio : 1.618;
    return horizontalMarginRatio;
  };

  var padding = 6;

  var loadingAnimationDuration = 600;
  var defaultColorPalette = ColorSeriesGenerator.sap32();

  var id = "viz-pie";
  var defsId = id + "-defs" + randomSuffix;

  var clipPathIdPrefix = id + "-clipPath-";
  var wrapperClass = id, mainshapeClass = 'datashapesgroup', backgroundClass = "background", donutTitleClass = wrapperClass +
      "-donut-title", hoverSectorClass = "hoverSector", sectorGroupClass = "sectorgroup";

  var selection = selectionModule();

  var tooltipFunc = tooltip();

  var sectorFunc = sectorModule();

  var defaultStyle = "." +
      wrapperClass +
      "{font-family:'Open Sans',Arial,Helvetica,sans-serif;text-anchor:middle}" +
      "." + wrapperClass + " ." + backgroundClass + "{fill-opacity:0;}" + " ." +
      donutTitleClass +
      "{font-weight:bold;font-size:16px;fill:#333;dominant-baseline: middle}" +
      tooltipFunc.defaultStyle(wrapperClass) +
      selection.defaultStyle(hoverSectorClass, sectorGroupClass);

  function rotateTootltipBySector(d, tip, caret) {
    if (!caret) {
      caret = tip.caret();
    }
    caret.show().rotateTo(d.midAngle());
    var tipValue, tipPercentage;
    tipValue = d.value();
    tipPercentage = d.proportion();
    if (TypeUtils.isExist(d.p.tooltip.formatString)) {
      tipValue = formatManager.format(tipValue, d.p.tooltip.formatString[0]);
      tipPercentage = formatManager.format(tipPercentage,
          d.p.tooltip.formatString[1]);
    } else {
      tipValue = d.value(d.p.tooltip.valueFormat);
      tipPercentage = d.proportion(d.p.tooltip.percentageFormat);
    }

    tip.texts(d.dimValues().map(function(s) {
      return s === null ? langManager.get('IDS_ISNOVALUE') : s;
    }).join(" - "), tipValue, tipPercentage).show();
  }

  function donutTitle(wrapper) {
    var text = wrapper.selectAll("text." + donutTitleClass).data(function(d) {
      if (d.p.isDonut) {
        var title = d.measure.col;
        if (title === null) {
          title = langManager.get('IDS_ISNOVALUE');
        }

        return [ {
          width : d.ir,
          title : title
        } ];
      }

      return [];
    });
    text.exit().remove();
    text.enter().insert("svg:text", ".sectorgroup").attr("class",
        donutTitleClass);

    text.each(function(d) {
      TextUtils.ellipsisInCircle(d.title, this, d.width, 0);
    });
  }

  function calculateOuterRadiusByHeight(h) {
    return h / 2 - padding;
  }

  function calculateOuterRadiusByWidth(w) {
    return Math.max(w / 2 / (1 + 1 / horizontalMarginRatio), padding *
        horizontalMarginRatio);
  }

  function calculateOuterRadius(w, h, maxRadius) {
    if (maxRadius) {
      return Math.min(h / 2, w / 2);
    }
    return Math.min(calculateOuterRadiusByHeight(h),
        calculateOuterRadiusByWidth(w));
  }

  function calculateInnerRadius(outerRadius) {
    return outerRadius / innerRadiusRatio(outerRadius);
  }

  var clipPathArc = d3.svg.arc();

  function clipPathTween(d) {
    var clipPathInterpolate = d3.interpolateNumber(d.startAngle, d.endAngle);
    return function(t) {
      d.endAngle = clipPathInterpolate(t);
      return clipPathArc(d);
    };
  }

  function defStyles(defs, styleManager) {
    var style = d3.select(defs).selectAll("style").data(
        [ defaultStyle + sectorModule.cssText(styleManager) ]);

    style.exit().remove();
    style.enter().append("style");
    style.text(String);
  }

  function highlight(el, flag, onSector, tip, sectorGroup) {
    selection.select(TypeUtils.isArray(el) ? d3.selectAll(el) : d3.select(el),
        flag);
    if (onSector === false) {
      refreshTooltip(tip, sectorGroup);
    }
  }

  function refreshTooltip(tip, sectorGroup) {
    if (!tip) {
      return;
    }
    var selectedSectors = selection.allSelected(sectorGroup);

    if (selectedSectors.empty()) {
      tip.hide();
    } else {
      var d = sectorGroup.datum();
      if (!d.p.tooltip.visible) {
        tip.hide();
      } else {
        var sum = 0;
        var proportionSum = 0;
        var numer = 0;
        selectedSectors.each(function(d) {
          sum += d.val;
          proportionSum += d.proportion();
          numer++;
        });
        var caret = tip.caret();
        if (numer === 1) {
          rotateTootltipBySector(selectedSectors.datum(), tip, caret);
        } else {
          tip.texts(numer + " selected", d3.format(d.p.tooltip.valueFormat)
              (sum), d3.format(d.p.tooltip.percentageFormat)(proportionSum));
          caret.hide();
        }
      }
    }
  }

  var fn = function(manifest, ctx) {
    var width = null, height = null, data = null, props = manifest.props(null), colorPalette;
    var effectManager = ctx.effectManager;
    var widthFunctor, heightFunctor, propsFunctor = FunctionUtils.noop;

    var parent, sectorGroup, wrapper, tip;

    var _dispatch = dispatch("selectData", "deselectData", "initialized",
        'startToInit');

    function pie() {
      parent = this;
      BoundUtil.drawBound(parent, width, height);
      
      var root = this.node().ownerSVGElement;
      var defs = root.getElementById(defsId);
      if (!defs) {
        defs = document.createElementNS(root.namespaceURI, "defs");
        root.insertBefore(defs, root.childNodes[0]);
        defs.id = defsId;
        tooltipFunc.createShadowFilterDef(defs);

        effectManager.setContainer(d3.select(defs));
      }
      _dispatch.startToInit();
      defStyles(defs, ctx.styleManager);

      wrapper = this.selectAll("g." + wrapperClass).data(pieWrapperData(data));
      wrapper.exit().each(
          function(d) {
            document.documentElement.removeEventListener("keydown",
                d.keydownListener);
            delete d.keydownListener;
          }).remove();
      
      var enterWrapper = wrapper.enter().append("g").attr("class", wrapperClass);
      if(!props.isGeoPie){
          enterWrapper.append("g").attr("class", sectorGroupClass + " " + mainshapeClass);
      }else{
          enterWrapper.append("g").attr("class", sectorGroupClass);
      }
      


      wrapper.attr(
          "transform",
          function(d) {
            if (d.p.alignCenter) {
              return null;
            }
            return "translate(" + d.w / 2 + "," +
                (d.p.valign === "center" ? d.h / 2 : (d.or + padding)) + ")";
          }).select("." + backgroundClass).attr("width", function(d) {
        return d.w;
      }).attr("height", function(d) {
        return d.h;
      }).attr("x", function(d) {
        return -d.w / 2;
      }).attr("y", function(d) {
        return -d.h / 2;
      });

      var clipPath = wrapper.selectAll(function() {
        var result = [];
        Array.prototype.forEach.call(this.childNodes, function(node) {
          if (node.tagName === 'clipPath') {
            result.push(node);
          }
        });
        return result;
      }).data(function(d) {
        var result = [];
        var isDonut = d.p.isDonut;
        var animation = d.animation = d.p.animation.dataLoading;
        if (isDonut || animation) {
          result.push({
            innerRadius : isDonut ? d.ir : 0,
            outerRadius : d.or + padding,
            startAngle : 0,
            endAngle : Math.PI * 2,
            animation : animation
          });
        }
        return result;
      });

      clipPath.exit().remove();
      clipPath.enter().append("svg:clipPath").attr(
          "id",
          function() {
            var id, k = 0;
            while (true) {
              id = clipPathIdPrefix + (k++) + randomSuffix;
              if (!document.getElementById(id)) {
                break;
              }
            }
            this.parentNode.querySelector("." + sectorGroupClass).setAttribute(
                "clip-path", "url(#" + id + ")");
            return id;
          }).append("svg:path").attr("clip-rule", "evenodd").attr("d",
          clipPathArc);

      wrapper.call(donutTitle);
      sectorGroup = wrapper.select("g." + sectorGroupClass ).call(sectorFunc, effectManager);

      selection.clearAll(sectorGroup);

      wrapper.call(tooltipFunc, ctx.styleManager);
      tip = tooltipFunc.select(wrapper);
      if (tip) {
        tip.hide();
      }
      clipPath.filter(function(d) {
        return d.animation;
      }).select(":first-Child").transition().duration(loadingAnimationDuration)
          .each(
              "end",
              function(d) {
                var clipPathNode = this.parentNode;
                var wrapperNode = clipPathNode.parentNode;
                if (wrapperNode) {
                  if (d.innerRadius === 0) {
                    wrapperNode.removeChild(clipPathNode);
                    wrapperNode.querySelector("." + sectorGroupClass)
                        .removeAttribute("clip-path");
                  }
                  var wrapperData = d3.select(wrapperNode).datum();
                  wrapperData.animationEnd = true;
                  fireInitializedEvent(wrapperData);
                }
              }).attrTween("d", clipPathTween);

      clipPath.filter(function(d) {
        return !d.animation;
      }).select(":first-Child").attr("d", clipPathArc);

      wrapper.each(function(d) {
        d.domInitialized = true;
        fireInitializedEvent(d);
      });
    }

    function pieWrapperData(d) {
      var parentNode = this.parentNode;
      var p = propsFunctor.apply(parentNode, arguments);
      var w = widthFunctor.apply(parentNode, arguments);
      var h = heightFunctor.apply(parentNode, arguments);
      var or = calculateOuterRadius(w, h, p.maxRadius);
      var colorRange = d3.functor(colorPalette).apply(parentNode, arguments);

      var result = {
        w : w,
        h : h,
        p : p,
        or : or,
        ir : calculateInnerRadius(or),
        color : colorRange ? d3.scale.ordinal().range(colorRange)
            : defaultColorPalette.copy(),
        measure : d.getMeasureValuesGroupDataByIdx(0).values[0],
        dimensions : d.getAnalysisAxisDataByIdx(0).values
      };
      result.drawingEffect = result.p.drawingEffect;

      return [ result ];
    }

    function fireInitializedEvent(d) {
      if (d.domInitialized && (!d.animation || d.animationEnd)) {
        _dispatch.initialized({
          name : 'initialized'
        });
      }
    }
    
    pie.afterUIComponentAppear = function(){
      _dispatch.initialized(); 
    };
    
    pie.dataLabel = function(_) {
    };

    pie.parent = function() {
      return parent;
    };

    pie.clear = function(flag) {
      selection.clear(sectorGroup, flag);
      return pie;
    };

    pie.highlight = function(el, onSector) {
      highlight(el, true, onSector, tip, sectorGroup);
      return pie;
    };

    pie.unhighlight = function(el, onSector) {
      highlight(el, false, onSector, tip, sectorGroup);
      return pie;
    };

    pie.mouseover = function(el) {
      var s = d3.select(el);
      s.classed(hoverSectorClass, true);

      var d = s.datum();
      if (d.p.tooltip.visible) {
        if (tip) {
          rotateTootltipBySector(d, tip, undefined);
        }
      } else {
        if (tip) {
          tip.hide();
        }
      }
      return pie;
    };

    pie.mouseout = function(el) {
      var sect = d3.select(el);
      if (UADetector.isIE()) {
        setTimeout(function() {
          sect.classed(hoverSectorClass, false);
        }, 0);
      } else {
        sect.classed(hoverSectorClass, false);
      }

      if (!tip) {
        return;
      }

      refreshTooltip(tip, sectorGroup);
      return pie;
    };

    /**
     * get/set width
     */
    pie.width = function(_) {
      if (arguments.length === 0) {
        return width;
      }
      width = _;
      widthFunctor = d3.functor(width);
      return pie;
    };

    /**
     * get/set height
     */
    pie.height = function(_) {
      if (arguments.length === 0) {
        return height;
      }
      height = _;
      heightFunctor = d3.functor(height);
      return pie;
    };

    /**
     * get/set size
     */
    pie.size = function(w, h) {
      if (arguments.length === 0) {
        return {
          width : this.width(),
          height : this.height()
        };
      }
      pie.width(w).height(h);
      return pie;
    };

    /**
     * get/set data
     */
    pie.data = function(_) {
      if (arguments.length === 0) {
        return data;
      }
      data = _;
      return pie;
    };

    /**
     * get event dispath
     */
    pie.dispatch = function(_) {
      return _dispatch;
    };

    /**
     * get/set properties
     */
    pie.properties = function(_) {
      if (arguments.length === 0) {
        return props;
      }
      Objects.extend(true, props, _);
      propsFunctor = d3.functor(props);

      if (typeof (props) === "function") {
        colorPalette = function(d, i) {
          return propsFunctor.apply(this, arguments).colorPalette;
        };
      } else if (props.colorPalette) {
        colorPalette = props.colorPalette;
      }
      return pie;
    };

    /**
     * get/set color palette
     */
    pie.colorPalette = function(_) {
      if (arguments.length === 0) {
        return colorPalette || defaultColorPalette.range();
      }
      colorPalette = _;
      return pie;
    };
    return pie;
  };

  return fn;
});sap.riv.module(
{
  qname : 'sap.viz.modules.stackedverticalbar',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TypeUtils, ObjectUtils, dispatch, MNDHandler, tooltipDataHandler, ColorSeries, Scaler, Repository, NumberUtils, Objects, langManager, boundUtil) {
  var bar = function(manifest, ctx) {
      var tooltipDataHandlerObj;
      var data, 
          data1 = [[]],
          data2 = [[]],
          seriesData = [], tooltipData = [],
          primaryAxisTopBoundary = 0,
          primaryAxisBottomBoundary = 0,
          primaryAxisManualRange = false,
          secondaryAxisManualRange = false,
          secondaryAxisTopBoundary = 0,
          secondaryAxisBottomBoundary = 0,
          gWrapper = null;
    
      var width = undefined,
          height = undefined,
          x = 0,y = 0,
          isDualAxis = false,
          hasMNDonCategoryAxis = false,
          colorPalette = [],
          axis1ColorPalette,
          axis2ColorPalette,
          MNDInnerOnColor = false,
          measureOnAxis1 = 0,
          measureOnAxis2 = 0,
          shapePalette = ['squareWithRadius'],
          properties,
          eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized','startToInit');
    
      var effectManager = ctx.effectManager;
    
      var valueScales = new Array(2);
          xScale = d3.scale.ordinal(),
          yScale = d3.scale.linear(),
          yScale2 = d3.scale.linear();
      
      var decorativeShape, 
          lastSelected = [], 
          tooltipVisible = true,      
          lastHovered = null;
      
      var barNumber,
          barGroupNumber,
          barNumberinGroup,
          yPositions = [],
          barWidth;
    
      var defsEnter, 
          roundCornerDefs,
          suffix = Repository.newId();

      var enableDataLoadingAnimation = true,
          enableDataUpdatingAnimation = true,
          enableRoundCorner = false,
          clipEdge = true,
          isOnlyInitAnimation = false,
          afterAttachToDOM = false,
          totalIntervalTime = 800;

      var mode = 'comparison'; //bar display mode
      var drawingEffect = 'normal';
    
      var sizeChange = false, dataStructureChange = false, dataValueChange = false, firstRectDrawed = false;
    
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
        // find the closet dimension
        var i = -1;
        while (i < seriesData.length) {
          if (Math.abs(xOnModule - xScale.rangeBand()*i - 0.5 * xScale.rangeBand() ) <= 0.5 * xScale.rangeBand()) {
            break;
          }
          i++;
        }

        if (i > (seriesData.length - 1) || i < 0) {
          decorativeShape.attr('visibility', 'hidden');
          return;
        }

        decorativeShape.attr('x',xScale.rangeBand() * i + barWidth/4)
                       .attr('visibility', 'visible');

        if(lastHovered !== i){
          if (tooltipVisible){      
            lastHovered = i;
            
            //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element
            var transform = gWrapper.node().getTransformToElement(gWrapper.node().ownerSVGElement);
            var xoffset = transform.e;
            var sumAxis1 = 100, sumAxis2 = 100 , m = 0;
            var tData = tooltipDataHandlerObj.generateTooltipData(data, tooltipData, i, colorPalette, shapePalette);
            tData.point = {
              x: xScale.rangeBand()*i + 0.5 * xScale.rangeBand() + xoffset,
              y: d3.event.layerY
            };
            tData.plotArea = {
              x : transform.e,
              y : transform.f,
              width : width,
              height : height
            };
            tData.valueAxis0Count = seriesData[0][0].length;
            tData.valueAxis1Count = TypeUtils.isExist(seriesData[0][1]) ? seriesData[0][1].length:0;
            eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
          }
        }
      };
   
      
      function turnToPercentage(){
        for(var i=0, len = seriesData.length; i < len; i++){
            for(var j=0 , rowSeriesData = seriesData[i], rowTooltipData = tooltipData[i]; j < rowSeriesData.length; j++){
              var sum = 0, avaCount = 0;;
              for(var k=0; k < rowSeriesData[j].length; k++){
                sum += Math.abs(rowSeriesData[j][k].val);
                if(!rowSeriesData[j][k].isNaN) avaCount++;
              }
              if(sum === 0){
                for(var k=0; k < rowSeriesData[j].length; k++){
                        rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                        rowSeriesData[j][k].val = rowSeriesData[j][k].isNaN? 0:1/avaCount ;
                        if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                          rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : 1/avaCount;
                        }
                }
              }else{
                for(var k=0; k < rowSeriesData[j].length; k++){
                      if(rowSeriesData[j][k].val < 0){
                        rowSeriesData[j][k].isNegative = true;
                      }
                      rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                      rowSeriesData[j][k].val = Math.abs(rowSeriesData[j][k].val/sum);
                      if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                        rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : rowTooltipData[j][k].val/sum;
                      }
                }
              }
              
            }
          }
        };
      
        chart.parent = function(){
          return gWrapper;
        };
        
      chart.blurOut = function(){
        decorativeShape.attr('visibility', 'hidden');
        lastHovered = null;
        if (tooltipVisible) {
          eDispatch.hideTooltip();
        }
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
        }else{
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      
      var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        mode = properties.mode === 'percentage'? 'percentage': 'comparison';
        enableDataLoadingAnimation = properties.animation.dataLoading; 
        enableDataUpdatingAnimation = properties.animation.dataUpdating; 
        tooltipVisible = properties.tooltip.enabled;    
        if(isDualAxis && !hasMNDonCategoryAxis){
          axis1ColorPalette = properties.primaryValuesColorPalette;   
          axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
          axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }
      
        drawingEffect = properties.drawingEffect;
        colorPalette = [];
        indexforSecondaryAxis = data1.length; 
        
        if(MNDInnerOnColor){
          var flag = 0, flag2 = 0, j = 0;
          for(var i=0 ; i < seriesData[0][0].length; i++){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
            flag++;
            if(flag == measureOnAxis1 && isDualAxis && TypeUtils.isExist(seriesData[0][1])){
              flag2 = 0;
              for(; j <= seriesData[0][1].length; j++){
                if(flag2 >= measureOnAxis2){
                  flag = 0;
                  break;
                }
                colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
                flag2++;
              }
            }
          }
        }else{
          for(var i=0 ; i < seriesData[0].length; i++){
            for(var j=0; j < seriesData[0][0].length; j++){
               colorPalette.push(axis1ColorPalette[j % axis1ColorPalette.length]);
            }
            if(isDualAxis && TypeUtils.isExist(seriesData[0][1])){
                    for(var j=0; j < seriesData[0][1].length; j++){
                       colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
                    }
            }
          }  
        }       
      };
      
      function chart(selection){
        
        boundUtil.drawBound(selection, width, height);
        
        tooltipDataHandlerObj = tooltipDataHandler();
        
        //deal with percentage mode
        if(mode === 'percentage'){
          turnToPercentage();
        };
        
        // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
        if(!TypeUtils.isExist(yScale) && !TypeUtils.isExist(yScale2)){
          return;
        }
        eDispatch.startToInit();
        
        selection.each(function(){
          var indexForAxis2 = data1.length;
              barNumberinGroup = seriesData[0][0].length + ((TypeUtils.isExist(seriesData[0][1])) ? seriesData[0][1].length : 0);
          var barWidthInitial = 8 * (xScale.rangeBand()) / (9*barNumberinGroup +7 );
              barNumber = (TypeUtils.isExist(data2)) ? 2 : 1;
              barWidth = 8 * (xScale.rangeBand()) / (9*barNumber +7 );
        
          var svg = gWrapper = d3.select(this);
          
          if(decorativeShape == null){
            decorativeShape = svg.append('rect').attr('width', xScale.rangeBand() -barWidth/2).attr('height',
                height).attr('visibility', 'hidden').attr(
                'fill', 'rgba(133,133,133, 0.2)');
          }else{
            decorativeShape.attr('width', xScale.rangeBand() -barWidth/2).attr('height',height).attr('visibility', 'hidden');
          }

          if(defsEnter == null){
            defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
          }else{
            defsEnter.attr('width', width).attr('height', height);
          }  
          
          if(roundCornerDefs == null){      
            roundCornerDefs = svg.append('defs');
          }else{
            if( dataStructureChange || sizeChange || dataValueChange || !enableRoundCorner ){
              roundCornerDefs.remove();
              roundCornerDefs = svg.append('defs');
            }
          }
           
          var r = Math.log(barWidth)/Math.log(2);
          if( r < 0 ){
            enableRoundCorner = false;
          }
        
          var valueScale, tempPos = tempNeg = 0, negativeIndex = postiveIndex = 0;
          var datashapesgroup = svg.selectAll('g.datashapesgroup');
          if(!TypeUtils.isExist(datashapesgroup[0][0])){
            datashapesgroup = svg.append('g').attr('class', 'datashapesgroup');
          }
          var barGroup = datashapesgroup.selectAll('g.bar').data(seriesData);          
          barGroup.enter().append('g');
          barGroup.attr('class','bar').each(function (perGroupData, i) {
                var axisGroup = d3.select(this).selectAll('g.axisGroup').data(perGroupData);     
                axisGroup.enter().append('g');
                axisGroup.attr('class','axisGroup').each( function (perAxisData,j) {  
                  // This is for dual axis
                  var valueScale = (j == 0) ? yScale : yScale2;
                  var startPoint = (j == 0) ? barWidth /2 : (barWidth /2 + barWidth + barWidth/8);
                  var initStartPoint = (j == 0) ? xScale(i) : (xScale(i) + barWidth / 2 + barWidth) ;
                  var fillingColor =  (j == 0) ? axis1ColorPalette : axis2ColorPalette;
                  
                  // This is for pos/neg values.
                  var positiveY = 0, negativeY = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                  var yArray = [], xArray=[];
                  
                  // wrap a datashape g for each rect
                  var barShape = d3.select(this).selectAll('g.datashape').data(perAxisData);
                      barShape.enter().append('g').attr('class','datashape').append('rect').attr('class', 'datapoint');
                      barShape.exit().remove();
                      
                      // [21-Nov-2012 Nick] Keep the original x-position for each g.datashape, it is used when data value changes.
                      if(afterAttachToDOM){
                        barShape.each(function(){
                          yArray.push(this.getTransformToElement(this.parentNode).f);
                        });
                      }
                      
                      // [20-Nov-2012 Nick] As g.datashape is considered as a 'shape' concept, all positioning behavior is applied to this element
                      barShape.attr('transform', function (perRectData, m) {
                          var y ;
                          if(perRectData.val >=0 ){
                            positiveStackedValue += perAxisData[m].val;
                            positiveY = valueScale(positiveStackedValue);                          
                            y= positiveY;
                          }else{
                            negativeY = valueScale(negativeStackedValue);
                            negativeStackedValue += perAxisData[m].val;
                            y= negativeY;
                          }
                          var x = xScale(i) + startPoint;
                          xArray.push(x);
                          return 'translate('+x+','+y+')'
                      });
                      
                  var bar = barShape.select('rect.datapoint');
                      bar.attr('fill', function(d,colorIndex){  
                      d.fillColor = fillingColor[colorIndex % fillingColor.length];
                      var parameter = {
                          drawingEffect:drawingEffect,
                          fillColor : d.fillColor,
                          direction : 'horizontal'
                      };
                      return effectManager.register(parameter);
                    }).attr('shape-rendering','crispEdges').attr('fill-opacity', 1);
                    
                  if(enableDataLoadingAnimation && !isOnlyInitAnimation){
                    // [04 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                    // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                    if(dataStructureChange){
                      bar.attr('x', function(perRectData, m){
                            var x = initStartPoint - xArray[m] + barWidthInitial * m;
                            x = x + barWidthInitial/8 *(m) + barWidthInitial/2;
                            return x;
                        })
                        .attr('width', barWidthInitial) .attr('height', 0)
                        .attr('y', function (perRectData) {
                          if(perRectData.val > 0){
                            return Math.abs(valueScale(perRectData.val) - valueScale(0));
                          }else{
                            return 0
                          }
                        });
                      // [04 - Sep - 2012 Nick] Round corner enabled. Do the same transition as the bars do.
                      if(enableRoundCorner){
                        bar.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r).attr('y',  Math.abs(valueScale(perRectData.val) - valueScale(0)) + r)
                                        .attr('height',r).attr('width', barWidthInitial)
                                        .attr('x', this.x.baseVal.value)
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return 0 - r;
                                          }else{
                                            return 0;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                                        .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                                        .attr('x',0)
                                        .attr('width', barWidth);
                            return 'url(#' + id + ')' ;
                          }
                           
                        });
                      }
                      bar.transition().duration(totalIntervalTime/2)
                         .attr('height', function(perRectData){
                           if(i == 0){
                             firstRectDrawed = true;
                           }
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                         })
                         .attr('y', 0);
                      
                      bar.transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                        .attr('width', barWidth).attr('x',0)
                        .each('end', function(d, m){
                         if(firstRectDrawed == false){
                           this.setAttribute('height', Math.abs(valueScale(d.val) - valueScale(0)));
                         }
                         // Fire out event to tell the animation is done.
                         if(m === seriesData[0][0].length - 1 && i == 0){
                           completeAnimation();
                         }
                      });    
                    }else if(sizeChange){
                      bar.attr('y',function(d,k){
                          return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                        })
                        .attr('height', function(perRectData,k){
                          var newHeight = Math.abs(valueScale(perRectData.val) - valueScale(0));
                          if(parseFloat(this.height.baseVal.value) > newHeight){
                            return this.height.baseVal.value;
                          }else{
                            return newHeight;
                          }
                        });
                      var sizeChangeTransition = bar.transition();
                      sizeChangeTransition.duration(totalIntervalTime/2)
                        .attr('width', barWidth)
                        .attr('x', 0)
                        .attr('height', function(perRectData){
                          if(i == 0){
                            firstRectDrawed = true;
                          }
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                        })
                        .attr('y',0)
                        .each('end', function(d, m){
                          if(firstRectDrawed == false){
                             this.setAttribute('height', Math.abs(valueScale(d.val) - valueScale(0)));
                           }
                           // Fire out event to tell the animation is done.
                           if(m === seriesData[0][0].length - 1 && i == 0){
                             completeAnimation();
                           }
                        });
                      if(enableRoundCorner){
                        sizeChangeTransition.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var  y = parseFloat(this.y.baseVal.value);
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r)
                                        .attr('y',  function(){
                                          return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                        })
                                        .attr('height',this.height.baseVal.value + r).attr('width', this.width.baseVal.value)
                                        .attr('x', this.x.baseVal.value)
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return 0 - r;
                                          }else{
                                            return 0;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                                        .attr('x',0)
                                        .attr('width', barWidth);
                            return 'url(#' + id + ')' ;
                          }
                           
                        });
                      }
  
                    }else if(dataValueChange){
                      bar.attr('y',function(d,k){
                        return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                      })
                      var dataValueChangeTransition = bar.transition();
                      dataValueChangeTransition.duration(totalIntervalTime/2)
                         .attr('height', function(perRectData){
                           if(i == 0){
                             firstRectDrawed = true;
                           }
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                         })
                         .attr('y', 0)
                         .each('end', function(d, m){
                             if(firstRectDrawed == false){
                             this.setAttribute('height', Math.abs(valueScale(d.val) - valueScale(0)));
                           }
                           // Fire out event to tell the animation is done.
                           if(m === seriesData[0][0].length - 1 && i == 0){
                             completeAnimation();
                           }
                        });
                      if(enableRoundCorner){
                        dataValueChangeTransition.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var  y = parseFloat(this.y.baseVal.value);
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r)
                                        .attr('y',  function(){
                                          return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                        })
                                        .attr('height',this.height.baseVal.value + r).attr('width', this.width.baseVal.value)
                                        .attr('x', this.x.baseVal.value)
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return negativeY - r;
                                          }else{
                                            return positiveY;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                            return 'url(#' + id + ')' ;
                          }
                           
                        });
                      }
                    }
                    else if (enableRoundCorner){
                      bar.attr('clip-path', function(perRectData, indexinGroup){
                        if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                            var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                            var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                      .append('rect').attr('class', 'roundCorner-clip')
                                      .attr('rx', r).attr('ry', r)      
                                      .attr('y', function () {
                                        if(indexinGroup === negativeIndexes[j][i]){
                                          return 0 - r;
                                        }else{
                                          return 0;
                                        }
                                      })
                                      .attr('height',function(){
                                         return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                      })
                                      
                                      .attr('x',0)
                                      .attr('width', barWidth);
                          return 'url(#' + id + ')' ;
                        }
                     });
                      
                    }
                  }else{
                    bar.attr('y', 0).attr('x', 0)
                       .attr('width', barWidth)
                       .attr('height', function(perRectData){
                         return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                       });
                    if(enableRoundCorner){
                        bar.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r)      
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return 0 - r;
                                          }else{
                                            return 0;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                                        
                                        .attr('x',0)
                                        .attr('width', barWidth);
                            return 'url(#' + id + ')' ;
                          }
                       });
                     }
                   }
                });       
              });
          if(!enableDataUpdatingAnimation){
            isOnlyInitAnimation = true;
          }
            
          barGroup.exit().remove();
          sizeChange = false, dataValueChange = false, dataStructureChange = false, firstRectDrawed = false;
        });
        if(!enableDataLoadingAnimation)
          completeAnimation();
        
        return chart;
      }
      
      function completeAnimation(){
            eDispatch.initialized();
            afterAttachToDOM = true;
        };
      
        chart.afterUIComponentAppear = function(){
          eDispatch.initialized(); 
        };
        
    
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange = (width === value)&&!sizeChange? false:true;
          width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }  
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange? false:true;
        height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }  
         return chart;        
      };

      chart.data = function(value){
      if (!arguments.length){
          return data;
      }
      
      data = value;
      var obj = MNDHandler(data);

      var _data1 = obj["MG1"];
          var _data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
        tooltipData = [];
        
      if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
          var tempData1 = [], tempData2 = [];
          var tempStackedData1 = [], tempStackedData2 = [];
          for(var i=0; i<_data1.length; i++){
            tempData1 = [];
            tempData2 = [];
            for(var j=0; j<_data1[i].length; j++){
              if(obj.color[j] == 0){
                tempData1.push(_data1[i][j]);
                tempData2.push({
                val:null,
                hasMNDonCategoryAxis : true
              });
              }else{

                tempData1.push({
                val:null,
                hasMNDonCategoryAxis : true
              });
                tempData2.push(_data1[i][j]);
              }
            }
            tempStackedData1.push(tempData1);
            tempStackedData2.push(tempData2);
          }
          _data1 = tempStackedData1;
          _data2 = tempStackedData2;

      }else{
        hasMNDonCategoryAxis = false;
        if(TypeUtils.isExist(_data2)){
          if(! dataStructureChange && (data2.length !== _data2.length || data2[0].length !== _data2[0].length)){
                  dataStructureChange = true;
               }
          isDualAxis = true;
           }else{
              isDualAxis = false;
            }
        }
      
      if(data1.length !== _data1.length || data1[0].length !== _data1[0].length){
            dataStructureChange = true;
          }
      
      var _seriesData = dataHandler(_data1, _data2);
      seriesData = _seriesData;
        data1 = _data1;
        data2 = _data2;
      
        //judge what changed in dataset
        if(!dataStructureChange){
          dataValueChange = true;
        }
        
        if(hasMNDonCategoryAxis){
          for(var i=0; i< seriesData.length; i++){
            var temp = seriesData[i];
            if(temp[0][0].hasMNDonCategoryAxis){
              tooltipData.push(temp[1]);
            }else{
              tooltipData.push(temp[0]);
            }
          }
        }else{
          tooltipData = ObjectUtils.extend(true, {}, seriesData); 
        }
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      
      parseOptions();
      
      return chart;        
    };


    /**
     * set/get properties
    */
    chart.properties = function(props){
      if (!arguments.length){
          return properties;
       }
      Objects.extend(true, properties, props);
            parseOptions();
        
        return chart;        
    };
       

    var makeScales = function(){
      var domain = [];
      for (var i=0; i < seriesData.length; i++){
          domain.push(i);
        }
        xScale.domain(domain).rangeBands([0, width]);

        if(mode === 'percentage'){
          yScale.domain([0,1]).range([height, 0]);
          yScale2.domain([0,1]).range([height, 0]);
        }else{
          //when all data is 0 or null, we make the domain from 0 to 1
          if( primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0 ){
            yScale.domain([0,1]).range([height, 0]);
          }else{
            yScale.domain([primaryAxisBottomBoundary,primaryAxisTopBoundary]).range([height, 0]);
          }

          if(TypeUtils.isExist(data2) || isDualAxis){
          //when data of second axis is all 0 or null, we make the xScale2 same with xScale .

            if(secondaryAxisTopBoundary === 0 && secondaryAxisBottomBoundary === 0){
              yScale2.domain(yScale.domain()).range(yScale.range());
            }else{
              yScale2.domain([secondaryAxisBottomBoundary, secondaryAxisTopBoundary]).range([height, 0])
              //when data of first axis is all 0 or null, we make the xScale same with xScale2 .
              if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
                yScale.domain(yScale2.domain()).range(yScale2.range());
              }
            }
                      
            if (!primaryAxisManualRange && !secondaryAxisManualRange)
            {
                Scaler.perfectDual(yScale, yScale2);
            }
            else if(!primaryAxisManualRange && secondaryAxisManualRange)
            {
                Scaler.perfect(yScale);
            }
            else if(primaryAxisManualRange && !secondaryAxisManualRange)
            {
                Scaler.perfect(yScale2);
            }
          }else{
            if (!primaryAxisManualRange) {
              Scaler.perfect(yScale);
            }
          }
        }
        if(!TypeUtils.isExist(data2)){
            yScale2.range([0, 0]);
        }
    };

    chart.colorPalette = function(Palette){
        if (!arguments.length){
          return colorPalette;
       }
        colorPalette = Palette;
       return chart;        
    };
    
    chart.primaryDataRange = function(range){
      if (!arguments.length){
        var maxt, mint;
        if(mode === 'percentage'){
          maxt = 1;
          mint = 0;
        }else{
          mint = primaryAxisBottomBoundary < 0 ? primaryAxisBottomBoundary : 0;
          maxt = primaryAxisTopBoundary;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      if (range !== null) {
          primaryAxisTopBoundary = range.max;
          primaryAxisBottomBoundary = range.min;
          if (range.from === 'axis') {
            primaryAxisManualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            makeScales();
          }
      }
      return chart;
    };
      
      chart.secondDataRange = function(range){
        if (!arguments.length){
          var maxt, mint;
          if(mode === 'percentage'){
            maxt = 1;
            mint = 0;
          }else{
            mint = secondaryAxisBottomBoundary< 0 ? secondaryAxisBottomBoundary : 0 ;
          maxt = secondaryAxisTopBoundary;
          }
          return {
            min: mint,
            max: maxt
          };
        }
        if (range !== null) {
            secondaryAxisTopBoundary = range.max;
            secondaryAxisBottomBoundary = range.min;
            if (range.from === 'axis') {
                secondaryAxisManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
        return chart;
      };

    chart.categoryScale = function(scale){
        if (!arguments.length){
          return xScale;
       }
        xScale = scale;
       return chart;
    };
       
    chart.primaryScale = function(scale){
        if (!arguments.length){
          return yScale;
       }
        yScale = scale;
        valueScales[0] = yScale;
       return chart;
    };  
    
    chart.secondScale = function(scale){
            if (!arguments.length){
                return yScale2;
            }
            yScale2 = scale;
            valueScales[0] = yScale2;
            return chart;
        };        

      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(TypeUtils.isExist(seriesData[0][1]) && !hasMNDonCategoryAxis){
          return axis2ColorPalette[seriesData[0][1].length-1];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };  
        
      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
      
      chart.dataLabel = function(_){};
      
      chart.x = function(_){
        if(!arguments.length){
          return x;
        }
        x= _;
        return this;
      };
      
      chart.y = function(_){
        if(!arguments.length)
          return y;
        y = _;
        return this;
      };
      
      chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
//        var dataTransform = function(data1,data2){
//            var stackedBarGroup = [];
//            // the number of bar in each group
//            var barGroupNumber =  data1[0].length;;
//            var transferredDataSet = data1;
//            var temp;
//            for(var j=0; j < barGroupNumber; j++){
//                var ds = [];
//                temp = 0
//                for(i=0; i< transferredDataSet.length; i++){
//                    ds.push(transferredDataSet[i][j]);
//                    temp += transferredDataSet[i][j].val;
//                }
//                if(primaryAxisBoundary < temp){
//                    primaryAxisBoundary = temp
//                }
//                stackedBarGroup.push(ds);
//            }
//            if(TypeUtils.isExist(data2)){
//                barGroupNumber =  data2[0].length;;
//                transferredDataSet = data2;
//                for(var j=0; j < barGroupNumber; j++){
//                    temp = 0
//                    for(i=0; i< transferredDataSet.length; i++){
//                        stackedBarGroup[j].push(transferredDataSet[i][j]);
//                        temp += transferredDataSet[i][j].val;
//                    }
//                    if(secondaryAxisBoundary < temp){
//                        secondaryAxisBoundary = temp;
//                    }
//                }
//            }
//            return stackedBarGroup;
//        };
        
        
      var dataHandler = function(valueAxis1Data, valueAxis2Data, colorIndexArray){
        
        var positiveIndex = -1, negativeIndex = -1;
        positiveIndexes = [[],[]], negativeIndexes = [[],[]];
      
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        
        var stackedBarGroupsData = [];
        
      // the number of bar in each group
      barGroupNumber =  valueAxis1Data[0].length;;
      var temp, temp2;
      for(var j=0; j < barGroupNumber; j++){
        var tempDataSetAxis1 = [], tempDataSetAxis2 = [];
        var oneGroupDataSet = [];
        temp = 0, temp2 = 0;
        positiveIndex = -1, negativeIndex = -1;
        for(var i=0; i< valueAxis1Data.length; i++){
          if(NumberUtils.isNoValue(valueAxis1Data[i][j].val)){
            //Jimmy/1/9/2013, what happens if we use null as the number value
            //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
            //and http://bclary.com/2004/11/07/#a-11.8.5
            //checked in chrome/IE9/firefox/javafx, it works fine
            //the change is to ensure we display 'No Value' in other places related to this data point
            valueAxis1Data[i][j].val = null;
            valueAxis1Data[i][j].isNaN = true;
          }else{
            
            if(valueAxis1Data[i][j].val >= 0){
              temp += valueAxis1Data[i][j].val;
              positiveIndex = i;
            }else{
              temp2 += valueAxis1Data[i][j].val;
              negativeIndex = i;
            }
          }
          tempDataSetAxis1.push(valueAxis1Data[i][j]);
        }
        positiveIndexes[0].push(positiveIndex);
        negativeIndexes[0].push(negativeIndex);
        
        if(primaryAxisTopBoundary < temp){
          primaryAxisTopBoundary = temp;
        }
        if(primaryAxisBottomBoundary > temp2){
          primaryAxisBottomBoundary = temp2;
        }
        oneGroupDataSet.push(tempDataSetAxis1);
        
        
        if(TypeUtils.isExist(valueAxis2Data)){
          temp = 0, temp2 = 0;
          positiveIndex = -1, negativeIndex = -1;
          for(i=0; i< valueAxis2Data.length; i++){
            if(NumberUtils.isNoValue(valueAxis2Data[i][j].val)){
              //Jimmy/1/9/2013, what happens if we use null as the number value
              //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
              //and http://bclary.com/2004/11/07/#a-11.8.5
              //checked in chrome/IE9/firefox/javafx, it works fine
              //the change is to ensure we display 'No Value' in other places related to this data point
              valueAxis2Data[i][j].val = null;
              valueAxis2Data[i][j].isNaN = true;
            }else{
              
              if(valueAxis2Data[i][j].val >= 0){
                temp += valueAxis2Data[i][j].val;
                positiveIndex = i;
              }else{
                temp2 += valueAxis2Data[i][j].val;
                negativeIndex = i;
              }
            }
            tempDataSetAxis2.push(valueAxis2Data[i][j]);
          }
          positiveIndexes[1].push(positiveIndex);
          negativeIndexes[1].push(negativeIndex);
          
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp;
          }
          if(secondaryAxisBottomBoundary > temp2){
            secondaryAxisBottomBoundary = temp2;
          }
          oneGroupDataSet.push(tempDataSetAxis2);
        }
        stackedBarGroupsData.push(oneGroupDataSet);
      }
      
        return stackedBarGroupsData;
      };
        
      properties = manifest.props(null);
      return chart;
  };
  return bar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.background',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(Repository, dispatch, Objects, BoundUtil) {
  return function(manifest, ctx) {
 
     var CSSCLASS_BORDER = 'viz-plot-background-border',
      CSSCLASS_BACKGROUND = 'viz-plot-background';
    var randomSuffix = Repository.newId();
    var width = 0, 
      height = 0;
    var effectManager = ctx.effectManager,
      properties,
      d3root;
    var eDispatch = new dispatch('initialized');
    
    function background(selection) {
      d3root = selection;
      BoundUtil.drawBound(selection, width, height);
      
      if (properties.visible) {
        getCSSStyle();
        drawCSS();

        var d3rect = d3root.select('#' + 'background-rect-' + randomSuffix);
        if (d3rect.empty()) {
          d3rect = d3root.append('svg:rect').attr('id', 'background-rect-' + randomSuffix);
        }
        var fillID = effectManager.register({
          graphType : 'background',
          fillColor : properties.style.fillColor,
          drawingEffect : properties.drawingEffect,
          direction : properties.direction
        });
        d3rect.attr('x', 0).attr('y', 0).attr('width', width).attr('height', height).attr('fill', fillID);
        
        var borderData = [];
        if (properties.border.left.visible) {
          borderData.push({
            x1: 0, y1: 0, x2: 0, y2: height
          });
        }
        if (properties.border.right.visible) {
          borderData.push({
            x1: width, y1: 0, x2: width, y2: height
          });
        }
        if (properties.border.top.visible) {
          borderData.push({
            x1: 0, y1: 0, x2: width, y2: 0
          });
        }
        if (properties.border.bottom.visible) {
          borderData.push({
            x1: 0, y1: height, x2: width, y2: height
          });
        }
        
        var d3border = selection.selectAll("." + CSSCLASS_BORDER).data(borderData);
        d3border.enter().append('svg:line').attr('class', CSSCLASS_BORDER);
        d3border.exit().remove();
        d3border.attr('x1', function(d){return d.x1;}).attr('y1', function(d){return d.y1;})
          .attr('x2', function(d){return d.x2;}).attr('y2', function(d){return d.y2;});
      } else {
        var temp = d3root.node();
        while(temp.hasChildNodes()) {
            temp.removeChild(temp.firstChild);
        }
      }
      
      //currently, we do not have animation. If it has, should fire initialized event after animation complete.
      eDispatch.initialized();
      
      return background;
    }
    
    background.properties = function(_){
      if (!arguments.length){
        return properties;
       }
      Objects.extend(true, properties, _);
      return background;
    };
    background.size = function(_size) {
      if (arguments.length === 0) {
        return {
            "width" : width,
            "height": height
        };
      }
      width = _size.width;
      height = _size.height;
      return background;
    };
    background.width = function(_width) {
      if (arguments.length === 0) {
        return width;
      }
      width = _width;
      return background;
    };
    background.height = function(_height) {
      if (arguments.length === 0) {
        return height;
      }
      height = _height;
      return background;
    };
    background.data = function(_) {
      if(!arguments.length) {
        return {};
      }
      return background;
    };
    background.parent = function() {
      return null;
    };

    background.dispatch = function(_){
      if(!arguments.length) {
        return eDispatch;
      }
      eDispatch = _;
      return background;
    };
    
    function drawCSS () {
      var d3defs = d3root.select('#' + 'background-defs-' + randomSuffix);
      if (d3defs.empty()) {
        d3defs = d3root.insert('defs', ':first-child').attr('id', 'background-defs-' + randomSuffix);
      }
      
      var d3style = d3defs.select('style');
      if (d3style.empty()) {
        d3style = d3defs.insert('style', ':first-child');
        d3style[0][0].setAttribute('type', 'text/css');
      }
      var cssStr = '.' + CSSCLASS_BORDER + '{' + ctx.styleManager.cssText(CSSCLASS_BORDER) + '}';
      d3style[0][0].textContent = cssStr;
    }
    
    function getCSSStyle() {
      if (!properties.style) {
        properties.style = {};
      }
      var cssDef = ctx.styleManager.query(CSSCLASS_BACKGROUND);
      if (cssDef) {
        if (cssDef['fill']) {
          properties.style.fillColor = cssDef['fill'];
        }
      }
    }

    properties = manifest.props(null);
    return background;

  };
});sap.riv.module(
{
  qname : 'sap.viz.mvc.CSSParserUtility',
  version : '4.0.0'},
[

],
function Setup() {
    var CSSParserUtility = function() {
    }
    
    var cp = CSSParserUtility.prototype;
    
    /*
     * split string
     */
    cp.split = function(str, splitter) {
        if (/['"]/.test(splitter)) throw '\' " is not allowed in splitter.';
        if (str == '') return [str];
        var stack = [];
        var res = [];
        var start = 0;
        var sl = splitter.length;
        var l = str.length;
        for (var i = 0; i < l; i++) {
            var c = str.charAt(i);
            if (c == "'" || c == '"') {
                if (stack.length > 0) {
                    var c2 = stack.pop();
                    if (c != c2) {
                        stack.push(c2);
                        stack.push(c);
                    } 
                } else {
                    stack.push(c);
                }
                continue;
            }
            if (stack.length > 0) continue;
            var sub = str.substring(i, i + sl);
            if (sub == splitter) {
                res.push(str.substring(start, i));
                i = start = i + sl;
            }
        }
        if (start < l) res.push(str.substring(start));
        return res;
    }
    /*
     * is the string a color
     */
    cp.COLORS = ['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow', 'transparent'];
    cp.isColor = function(colorStr) {
        colorStr = colorStr.toLowerCase();
        //color name
        if (this.COLORS.indexOf(colorStr) >= 0) return true;
        //starts with #
        if (colorStr.charAt(0) == '#') {
            var l = colorStr.length;
            if (l != 4 && l != 7) return false;
            return ! /[^0-9a-f]/.test(colorStr.substring(1));
        }
        //rgb()
        var num = '-?[0-9\\.]+%?';
        var rgbRE = RegExp('^rgb\\(' + num + ',' + num + ',' + num + '\\)$');
        if (rgbRE.test(colorStr)) return true;
        return false;
    }
    cp.NUM_RE_STR = '[0-9]+|[0-9]*\\.[0-9]+';
    /*
     * is the string a length
     */
    cp.isLength = function(lengthStr) {
        lengthStr = lengthStr.toLowerCase();
        var lengthRE =  new RegExp('^(' + this.NUM_RE_STR + ')(em|ex|in|cm|mm|pt|pc|px)$');
        return lengthRE.test(lengthStr);
    }
    /*
     * is percentage
     */
    cp.isPercentage = function(str) {
        var re = new RegExp('^' + this.NUM_RE_STR + '%$');
        return re.test(str);
    }
    /*
     * is the string a width
     */
    cp.WIDTHS = ['thin', 'medium', 'thick'];
    cp.isWidth = function(widthStr) {
        return this.WIDTHS.indexOf(widthStr) >=0 || this.isLength(widthStr);
    }
    /*
     * is the string a border style
     */
    cp.BORDER_STYLES = ['none', 'hidden', 'dotted', 'dashed', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset'];
    cp.isBorderStyle = function(styleStr) {
        styleStr = styleStr.toLowerCase();
        return this.BORDER_STYLES.indexOf(styleStr) >= 0;
    }
    /*
     * is font style
     */
    cp.FONT_STYLES = ['italic', 'oblique'];
    cp.isFontStyle = function(str) {return this.FONT_STYLES.indexOf(str.toLowerCase()) >= 0;}
    /*
     * is font variant
     */
    cp.isFontVariant = function(str) {return 'small-caps' == str;}
    /*
     * is font weight
     */
    cp.FONT_WEIGHTS = ['bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '700', '800', '900'];
    cp.isFontWeight = function(str) {return this.FONT_WEIGHTS.indexOf(str.toLowerCase()) >= 0;}
    
    cp.TYPE_COLOR = 'color';
    cp.TYPE_WIDTH = 'width';
    cp.TYPE_BORDERSTYLE = 'borderstyle';
    cp.TYPE_FONTSTYLE = 'font-style';
    cp.TYPE_FONTVARIANT = 'font-variant';
    cp.TYPE_FONTWEIGHT = 'font-weight';
    cp.TYPE_UNKNOWN = 'unknown';
    cp.valueType = function(valStr) {
        if (this.isColor(valStr)) return this.TYPE_COLOR;
        if (this.isWidth(valStr)) return this.TYPE_WIDTH;
        if (this.isBorderStyle(valStr)) return this.TYPE_BORDERSTYLE;
        if (this.isFontStyle(valStr)) return this.TYPE_FONTSTYLE;
        if (this.isFontVariant(valStr)) return this.TYPE_FONTVARIANT;
        if (this.isFontWeight(valStr)) return this.TYPE_FONTWEIGHT;
        return this.TYPE_UNKNOWN;
    }
    
    //validator
    cp.FONT_SIZES = ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 'smaller', 'larger'];
    cp.validateFontSize = function(str) {
        return this.FONT_SIZES.indexOf(str) >=0 || this.isLength(str) || this.isPercentage(str);
    }
    cp.validateMargin = function(str) {
        return str == 'auto' || this.isLength(str) || this.isPercentage(str);
    }
    cp.validatePadding = function(str) {
        return this.isLength(str) || this.isPercentage(str);
    }
    
    return CSSParserUtility;	
});sap.riv.module(
{
  qname : 'sap.viz.mvc.CSSParser',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.mvc.CSSParserUtility',
  version : '4.0.0'
}
],
function Setup(CSSParserUtility) {
	
	/*######################### ThemeGrammarGenerated Begin*/
				/* Jison generated parser */
				var parser = (function(){
				var parser = {trace: function trace() { },
				yy: {},
				symbols_: {"error":2,"theme":3,"ruleset":4,"rule":5,"selector_list":6,"{":7,"declaration_list":8,"}":9,"selector":10,",":11,"class":12,".":13,"IDENT":14,"declaration":15,";":16,"property":17,":":18,"expr":19,"prio":20,"IMPORTANT_SYM":21,"term":22,"operator":23,"/":24,"signed_term":25,"STRING":26,"URI":27,"HASH":28,"function":29,"NUMBER":30,"PERCENTAGE":31,"LENGTH":32,"EMS":33,"EXS":34,"ANGLE":35,"TIME":36,"FREQ":37,"unary_operator":38,"FUNCTION":39,")":40,"-":41,"+":42,"$accept":0,"$end":1},
				terminals_: {2:"error",7:"{",9:"}",11:",",13:".",14:"IDENT",16:";",18:":",21:"IMPORTANT_SYM",24:"/",26:"STRING",27:"URI",28:"HASH",30:"NUMBER",31:"PERCENTAGE",32:"LENGTH",33:"EMS",34:"EXS",35:"ANGLE",36:"TIME",37:"FREQ",39:"FUNCTION",40:")",41:"-",42:"+"},
				productions_: [0,[3,1],[4,1],[4,2],[5,4],[6,1],[6,3],[10,1],[10,2],[12,2],[8,1],[8,3],[8,2],[15,3],[15,2],[17,1],[20,1],[19,1],[19,2],[19,3],[23,1],[23,1],[22,1],[22,1],[22,1],[22,1],[22,1],[22,1],[25,1],[25,1],[25,1],[25,1],[25,1],[25,1],[25,1],[25,1],[25,2],[29,3],[38,1],[38,1]],
				performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
				
				var $0 = $$.length - 1;
				switch (yystate) {
				case 1: return $$[$0];
				case 2: this.$ = [$$[$0]];
				break;
				case 3: this.$ = $$[$0-1]; this.$.push($$[$0]);
				break;
				case 4: this.$ = {selector: $$[$0-3], declaration: $$[$0-1]};
				break;
				case 5: this.$ = [$$[$0]];
				break;
				case 6: this.$ = $$[$0-2]; this.$.push($$[$0]);
				break;
				case 7: this.$ = $$[$0];
				break;
				case 8: this.$ = $$[$0-1] + $$[$0];
				break;
				case 9: this.$ = $$[$0-1] + $$[$0];
				break;
				case 10: this.$ = [$$[$0]];
				break;
				case 11:
					this.$ = $$[$0-2];
					this.$.push($$[$0]);
				break;
				case 12: this.$ = $$[$0-1];
				break;
				case 13: this.$ = { name: $$[$0-2], value: $$[$0] };
				break;
				case 14: this.$ = $$[$0-1]; this.$.important = true;
				break;
				case 18: this.$ = $$[$0-1] + ' ' + $$[$0];
				break;
				case 19: this.$ = $$[$0-2] + $$[$0-1] + $$[$0];
				break;
				case 36: this.$ = $$[$0-1] + $$[$0];
				break;
				case 37: this.$ = $$[$0-2] + $$[$0-1] + $$[$0];
				break;
				}
				},
				table: [{3:1,4:2,5:3,6:4,10:5,12:6,13:[1,7]},{1:[3]},{5:8,6:4,10:5,12:6,13:[1,7],1:[2,1]},{1:[2,2],13:[2,2]},{7:[1,9],11:[1,10]},{12:11,13:[1,7],7:[2,5],11:[2,5]},{7:[2,7],13:[2,7],11:[2,7]},{14:[1,12]},{1:[2,3],13:[2,3]},{8:13,15:14,17:15,14:[1,16]},{10:17,12:6,13:[1,7]},{7:[2,8],13:[2,8],11:[2,8]},{7:[2,9],11:[2,9],13:[2,9]},{9:[1,18],16:[1,19]},{20:20,21:[1,21],9:[2,10],16:[2,10]},{18:[1,22]},{18:[2,15]},{12:11,13:[1,7],7:[2,6],11:[2,6]},{1:[2,4],13:[2,4]},{15:23,17:15,14:[1,16],9:[2,12],16:[2,12]},{9:[2,14],21:[2,14],16:[2,14]},{21:[2,16],9:[2,16],16:[2,16]},{19:24,22:25,25:26,26:[1,27],14:[1,28],27:[1,29],28:[1,30],29:31,30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,39:[1,41],41:[1,42],42:[1,43]},{20:20,21:[1,21],9:[2,11],16:[2,11]},{22:44,23:45,25:26,26:[1,27],14:[1,28],27:[1,29],28:[1,30],29:31,24:[1,46],11:[1,47],30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,39:[1,41],41:[1,42],42:[1,43],9:[2,13],21:[2,13],16:[2,13]},{9:[2,17],16:[2,17],30:[2,17],31:[2,17],32:[2,17],33:[2,17],34:[2,17],35:[2,17],36:[2,17],37:[2,17],41:[2,17],42:[2,17],26:[2,17],14:[2,17],27:[2,17],28:[2,17],39:[2,17],24:[2,17],11:[2,17],21:[2,17],40:[2,17]},{16:[2,22],9:[2,22],21:[2,22],11:[2,22],24:[2,22],39:[2,22],28:[2,22],27:[2,22],14:[2,22],26:[2,22],42:[2,22],41:[2,22],37:[2,22],36:[2,22],35:[2,22],34:[2,22],33:[2,22],32:[2,22],31:[2,22],30:[2,22],40:[2,22]},{16:[2,23],9:[2,23],21:[2,23],11:[2,23],24:[2,23],39:[2,23],28:[2,23],27:[2,23],14:[2,23],26:[2,23],42:[2,23],41:[2,23],37:[2,23],36:[2,23],35:[2,23],34:[2,23],33:[2,23],32:[2,23],31:[2,23],30:[2,23],40:[2,23]},{16:[2,24],9:[2,24],21:[2,24],11:[2,24],24:[2,24],39:[2,24],28:[2,24],27:[2,24],14:[2,24],26:[2,24],42:[2,24],41:[2,24],37:[2,24],36:[2,24],35:[2,24],34:[2,24],33:[2,24],32:[2,24],31:[2,24],30:[2,24],40:[2,24]},{16:[2,25],9:[2,25],21:[2,25],11:[2,25],24:[2,25],39:[2,25],28:[2,25],27:[2,25],14:[2,25],26:[2,25],42:[2,25],41:[2,25],37:[2,25],36:[2,25],35:[2,25],34:[2,25],33:[2,25],32:[2,25],31:[2,25],30:[2,25],40:[2,25]},{16:[2,26],9:[2,26],21:[2,26],11:[2,26],24:[2,26],39:[2,26],28:[2,26],27:[2,26],14:[2,26],26:[2,26],42:[2,26],41:[2,26],37:[2,26],36:[2,26],35:[2,26],34:[2,26],33:[2,26],32:[2,26],31:[2,26],30:[2,26],40:[2,26]},{16:[2,27],9:[2,27],21:[2,27],11:[2,27],24:[2,27],39:[2,27],28:[2,27],27:[2,27],14:[2,27],26:[2,27],42:[2,27],41:[2,27],37:[2,27],36:[2,27],35:[2,27],34:[2,27],33:[2,27],32:[2,27],31:[2,27],30:[2,27],40:[2,27]},{9:[2,28],16:[2,28],30:[2,28],31:[2,28],32:[2,28],33:[2,28],34:[2,28],35:[2,28],36:[2,28],37:[2,28],41:[2,28],42:[2,28],26:[2,28],14:[2,28],27:[2,28],28:[2,28],39:[2,28],24:[2,28],11:[2,28],21:[2,28],40:[2,28]},{9:[2,29],16:[2,29],30:[2,29],31:[2,29],32:[2,29],33:[2,29],34:[2,29],35:[2,29],36:[2,29],37:[2,29],41:[2,29],42:[2,29],26:[2,29],14:[2,29],27:[2,29],28:[2,29],39:[2,29],24:[2,29],11:[2,29],21:[2,29],40:[2,29]},{9:[2,30],16:[2,30],30:[2,30],31:[2,30],32:[2,30],33:[2,30],34:[2,30],35:[2,30],36:[2,30],37:[2,30],41:[2,30],42:[2,30],26:[2,30],14:[2,30],27:[2,30],28:[2,30],39:[2,30],24:[2,30],11:[2,30],21:[2,30],40:[2,30]},{9:[2,31],16:[2,31],30:[2,31],31:[2,31],32:[2,31],33:[2,31],34:[2,31],35:[2,31],36:[2,31],37:[2,31],41:[2,31],42:[2,31],26:[2,31],14:[2,31],27:[2,31],28:[2,31],39:[2,31],24:[2,31],11:[2,31],21:[2,31],40:[2,31]},{9:[2,32],16:[2,32],30:[2,32],31:[2,32],32:[2,32],33:[2,32],34:[2,32],35:[2,32],36:[2,32],37:[2,32],41:[2,32],42:[2,32],26:[2,32],14:[2,32],27:[2,32],28:[2,32],39:[2,32],24:[2,32],11:[2,32],21:[2,32],40:[2,32]},{9:[2,33],16:[2,33],30:[2,33],31:[2,33],32:[2,33],33:[2,33],34:[2,33],35:[2,33],36:[2,33],37:[2,33],41:[2,33],42:[2,33],26:[2,33],14:[2,33],27:[2,33],28:[2,33],39:[2,33],24:[2,33],11:[2,33],21:[2,33],40:[2,33]},{9:[2,34],16:[2,34],30:[2,34],31:[2,34],32:[2,34],33:[2,34],34:[2,34],35:[2,34],36:[2,34],37:[2,34],41:[2,34],42:[2,34],26:[2,34],14:[2,34],27:[2,34],28:[2,34],39:[2,34],24:[2,34],11:[2,34],21:[2,34],40:[2,34]},{9:[2,35],16:[2,35],30:[2,35],31:[2,35],32:[2,35],33:[2,35],34:[2,35],35:[2,35],36:[2,35],37:[2,35],41:[2,35],42:[2,35],26:[2,35],14:[2,35],27:[2,35],28:[2,35],39:[2,35],24:[2,35],11:[2,35],21:[2,35],40:[2,35]},{25:48,30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,41:[1,42],42:[1,43]},{19:49,22:25,25:26,26:[1,27],14:[1,28],27:[1,29],28:[1,30],29:31,30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,39:[1,41],41:[1,42],42:[1,43]},{30:[2,38],31:[2,38],32:[2,38],33:[2,38],34:[2,38],35:[2,38],36:[2,38],37:[2,38],41:[2,38],42:[2,38]},{30:[2,39],31:[2,39],32:[2,39],33:[2,39],34:[2,39],35:[2,39],36:[2,39],37:[2,39],41:[2,39],42:[2,39]},{9:[2,18],16:[2,18],30:[2,18],31:[2,18],32:[2,18],33:[2,18],34:[2,18],35:[2,18],36:[2,18],37:[2,18],41:[2,18],42:[2,18],26:[2,18],14:[2,18],27:[2,18],28:[2,18],39:[2,18],24:[2,18],11:[2,18],21:[2,18],40:[2,18]},{22:50,25:26,26:[1,27],14:[1,28],27:[1,29],28:[1,30],29:31,30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,39:[1,41],41:[1,42],42:[1,43]},{30:[2,20],31:[2,20],32:[2,20],33:[2,20],34:[2,20],35:[2,20],36:[2,20],37:[2,20],41:[2,20],42:[2,20],26:[2,20],14:[2,20],27:[2,20],28:[2,20],39:[2,20]},{30:[2,21],31:[2,21],32:[2,21],33:[2,21],34:[2,21],35:[2,21],36:[2,21],37:[2,21],41:[2,21],42:[2,21],26:[2,21],14:[2,21],27:[2,21],28:[2,21],39:[2,21]},{9:[2,36],16:[2,36],30:[2,36],31:[2,36],32:[2,36],33:[2,36],34:[2,36],35:[2,36],36:[2,36],37:[2,36],41:[2,36],42:[2,36],26:[2,36],14:[2,36],27:[2,36],28:[2,36],39:[2,36],24:[2,36],11:[2,36],21:[2,36],40:[2,36]},{40:[1,51],22:44,23:45,25:26,26:[1,27],14:[1,28],27:[1,29],28:[1,30],29:31,24:[1,46],11:[1,47],30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,39:[1,41],41:[1,42],42:[1,43]},{9:[2,19],16:[2,19],30:[2,19],31:[2,19],32:[2,19],33:[2,19],34:[2,19],35:[2,19],36:[2,19],37:[2,19],41:[2,19],42:[2,19],26:[2,19],14:[2,19],27:[2,19],28:[2,19],39:[2,19],24:[2,19],11:[2,19],21:[2,19],40:[2,19]},{9:[2,37],16:[2,37],30:[2,37],31:[2,37],32:[2,37],33:[2,37],34:[2,37],35:[2,37],36:[2,37],37:[2,37],41:[2,37],42:[2,37],26:[2,37],14:[2,37],27:[2,37],28:[2,37],39:[2,37],24:[2,37],11:[2,37],21:[2,37],40:[2,37]}],
				defaultActions: {16:[2,15]},
				parseError: function parseError(str, hash) {
					throw new Error(str);
				},
				parse: function parse(input) {
					var self = this,
					stack = [0],
					vstack = [null], // semantic value stack
					lstack = [], // location stack
					table = this.table,
					yytext = '',
					yylineno = 0,
					yyleng = 0,
					recovering = 0,
					TERROR = 2,
					EOF = 1;
				
					//this.reductionCount = this.shiftCount = 0;
				
					this.lexer.setInput(input);
					this.lexer.yy = this.yy;
					this.yy.lexer = this.lexer;
					this.yy.parser = this;
					if (typeof this.lexer.yylloc == 'undefined')
						this.lexer.yylloc = {};
					var yyloc = this.lexer.yylloc;
					lstack.push(yyloc);
				
					var ranges = this.lexer.options && this.lexer.options.ranges;
				
					if (typeof this.yy.parseError === 'function')
						this.parseError = this.yy.parseError;
				
					function popStack (n) {
						stack.length = stack.length - 2*n;
						vstack.length = vstack.length - n;
						lstack.length = lstack.length - n;
					}
				
					function lex() {
						var token;
						token = self.lexer.lex() || 1; // $end = 1
						// if token isn't its numeric value, convert
						if (typeof token !== 'number') {
							token = self.symbols_[token] || token;
						}
						return token;
					}
				
					var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;
					while (true) {
						// retreive state number from top of stack
						state = stack[stack.length-1];
				
						// use default actions if available
						if (this.defaultActions[state]) {
							action = this.defaultActions[state];
						} else {
							if (symbol === null || typeof symbol == 'undefined') {
								symbol = lex();
							}
							// read action for current state and first input
							action = table[state] && table[state][symbol];
						}
				
						// handle parse error
						_handle_error:
						if (typeof action === 'undefined' || !action.length || !action[0]) {
				
							var errStr = '';
							if (!recovering) {
								// Report error
								expected = [];
								for (p in table[state]) if (this.terminals_[p] && p > 2) {
									expected.push("'"+this.terminals_[p]+"'");
								}
								if (this.lexer.showPosition) {
									errStr = 'Parse error on line '+(yylineno+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol)+ "'";
								} else {
									errStr = 'Parse error on line '+(yylineno+1)+": Unexpected " +
											(symbol == 1 /*EOF*/ ? "end of input" :
												("'"+(this.terminals_[symbol] || symbol)+"'"));
								}
								this.parseError(errStr,
									{text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
							}
				
							// just recovered from another error
							if (recovering == 3) {
								if (symbol == EOF) {
									throw new Error(errStr || 'Parsing halted.');
								}
				
								// discard current lookahead and grab another

								yyleng = this.lexer.yyleng;
								yytext = this.lexer.yytext;
								yylineno = this.lexer.yylineno;
								yyloc = this.lexer.yylloc;
								symbol = lex();
							}
				
							// try to recover from error
							while (1) {
								// check for error recovery rule in this state
								if ((TERROR.toString()) in table[state]) {
									break;
								}
								if (state === 0) {
									throw new Error(errStr || 'Parsing halted.');
								}
								popStack(1);
								state = stack[stack.length-1];
							}
				
							preErrorSymbol = symbol == 2 ? null : symbol; // save the lookahead token
							symbol = TERROR;		 // insert generic error symbol as new lookahead
							state = stack[stack.length-1];
							action = table[state] && table[state][TERROR];
							recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
						}
				
						// this shouldn't happen, unless resolve defaults are off
						if (action[0] instanceof Array && action.length > 1) {
							throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);
						}
				
						switch (action[0]) {
				
							case 1: // shift
								//this.shiftCount++;
				
								stack.push(symbol);
								vstack.push(this.lexer.yytext);
								lstack.push(this.lexer.yylloc);
								stack.push(action[1]); // push state
								symbol = null;
								if (!preErrorSymbol) { // normal execution/no error
									yyleng = this.lexer.yyleng;
									yytext = this.lexer.yytext;
									yylineno = this.lexer.yylineno;
									yyloc = this.lexer.yylloc;
									if (recovering > 0)
										recovering--;
								} else { // error just occurred, resume old lookahead f/ before error
									symbol = preErrorSymbol;
									preErrorSymbol = null;
								}
								break;
				
							case 2: // reduce
								//this.reductionCount++;
				
								len = this.productions_[action[1]][1];
				
								// perform semantic action
								yyval.$ = vstack[vstack.length-len]; // default to $$ = $1
								// default location, uses first token for firsts, last for lasts
								yyval._$ = {
									first_line: lstack[lstack.length-(len||1)].first_line,
									last_line: lstack[lstack.length-1].last_line,
									first_column: lstack[lstack.length-(len||1)].first_column,
									last_column: lstack[lstack.length-1].last_column
								};
								if (ranges) {
								  yyval._$.range = [lstack[lstack.length-(len||1)].range[0], lstack[lstack.length-1].range[1]];
								}
								r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
				
								if (typeof r !== 'undefined') {
									return r;
								}
				
								// pop off stack
								if (len) {
									stack = stack.slice(0,-1*len*2);
									vstack = vstack.slice(0, -1*len);
									lstack = lstack.slice(0, -1*len);
								}
				
								stack.push(this.productions_[action[1]][0]);	// push nonterminal (reduce)
								vstack.push(yyval.$);
								lstack.push(yyval._$);
								// goto new state = table[STATE][NONTERMINAL]
								newState = table[stack[stack.length-2]][stack[stack.length-1]];
								stack.push(newState);
								break;
				
							case 3: // accept
								return true;
						}
				
					}
				
					return true;
				}};
				/* Jison generated lexer */
				var lexer = (function(){
				var lexer = ({EOF:1,
				parseError:function parseError(str, hash) {
						if (this.yy.parser) {
							this.yy.parser.parseError(str, hash);
						} else {
							throw new Error(str);
						}
					},
				setInput:function (input) {
						this._input = input;
						this._more = this._less = this.done = false;
						this.yylineno = this.yyleng = 0;
						this.yytext = this.matched = this.match = '';
						this.conditionStack = ['INITIAL'];
						this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
						if (this.options.ranges) this.yylloc.range = [0,0];
						this.offset = 0;
						return this;
					},
				input:function () {
						var ch = this._input[0];
						this.yytext += ch;
						this.yyleng++;
						this.offset++;
						this.match += ch;
						this.matched += ch;
						var lines = ch.match(/(?:\r\n?|\n).*/g);
						if (lines) {
							this.yylineno++;
							this.yylloc.last_line++;
						} else {
							this.yylloc.last_column++;
						}
						if (this.options.ranges) this.yylloc.range[1]++;
				
						this._input = this._input.slice(1);
						return ch;
					},
				unput:function (ch) {
						var len = ch.length;
						var lines = ch.split(/(?:\r\n?|\n)/g);
				
						this._input = ch + this._input;
						this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
						//this.yyleng -= len;
						this.offset -= len;
						var oldLines = this.match.split(/(?:\r\n?|\n)/g);
						this.match = this.match.substr(0, this.match.length-1);
						this.matched = this.matched.substr(0, this.matched.length-1);
				
						if (lines.length-1) this.yylineno -= lines.length-1;
						var r = this.yylloc.range;
				
						this.yylloc = {first_line: this.yylloc.first_line,
						  last_line: this.yylineno+1,
						  first_column: this.yylloc.first_column,
						  last_column: lines ?
							  (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
							  this.yylloc.first_column - len
						  };
				
						if (this.options.ranges) {
							this.yylloc.range = [r[0], r[0] + this.yyleng - len];
						}
						return this;
					},
				more:function () {
						this._more = true;
						return this;
					},
				less:function (n) {
						this.unput(this.match.slice(n));
					},
				pastInput:function () {
						var past = this.matched.substr(0, this.matched.length - this.match.length);
						return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
					},
				upcomingInput:function () {
						var next = this.match;
						if (next.length < 20) {
							next += this._input.substr(0, 20-next.length);
						}
						return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
					},
				showPosition:function () {
						var pre = this.pastInput();
						var c = new Array(pre.length + 1).join("-");
						return pre + this.upcomingInput() + "\n" + c+"^";
					},
				next:function () {
						if (this.done) {
							return this.EOF;
						}
						if (!this._input) this.done = true;
				
						var token,
							match,
							tempMatch,
							index,
							col,
							lines;
						if (!this._more) {
							this.yytext = '';
							this.match = '';
						}
						var rules = this._currentRules();
						for (var i=0;i < rules.length; i++) {
							tempMatch = this._input.match(this.rules[rules[i]]);
							if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
								match = tempMatch;
								index = i;
								if (!this.options.flex) break;
							}
						}
						if (match) {
							lines = match[0].match(/(?:\r\n?|\n).*/g);
							if (lines) this.yylineno += lines.length;
							this.yylloc = {first_line: this.yylloc.last_line,
											last_line: this.yylineno+1,
											first_column: this.yylloc.last_column,
											last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
							this.yytext += match[0];
							this.match += match[0];
							this.matches = match;
							this.yyleng = this.yytext.length;
							if (this.options.ranges) {
								this.yylloc.range = [this.offset, this.offset += this.yyleng];
							}
							this._more = false;
							this._input = this._input.slice(match[0].length);
							this.matched += match[0];
							token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
							if (this.done && this._input) this.done = false;
							if (token) return token;
							else return;
						}
						if (this._input === "") {
							return this.EOF;
						} else {
							return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
									{text: "", token: null, line: this.yylineno});
						}
					},
				lex:function lex() {
						var r = this.next();
						if (typeof r !== 'undefined') {
							return r;
						} else {
							return this.lex();
						}
					},
				begin:function begin(condition) {
						this.conditionStack.push(condition);
					},
				popState:function popState() {
						return this.conditionStack.pop();
					},
				_currentRules:function _currentRules() {
						return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
					},
				topState:function () {
						return this.conditionStack[this.conditionStack.length-2];
					},
				pushState:function begin(condition) {
						this.begin(condition);
					}});
				lexer.options = {"flex":true,"case-insensitive":true};
				lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
				
				var YYSTATE=YY_START;
				switch($avoiding_name_collisions) {
				case 0:/*return 'S';*/
				break;
				case 1:/* ignore comments */
				break;
				case 2:/* unclosed comment at EOF */
				break;
				case 3:return 'CDO';
				
				case 4:return 'CDC';
				
				case 5:return 'INCLUDES';
				
				case 6:return 'DASHMATCH';
				
				case 7:return 26;
				
				case 8:return 'BAD_STRING';
				
				case 9:return 14;
				
				case 10:return 28;
				
				case 11:return 'IMPORT_SYM';
				
				case 12:return 'PAGE_SYM';
				
				case 13:return 'MEDIA_SYM';
				
				case 14:return 'CHARSET_SYM';
				
				case 15:return 21;
				
				case 16:return 33;
				
				case 17:return 34;
				
				case 18:return 32;
				
				case 19:return 32;
				
				case 20:return 32;
				
				case 21:return 32;
				
				case 22:return 32;
				
				case 23:return 32;
				
				case 24:return 35;
				
				case 25:return 35;
				
				case 26:return 35;
				
				case 27:return 36;
				
				case 28:return 36;
				
				case 29:return 37;
				
				case 30:return 37;
				
				case 31:return 'DIMENSION';
				
				case 32:return 31;
				
				case 33:return 30;
				
				case 34:return 27;
				
				case 35:return 27;
				
				case 36:return 'BAD_URI';
				
				case 37:return 39;
				
				case 38:return yy_.yytext;
				
				case 39:console.log(yy_.yytext);
				break;
				}
				};
				lexer.rules = [/^(?:([ \t\r\n\f]+))/i,/^(?:\/\*[^*]*\*+([^\/*][^*]*\*+)*\/)/i,/^(?:((\/\*[^*]*\*+([^\/*][^*]*\*+)*)|(\/\*[^*]*(\*+[^\/*][^*]*)*)))/i,/^(?:<!--)/i,/^(?:-->)/i,/^(?:~=)/i,/^(?:\|=)/i,/^(?:(("([^\n\r\f\\"]|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*")|('([^\n\r\f\\']|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*')))/i,/^(?:(("([^\n\r\f\\"]|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*\\?)|('([^\n\r\f\\']|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*\\?)))/i,/^(?:([-]?([_a-zA-Z]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))([_a-zA-Z0-9-]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*))/i,/^(?:#(([_a-zA-Z0-9-]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))+))/i,/^(?:@([iI])([mM])([pP])([oO])([rR])([tT]))/i,/^(?:@([pP])([aA])([gG])([eE]))/i,/^(?:@([mM])([eE])([dD])([iI])([aA]))/i,/^(?:@charset )/i,/^(?:!((([ \t\r\n\f]+)?)|(\/\*[^*]*\*+([^\/*][^*]*\*+)*\/))*([iI])([mM])([pP])([oO])([rR])([tT])([aA])([nN])([tT]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([eE])([mM]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([eE])([xX]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([pP])([xX]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([cC])([mM]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([mM])([mM]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([iI])([nN]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([pP])([tT]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([pP])([cC]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([dD])([eE])([gG]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([rR])([aA])([dD]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([gG])([rR])([aA])([dD]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([mM])([sS]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([sS]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([hH])([zZ]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([kK])([hH])([zZ]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([-]?([_a-zA-Z]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))([_a-zA-Z0-9-]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)%)/i,/^(?:([0-9]+|[0-9]*\.[0-9]+))/i,/^(?:url\((([ \t\r\n\f]+)?)(("([^\n\r\f\\"]|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*")|('([^\n\r\f\\']|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*'))(([ \t\r\n\f]+)?)\))/i,/^(?:url\((([ \t\r\n\f]+)?)(([!#$%&*-~]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*)(([ \t\r\n\f]+)?)\))/i,/^(?:((url\((([ \t\r\n\f]+)?)([!#$%&*-\[\]-~]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*(([ \t\r\n\f]+)?))|(url\((([ \t\r\n\f]+)?)(("([^\n\r\f\\"]|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*")|('([^\n\r\f\\']|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*'))(([ \t\r\n\f]+)?))|(url\((([ \t\r\n\f]+)?)(("([^\n\r\f\\"]|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*\\?)|('([^\n\r\f\\']|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*\\?)))))/i,/^(?:([-]?([_a-zA-Z]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))([_a-zA-Z0-9-]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*)\()/i,/^(?:.)/i,/^(?:.)/i];
				lexer.conditions = {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39],"inclusive":true}};
				return lexer;})();
				parser.lexer = lexer;
				function Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;
				return new Parser();
				})();
				if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
				exports.parser = parser;
				exports.Parser = parser.Parser;
				exports.parse = function () { return parser.parse.apply(parser, arguments); };
				exports.main = function commonjsMain(args) {
					if (!args[1])
						throw new Error('Usage: '+args[0]+' FILE');
					var source, cwd;
					if (typeof process !== 'undefined') {
						source = require("fs").readFileSync(require("path").resolve(args[1]), "utf8");
					} else {
						source = require("file").path(require("file").cwd()).join(args[1]).read({charset: "utf-8"});
					}
					return exports.parser.parse(source);
				};
				if (typeof module !== 'undefined' && require.main === module) {
					exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require("system").args);
				}
				}	

	/* ThemeGrammarGenerated End#########################*/

    var CSSParser = function() {
	};
    
    var cp = CSSParser.prototype;
    
    var u = new CSSParserUtility();
    
    cp._processBorderCommon = function(valStr, edges) {
        /*
        border-width
        border-style (required)
        border-color
         */
        var vals = valStr.split(' ');
        var l = vals.length;
		if ( l == 0 || l > 3) return null;
        var repos = {};
        var res = [];
        var legalTypes = [u.TYPE_COLOR, u.TYPE_WIDTH, u.TYPE_BORDERSTYLE];
        for (var i = 0; i < l; i++) {
            var val = vals[i];
            var type = u.valueType(val);
            //check duplication
            if (legalTypes.indexOf(type) < 0 || repos[type]) return null;
            repos[type] = 'XXX';
            //expand to result object
            for (var j = 0; j < edges.length; j++) {
                var name = edges[j] + '-';
                switch(type) {
                    case u.TYPE_COLOR:
                        name += 'color';
                        break;
                    case u.TYPE_WIDTH:
                        name += 'width';
                        break;
                    case u.TYPE_BORDERSTYLE:
                        name += 'style';
                        break;
                }   
                res.push({name: name, value: val});
            }
        }
        if (!repos[u.TYPE_BORDERSTYLE]) return null;
        return res;
    };
    
    cp.processBorder = function(valStr) {
        var edges = ['border-top', 'border-right', 'border-bottom', 'border-left'];
        return this._processBorderCommon(valStr, edges);
    };
    
    cp.processBorderEdge = function(valStr, border) {
        return this._processBorderCommon(valStr, [border]);
    };
    
    cp._expandAttrTo4Edges = function(valStr, attrName, vFunc, range, edges) {
        var vals = valStr.split(' ');
        var l = vals.length;
        if (l == 0 || l > 4) return null;
        var res = [];
        for (var i = 0; i < 4; i++) {
            var name = edges[i].replace('*', attrName);
            var k = i;
            k < l || (k -= 2) < l || (k -= 3) < l;
            k >= 0 || (k = 0);
            var value = vals[k];
            if (valStr != 'inherit' && !vFunc.call(range, value)) return null;
            res.push({name: name, value: value});
        }
        return res;
    };
    
    cp._processBorderAttr = function(valStr, attrName) {
        var vFunc = null;
        switch (attrName) {
            case 'color':
                vFunc = u.isColor;
                break;
            case 'width':
                vFunc = u.isWidth;
                break;
            case 'style':
                vFunc = u.isBorderStyle;
                break;
            default:
                return null;
        }
        var edges = ['border-top-*', 'border-right-*', 'border-bottom-*', 'border-left-*'];
        return this._expandAttrTo4Edges(valStr, attrName, vFunc, u, edges);
    };
    
    cp.processBorderColor = function(valStr) {
        return this._processBorderAttr(valStr, 'color');
    };
    cp.processBorderWidth = function(valStr) {
        return this._processBorderAttr(valStr, 'width');
    };
    cp.processBorderStyle = function(valStr) {
        return this._processBorderAttr(valStr, 'style');
    };
    
    cp.processFont = function(valStr) {
        var vals = u.split(valStr, ' ');
        if (vals.length < 2) return null;
        var hasHeight = valStr.indexOf('/') >= 0;
        var res = [];
        res.push({name: 'font-family', value: vals.pop()});
        var size = vals.pop();
        if (hasHeight) {
            var eles = size.split('/');
            if (eles.length != 2 || eles[1] == '') return null;
            res.push({name: 'line-height', value: eles[1]});
            size = eles[0];
        }
        if (size == '') return null;
        if (!u.validateFontSize(size)) return null;
        res.push({name: 'font-size', value: size});
        var repos = {};
        var legalTypes = [u.TYPE_FONTSTYLE, u.TYPE_FONTVARIANT, u.TYPE_FONTWEIGHT];
        for (var i = 0, l = vals.length; i < l; i++) {
            var type = u.valueType(vals[i]);
            if (legalTypes.indexOf(type) < 0 || repos[type]) return null;
            repos[type] = 'XXX';
            var name = null;
            res.push({name: type, value: vals[i]});
        }
        return res;
    };
    
    cp.processMargin = function(str) {
        var edges = ['*-top', '*-right', '*-bottom', '*-left'];
        return this._expandAttrTo4Edges(str, 'padding', u.validateMargin, u, edges);
    };
    
    cp.processPadding = function(str) {
        var edges = ['*-top', '*-right', '*-bottom', '*-left'];
        return this._expandAttrTo4Edges(str, 'margin', u.validatePadding, u, edges);
    };
    
    cp.processParentAttrs = function(declarations) {
        /*
         * according to CSS 2.1:
         * 
         * parent attributes (need expanding to children attributes)
         * border, border-bottom, border-left, border-right, border-top, border-color, border-style, border-width, font, margin, outline(TODO), padding
         * 
         * abstract attributes (no expanding needed)
         * background, list-style
         * 
         */
        var res = [];
        for ( var i = 0, l = declarations.length; i < l; i++) {
            var attr = declarations[i];
            var attrName = attr.name.toLowerCase();
            var subAttrs = attr;
            switch (attrName) {
                case 'border':
                    subAttrs = this.processBorder(attr.value);
                    break;
                case 'border-top':
                case 'border-right':
                case 'border-bottom':
                case 'border-left':
                    subAttrs = this.processBorderEdge(attr.value, attrName);
                    break;
                case 'border-color':
                    subAttrs = this.processBorderColor(attr.value);
                    break;
                case 'border-style':
                    subAttrs = this.processBorderStyle(attr.value);
                    break;
                case 'border-width':
                    subAttrs = this.processBorderWidth(attr.value);
                    break;
                case 'font':
                    subAttrs = this.processFont(attr.value);
                    break;
                case 'margin':
                    subAttrs = this.processMargin(attr.value);
                    break;
                case 'padding':
                    subAttrs = this.processPadding(attr.value);
                    break;
                default:
                    break;
            }
            if (subAttrs === attr) {
                res.push(attr);
            } else {
                for (var idx in subAttrs) {
                    subAttrs[idx].important = attr.important;
                    res.push(subAttrs[idx]);
                }
            }
        }
        return res;
    };
    /**
     * parse css string
     */
    cp.parse = function(cssText) {
        var sheet = null;
        try {
            sheet = parser.parse(cssText);
        } catch(ex) {
            alert('Parse error, please check your console output: \n' + ex);
            console.log( ex );
            console.log( ex.message );
            return null;
        }
        var records = [];
        var idx = 1;
        for (var i = 0, l = sheet.length; i < l; i++) {
            var rawRule = sheet[i];
            var des = this.processParentAttrs(rawRule.declaration);
            for (var j = 0, k = des.length; j < k; j++) {
                var record = {
                    idx: idx++,
                    selector: rawRule.selector,
                    property: des[j].name,
                    value: des[j].value,
                    important: des[j].important ? true : false
                };
                records.push(record);
            }
        }
        return records;
    };
    
    return new CSSParser();	
});sap.riv.module(
{
  qname : 'sap.viz.util.parseCSS',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.mvc.CSSParser',
  version : '4.0.0'
}
],
function Setup(CSSParser) {
  function process(attrName, value, result) {
    var subAttrs;
    attrName = attrName.toLowerCase();
    switch (attrName) {
    case 'border':
      subAttrs = CSSParser.processBorder(value);
      break;
    case 'border-top':
    case 'border-right':
    case 'border-bottom':
    case 'border-left':
      subAttrs = CSSParser.processBorderEdge(value, name);
      break;
    case 'border-color':
      subAttrs = CSSParser.processBorderColor(value);
      break;
    case 'border-style':
      subAttrs = CSSParser.processBorderStyle(value);
      break;
    case 'border-width':
      subAttrs = CSSParser.processBorderWidth(value);
      break;
    case 'font':
      subAttrs = CSSParser.processFont(value);
      break;
    case 'margin':
      subAttrs = CSSParser.processMargin(value);
      break;
    case 'padding':
      subAttrs = CSSParser.processPadding(value);
      break;
    default:
      break;
    }

    if (!subAttrs) {
      result[attrName] = value;
    } else {
      subAttrs.forEach(function(subAttr) {
        result[subAttr.name] = subAttr.value;
      });
    }
  }

  return function(css) {
    var result = {};
    for ( var selector in css) {
      if (css.hasOwnProperty(selector)) {
        var defs = css[selector];
        var rule = {};
        for ( var name in defs) {
          if (defs.hasOwnProperty(name)) {
            process(name, defs[name], rule);
          }
        }
        result[selector] = rule;
      }
    }

    return result;
  };
});sap.riv.module(
{
  qname : 'sap.viz.manifest',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils, FunctionUtils, ObjectUtils) {
  /**
   * <pre>
   * Manifest is an internal collection to store all definitions/configurations.
   * There are three built-in categories:
   *      feeds: store definitions of all feed groups
   *      module: store definitions of all modules
   *      viz: store definitions of all charts
   * </pre>
   * @module sap.viz.manifest
   * @example
   * 
   * var Manifest = sap.viz.manifest;
   * @ignore
   */

  var manifest = {};
  /**
   * <pre>
   * register a new category in manifest.
   * Once a category is registered, you can access it by Manifest[name] or Manifest.name
   * </pre>
   * @method sap.viz.manifest#registerCategory
   * @param {String}name name of the new category
   * @param {Function} factory optional and if provided,it will become "item factory function" of this category
   * @param {Object} factoryThisObj optional and if provided, it will become the object executed by item factory function
   * @returns {[Object] category} the new category {link sap.viz.manifest.xxxcategory} 
   * @example
   * manifest.registerCategory("feeds", function(obj) {
   *
   * var feeds = {};
   *  obj.feeds.forEach(function(o) {
   *    feeds[o.id] = o;
   *  });
   *
   * Object.defineProperty(obj, "feedsMap", {
   *    value : feeds,
   *    writable : false,
   *    enumerable : false,
   *    configurable : false
   *  });
   *
   *  return obj;
   * });
   * @ignore
   */
  manifest.registerCategory = function(name, factory, factoryThisObj) {
    if (!TypeUtils.isNonEmptyString(name)) {
      FunctionUtils.error("The category name must be a non-empty string.");
    }

    if (factory && !TypeUtils.isFunction(factory)) {
      FunctionUtils.error("The category factory must be a function.");
    }

    if (manifest.hasOwnProperty(name)) {
      FunctionUtils.error("There is already a category named \"{0}\"", name);
    }

    var collection = d3.map();
    /**
     * xxx represents feeds, module and viz. The three categories have been registered into manifest and could provide some common APIs. 
     * @class sap.viz.manifest.xxx
     * @ignore
     */
    var category = {
        /**
           * Load an item from category by id.</br>
           * </br>
           * If the item is a Built-in_Manifest_Objects, it will provide some other APIs.Please see the corresponding object in Built-in_Manifest_Objects.</br>
           * @see Built-in_Manifest_Objects
           * @method sap.viz.manifest.xxx#get
           * @param {String} id the id of item
           * @param {Object} throwErrorIfNull optional, a exception type
           * @returns {Object} the item loaded from category by id
           * @example
           * 
           * var moduleFeeds =  manifest.feeds.get(id);//xxx represents feeds
           * var barModule = manifest.module.get(barId);//xxx represents module
           * var lineChart = manifest.viz.get(lineChartId);//xxx represents viz
           * @ignore
           */
      get : function(id, throwErrorIfNull) {
        var result = collection.get(id);
        if (result === undefined && throwErrorIfNull) {
          FunctionUtils.error("Cannot find \"{0}\" in category \"{1}\"", id,
              name);
        }
        return result;
      },
      /**
       * <pre>
       * Iterate whole category execute callback function for every item which has been registered into xxx. 
       * </pre>
       * @method sap.viz.manifest.xxx#each
       * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
       * @param {Object} thisObj optional and default value is obj self
       * @return {Object} manifest
       * @example
       * 
       * manifest.xxx.each(function(obj, id){
       *   .... 
       * });
       * @ignore
       */
      each : function(callback, thisObj) {
        collection.forEach(function(id, obj) {
          callback.call(thisObj, obj, id);
        });
        return manifest;
      },
      
      /**
       * unregister the item with specified id from category
       * @method sap.viz.manifest.xxx#unregister
       * @param {String} id id of the item being unregistered
       * @return {Object} the removed module Object
       * @example
       * manifest.module.unregister('sap.viz.modules.bar');
       * @ignore
       */
      unregister : function (id) {
        var ret;
        if(TypeUtils.isExist(id)){
          ret = collection.get(id);
          collection.remove(id);
        }
        return ret;
      },
      
      /**
       * Register an item into category
       * @method sap.viz.manifest.xxx#register 
       * @param {Object} newItems variable parameters, at least need one item to be registered into category
       * @return {Object} manifest
       * @example
       * 
       * manifest.viz.register(chartOne);//xxx represents viz
       * ....
       * manifest.viz.register(chartOne,chartTwo,chartThree);
       * ....
       * manifest.module.register(tooltip);//xxx represents module
       * @ignore
       */
      register : function() {
        Array.prototype.forEach.call(arguments, function(obj) {
          if (TypeUtils.isUndefined(obj)) {
            FunctionUtils.error("Cannot register a undefined object.");
          }

          var idStr = obj.id;

          if (!TypeUtils.isNonEmptyString(idStr)) {
            FunctionUtils.error("Cannot register without a valid id.");
          }

          if (collection.has(idStr)) {
            FunctionUtils.error(
                "There is already an item named \"{0}\" in category \"{1}\".",
                idStr, name);
          }

          var isAbstract = obj["abstract"] === true;
          obj = ObjectUtils
              .extend(true, null, obj.base !== undefined ? category.get(
                  obj.base, true) : null, obj);

          Object.defineProperty(obj, "abstract", {
            value : isAbstract,
            enumerable : false
          });

          if (factory && !isAbstract) {
            factory.call(factoryThisObj, obj, manifest);
          }

          collection.set(idStr, obj);
        });

        return manifest;
      }
    };

    manifest[name] = category;
    return category;
  };
  
  /**
   * unregister category with the specified category name
   * @param {String} cname name of the category to be unregistered
   * @returns {Boolean} true if successfully deleted 
   * @ignore
   */
  manifest.unregisterCategory = function (cname){
    return cname in manifest && delete manifest[cname];
  };
  
  /**
   * {@link sap.viz.manifest.feeds} is a category which have been registered into manifest. It could provide some common APIs. 
   * @class sap.viz.manifest.feeds
   */
  /**
  * Load an item from {@link sap.viz.manifest.feeds}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.feeds} will provide some API.</br>
  * @method sap.viz.manifest.feeds#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
    * @returns {Object} {@link Built-in_Manifest_Objects.feedsManifest}
  * @example
  * 
  * var moduleFeeds =  manifest.feeds.get(id);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.feeds} category execute callback function for every item which has been registered into {@link sap.viz.manifest.feeds}. 
  * 
  * @method sap.viz.manifest.feeds#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.feeds}
  * @example
  * 
  * manifest.feeds.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.feeds} category
   * @method sap.viz.manifest.feeds#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.feeds}
   * @example
   * 
   * manifest.feeds.register(chartOneFeeds);
   * manifest.feeds.register(chartTwoFeeds,chartThreeFeeds);
   */
  
  /**
   * unregister an item from {@link sap.viz.manifest.feeds} category
   * @method sap.viz.manifest.feeds#unregister 
   * @param {String} id id of the feed being unregistered
   * @return {Object} the removed feed object {@link sap.viz.manifest.feeds}
   * @example
   * 
   * manifest.feeds.unregister('CHART_FEED_ID');
   */

   /**
   * {@link sap.viz.manifest.viz} is a category which have been registered into manifest. It could provide some common APIs. 
   * @class sap.viz.manifest.viz
   */
  /**
  * Load an item from {@link sap.viz.manifest.viz}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.viz} will provide some API.</br>
  * @method sap.viz.manifest.viz#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
    * @returns {Object} {@link Built-in_Manifest_Objects.vizManifest}
  * @example
  * 
  * var lineChart =  manifest.viz.get(lineChartId);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.viz} category execute callback function for every item which has been registered into {@link sap.viz.manifest.viz}. 
  * 
  * @method sap.viz.manifest.viz#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.viz}
  * @example
  * 
  * manifest.viz.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.viz} category
   * @method sap.viz.manifest.viz#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.viz}
   * @example
   * 
   * manifest.viz.register(lineChart);
   * manifest.viz.register(pieChart,radarChart);
   */
  
  /**
   * unregister an item from {@link sap.viz.manifest.viz} category
   * @method sap.viz.manifest.viz#unregister 
   * @param {String} id id of the viz being unregistered
   * @return {Object} the removed viz object {@link sap.viz.manifest.viz}
   * @example
   * 
   * manifest.viz.unregister('viz/bar');
   */

   /**
   * {@link sap.viz.manifest.module} is a category which have been registered into manifest. It could provide some common APIs. 
   * @class sap.viz.manifest.module
   */
  /**
  * Load an item from {@link sap.viz.manifest.module}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.module} will provide some API.</br>
  * @method sap.viz.manifest.module#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
    * @returns {Object} {@link Built-in_Manifest_Objects.moduleManifest}
  * @example
  * 
  * var lineModule =  manifest.viz.get(lineModuleId);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.module} category execute callback function for every item which has been registered into {@link sap.viz.manifest.module}. 
  * 
  * @method sap.viz.manifest.module#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.module}
  * @example
  * 
  * manifest.module.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.module} category
   * @method sap.viz.manifest.module#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.module}
   * @example
   * 
   * manifest.module.register(lineModule);
   * manifest.module.register(pieModule,radarModule);
   */

  /**
   * unregister an item from {@link sap.viz.manifest.module} category
   * @method sap.viz.manifest.module#unregister 
   * @param {String} id id of the module being unregistered
   * @return {Object} the removed module object {@link sap.viz.manifest.module}
   * @example
   * 
   * manifest.module.unregister('sap.viz.modules.bar');
   */
  return manifest;
});sap.riv.module(
{
  qname : 'sap.viz.TemplateManager',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.parseCSS',
  version : '4.0.0'
}
],
function Setup(manifest, FunctionUtils, TypeUtils, ObjectUtils, parseCSS) {

  function loadResource(url, cb, onError) {
    var head = document.getElementsByTagName("head")[0] ||
        document.documentElement;
    var script = document.createElement("script");
    script.type = 'text/javascript';
    script.src = url;

    var done = false;
    script.onload = script.onreadystatechange = function() {
      if (!done &&
          (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
        done = true;
        cleanScript(script);
        cb();
      }
    };
    if (script.addEventListener) {
      script.addEventListener('error', function() {
        cleanScript(script);
        onError();
      }, true);
    }

    head.insertBefore(script, head.firstChild);
  }

  function loadTemplate(loadPaths, index, templateId, cb, onError) {
    if (index < loadPaths.length) {
      var url = loadPaths[index] + templateId + '/template.js';
      var done = function() {
        loadTemplate(loadPaths, index + 1, templateId, cb, onError);
      };
      loadResource(url, done, done);
    } else {
      var template = get(templateId);
      if (template) {
        cb(template);
      } else {
        onError();
      }
    }
  }

  function load(templateId, cb) {
    loadTemplate(manager.loadPath, 0, templateId, cb, function() {
      FunctionUtils.error('Loading template {0} failed.', templateId);
    });
  }

  function cleanScript(script) {
    script.onload = script.onreadystatechange = null;
    script.parentNode.removeChild(script);
  }

  var templateCategory = manifest.registerCategory("template", function(obj) {
    obj.css = parseCSS(obj.css);
    Object.defineProperties(obj, {
      props : {
        value : function(vizId) {
          var properties = obj.properties;
          if (properties) {
            return properties[vizId];
          }
        }
      }
    });
    return obj;
  });

  var current;

  function get(id) {
    return templateCategory.get(id);
  }

  function onTemplateChanged(template, cb, thisObj) {
    current = template;
    if (cb) {
      cb.call(thisObj, current);
    }
  }

  var defaultTemplateId = "default", defaultTemplate = {
    id : defaultTemplateId,
    name : "Default"
  };
  var manager =
  /** @lends sap.viz.TemplateManager */
  {
    /**
     * @constructs
     */
    constructor : function() {
      return;
    },
    /**
     * The file paths of templates folder. {@link sap.viz.TemplateManager} will
     * discover available templates in this folder.
     * 
     * @default ["../../../resources/templates/"]
     */
    loadPath : [ "../../../resources/templates/" ],
    /**
     * Return current applied template.
     * 
     * @returns {Object} the manifest of template
     */
    current : function() {
      return current;
    },
    /**
     * Apply(switch) a template.
     * 
     * @param {String}
     *          id the template id
     * @param {Function}
     *          [cb] the call back function. It will be executed after template
     *          is applied successfully with current template as parameter. *
     * @param {Object}
     *          [thisObj] "this" object during calling call beck function.
     * 
     * @returns {Object} {@link sap.viz.TemplateManager}
     */
    apply : function(id, cb, thisObj) {
      var template = get(id);
      if (!template) {
        load(id, function(template) {
          onTemplateChanged(template, cb, thisObj);
        });
      } else {
        onTemplateChanged(template, cb, thisObj);
      }

      return manager;
    },
    /**
     * Register new templates.
     * 
     * @param {Object...}
     *          templates the template descriptors(may be multiple).
     * 
     * @returns {Object} {@link sap.viz.TemplateManager}
     */
    register : function() {
      templateCategory.register.apply(templateCategory, arguments);
      return manager;
    },
    /**
     * Extend/modify an existing template.
     * 
     * @param {String}
     *          id the template id
     * @param {Object}
     *          obj the extended part.
     * 
     * @returns {Object} {@link sap.viz.TemplateManager}
     */
    extend : function(id, obj) {
      var template = templateCategory.get(id, true);
      ObjectUtils.extend(true, template, obj);
      return manager;
    }
  };

  delete manager.constructor;

  var apiProp = {
    writable : false,
    configurable : false
  };
  Object.defineProperties(manager, {
    loadPath : {
      configurable : false
    },
    current : apiProp,
    apply : apiProp,
    register : apiProp
  });

  manager.register(defaultTemplate);
  current = get(defaultTemplateId);
  return manager;
});sap.riv.module(
{
  qname : 'sap.viz.StyleManager',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
}
],
function Setup(ObjectUtils) {
  function StyleDef(rule) {
    ObjectUtils.extend(this, rule);
  }

  StyleDef.prototype.toString = function() {
    var str = "", i;

    for (i in this) {
      if (this.hasOwnProperty(i)) {
        str += i + ":" + this[i] + ";";
      }
    }

    return str;
  };

  function StyleManager() {
    this.style = {};
    this.defaultStyle = {};
  }

  StyleManager.prototype.update = function(cssObj) {
    ObjectUtils.extend(true, this.style, cssObj);
  };

  StyleManager.prototype.setDefault = function(cssObj) {
    this.defaultStyle = ObjectUtils.extend(true, null, cssObj, this.defaultStyle);
  };

  StyleManager.prototype.query = function(classNames,  backupStyle) {
    
    if (/\./.test(classNames)) {
      throw '. is not allowed';
    }
    var cls = classNames.split(' ');

    var cssValueObj = {};
    for ( var i = 0, l = cls.length; i < l; i++) {
      if (cls[i] === '') {
        continue;
      }

      ObjectUtils.extend(cssValueObj, this.defaultStyle['.' + cls[i]], backupStyle, this.style['.' + cls[i]]);
    }

    return new StyleDef(cssValueObj);
  };

  StyleManager.prototype.cssText = function(classNames) {
    return this.query(classNames).toString();
  };

  return StyleManager;
});sap.riv.module(
{
  qname : 'sap.viz.config',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(FunctionUtils) {
  
  var configs = {};
  
  var enableCanvg = false; 
  
  var manager = {
      
      constructor : function(){
        return;
      },
      
      enableCanvg : function(_) {
          if(!arguments.length){
            return enableCanvg;
          }
          enableCanvg = _;
          return manager;
      },
      
      register : function(obj) {
          if(configs[obj.id]){
            return;
          }
          configs[obj.id] = obj.value;
          return manager;
      },
        
      get: function(ids){
        if(configs[ids]){
          return configs[ids];
        }
      }
  };
  
  return manager;
});sap.riv.module(
{
  qname : 'sap.viz.util.EffectManager',
  version : '4.0.0'},
[

],
function Setup(){

  /**
   * 
   * @param svgdef d3 svg defs to store all gradient effect
   * @return TODO: add desc
   */
  function EffectManager(svgdef, enableGhostEffect){
    this._defs  = svgdef;
    this._enableGhostEffect = enableGhostEffect;
  }

  function color2hex(color) {
    var hex;
    if(color !== undefined && typeof(color) === 'object') {
      if (color.rgb) {
        hex = color.rgb().toString();
      } else {
        hex = color.toString();
      }
    } else if (typeof(color) === 'string') {
      hex = d3.rgb(color.toLowerCase()).toString();
    }
    return hex;
  }
  
  function rgb2gray (hex) {
    var r = parseInt(hex.substr(1, 2), 16);
    var g = parseInt(hex.substr(3, 2), 16);
    var b = parseInt(hex.substr(5, 2), 16);

    var gstr;
    if ((r === g) && (g === b)) {
      gstr = (Math.round(256 + r + (255 - r)*0.6).toString(16)).substr(1);
    } else {
      var gray = (r*299 + g*587 + b*114 + 500) / 1000;
      gstr = (Math.round(256 + gray).toString(16)).substr(1);
    }
    return '#' + gstr + gstr + gstr;
  }

  function increaseBrightness(hex, percent) {
    var r = parseInt(hex.substr(1, 2), 16);
    var g = parseInt(hex.substr(3, 2), 16);
    var b = parseInt(hex.substr(5, 2), 16);

    var temp;
    if (percent >= 0) {
      temp = '#';
      temp += (Math.round(256 + r + (255 - r) * percent / 100).toString(16)).substr(1);
      temp += (Math.round(256 + g + (255 - g) * percent / 100).toString(16)).substr(1);
      temp += (Math.round(256 + b + (255 - b) * percent / 100).toString(16)).substr(1);
      return temp;
    } else {
      temp = '#';
      temp += (Math.round(256 + r * (100 + percent) / 100).toString(16)).substr(1);
      temp += (Math.round(256 + g * (100 + percent) / 100).toString(16)).substr(1);
      temp += (Math.round(256 + b * (100 + percent) / 100).toString(16)).substr(1);
      return temp;
    }
  }
  
  function drawGlossySector(d3defs, id, fillColor, radius) {
    var c0 = fillColor;
    var c2 = increaseBrightness(c0, 50);
    var c3 = increaseBrightness(fillColor, -30);

    var d3rg = d3defs.append('radialGradient');
    var rg = d3rg[0][0];
    rg.setAttribute('id', id);
    rg.setAttribute('cx', 0);
    rg.setAttribute('cy', 0);
    rg.setAttribute('r', radius);
    rg.setAttribute('fx', 0);
    rg.setAttribute('fy', 0);
    rg.setAttribute('gradientUnits',"userSpaceOnUse");
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 0).attr("stop-color", c2);
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 0.9).attr("stop-color", c0);
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 1).attr("stop-color", c3);
  }
   
  function drawGlossyCircle(d3defs, id, fillColor) {
    var c0 = fillColor;
    var c1 = increaseBrightness(c0, 10);
    var c2 = increaseBrightness(c0, 80);

    var d3rg = d3defs.append('radialGradient');
    var rg = d3rg[0][0];
    rg.setAttribute('id', id);
    rg.setAttribute('cx', '50%');
    rg.setAttribute('cy', '50%');
    rg.setAttribute('r', '50%');
    rg.setAttribute('fx', '50%');
    rg.setAttribute('fy', '20%');
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 0).attr("stop-color", c2);
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 0.7).attr("stop-color", c1);
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 0.9).attr("stop-color", c0);
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 1).attr("stop-color", c0);
  }

  function drawGlossyRectangle(d3defs, id, fillColor, direction) {
     var c1 = increaseBrightness(fillColor, 30);
     var c2 = increaseBrightness(fillColor, 50);
     var c3 = increaseBrightness(fillColor, -10);
     var c4 = increaseBrightness(fillColor, 10);
     var gradient = d3defs.append("svg:linearGradient").attr("id", id).attr("x1", "0%").attr("y1", "0%");
     if(direction === 'horizontal') {
       gradient.attr("y2", "0%").attr("x2", "100%");
     } else {
       gradient.attr("y2", "100%").attr("x2", "0%");
     }
     
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 0).attr("stop-color", c1);
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 0.2).attr("stop-color", c2);
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 0.8).attr("stop-color", c3);
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 1).attr("stop-color", c4);
  }

  function drawGlossyBackground(d3defs, id, fillColor, direction) {
     var gradient = d3defs.append("svg:linearGradient").attr("id", id);
     if(direction === 'horizontal') {
       gradient.attr("x1", "100%").attr("y1", "0%").attr("x2", "0%").attr("y2", "0%");
     } else {
       gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
     }
     
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 0).attr("stop-color", '#ffffff');
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 1).attr("stop-color", fillColor);
  }

  
  function getFillElementId(parameters, color)
  {
    var id;
    if(parameters.drawingEffect === "glossy")
    {
      switch(parameters.graphType)
      {
      case 'sector':
        id = parameters.drawingEffect + parameters.graphType + color.slice(1) + Math.round(parameters.radius);
        break;
      case 'circle':
        id = parameters.drawingEffect + parameters.graphType + color.slice(1);
        break;
      case 'triangle-up' :
      case 'triangle-down' :
        id = parameters.drawingEffect + 'triangle' + color.slice(1) + 'vertical';
        break;
      case 'triangle-left' :
      case 'triangle-right' :
        id =  parameters.drawingEffect + 'triangle' + color.slice(1) + 'horizontal';
        break;
      case 'rectangle' :
      case 'diamond' :
      case 'cross' :
      case 'star' :
      case 'intersection' :
      case 'background' :
        id =  parameters.drawingEffect + 'rectangle' + color.slice(1) + parameters.direction;
        break;
      default :
        id =  parameters.drawingEffect + 'rectangle' + color.slice(1) + parameters.direction;
        break;
      case 'line' :
        id = null;
        break;
      }
    }

    return id;

  }
  /**
   * 
   * @param parameters
   * {
   *   graphType: 'circle','square','diamond'.....
   *   drawingEffect,
   *   fillColor,
   *   direction,  "horizontal" means left to right. "vertical" means top to bottom
   * }
   * @return id to use in "fill"
   */

  EffectManager.prototype.register = function(parameters)
  {
    var originalColor = parameters.fillColor;

    if (this._enableGhostEffect) {
      originalColor = color2hex(originalColor);
      originalColor = rgb2gray(originalColor);
    }

    var color = color2hex(originalColor);
    var id = getFillElementId(parameters, color);
    if(!id) { return originalColor; }

    var element = this._defs.select("#" + id);
    if(element.empty())
    {
      if(parameters.drawingEffect === "glossy") {
        switch (parameters.graphType)
        {
        case 'background' : 
          drawGlossyBackground(this._defs, id, color, parameters.direction);
          break;
         case 'sector' :
          drawGlossySector(this._defs, id, color, parameters.radius);
          break;
         case 'circle' :
          drawGlossyCircle(this._defs, id, color, parameters.direction);
          break;
         case 'triangle-up' :
         case 'triangle-down' :
          drawGlossyRectangle(this._defs, id, color, 'vertical');
          break;
         case 'triangle-left' :
         case 'triangle-right' :
          drawGlossyRectangle(this._defs, id, color, 'horizontal');
          break;
         case 'rectangle' :
         case 'diamond' :
         case 'cross' :
         case 'star' :
         case 'intersection' :
           drawGlossyRectangle(this._defs, id, color, parameters.direction);
           break;
         default :
          drawGlossyRectangle(this._defs, id, color, parameters.direction);
          break;
         }
       } else {
            return color;
       }
     }
     return "url(#" + id + ")";
     
   };
   
   EffectManager.prototype.setContainer = function(container){
    this._defs = container;
  };

  EffectManager.prototype.ghostEffect = function(_){
    if(!arguments.length) {
      return this._enableGhostEffect;
    }
    this._enableGhostEffect = _;
  };
  return EffectManager;
});sap.riv.module(
{
  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils, FunctionUtils){


   /**
    * @name sap.viz.data.MultiAxesDataAdapter
    * @constructor
      */
   function MultiAxesDataAdapter(bindingInfo){
     this._bindingInfo = bindingInfo;
     this._aa  = [];
     this._mg  = [];
     this._fakeData = false;
     this._dataPointCount = 0;
     this._emptyDataset = false;
   }
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#addAnalysisAxis
    * @function
    * @param {Object} aa
    */
   MultiAxesDataAdapter.prototype.addAnalysisAxis = function(aa){
        if(aa){
           this._aa.push(aa);
        }
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#addMeasureValuesGroup
    * @function 
    * @param {Object} mg
    */
   MultiAxesDataAdapter.prototype.addMeasureValuesGroup = function(mg){
        if(mg){
          this._mg.push(mg);
        }
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#getAnalysisAxisDataByIdx
    * @function 
    * @param {Object} index
    */
   MultiAxesDataAdapter.prototype.getAnalysisAxisDataByIdx = function(idx){
     if(!arguments.length){
        return this._aa;
     }
     
     for(var i = 0; i < this._aa.length; i++){
       if(this._aa[i].index === idx){
          return this._aa[i];
       }
     }
     
     return null;
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#getMeasureValuesGroupDataByIdx
    * @function 
    * @param {Object} index
    */
   MultiAxesDataAdapter.prototype.getMeasureValuesGroupDataByIdx = function(idx){
     if(!arguments.length){
        return this._mg;
     }
     
     for(var i = 0; i < this._mg.length; i++){
       if(this._mg[i].index === idx){
          return this._mg[i];
       }
     }
     
     return null;
   };
   
   MultiAxesDataAdapter.prototype.createDataAdapterForModule = function(ctx){
     
      var subDataAdapter = new MultiAxesDataAdapter();
      var i;
      if(ctx && ctx.aa){
        for(i = 0; i < ctx.aa.length; i++){
          var aa = this.getAnalysisAxisDataByIdx(ctx.aa[i] - 1);
          if(aa){
             subDataAdapter.addAnalysisAxis({index:i, values: aa.values});
          }
        } 
      }
      
      if(ctx && ctx.mg){
        for(i = 0; i < ctx.mg.length; i++){
          var mg = this.getMeasureValuesGroupDataByIdx(ctx.mg[i] - 1);
          if(mg){
             subDataAdapter.addMeasureValuesGroup({index: i, values: mg.values});
          }
        }
      }
      
      return subDataAdapter;
     
   };
   
   MultiAxesDataAdapter.prototype.getBindingInfo = function(){
        return this._bindingInfo;
   };
   
   MultiAxesDataAdapter.prototype.fakeData = function(_){
     if (!arguments.length){
         return this._fakeData;
     }
     
     this._fakeData = _;
   };
   

   MultiAxesDataAdapter.prototype.dataPointCount = function(_){
     if (!arguments.length){
       return this._dataPointCount;
     }
     
     this._dataPointCount = _;
   };
   
   MultiAxesDataAdapter.prototype.emptyDataset = function(_){
     if (!arguments.length){
         return this._emptyDataset;
     }
     
     this._emptyDataset = _;
   };
   
   return MultiAxesDataAdapter;
   
});sap.riv.module(
{
  qname : 'sap.viz.data.handler.BaseDataHandler',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
 function Setup(FunctionUtils, TypeUtils, langManager){
 
   
   /**
    * determine which feed should be appended with MeasureNamesDimension 
    * @param feeds feeds Array
    * @returns feedId  to auto feed mnd
    */
   function determineMNDFeed(feeds){
     
     var dimensionFeed = [];
     var allFeeded = true;
     //first to see if MND is manually feeded
     var i = 0;
     for(; i < feeds.length; i++){
       var feed = feeds[i];
       if(feed.type() === "Dimension" && feed.acceptMND() >= 0){
         if(feed.hasMNDFeeded()){
            return feed.feedId();
         }else if(feed.getDataCount() < feed.max()){
           dimensionFeed[feed.acceptMND()] = feed;
           if(allFeeded){
              allFeeded = feed.hasFeeded();
           }
         }
           
       } 
     }
     
     if(dimensionFeed.length === 0){
        return "";
     }
     
     //Second, see which feed should be auto feeded MND
     //case 1: all feeds has been feeded, decide by mndPriority
     
     if(allFeeded){
        return dimensionFeed[dimensionFeed.length - 1].feedId();
     }
      
     //case 2: not all feeds has been feeded, feed MND to non-feeded feed with highest priority
     for(i = dimensionFeed.length - 1; i >= 0; i--){
       if(dimensionFeed[i] && !dimensionFeed[i].hasFeeded()){
          return dimensionFeed[i].feedId();
       }
     }
     
     return "";
   }
   
   /**
    * return a validate value according to val passed by user
    * 1 if val is string, just return
    * 2 if val is number, convert to string , return
    * 3 if val is other type, return null
    * 
    */
   function validateStringValue(val){
     if(TypeUtils.isString(val)){
        return val;
     }else if(TypeUtils.isNumber(val)){
        return val.toString();
     }else{
        return null;
     }
   }
   
   /**
    * return a validate value according to val passed by user
    * 1 if val is number, just return
    * 2 if val is string, convert to number , return
    * 3 if val is other type, return null
    * 
    */
   function validateNumberValue(val){
     if(TypeUtils.isNumber(val)){
        return parseFloat(val);
     }else{
        return null;
     }
   }
   
   function initDataPointUpperLimit(rawData, upperLimit){
       var limit = [ Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
       
       var rawDataCount = rawData.getDataPointCount();
       if(upperLimit === Number.POSITIVE_INFINITY || !TypeUtils.isNumber(upperLimit) || upperLimit >= rawDataCount){
          return limit;
       }
       
       //get total measure values count
       var mvCount = 0;
       var mvgCount = rawData.getMeasureValuesGroupCount();
       for(var i = 0; i < mvgCount; i++){
         mvCount += rawData.getMeasureValuesGroupByIdx(i).getMeasureValues().length;
       }
       
       //limit of one measure value
       var mvLimit = Math.floor(upperLimit / mvCount);
       
       var aaCount = rawData.getAnalysisAxisCount();
       if(aaCount === 0 || aaCount === 1){
          limit[0] = mvLimit; 
       }else if(aaCount === 2){
         var mv = rawData.getMeasureValuesGroupByIdx(0).getMeasureValues()[0];
         //var aa2Point = mv.getValues().length;
         var aa1Point = mv.getValues()[0].length;
         if(mvLimit/aa1Point < 1){
           limit[0] = mvLimit;
           limit[1] = 1;
         }else{
           limit[1] = Math.floor(mvLimit/aa1Point);
         }
       }
       
       return limit;
   }
   
   function BaseDataHandler(feeder, rawData, upperLimit){
          this._feeder  = feeder;
          this._feeds   = feeder.getFeeds();
          this._mndFeed = determineMNDFeed(this._feeds);
          this._limit = initDataPointUpperLimit(rawData, upperLimit);
   }
   
   
   BaseDataHandler.prototype.getFeedValues = function(feedId){
      var feed = this._feeder.findFeed(feedId);
      if(!feed){
         FunctionUtils.error('could not find feed definition of ' + feedId );
      }
      
      if(feed.type() === "Dimension"){
         return this.getDimensionFeedValues(feed);
      }else if(feed.type() === "Measure"){
         return this.getMeasureFeedValues(feed);
      }
     
   };
   
   
   BaseDataHandler.prototype.getDimensionFeedValues = function(feed){
     
      var feedValues = [];
      var hasManualMND = false;
      
      var datas = feed.data();
      
      var obj;
      
      var mndDefaultString = langManager.get('IDS_DEFAULTMND');
      if(datas.length > 0){
        
        for(var i = 0; i < datas.length; i++ ){
          var data = datas[i];
       
          if(data){
            if(data.getType() === "measureNamesDimension"){ 
                obj = {};
                
                //col
                obj['col'] = {'val': mndDefaultString};
                obj['type'] = 'MND';
                
                obj['rows'] = this.getMeasureNamesValues(); 
                feedValues.push(obj);
                hasManualMND = true;
                
            }else if(data.getType() === "analysisAxis"){
              
              var dimensionLabels = data.getDimensionLabels();
              var aaIndex = this._feeder.getAnalysisAxisIndex(feed);
              
              for(var j = 0 ; j < dimensionLabels.length; j++){
                  obj = {};
                  
                  //col
                  obj['col'] = {'val': validateStringValue(dimensionLabels[j].getId())};
                  //rows
                  var rows = [];
                  var values =  dimensionLabels[j].getValues();
                  var infos =  dimensionLabels[j].infos();
                  var limit = values.length;
                  if(this._limit[aaIndex] !== Number.POSITIVE_INFINITY){
                     limit = this._limit[aaIndex];
                  }
                  
                  for(var k = 0; k < limit; k++){
                        var value = { 'val':validateStringValue(values[k]), 
                                      'ctx': {
                                                          'type' : 'Dimension',
                                                          'path': {
                                                                     'aa': aaIndex,
                                                                     'di':  j,
                                                                     'dii': k  }
                                                         }
                                                };
                        
                        if(TypeUtils.isExist(infos)){
                           value.info = infos[k];
                        }
                        
                    rows.push(value);
     
                  }
                  
                  obj['rows'] = rows;
                    
                  feedValues.push(obj);
               }                
            }else{
              FunctionUtils.error('wrong type when getting data');
            } 
          }
          
        }
      }
     
      if(feed.feedId() === this._mndFeed && hasManualMND === false){
          //col
          obj = {};
          obj['col'] = {'val': mndDefaultString};
          obj['type'] = 'MND';
          
          obj['rows'] = this.getMeasureNamesValues();
          
          feedValues.unshift(obj);
      }
      
      return feedValues.length > 0 ? feedValues : null;
   };
   
     BaseDataHandler.prototype.getMeasureFeedValues = function(feed){
       var feedValues = [];
       var measureValues = feed.getMeasureValues();
         var mgIndex = this._feeder.getMeasureValuesGroupIndex(feed);
         for(var i = 0; i < measureValues.length; i++){
                 var obj = {};
                 
                 //col
                 obj['col'] =  validateStringValue(measureValues[i].getId());
                 
                 //rows
                 var rows = [];
                 var values =  measureValues[i].getValues(); //values is an aa2 * aa1 array;
                 //aa2
                 var aa2Limit = values.length;
                 if(this._limit[1] !== Number.POSITIVE_INFINITY){
                    aa2Limit = this._limit[1];
                 }
                 
                 for(var j = 0; j < aa2Limit; j++){
                   var value = values[j];
                   var row = [];
                   //aa1
                   var aa1Limit = value.length;
                   if(this._limit[0] !== Number.POSITIVE_INFINITY){
                      aa1Limit = this._limit[0];
                   }
                   
                   for(var k = 0; k < aa1Limit; k++){
                    
                     row.push({'val': validateNumberValue(value[k]), 'ctx': {
                                                    'type' : 'Measure',
                                                    'path': {
                                                      'mg'     :  mgIndex,
                                                      'mi'     :  i,
                                                      'dii_a1' :  k, 
                                                      'dii_a2' :  j
                                                    }
                                                       }
                               });
                   }
                   
                   rows.push(row);
                 }
                 
                 obj['rows'] = rows;
                 
                 feedValues.push(obj);
         }
         
          return feedValues.length > 0 ? feedValues : null;
   };
   
   
     BaseDataHandler.prototype.getMeasureNamesValues = function(){
       var values = [];
     var mgFeeds = this._feeder.getMeasureValuesGroupFeeds();
     for(var i = 0; i < mgFeeds.length; i++){
       if(mgFeeds[i].hasFeeded()){   
           var mvs = mgFeeds[i].getMeasureValues();
           for(var j = 0; j < mvs.length; j++){
             values.push({'val':validateStringValue(mvs[j].getId()),'ctx': { 'path' : {'mg': i, 'mi': j}}});
           }   
         }    
       }  
     
     return values;
   };
   
   return BaseDataHandler;
 });sap.riv.module(
{
  qname : 'sap.viz.data.handler.MeasureDataHandler',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],

function Setup(FunctionUtils){
  
  var MeasureValuesDataHandler = {
      
      makeMeasureValues: function(ctx, mvg, axisIndex, maxAxisNumber, matchMeasure){
          
          var values = [];
          for(var i = 0; i < mvg.values.length; i++){
              if(matchMeasure && i !== ctx.path.mi){
                 continue;
              }
            
              var value = {};
              var mv = mvg.values[i];
              var rows = mv["rows"];
              value["col"] = mv["col"];
              if(ctx){
                 value["rows"] = this.createMeasureValues(ctx, rows, axisIndex, maxAxisNumber);
              }else{
                value["rows"] = this.createMeasureValuesWithoutCtx(rows, axisIndex, maxAxisNumber);
              }
          
              values.push(value);
           }
          
          return values;
        },
       
        /**
         * Create Measure values without context
         *   
         * @param rows
         * @param axisIndex
         * @returns {Array}
         */
        createMeasureValuesWithoutCtx_1_2 : function(rows, axisIndex){
          var values = [], j, row;
          if(axisIndex[0] === 1){
             row = [];
             for(j = 0; j < rows[0].length; j++){
               row.push(rows[0][j]);
             }   
             values.push(row);
           
          }else if(axisIndex[0] === 2){     
             for(j = 0; j < rows[0].length; j++){
               row = [];
               row.push(rows[0][j]);
               values.push(row);
             }   
          }else{
             FunctionUtils.error("Not supported");
         } 
          
          return values;
        },
        
        createMeasureValuesWithoutCtx_1_3 : function(rows, axisIndex){
           var values = [], j, row;
           if(axisIndex[0] === 1){
              row = [];
              for(j = 0; j < rows[0].length; j++){
                  row.push(rows[0][j]);
           }   
              
           values.push([row]);
           
         }else if(axisIndex[0] === 2){
              row = [];
              for(j = 0; j < rows[0].length; j++){
                  row.push([rows[0][j]]);
              }
              
              values.push(row);
              
         }else if(axisIndex[0] === 3){   
               for(j = 0; j < rows[0].length; j++){
                   row = [];
                   row.push([rows[0][j]]);
                   values.push(row);
               }
         }else{
           FunctionUtils.error("Not supported");
         }  
           
         return values;
         
        },
        
        createMeasureValuesWithoutCtx : function(rows, axisIndex, maxAxisNumber){
           if(axisIndex.length === 1){
             if(maxAxisNumber === 1 || maxAxisNumber === 2){
                return this.createMeasureValuesWithoutCtx_1_2(rows, axisIndex); 
             }else if(maxAxisNumber === 3){
                return this.createMeasureValuesWithoutCtx_1_3(rows, axisIndex);
             }else{
                FunctionUtils.error("Not supported");
             }
           }else if(axisIndex.length === 2){
             if(maxAxisNumber === 2){
                return rows;
             }
             else if(maxAxisNumber === 3){
                return this.createMeasureValues_2_3(rows, axisIndex); 
             }else{
                FunctionUtils.error("Not supported");
             } 
             
           }else{
             FunctionUtils.error("Not supported");
           }
           
           FunctionUtils.error("Not supported");
      },
      
      /**
         * Create Measure values without context
         *   
         * @param rows
         * @param axisIndex
         * @returns {Array}
         */
        createMeasureValues_1_2 : function(ctx, rows, axisIndex){
          var values = [], j, row;
           if(axisIndex[0] === 1){
              row = [];
              for(j = 0; j < rows.length; j++){
                  row.push(rows[j][ctx.path.dii]);
              } 
              
           values.push(row);
           
         }else if(axisIndex[0] === 2){
           
           for(j = 0; j < rows.length; j++){
             row = [];
             row.push(rows[j][ctx.path.dii]);
             values.push(row);
           }  
           
         }else{
           FunctionUtils.error("Not supported");
         } 
          
          return values;
        },
        
        createMeasureValues_1_3 : function(ctx, rows, axisIndex){
          var values = [], j, row;
          if(axisIndex[0] === 1){
             
           row = [];
           for(j = 0; j < rows.length; j++){
             row.push(rows[j][ctx.path.dii]);
           }   
           values.push([row]);
           
         }else if(axisIndex[0] === 2){
           row = [];
           for(j = 0; j < rows.length; j++){
             
             row.push([rows[j][ctx.path.dii]]);
             
           }  
           values.push(row);
           
         }else if(axisIndex[0] === 3){
           
           for(j = 0; j < rows.length; j++){
             row = [];
             row.push([rows[j][ctx.path.dii]]);
             values.push(row);
           }
           
         }else{
           FunctionUtils.error("Not supported");
         }
           
           return values;
        },
      
      createMeasureValues : function(ctx, rows, axisIndex, maxAxisNumber){
         var values = [];
         if(axisIndex.length === 1){
             if(maxAxisNumber === 1 || maxAxisNumber === 2){
              return this.createMeasureValues_1_2(ctx, rows, axisIndex); 
             }else if(maxAxisNumber === 3){
               return this.createMeasureValues_1_3(ctx, rows, axisIndex);
             }else{
                FunctionUtils.error("Not supported");
             }
         }else if(axisIndex.length === 2){
             if(maxAxisNumber === 2){
                return rows;
             }else if(maxAxisNumber === 3){
                return this.createMeasureValues_2_3(rows, axisIndex);
             }else{
              FunctionUtils.error("Not supported");
             }
         }else{
             FunctionUtils.error("Not supported");
         }
           
         
           return values;
      },
     
        createMeasureValues_2_3 : function(rows, axisIndex){
          var i ,j, values;
          if(axisIndex[0] === 1 && axisIndex[1] === 2){
            return [rows];
          }else if(axisIndex[0] === 1 && axisIndex[1] === 3){
            values = [];
            for(i = 0 ; i < rows.length; i++){
                values.push([rows[i]]);
            }
            return values;
            
          }else if(axisIndex[0] === 2 && axisIndex[1] === 3){
            values = [];
            for(i = 0 ; i < rows.length; i++){
              var value = [];
              var cols = rows[i];
              for(j = 0; j < cols.length; j++){
                var col = cols[j];
                value.push([col]);
              }
              values.push(value);
            }
            
            return values;
          }else{
            FunctionUtils.error("Not supported");
          }
        }
        
     };
  
  return MeasureValuesDataHandler;
});sap.riv.module(
{
  qname : 'sap.viz.data.handler.SingleChartDataHandler',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.MeasureDataHandler',
  version : '4.0.0'
}
],
 function Setup(FunctionUtils, MultiAxesDataAdapter, MeasureDataHandler){
   
   
   function initMeasureValueAxisIndex(bindingInfo){
     
      //axis 1 has been feeded with crosstable
      if(bindingInfo[0] === true){
       if(bindingInfo[1] === true){
          return [1 ,2];
       }
       else if(bindingInfo[2] === true){
        // pass crosstable data to module if module accpet more than 2 axis feed
          return [1, 2];
       }
       else if(bindingInfo[3] === true){// Multi Radar, aa 4 could not be feeded
          FunctionUtils.error("Not Supported");
       }
       else{
          return [1];
       }
      }else if(bindingInfo[1] === true){
       if(bindingInfo[2] === true){
          //pass crosstable data to module if module accpet more than 2 axis feed
          return [1,2];
       }
       else if(bindingInfo[3] === true){
          FunctionUtils.error("Not Supported");
       }
       else{
         //pass crosstable data to module if module accpet more than 2 axis feed
         if(bindingInfo.length > 2){
            return [1];
         }
         else{
            return [2];
         }
       }
      }else if(bindingInfo[2] === true){
        if(bindingInfo[3] === true){
           FunctionUtils.error("Not Supported");
        }
        else{
         //pass crosstable data to module if module accpet more than 2 axis feed
         return [1];
        }
      }else{
        for(var i = 0; i< bindingInfo.length;i++){
          if(bindingInfo[i] === true){
            FunctionUtils.error("could not determin measure value axis index");
          }
        }
        //all false
        return [1];
      }
       
      FunctionUtils.error("could not determin measure value axis index");
     
    } 
   
   function SinngleChartDataHandler(dataAdapter){
        this._dataAdapter =  dataAdapter;
   }
   
   SinngleChartDataHandler.prototype.getDataAdapter = function(){
      if(this._dataAdapter.getBindingInfo() === null || this._dataAdapter.getBindingInfo() === undefined ){
         return this._dataAdapter;
      }
      else{
         return this.getChartDataAdapter();
      }
   };
   
   SinngleChartDataHandler.prototype.getChartDataAdapter = function(){
      var measureAxisIndex = initMeasureValueAxisIndex(this._dataAdapter.getBindingInfo());
      var aa = this._dataAdapter.getAnalysisAxisDataByIdx();
      var mg = this._dataAdapter.getMeasureValuesGroupDataByIdx();
      var dataAdapter = new MultiAxesDataAdapter();
      for(var i = 0; i < aa.length; i++){
        var axis = aa[i];
        dataAdapter.addAnalysisAxis({index: axis.index, values: axis.values});
      }
      
      for(i = 0; i < mg.length; i++){
        var mvg = mg[i];
        dataAdapter.addMeasureValuesGroup({index:mvg.index, values: MeasureDataHandler.makeMeasureValues(null, mvg, measureAxisIndex, 2, false)});
      }
      
      return dataAdapter;
   };
   
   return SinngleChartDataHandler;
 });sap.riv.module(
{
  qname : 'sap.viz.modules.layout',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils) {
  
  /*
   * Function set that represents a light-weight layout manager
   * who calculates optimal component layout data, rather than
   * operating on components directly.
   */
  return function ( spec ) {
    
    var defaults = {
      resize : true,
      type : 'grid',
      padding : [0,0,0,0],
      hgap : 0,
      vgap : 0
    };  
  
    var hgap = spec.hgap || defaults.hgap,
        vgap = spec.vgap || defaults.vgap,
        padding = spec.padding || defaults.padding,
        bias = spec.bias || 'none';
    
    //Jimmy8/7/2012, different layout function may return different layoutSolution
    //so initialize it in each layout function
    var layoutSolution; // returning data
    
    switch ( spec.type ) {
    case 'border' : 
      border(spec.prefs);
      break;
    case 'grid' :
      grid(spec.prefs);
      break;
    case 'table' :
      //FIXME Elliott/Jimmy 8/7/2012, table layout has some special options
      //here we will read spec inside table layout function directly. consider
      //making it consistent with others 
    table();
    break;
    default :
      grid(spec.prefs);
    }
    
    /**
     * Represents a border-docking layout method which assigns components
     * with spaces of omni-directional border insets. Padding is leaved
     * prior to layout. Component marked as a bias will be processed first
     * to embody the predominance of it. North and South parts are naturally
     * biased against other parts due to the nature of border layout. So
     * the bias attribute supports up to two values: 'west', 'east' or both
     * (in an array and order matters). The center part is under passive 
     * control and queued last to be processed.
     * 
     * ---------------------------------------
     * |               Padding               |
     * |   -------------------------------   |
     * |   |     |     North       |     |   |
     * |   -------------------------------   |
     * |   |     |                 |     |   |
     * |   |  W  |                 |  E  |   |
     * |   |  e  |     Center      |  a  |   |
     * |   |  s  |                 |  s  |   |
     * |   |  t  |                 |  t  |   |
     * |   |     |                 |     |   |
     * |   |     |                 |     |   |
     * |   -------------------------------   |
     * |   |     |     South       |     |   |
     * |   -------------------------------   |
     * |                                     |
     * ---------------------------------------
     */
    function border( options ) {
    layoutSolution = {};
      var packedSize = {}; // Size without paddings.
      packedSize.width = spec.size.width - padding[1] - padding[3];
      packedSize.height = spec.size.height - padding[0] - padding[2];
      
      // Enclosing dimension bounds
      var minX = padding[3],
          minY = padding[0],
          maxX = spec.size.width - padding[1],
          maxY = spec.size.height - padding[2];

      var queue = new Array, i;
      
      // Layout ordering rule
      if ( bias instanceof Array ) {
        queue[0] = bias[0];
        queue[1] = bias[1];
        queue[2] = 'north';
        queue[3] = 'south';
      } else {
        switch ( bias ) {
        case 'west' :
          queue[0] = 'west';
          queue[1] = 'north';
          queue[2] = 'south';
          queue[3] = 'east';
          break;
        case 'east' :
          queue[0] = 'east';
          queue[1] = 'north';
          queue[2] = 'south';
          queue[3] = 'west';
          break;
        default :
          queue[0] = 'north';
          queue[1] = 'south';
          queue[2] = 'east';
          queue[3] = 'west';
        }
      }
      queue[4] = 'center';
      
      for ( i = 0; i < queue.length; i++ ) {
        doLayout(queue[i]);
      }
      
      function doLayout( division ) {
          
                function getAvailableSpacings(maxSize) {
                    if (arguments.length < 2) {
                        return 0;
                    }
                    var spacings = Array.prototype.slice.apply(arguments).slice(1);
                    var spacingsByOrder = [];
                    for (var i = 0; i < spacings.length; i++) {
                        if (spacings[i].length > 1) {
                            spacingsByOrder[i] = spacings[i].slice(1);
                            spacingsByOrder[i].push(spacings[i][0]);
                        }
                    }
                    
                    var availableSpacings = 0;
                    var availableSpacingsSum = 0;
                    for (var i = 0; i < spacingsByOrder[0].length; i++) {
                        for (var j = 0; j < spacingsByOrder.length; j++) {
                            availableSpacingsSum += spacingsByOrder[j][i];
                        }
                        if (availableSpacingsSum > maxSize) {
                            return availableSpacings;
                        }
                        availableSpacings += spacingsByOrder[0][i];
                    }
                    return availableSpacings;
                }

        var node = {}, preferredSize = {};
        if ( division === 'north' && options.north ) {
          node = layoutSolution.north = {};
          preferredSize = options.north.size;
          var nodeHeight = preferredSize.height;
          var heightSum = nodeHeight;
          if (preferredSize.spacings && options.south && options.south.size.spacings) {
              heightSum += options.south.size.height;
          }
          
          if (preferredSize.maxSizeConstant && heightSum > packedSize.height * preferredSize.maxSizeConstant) {
              if (preferredSize.hideOversize) {
                  nodeHeight = 0;
              } else if (preferredSize.spacings) {
                  if (options.south && options.south.size.spacings) {
                      nodeHeight = getAvailableSpacings(packedSize.height * preferredSize.maxSizeConstant, preferredSize.spacings, options.south.size.spacings);
                  } else {
                      nodeHeight = getAvailableSpacings(packedSize.height * preferredSize.maxSizeConstant, preferredSize.spacings);
                  }
              } else {
                  nodeHeight = packedSize.height * preferredSize.maxSizeConstant;
              }
          }
          node.bounds = { 
            x : minX, 
            y : minY,
            width  : maxX - minX,
            height : nodeHeight
          };
          minY += (node.bounds.height + hgap);
          if (node.bounds.height == 0) {
              layoutSolution.north = null;
          }
        }
        
        if ( division === 'east' && options.east ) {
          node = layoutSolution.east = {};
          preferredSize = options.east.size;
          var nodeWidth = preferredSize.width;
          var widthSum = nodeWidth;
          if (preferredSize.spacings && options.west && options.west.size.spacings) {
              widthSum += options.west.size.width;
          }
          if (preferredSize.maxSizeConstant && widthSum > packedSize.width * preferredSize.maxSizeConstant) {
              if (preferredSize.hideOversize) {
                  nodeWidth = 0;
              } else if (preferredSize.spacings) {
                  if (options.west && options.west.size.spacings) {
                      nodeWidth = getAvailableSpacings(packedSize.width * preferredSize.maxSizeConstant, preferredSize.spacings, options.west.size.spacings);
                  } else {
                      nodeWidth = getAvailableSpacings(packedSize.width * preferredSize.maxSizeConstant, preferredSize.spacings);
                  }
              } else {
                  nodeWidth = packedSize.width * preferredSize.maxSizeConstant;
              }
          }
          if (nodeWidth < preferredSize.minWidth) {
              nodeWidth = 0;
          }
          node.bounds = { 
            x : maxX - nodeWidth,
            y : minY,
            width : nodeWidth,
            height : maxY - minY
          };
          
          if (node.bounds.height < preferredSize.minHeight) {
              node.bounds.width = 0;
          }
          
          maxX -= (node.bounds.width - vgap);
          if (node.bounds.width == 0) {
              layoutSolution.east = null;
          }
        }
        
        if ( division === 'south' && options.south ) {
          node = layoutSolution.south = {};
          preferredSize = options.south.size;
          var nodeHeight = preferredSize.height;
          var heightSum = nodeHeight;
          if (preferredSize.spacings && options.north && options.north.size.spacings) {
              heightSum += options.north.size.height;
          }
          if (preferredSize.maxSizeConstant && heightSum > packedSize.height * preferredSize.maxSizeConstant) {
              if (preferredSize.hideOversize) {
                  nodeHeight = 0;
              } else if (preferredSize.spacings) {
                  if (options.north && options.north.size.spacings) {
                      nodeHeight = getAvailableSpacings(packedSize.height * preferredSize.maxSizeConstant, preferredSize.spacings, options.north.size.spacings);
                  } else {
                      nodeHeight = getAvailableSpacings(packedSize.height * preferredSize.maxSizeConstant, preferredSize.spacings);
                  }
              } else {
                  nodeHeight = packedSize.height * preferredSize.maxSizeConstant;
              }
          }
          node.bounds = {
            x : minX,
            y : (maxY - nodeHeight) < minY ? minY : (maxY - nodeHeight),
            width  : maxX - minX
          };
          node.bounds.height = nodeHeight;
          maxY -= (node.bounds.height - hgap);
          if (node.bounds.height == 0) {
              layoutSolution.south = null;
          }
        }
        
        if ( division === 'west' && options.west ) {
          node = layoutSolution.west = {};
          preferredSize = options.west.size;
          var nodeWidth = preferredSize.width;
          var widthSum = nodeWidth;
          if (preferredSize.spacings && options.east && options.east.size.spacings) {
              widthSum += options.east.size.width;
          }
          if (preferredSize.maxSizeConstant && widthSum > packedSize.width * preferredSize.maxSizeConstant) {
              if (preferredSize.hideOversize) {
                  nodeWidth = 0;
              } else if (preferredSize.spacings) {
                  if (options.east && options.east.size.spacings) {
                      nodeWidth = getAvailableSpacings(packedSize.width * preferredSize.maxSizeConstant, preferredSize.spacings, options.east.size.spacings);
                  } else {
                      nodeWidth = getAvailableSpacings(packedSize.width * preferredSize.maxSizeConstant, preferredSize.spacings);
                  }
              } else {
                  nodeWidth = packedSize.width * preferredSize.maxSizeConstant;
              }
          }
          node.bounds = {
            x : minX,
            y : minY,
            width  : nodeWidth,
            height : (minY + preferredSize.height) > maxY ? maxY : (minY + preferredSize.height)
          };
          minX += (node.bounds.width + vgap);
          if (node.bounds.width == 0) {
              layoutSolution.west = null;
          }
        }
        
        if ( division === 'center' && options.center ) {
          node = layoutSolution.center = {};
          node.bounds = {
            x : minX,
            y : minY,
            width  : maxX - minX,
            height : maxY - minY
          };
        }
      }
    }
    
    function grid( options ) {}
    
    /**
     * compared to HTML table, currently we only support cellpadding. we don't (need) support cellspacing 
   * @param {Object} options
     */
    function table( options ) {
      layoutSolution = [];//return layout solution by column * row
      //table layout options
      var columns = TypeUtils.isExist(spec.columns) ? spec.columns : 3;
      var rows = TypeUtils.isExist(spec.rows) ? spec.rows : 2;
      var cellpadding = TypeUtils.isExist(spec.cellpadding) ? spec.cellpadding : 5;
      var paddingThreshold = TypeUtils.isExist(spec.paddingThreshold) ? spec.paddingThreshold : 0.1;
      
      var packedSize = {}; // Size without paddings.
        packedSize.width = spec.size.width - padding[1] - padding[3];
        packedSize.height = spec.size.height - padding[0] - padding[2];
        
        var avgWidth = packedSize.width/columns;
        var avgHeight = packedSize.height/rows;
        //don't make the cellPadding too large
        if (cellpadding > avgWidth * paddingThreshold || cellpadding > avgHeight * paddingThreshold){
          cellpadding = 2;
        }
        var cellWidth = (packedSize.width - 2 * columns * cellpadding)/columns;
        cellWidth = cellWidth > 0 ? cellWidth : 0;
        var cellHeight = (packedSize.height - 2 * rows * cellpadding)/rows;
        cellHeight = cellHeight > 0 ? cellHeight : 0;
      
        // Enclosing dimension bounds
        var minX = padding[3],
        minY = padding[0],
        maxX = spec.size.width - padding[1],
        maxY = spec.size.height - padding[2];
        
        for( var col = 0; col < columns; col++ ){
          var colia = [];//column iteration array
          for( var row = 0; row < rows; row++ ){
            var node = {};
            node.bounds = {
              x: col * avgWidth + avgWidth/2 - cellWidth/2,
              y: row * avgHeight + avgHeight/2 - cellHeight/2,
              width: cellWidth,
              height: cellHeight
            };
            colia.push(node);
          }
          layoutSolution.push(colia);
        }
        
    }
    
    return layoutSolution;
  };
  
});sap.riv.module(
{
  qname : 'sap.viz.modules.xycontainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.SingleChartDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup ( TypeUtils, Objects, Functions, layout, Manifest, SingleChartDataHandler, dispatch, boundUtil) {    
  var retfn = function (manifest, ctx) {
    function load(moduleId) {
      return Manifest.module.get(moduleId).execute(ctx);
    }
      var width = 0, 
          height = 0, 
          properties = {}, 
          data = {},
          config = {},
          modules = {},
          selections = {},
          spaceWithoutPlot,
          parent = null; // a d3 selection
      
      var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), initializedModules = 0;;
      var innerProperties = manifest.props(null);
      ///////////////////////can be moved to base container/////////////////////
      var resolveProperties = function(nodeConfig, isContainer){
        var props = {}, // Empty properties basket
            propsCat,   // Property category node
            usrProps,   // User set properties
            sysProps;   // Predefined properties in configure node
        if(isContainer){
          //Jimmy/8/15/2012 pay attention to the property structure, for container we will pass
          //all properties instead of properties under propsCat only.
          if ( nodeConfig ) {
            propsCat = nodeConfig.propertyCategory;
            usrProps = properties;
            sysProps = {};
            sysProps[propsCat] = nodeConfig.properties;
            Objects.extend( true, props, sysProps, usrProps ); 
          }else{
            props = properties;
          }
        }else{
          if ( nodeConfig ) {
            propsCat = nodeConfig.propertyCategory;
            usrProps = properties[ propsCat ];
            sysProps = nodeConfig.properties;
            // User properties will override predefined properties 
            Objects.extend( true, props, sysProps, usrProps );
          }
        }
        return props;
    };
    
    var updateProperties = function (id, isContainer){
      var moduleManifest = config.modules; // Module configurations
      var props, nodeConfig, propsCat;
      if ( moduleManifest[id] && modules[id] ) {
        nodeConfig = moduleManifest[id].configure;
        if (isContainer){
          props = properties;
        }
        else {
          if (nodeConfig){
            propsCat = nodeConfig.propertyCategory;
            props = Objects.extend(true, {}, properties[propsCat]);
          }
          else{
            props = {};
          }
        }
        modules[id].properties(props);
      }
    };
    ///////////////////////can be moved to base container/////////////////////
    
    function initialize() {
      if ( TypeUtils.isEmptyObject(config) ) Functions.error('Container configuration missing');
      
      initializedModules = 0;
      
      initAxis('xAxis');
      initAxis('yAxis');
      initAxis('xAxis2');
      initAxis('yAxis2');
      initAxis('background');
      
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) return;
      var plot = modules.plot = load(plotConfig.id);
      var dataHandler = new SingleChartDataHandler(data); 
      plot.data(dataHandler.getDataAdapter());
      
      var props;
      if ( plotConfig.configure ) {
        props = resolveProperties(plotConfig.configure);
        plot.properties(props);
      }
      
      if(plot.dispatch){
        var dis =  plot.dispatch();
        if(dis.initialized) { initializedModules++; dis.on('initialized.xycontainer', initialized);};
        if(dis.showTooltip) dis.on('showTooltip.xycontainer', showTooltip);
        if(dis.hideTooltip) dis.on('hideTooltip.xycontainer', hideTooltip);
      }
      
      var dataLabelConfig =  config.modules.dataLabel;
      if(TypeUtils.isExist(dataLabelConfig) && TypeUtils.isExist(plot.dataLabel)){
        var dataLabel = modules.dataLabel = load(dataLabelConfig.id);
        plot.dataLabel(dataLabel);
        dataLabel.plot(plot);
        if ( dataLabelConfig.configure ) {
          props = resolveProperties(dataLabelConfig.configure);
          dataLabel.properties(props);
        }
      }
      
      if ( modules.xAxis && !selections.xAxis )
        selections.xAxis = parent.append('g').attr('class', 'xAxis');
      if ( modules.xAxis2 && !selections.xAxis2 )
        selections.xAxis2 = parent.append('g').attr('class', 'xAxis2');
      if ( modules.yAxis && !selections.yAxis ) 
        selections.yAxis = parent.append('g').attr('class', 'yAxis');
      if ( modules.yAxis2 && !selections.yAxis2 ) 
        selections.yAxis2 = parent.append('g').attr('class', 'yAxis2');
      if ( modules.plot && !selections.plot ) 
        selections.plot = parent.append('g').attr('class', 'plot');
      if ( modules.background && !selections.background ) 
        selections.background = parent.insert('g', ':first-child').attr('class', 'background');        
    }
    
    function updateAxisData ( id ) {
      if(modules[id]){
        var axisConfig = config.modules[id];
        var axisDataConfig = axisConfig.data;
        if (axisDataConfig) {
          modules[id].data(data.createDataAdapterForModule(axisDataConfig));
        } 
      }  
    };
    
    function initAxis( id ) {
      if ( !config.modules[id] ) return;
      
      var axisConfig = config.modules[id],
          axis = modules[id] = load(axisConfig.id); // Saves references to axis function.
      
      updateAxisData(id);

      var props = resolveProperties(axisConfig.configure);
      axis.properties(props);
      
      if(axis.dispatch && axis.dispatch()['initialized']){
        initializedModules++;
        axis.dispatch().on('initialized.xycontainer', initialized);
      }
    }
    
    function relayout() {
      if ( TypeUtils.isEmptyObject(modules) || !width || !height) return;
      
      width = width < 0 ? 0 : width;
      height = height < 0 ? 0 : height;
      var prefs = {};
      if ( modules.xAxis ) {
          modules.xAxis.drawable(true);
          prefs.south = { size : modules.xAxis.getPreferredSize() };
      }
      if ( modules.yAxis ) {
          modules.yAxis.drawable(true);
          prefs.west = { size : modules.yAxis.getPreferredSize() };
      }
      if ( modules.xAxis2 ) {
          modules.xAxis2.drawable(true);
          prefs.north = { size : modules.xAxis2.getPreferredSize() };
      }
      if ( modules.yAxis2 ) {
          modules.yAxis2.drawable(true);
          prefs.east = { size : modules.yAxis2.getPreferredSize() };
      }
      if ( modules.plot ) prefs.center = {};
      
      var solution = layout({
        type : 'border',
        bias : 'none',
        size : { width : width, height : height },
        prefs : prefs
      });

      //we have to layout top and bottom axes firstly, because if you change the size of top or bottom axes, the 
      //height of the axis may be changed (vertical label). Left and right axes have no vertical labels.
      if ( solution.east ) {
        // Modifies yAxis height and coordinate to handle vertical offset
        // to ensure joints with xAxis.
        var yAxis2Height = 0, yAxis2Y = 0;
        if ( solution.south ) {
          yAxis2Height = solution.east.bounds.height - solution.south.bounds.height;
          yAxis2Y = solution.east.bounds.y;
        }
        if ( solution.north ) {
          yAxis2Height = solution.east.bounds.height - solution.north.bounds.height;
          yAxis2Y = solution.west.bounds.y;
        }
        
        selections.yAxis2.attr('transform', 
          'translate(' + solution.east.bounds.x + ',' + yAxis2Y + ')');
        
        modules.yAxis2
          .width(solution.east.bounds.width)
          .height(yAxis2Height);
          
        modules.yAxis2.gridlineLength(solution.center.bounds.width); 
      } else if(modules.yAxis2) {
          modules.yAxis2.drawable(false);
      }

      if ( solution.north ) {
        
        var xAxis2Width = 0, xAxis2X = 0;
        if ( solution.west ) {
          xAxis2X = solution.north.bounds.x + solution.west.bounds.width;
        }

        selections.xAxis2.attr('transform', 
          'translate(' + xAxis2X + 
          ',' + solution.north.bounds.y + ')');

        modules.xAxis2
          .width(xAxis2X)
          .height(solution.north.bounds.height);
          
        modules.xAxis2.gridlineLength(solution.center.bounds.height);    
      } else if (modules.xAxis2) {
          modules.xAxis2.drawable(false);
      }
            
      if ( solution.west ) {
        // Modifies yAxis height and coordinate to handle vertical offset
        // to ensure joints with xAxis.
        var yAxisHeight = 0, yAxisY = 0;
        if ( solution.south ) {
          yAxisHeight = solution.west.bounds.height - solution.south.bounds.height;
          yAxisY = solution.west.bounds.y;
        }
        if ( solution.north ) {
          yAxisHeight = solution.west.bounds.height - solution.north.bounds.height;
          yAxisY = solution.west.bounds.y;
        }
        
        selections.yAxis.attr('transform', 
          'translate(' + solution.west.bounds.x + ',' + yAxisY + ')');
        
        modules.yAxis
          .width(solution.west.bounds.width)
          .height(yAxisHeight);
          
        modules.yAxis.gridlineLength(solution.center.bounds.width);  
      } else if(modules.yAxis) {
          modules.yAxis.drawable(false);
      }

      if ( solution.south ) {

        var xAxisWidth = 0, xAxisX = 0;
        if ( solution.west ) {
            xAxisX = solution.south.bounds.x + solution.west.bounds.width;
        }

        selections.xAxis.attr('transform', 
          'translate(' + xAxisX + 
          ',' + solution.south.bounds.y + ')');
          
        modules.xAxis
          .width(solution.south.bounds.width)
          .height(solution.south.bounds.height);
          
        modules.xAxis.gridlineLength(solution.center.bounds.height);
      }else if (modules.xAxis) {
          modules.xAxis.drawable(false);
      }

      //we should adjust the axes start and end padding
      //todo: add more padding
      var rightPadding = 0, rightPaddingxAxis = rightPaddingxAxis2 = 0;
      if(!solution.east)
      {
          if(modules.xAxis)
          {
            rightPaddingxAxis = modules.xAxis.endPadding();
          }
          if(modules.xAxis2)
          {
            rightPaddingxAxis2 = modules.xAxis2.endPadding();
          }
          rightPadding = rightPaddingxAxis > rightPaddingxAxis2 ? rightPaddingxAxis : rightPaddingxAxis2;
      }
      
      // if (!solution.south && modules.xAxis) {
          // modules.xAxis.drawable(false);
      // }
      // if (!solution.north && modules.xAxis2) {
          // modules.xAxis2.drawable(false);
      // }
            
      if ( solution.center ) {
        selections.plot.attr('transform', 
          'translate(' + solution.center.bounds.x + 
          ',' + solution.center.bounds.y + ')');
        var plotWidth = solution.center.bounds.width - rightPadding;
        modules.plot
          .width(plotWidth > 0 ? plotWidth : 0)
          .height(solution.center.bounds.height > 0 ? solution.center.bounds.height : 0);
        
        spaceWithoutPlot = width - plotWidth;

        if (selections.background) {
            selections.background.attr('transform', 
              'translate(' + solution.center.bounds.x + 
              ',' + solution.center.bounds.y + ')');
            modules.background
              .width(plotWidth > 0 ? plotWidth : 0)
              .height(solution.center.bounds.height > 0 ? solution.center.bounds.height : 0);
        }          
      }
      if ( solution.west )
      {
        modules.yAxis.gridlineLength(solution.center.bounds.width - rightPadding); 
      }
      
    }
    
    function container( selection ) {
      selection.each(function ( data ) {
        boundUtil.drawBound(selection, width, height);
        parent = selection;
        if ( TypeUtils.isEmptyObject(modules) ) initialize();
        render();
      });
      return container;
    }
    
    container.width = function (_) {
      if ( !arguments.length ) return width;
      width = _;
      //Jimmy,8/20/2012, as a container, you don't know whether your
      //sub elements need relayout even if the container size remains
      //the same. so here we just give a chance to sub elements to relayout
      relayout();
      return container;
    };
    
    container.height = function (_) {
      if ( !arguments.length ) return height;
      height = _;
      //see @width
      relayout();
      return container;
    };
    
    container.size = function(_) {
      if ( !arguments.length ) return {
        'width' : width,
        'height' : height
      };
      height = _.height;
      width = _.width;
      //see @width
      relayout();
      return container;
    };
    
    container.data = function (_) {
      if ( !arguments.length ) return data;
      data = _;
      if(!TypeUtils.isEmptyObject(modules)){
        //plot exists, we need update its data
        var dataHandler = new SingleChartDataHandler(data); 
        modules.plot.data(dataHandler.getDataAdapter());
        updateAxisData('xAxis');
        updateAxisData('yAxis');
        updateAxisData('xAxis2');
        updateAxisData('yAxis2');
      }
      
      return container;
    };
    
    container.properties = function (_) {
      if ( !arguments.length ) return innerProperties;
      properties = _;
      if(!TypeUtils.isEmptyObject(modules)){
        updateProperties('xAxis');
        updateProperties('xAxis2');
        updateProperties('yAxis');
        updateProperties('yAxis2');
        updateProperties('plot');
        updateProperties('dataLabel');
        updateProperties('background');
      }
      return container;
    };
    
    container.config = function (_) {
      if ( !arguments.length ) return config;
      config = _;
      return container;
    };
    
    container.modules = function (_) {
      if ( !arguments.length ) {
        if ( TypeUtils.isEmptyObject(modules) ) {
          initialize();
        } 
        return modules;
      }
      modules = _;
      return container;
    };
    
    container.parent = function (_) {
      if ( !arguments.length ) return parent;
      parent = _;
      return container;
    };
      
    container.dispatch = function(_){
        if ( !arguments.length) return eDispatch;
        eDispatch = _;
        return container;
    };
    
    container.infoForSizeLegend = function(){
            return {
              space : spaceWithoutPlot,
              number : 1,
              plotHeight : modules.plot.height()
            };
    };
    
    container.rotate = function(_) {
        var plot = modules.plot;
        if (!arguments.length) return plot.rotate();
        plot.rotate(_);
        return container;
    };
    
    function render() {
      for ( var sel in selections ) {
        if ( selections.hasOwnProperty(sel) ) {
          selections[sel].datum(modules[sel].data()).call(modules[sel]);
        }
      }
      if(TypeUtils.isExist(modules.dataLabel)){
        modules.dataLabel();
      }
    }
    
    var initializedCount = 0;
    function initialized(){
      if(initializedModules == ++initializedCount){
        initializedCount = 0;
        eDispatch.initialized();
      }
    };
    
    function showTooltip(evt){
        eDispatch.showTooltip(evt);
    };
    
    function hideTooltip(evt){
        eDispatch.hideTooltip(evt);
    };
    
    return container;
  };
  
  return retfn;
});sap.riv.module(
{
  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(constants) {
  var feed = {
    Type : {
      Dimension : "Dimension",
      Measure : "Measure"
    },
    Constraints : {
      INF : Number.POSITIVE_INFINITY
    }
  };
  constants.Feed = feed;
  return feed;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.parseCSS',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.Constants',
  version : '4.0.0'
}
],
function Setup(manifest, FunctionUtils, Objects, parseCSS, TypeUtils) {
  var KEEP_DEFINITION = true;
  function loadModule(modules, moduleConfig, moduleRefName) {
    var moduleId = moduleConfig.id;
    if (moduleId === undefined) {
      FunctionUtils.error("Cannot find module id in sub module config \"{0}\"",
          JSON.stringify(moduleConfig));
    }

    var module = manifest.module.get(moduleConfig.id, true);
    modules.push({
      module : module,
      config : moduleConfig,
      moduleRef : moduleRefName,
      subModules : module.subModules(moduleConfig, moduleRefName)
    });
  }

  function exactDefaultProperties(props, keepDefinition) {
    var defaultProps = {}, n, prop;
    for (n in props) {
      if (props.hasOwnProperty(n)) {
        prop = props[n];
        if (prop) {
          if (keepDefinition === true) {
            defaultProps[n] = Objects.extend(true, {}, prop);
          } else {
            defaultProps[n] = prop.supportedValueType === 'Object' ? exactDefaultProperties(
                prop.supportedValues, !KEEP_DEFINITION)
                : prop.defaultValue;
          }
        }
      }
    }
    return defaultProps;
  }
  /**
   * This is a instantce , which already have been registered into
   * {@link sap.viz.manifest.module}.</br> </br> Now, once an item is loaded
   * from {@link sap.viz.manifest.module}, it will automatically provide some
   * APIs .</br> </br>
   * 
   * @example var legend = manifest.module.get(legendID);
   * @see sap.viz.manifest.module#get
   * @class Built-in_Manifest_Objects.moduleManifest
   */
  manifest.registerCategory("module", function(obj) {
    var defaultPropertyValues;
    var allPropertyDefinitions;

    var cssObj = {};
    var css = obj.css;
    for ( var i in css) {
      if (!css.hasOwnProperty(i)) {
        continue;
      }

      cssObj[i] = css[i].value;
    }
    var parsedCSS = parseCSS(cssObj);

    Object.defineProperties(obj, {
      subModules : {
        value : function(moduleConfig, parentRefName) {
          var subModules;
          var subModuleConfigs = Objects.extend(true, {}, moduleConfig.modules, moduleConfig.controllers);
          // TODO: fix those hard code when new layout is cheched in.
          if (!TypeUtils.isEmptyObject(subModuleConfigs)) {
            subModules = [];
            var subModuleConfig;
            for (var key in subModuleConfigs ){
              if (subModuleConfigs.hasOwnProperty(key)){
                subModuleConfig = subModuleConfigs[key];
                if (subModuleConfig) {
                  loadModule(subModules, subModuleConfig, parentRefName + '.' + key);
                }               
              }
            }
          }
          
          return subModules;
        }
      },
      /**
       * return properties of this module with or without definitions,
       * controlled by the parameter. if without definition, only default value
       * is returned for each property.
       * 
       * @method Built-in_Manifest_Objects.moduleManifest#props
       * @param {Boolean}
       *          withDefinition whether include definitions in the return
       *          object. by default false
       * @return {Object} properties of this module
       */
      props : {
        value : function(withDefinition) {
          if (withDefinition === KEEP_DEFINITION) {
            if (!allPropertyDefinitions) {
              allPropertyDefinitions = exactDefaultProperties(obj.properties,
                  KEEP_DEFINITION);
            }
            return allPropertyDefinitions;
          } else {
            if (!defaultPropertyValues) {
              defaultPropertyValues = exactDefaultProperties(obj.properties,
                  !KEEP_DEFINITION);
            }
            return Objects.extend(true, {}, defaultPropertyValues);
          }
        }
      },
      /**
       * execute the fn(function) defined in selected module. The default
       * argument of fn is the module self.</br>
       * 
       * @method Built-in_Manifest_Objects.moduleManifest#execute
       * @return {Object} the result of executing fn
       * @example
       * 
       * var moduleManifest = manifest.module.get(id);//get the item from module's manifest by id
       * var result = moduleManifest.execute();//execute the fn defined in the item
       * 
       */
      execute : {
        value : function(ctx) {
          ctx.styleManager.setDefault(parsedCSS);
          return obj.fn(obj, ctx);
        }
      }
    });
    return obj;
  });

  manifest.module.loadModule = loadModule;

  return manifest.module;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.controller.Base',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants) {
  var module = {
    'id' : 'sap.viz.modules.controller.base',
    'abstract' : true,
    'type' : Constants.Module.Type.Controller,
    'name' : 'controller base module',
    'properties' : null,
    'events' : null,
    'feeds' : null
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.0'},
[

],

function Setup() {
  var boundingbox = {};
  boundingbox.getBBox = function (node, rootNode) {
    var matrix;
    if (arguments.length === 1) {
      matrix = node.getCTM();
    } else {
      matrix = node.getTransformToElement(rootNode);
    }
    return boundingbox.getBBoxHelp(node, matrix);
  };

  boundingbox.getBBoxHelp = function (node, matrix) {
    var box = node.getBBox();
    var corners = new Array();
    var point = d3.select('svg')[0][0].createSVGPoint();
    point.x = box.x;
    point.y = box.y;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x + box.width;
    point.y = box.y;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x + box.width;
    point.y = box.y + box.height;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x;
    point.y = box.y + box.height;
    corners.push(point.matrixTransform(matrix));
    var minX = corners[0].x;
    var maxX = corners[0].x;
    var minY = corners[0].y;
    var maxY = corners[0].y;
    for (var i = 1; i < corners.length; i++) {
      var x = corners[i].x;
      var y = corners[i].y;
      if (x < minX) {
        minX = x;
      } else if (x > maxX) {
        maxX = x;
      }
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
    }

    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  };

  // return true if the two boxes intersect
  boundingbox.intersects = function(a, b) {
    return (a.x <= (b.x + b.width) &&
        b.x <= (a.x + a.width) &&
        a.y <= (b.y + b.height) &&
        b.y <= (a.y + a.height));
  };

  // returns a box representing the intersection of box1 and box2 if it exists, otherwise null
  boundingbox.intersection = function(box1, box2) {
    if (boundingbox.intersects(box1, box2)) {
      var x1 = Math.max(box1.x, box2.x),
          x2 = Math.min(box1.x + box1.width, box2.x + box2.width),
          y1 = Math.max(box1.y, box2.y),
          y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

      return {
        x: x1,
        y: y1,
        width: x2 - x1,
        height: y2 - y1
      };
    }

    return null;
  };

  return boundingbox;
});sap.riv.module(
{
  qname : 'sap.viz.modules.controller.lasso',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(TextUtils, dispatch, ObjectUtils, TypeUtils, BoundingBox,Constants) {
  return function(){
    var eDispatch = null;
    var g, m, eventshape, props, domElement, modules, plots = [], lastSelected = [], selectionMode = 'multiple', lastLassoed = [];
    var startPos,  //point on client position
      lassoHelper, //a rect holder
      hitTestRect = {}, eFilter = '.datapoint', 
      isLassoStart = false,
      selectWithCtrlKey = false;
    
    var unhighlightTarget = null, lastOvered = [], eventLayer = null, lastHovered = [];
    
    var reset = function(){
      plots = [];
    };
    
    //selection is the contain of main
    var lasso = function(){
      return lasso;
    };
    
    lasso.lastOvered = function(_){
      if(!arguments.length){
        return lastOvered;
      }
      lastOvered = _;
      return lasso;
    };
    
    lasso.unhighlightTarget = function(_){
      if(!arguments.length){
        return unhighlightTarget;
      }
      unhighlightTarget = _;
      return lasso;
    };
    
    lasso.lastHovered = function(_){
      if(!arguments.length){
        return lastHovered;
      }
      lastHovered = _;
      return lasso;
    };
    
    lasso.eventLayer = function(_){
      if(!arguments.length){
        return eventLayer;
      }
      eventLayer = _;
      return lasso;
    };
    
    lasso.registerEvent = function(){
      var temp = m.modules();
      for(var i in temp){
        if(temp.hasOwnProperty(i) && !(temp[i] instanceof Array) && temp[i].parent()){
          plots.push(temp[i]);
        }
      }
      
      g.on('mousedown.lasso', lassoStart, true);
      g.on('mousemove.lasso', lassoMove, true);
      g.on('mouseup.lasso', lassoEnd, true);
      
      $(g.node()).mouseleave(mouseleaveHandler);
    };
    
    lasso.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return lasso;
    };
    
    lasso.properties = function(_){
      if(!arguments.length){
        return props;
      }
      props = _;
      selectionMode = props.selectability && props.selectability.mode ? props.selectability.mode: 'multiple';
      selectWithCtrlKey = props.selectability && props.selectability.selectWithCtrlKey;
      return lasso;
    };
    
    lasso.isLasso = function(){
      return isLassoStart;
    };
    
    lasso.selected = function(_){
      if(!arguments.length){
        return lastSelected;
      }
      lastSelected = _;
      return lasso;
    };
    
    lasso.module = function(_){
      if(!arguments.length){
        return m;
      }
      reset();
      m = _, g = m.parent(), domElement = g.node();
      return lasso;
    };

    /*
     * alternative to mouse
     * reason: the result is incorrect in chrome/ie9 when browser zoom != 1
     */
    var mouse = function() {
      var e = d3.event,
          // geo needs to use eventLayer due to the fact that domElement will a bounding rect
          // that is greater than the viewport
          node = !eventLayer.empty() ? eventLayer.node() : domElement, 
          rect = node.getBoundingClientRect(),
          x = e.clientX - rect.left,
          y = e.clientY - rect.top;

      return [ x, y ];
    };

    // return a bounding box for the provided node
    var getBoundingBox = function(node) {
      var rect = node.getBoundingClientRect();
      return { x: rect.left, y: rect.top, height: rect.height, width: rect.width };
    };

    var stopEvent = function() {
      if(d3.event){
        d3.event.stopPropagation();
        d3.event.preventDefault();
      }
    };
    
    //filter the selectees to see whether the shape intersect with hitTestRect. 
    var filter = function(selectees, hitTestRect){
      var res = [];
      
      selectees.filter(function(d, m){
        var rect = getBoundingBox(this);
        if(BoundingBox.intersects(rect , hitTestRect)){
          res.push(this);
        }
      });

      return res;
    };
    
    var lassoStart = function(){
      if (selectionMode !== 'multiple')
        return;

      if (selectWithCtrlKey && !(d3.event.ctrlKey)) {
        return;
      }

      startPos = mouse();
      
      lassoHelper = g.append('rect')
        .attr('x', startPos[0])
        .attr('y', startPos[1])
        .attr('width', 0)
        .attr('height', 0)
        .attr('pointer-events', 'none')
        .attr('fill', 'rgba(64,176,240, 0.4)')
        .style('stroke-width', '2px')
        .attr('stroke', 'rgb(64, 176, 240)');
      
      isLassoStart = true;
      stopEvent();
    };
    
    var clearPlots  = function(_){
      for(var i = 0; i< plots.length; i++){
        if(plots[i].clear){
          plots[i].clear(_);
        }
      }
    };
    
    var lassoMove = function(){
      if(selectionMode !== 'multiple' || !isLassoStart)
        return;
      
      var pos = mouse(),
        x = Math.min(pos[0], startPos[0]),
        y = Math.min(pos[1], startPos[1]),
        width = Math.abs(pos[0] - startPos[0]),
        height = Math.abs(pos[1] - startPos[1]);

      lassoHelper.attr('x', x).attr('y', y).attr('width', width).attr('height', height);
    };
    
    var lassoEnd = function(){
      var clientPoint = {
          x : d3.event.clientX,
          y:  d3.event.clientY
      };
      lassoEndHandler(clientPoint);
    };

    var lassoEndHandler = function(clientPoint){
      if(selectionMode !== 'multiple' || !isLassoStart)
        return;
      
      isLassoStart = false;

      var bnode = lassoHelper.node(), box = getBoundingBox(bnode), bwidth = parseFloat(bnode.getAttribute('width')), bheight = parseFloat(bnode.getAttribute('height')),
          selectedData = [], 
          deselectedData = [];

      // remove the lasso element after this function executes
      setTimeout(function() {
        lassoHelper.remove();
      }, 0);
    
      if(bwidth || bheight){
        var plot, candidates, isInShape = false, selectees = null, selectedObj = [], 
            plotSubLayer = null,
            plotBox = null,
            intersectedBox = null;
        for(var i = 0, len= plots.length; i< len; i++) {
          plot = plots[i];
          candidates = null;

          if (TypeUtils.isFunction(plot.getDatapointsInRect)) {
            // if the plot supports this function, use it to retrieve datapoints within the 
            // bounds of the lasso element
            candidates = plot.getDatapointsInRect(lassoHelper.node());
          }
          else {
            // get a rectangle that represent the viewbox of the plot module
            plotSubLayer = plot.parent().select('rect.viz-event-sub-layer').node();

            // find the intersection of the plot rectangle with the lasso rectangle
            plotBox = plotSubLayer ? getBoundingBox(plotSubLayer) : null;
            intersectedBox = plotBox ? BoundingBox.intersection(plotBox, box) : box; // fall back to lasso rect if plot rectangle not available

            if (!intersectedBox) {
              // this is null if the lasso was not over the plot's area
              // no need to check datapoints for this plot
              continue;
            }

            selectees = plot.parent().selectAll('.datapoint');

            if(selectees[0].length > 0){
              candidates = filter( selectees , intersectedBox );
            }
          }

          if(candidates && candidates.length > 0 ){
            selectedObj.push({
              plot: plot,
              selected: candidates
            });
          }
        }
        
        if(selectedObj.length > 0){
          
          if(lastSelected.length  == 0){
            
            unhighlightTarget(lastSelected, false);
            
            clearPlots(true);
          }
          
          //if the length of lastSelect is large than 0, it means that the chart is in highlight status, do not need to clear the chart to gray
          var plot = null, selected = null, isHighlight = false, lastSelectedBack = ObjectUtils.extend(true , [], lastSelected);
          for(var i=0, len= selectedObj.length; i < len; i++){
            plot = selectedObj[i].plot, selected = selectedObj[i].selected;
            for(var j=0, jlen = selected.length; j < jlen; j++){
              for(var t =0, tlen = lastSelectedBack.length; t < tlen; t++){
                if(selected[j] == lastSelectedBack[t]){
                  isHighlight = true;
                  break;
                }
              }
              
              //If the shape is not in queue of lastSelected
              //maybe we should deselect the shape which is already in highlight status, currently, do not need
              if(isHighlight){
                //lastSelected.splice((t - 1, 1));
                selectedData.push(selected[j]); // only fire the change the data
              }else{
                lastSelected.push(selected[j]);
                selectedData.push(selected[j]); // only fire the change the data
              }
              
              isHighlight = false;
            }
            //highlight selected shapes
            plot.highlight(selected);
          }
        }else{
          //there are no shapes selected
          if(lastSelected.length > 0){
            //if there are selected before, clear all
            unhighlightTarget(lastSelected, false);

            
            clearPlots();
          }
          
          deselectedData  = deselectedData.concat(lastSelected);
          
          lastSelected.splice(0, lastSelected.length);
        }
        
        //eDispatch.lassoEnd(candidates);
        if(selectedData.length > 0){
          fireSelectDataEvent(selectedData);
        }
        
        if(deselectedData.length >0){
          fireDeselectDataEvent(deselectedData);
        }
        
        //clear lastOvered effect
        for(var i =0, len = lastOvered.length; i< len;i++){
          if(lastOvered[i].plot.mouseout){
            lastOvered[i].plot.mouseout(lastOvered[i].target, true);
          }
        }
        
        lastOvered.splice(0, lastOvered.length);
        
        stopEvent();
      }
    };
    
    var mouseleaveHandler = function(evt){
      if(isLassoStart){
        var clientPoint = {
            x: evt.clientX,
            y: evt.clientY
        };
        lassoEndHandler(clientPoint);
        
        isLassoStart = false;
      }
      
      for(var i=0, len = lastHovered.length; i <len; i++){
        if(lastHovered[i].blurOut){
          lastHovered[i].blurOut();
        }
      }
      
      lastHovered.splice(0, lastHovered.length);
    };
    
    function fireSelectDataEvent(selectedShapes){
      var selectData = [];
      for(var i=0, len= selectedShapes.length; i < len; i++){
        var tarData = [], value = selectedShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen= value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: selectedShapes[i].__data__.val,
            ctx: selectedShapes[i].__data__.ctx
          });
        }
        selectData.push({
          target: selectedShapes[i],
          data: tarData
        });
      }
      
      eDispatch.selectData({
        name: Constants.Module.Event.SelectData.name,
        data: selectData
      });
    };
    
    function fireDeselectDataEvent(deselectShapes){
      var deselectData = [];
      for(var i=0, len= deselectShapes.length; i < len; i++){
        var tarData = [], value = deselectShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen=value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: deselectShapes[i].__data__.val,
            ctx: deselectShapes[i].__data__.ctx
          });
        }
        deselectData.push({
          target: deselectShapes[i],
          data: tarData
        });
      }
      
      eDispatch.deselectData({
        name: Constants.Module.Event.DeSelectData.name,
        data: deselectData
      });
    };
    
    return lasso;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.controller.interaction',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.controller.lasso',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
}
],
function Setup(TextUtils, dispatch, lassoHelp, TypeUtils,Constants, Objects) {
  return function(manifest){
    
    var g = null, m, lastSelected = [], selectionMode = 'multiple', plots = [], subeventLayers = [], props = manifest.props(null), lasso = lassoHelp(), supportedEventNames = []; 
    var supportLassoEvent = true, lastHovered = [], eventLayer = null, lastOvered = [];
    var eDispatch = new dispatch('selectData', 'deselectData', 'deselectLegend');
    var mouseEventHandler = {
        'mouseup' :  null,
        'mousemove' : null,
        'mouseout' : null,
        'mouseover' : null,
        'touchstart' : null
    }, isRegister = false, defaultSupportedEventNames = ['mouseup', 'mousemove', 'mouseout', 'mouseover','touchstart'],
      mousedownPos = null,
      preserveSelectionWhenDragging = false;
    
    var enableMouseMove = true, enableMouseOver = true, enableMouseOut = true, holdSelection = false;
    
    var reset = function(){
      isRegister = false;
      plots = [];
      lastSelected.splice(0, lastSelected.length);
      lastHovered.splice(0, lastHovered.length);
      lastOvered.splice(0, lastOvered.length);
      for(var i =0, len = subeventLayers.length; i<len;i++){
        subeventLayers[i].remove();
      }
      subeventLayers = [];
    };
    
    var selection = function(){
      
      lasso.dispatch(eDispatch).selected(lastSelected).lastOvered(lastOvered).lastHovered(lastHovered).unhighlightTarget(unhighlightTarget);
      
      return selection;
    };
    
    var clearPlots  = function(_){
      for(var i = 0; i< plots.length; i++){
        if(plots[i].clear){
          plots[i].clear(_);
        }
      }
    };

    var pointInPlot = function(t, plot){
      var p = plot.parent()[0][0].getBoundingClientRect();
      return (t.x >= p.left && t.x <= p.left + p.width && t.y >= p.top && t.y <= p.top + p.height);
    };

    // returns an array of the plot's parent nodes, in the same order as the "plots" array
    var getPlotNodes = function() {
      var nodes = [];
      for (var i = 0, len = plots.length; i < len; i++) {
        if (plots[i].parent()) {
          nodes.push(plots[i].parent().node());
        }
      }
      return nodes;
    };

    // returns the index of the plot (in the "plots" array) that contains the target element
    // nodes is optional and should contain the container elements for the plots
    var plotIndexContainingTarget = function(target, nodes) {
      var n = target,
        plotNodes = nodes || getPlotNodes(),
        idx;

      for (; n && n.ownerSVGElement; n = n.parentNode) {
        idx = plotNodes.indexOf(n);
        if (idx !== -1) {
          return idx;
        }
      }

      return -1;
    };

    // returns the plot module object that contains the target element
    var plotContainingTarget = function(target, nodes) {
      var plotIdx = plotIndexContainingTarget(target, nodes);

      if (plotIdx !== -1) {
        return plots[plotIdx];
      }

      return null;
    };

    // returns the input targets, organized by their parent plot
    // the result object is an array, with each entry corresponding to a plot in the "plot" array
    // each entry is an array of targets
    var groupTargetsByPlot = function(targets) {
      var plotNodes = getPlotNodes(),
          results = [];

      for (var i = 0, len = plots.length; i < len; i++) {
        results.push([]);
      }

      for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i],
          idx = plotIndexContainingTarget(target, plotNodes),
          plotTargets;

        if (idx !== -1) {
          plotTargets = results[idx];
          plotTargets.push(target);
        }
        else {
          // log/throw error?
        }
      }

      return results;
    };

    var highlightTarget = function(target) {
      var plot = plotContainingTarget(target);
      if (plot && plot.highlight) {
        plot.highlight(target, selectionMode);
      }
    };
    
    // CTIsDatapoint means the current target is datapoint shape or not
    // target can be an array or a single element
    var unhighlightTarget = function(target, CTIsDatapoint) {
      var targets = TypeUtils.isArray(target) ? target : [ target ],
          targetsGroupedByPlot = groupTargetsByPlot(targets);

      for (var i = plots.length - 1; i >= 0; i--) {
        var plot = plots[i],
            plotTargets = targetsGroupedByPlot[i];

        if (plotTargets && plotTargets.length > 0 && plot.unhighlight) {
          plot.unhighlight(plotTargets, CTIsDatapoint);
        }
      }
    };
    
    selection.registerEvent = function(){
      //TODO, [Ian] register event function will be called more than once as in multi chart, modules will fire more than one complete animation event.
      if(isRegister == false){
        isRegister = true;
        
        
        var temp = m.modules();
        for(var i in temp){
          if(temp.hasOwnProperty(i) && !(temp[i] instanceof Array) && temp[i].parent()){
            var height, width;
            if (temp[i].getPreferredSize && temp[i].getPreferredSize()){
              height = temp[i].getPreferredSize().height;
              width = temp[i].getPreferredSize().width;
            } else {
              height = temp[i].height();
              width = temp[i].width();
            }
            var subeventLayer = temp[i].parent().insert('rect', 'g').attr('width', width).attr('height', height).attr('opacity', '0').attr('class', 'viz-event-sub-layer');
            subeventLayers.push(subeventLayer);

            plots.push(temp[i]);
          }
        }
        
        if(!eventLayer){
          eventLayer = g.insert("rect", "g").attr("x", 0).attr("y", 0).attr("fill-opacity", 0);
          lasso.eventLayer(eventLayer);
        }
        eventLayer.attr("width", m.width()).attr("height", m.height());
        if(supportedEventNames != null && supportedEventNames instanceof Array){
          for(var i=0, len = supportedEventNames.length; i< len; i++){
            if(mouseEventHandler[supportedEventNames[i]]){
              g.on(supportedEventNames[i] + '.interaction', mouseEventHandler[supportedEventNames[i]]);
            }
          }
        }
        
        if(supportLassoEvent == true){
          lasso.registerEvent();
        }
        if (preserveSelectionWhenDragging === true) {
          g.on('mousedown.preserveSelectionWhenDragging', function() {
              mousedownPos = d3.mouse(g.node());
            }, true);
        }
      }else{
        eventLayer.attr('width', m.width()).attr('height', m.height());
        lasso.eventLayer(eventLayer);
        
        //reset the size of subevent layer
        for(var i=0, len= subeventLayers.length; i<len; i++){
          subeventLayers[i].attr('width', plots[i].width()).attr('height', plots[i].height());
        }
        
        for(var i=0, len =lastHovered.length; i<len; i++){
          if(lastHovered[i].blurOut){
            lastHovered[i].blurOut();
          }
        }
        lastHovered.splice(0, lastHovered.length);
        
        for(var i=0, len =lastOvered.length; i< len; i++){
          if(lastOvered[i].plot.mouseout){
            lastOvered[i].plot.mouseout();
          }
        }
        lastOvered.splice(0, lastOvered.length);
        
        if(holdSelection == false){
          lastSelected.splice(0, lastSelected.length);
        }
      }
      
    };
    
    //[2012/09/11 Christy] Get selection mode for legend.
    selection.getSelectionMode = function(){
      return selectionMode;
    };
    
    //[2012/09/10 Christy] Legend is selected.  
    selection.highlightedByLegend = function(selectedData, isSelected){
      if(selectionMode === 'single' || selectionMode === 'none'){
        //Doesn't work in single mode.
        return;
      }
      var datapoints = [], itemData, isSame = true, ctxDatapoints = [], isDeselected = true, selectedObjs = [], selectDatas = [], deselectDatas = [], selectDatapoints = [], deselectDatapoints = [];
      for(var i = 0, len = plots.length; i < len; i++){
        //Reset datapoints arrary which contains selectedData ctx.
        ctxDatapoints = [];
        
        if(selectedData.ctx.ranges){
          //MBC legend
          if(plots[i].getDatapointsByRange){
            ctxDatapoints = plots[i].getDatapointsByRange(selectedData);
            selectedObjs.push({
              plot: plots[i],
              ctxDatapoints : ctxDatapoints
            });
          }
        } else { 
          if (plots[i].getDatapointsByLegend) {
            ctxDatapoints = plots[i].getDatapointsByLegend(selectedData);
            selectedObjs.push({
              plot: plots[i],
              ctxDatapoints : ctxDatapoints
            });
          } else {
            datapoints = plots[i].parent().selectAll('.datapoint')[0];
            
            for(var j = 0, jLen = datapoints.length; j < jLen; j++){
              if(datapoints[j].__data__ && datapoints[j].__data__.ctx){
                if(datapoints[j].__data__.ctx.path) {
                  itemData = datapoints[j].__data__.ctx.path;
                }else{
                  //Multi measures. For bubble or tagcloud.
                  itemData = datapoints[j].__data__.ctx[0].path;
                }
                
                //Check selectedData contains this ctx.
                isSame = true;
                for(var k in itemData){
                  if(selectedData.ctx.path[k] != undefined){
                    if(selectedData.ctx.path[k].length > 0){
                      if(_contains(selectedData.ctx.path[k], itemData[k]) === false){
                        isSame = false;
                      }
                    }else{
                      if(selectedData.ctx.path[k] !== itemData[k]){
                        isSame = false;
                      }
                    }
                  }
                }
                if(isSame === true){
                  //Push datapoint which has the same ctx with selectedData.
                  ctxDatapoints.push(datapoints[j]);
                }
              }
            }
          
            if(datapoints.length > 0){
              selectedObjs.push({
                plot: plots[i],
                ctxDatapoints : ctxDatapoints
              });
            }
          }
        }
      }

      //Deselected this series datapoint or not.
      if(lastSelected.length === 0){
        isDeselected = false;
      } else {
        var numOfDataPoints = 0;
        
        for(var i = 0, len = selectedObjs.length; i < len; i++){
          ctxDatapoints = selectedObjs[i].ctxDatapoints;
          var kLen = ctxDatapoints.length;
          numOfDataPoints += kLen;
          for(var k= 0; k < kLen; k++){
            if(_contains(lastSelected, ctxDatapoints[k]) === false){
              //One ctxDatapoint is not selected. Highlight this series datapoints.
              isDeselected = false;
              break;
            }
          }
        }
        if (isDeselected && !numOfDataPoints) {
          isDeselected = false;
        }
      }
      
      for(var i = 0, len = selectedObjs.length; i < len; i++){
        ctxDatapoints = selectedObjs[i].ctxDatapoints;  
        selectDatapoints = [], deselectDatapoints = [];
        for(var k= 0, kLen = ctxDatapoints.length; k < kLen; k++){
          var index = _contains(lastSelected, ctxDatapoints[k]);
          if(isDeselected){
            //deselected
            deselectDatapoints.push(ctxDatapoints[k]);
            lastSelected.splice(index, 1);
            deselectDatas.push(ctxDatapoints[k]);
          }else{
            //selected
            if(lastSelected.length == 0){
              clearPlots(true);
            }
            selectDatapoints.push(ctxDatapoints[k]);
            selectDatas.push(ctxDatapoints[k]);
            if(index === false){
              lastSelected.push(ctxDatapoints[k]);
            }
          }
        }
        
        //update highlight and unhighlight effect.
        if(deselectDatapoints.length > 0){
          selectedObjs[i].plot.unhighlight(deselectDatapoints, false, selectionMode);
        }
        if(selectDatapoints.length > 0){
          selectedObjs[i].plot.highlight(selectDatapoints, false, selectionMode);
        }
        
        if(isDeselected){
          //remove legend selected effect.
          eDispatch.deselectLegend(selectedData);
        }
        if(lastSelected.length === 0){
          clearPlots();
        }
      }
      
      //Send select/deselect event
      if(selectDatas.length > 0){
          fireSelectDataEvent(selectDatas);
        }
        
        if(deselectDatas.length > 0){
          fireDeselectDataEvent(deselectDatas);
        }
        
      return isDeselected;
    };
    
    //[2012/09/10 Christy] utility method.
    var _contains = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return i;
            }
        }
        return false;
    };
    
    selection.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return selection;
    };
    
    mouseEventHandler['mousemove'] = function(){
      if(lasso.isLasso() || enableMouseMove == false){
        return;
      }
      var cp = {
          x: d3.event.clientX,
          y: d3.event.clientY
      };
      var hoveredplots = [];
      for(var i =0, len = plots.length; i< len; i++){
        if(plots[i].parent() && pointInPlot(cp, plots[i])){
          hoveredplots.push(plots[i]);
        }
      }
      
      var isHovered = false;
      for(var i =0, len= lastHovered.length; i< len; i++){
        for(var j=0, jlen = hoveredplots.length; j< jlen; j++){
          if(lastHovered[i] == hoveredplots[j]){
            isHovered = true;
            break;
          }
        }
        if(isHovered == false && lastHovered[i].blurOut){
          lastHovered[i].blurOut();
        }
        isHovered = false;
      }
      
      for(var i=0, len= hoveredplots.length; i < len; i++){
        if(hoveredplots[i].hoverOnPoint){
            var cb = hoveredplots[i].parent().node().getBoundingClientRect();
             
             hoveredplots[i].hoverOnPoint({
               x : cp.x - cb.left,
               y : cp.y - cb.top
             });
        }
      }
      
      lastHovered.splice(0, lastHovered.length);
      for(var i=0, len = hoveredplots.length; i<len;i++){
        lastHovered.push(hoveredplots[i]);
      }
    };
    
    mouseEventHandler['mouseover'] = function(){
      if(lasso.isLasso() || enableMouseOver == false){
        return;
      }
      
       var target = d3.event.target, classname = target.getAttribute('class');
       if(classname != null && classname.indexOf('datalabel') != -1){
         target = target.__data__.dataShape;
       }else {
         target = isDatapoint(target);
         classname = target.getAttribute('class');
       }
       
       if(classname != null && (classname.indexOf('datapoint') != -1 || classname.indexOf('datalabel') != -1) ){
         
         var isHighlighted = false;
         for(var i=0, len = lastSelected.length; i < len; i++){
           if(target === lastSelected[i]){
             isHighlighted = true;
             break;
           }
         }
        
         if(lastSelected.length == 0 ){
          isHighlighted = true;
        }

        var plot = plotContainingTarget(target);
        if (plot) {
          lastOvered.push({
               plot: plot,
               target: target
            });

          if(plot.mouseover){
            plot.mouseover(target, isHighlighted);
          }
        }
       }
       
    };
    
    mouseEventHandler['mouseout'] = function(){
      if(lasso.isLasso() || enableMouseOut == false){
        return;
      }
      
       var target = d3.event.target, classname = target.getAttribute('class');
       if(classname != null && classname.indexOf('datalabel') != -1){
         target = target.__data__.dataShape;
       }else {
         target = isDatapoint(target);
         classname = target.getAttribute('class');
       }
 
       if(classname != null && (classname.indexOf('datapoint') != -1 || classname.indexOf('datalabel') != -1) ){
         
         var isHighlighted = false;
         for(var i=0, len = lastSelected.length; i < len; i++){
           if(target === lastSelected[i]){
             isHighlighted = true;
             break;
           }
         }
         
        if(lastSelected.length == 0 ){
          isHighlighted = true;
        }
         
        var plot = plotContainingTarget(target);

        for (var i = 0, len = lastOvered.length; i < len; i++) {
          var lastOver = lastOvered[i];

          // FIXME always invoke mouseout event handler on plot?
          if (lastOver.target === target/* && lastOver.plot === plot*/) {
            lastOvered.splice(i, 1);
            if (plot.mouseout) {
              plot.mouseout(target, isHighlighted);
            }
            break;
          }
        }
       }
    };
    
    var isDatapoint = function(node){
      if(node === g.node()){
        return node;
      }else{
        var classname = node.getAttribute('class');
        if(classname != null && classname.indexOf('datapoint') != -1){
          return node;
        }else{
          return isDatapoint(node.parentNode);
        }
      }
      
    };
    mouseEventHandler['mouseup'] = function(){
      if (preserveSelectionWhenDragging && mousedownPos) {
        var pos = d3.mouse(g.node());

        // cheap mechanism to cancel the 'mouseup' event handler when dragging the mouse
        // for example, when panning the geocharts
        if (Math.abs(pos[0] - mousedownPos[0]) > 5 ||
            Math.abs(pos[1] - mousedownPos[1]) > 5) {
          return;
        }
      }
      if(selectionMode !== 'none'){
          
          var target = d3.event.target,  classname = target.getAttribute('class'), selectDatas = [], deselectDatas = [];
          
          if( classname != null && classname.indexOf('datalabel') != -1){
            target = target.__data__.dataShape;
          }else {
            target = isDatapoint(target);
            classname = target.getAttribute('class');
          }
          
          //if  the click is on eventLayer, deselect all
          if( classname == null || (classname.indexOf('datapoint') == -1 && classname.indexOf('datalabel') == -1) ){
            
            unhighlightTarget(lastSelected, false);

            clearPlots();
            deselectDatas = deselectDatas.concat(lastSelected);
            lastSelected.splice(0, lastSelected.length);
            
            //[2012/09/11 Christy] deselect all legend items.
            eDispatch.deselectLegend();
          }else{
            var isHighlighted = false;
            for(var i =0, len = lastSelected.length; i<len; i++){
              if(target == lastSelected[i]){
                isHighlighted = true;
                break;
              }
            }
            if(lastSelected.length == 0){ //it means the isHighlighted false
              
              clearPlots(true);
              highlightTarget(target);
              lastSelected.push(target);
              
              selectDatas.push(target);
            }else{
              if(isHighlighted){
                if(selectionMode == 'single'){
                  unhighlightTarget(lastSelected[0]);
                  
                  clearPlots();
                  lastSelected.splice(0, lastSelected.length);
                  
                  deselectDatas.push(target);
                }else{
                  var changeSelected = lastSelected.splice((i),1);
                  deselectDatas = deselectDatas.concat(changeSelected);
                  
                  if(lastSelected.length == 0){
                    unhighlightTarget(target);
                    clearPlots();
                  }else{
                    unhighlightTarget(target);
                    deselectDatas.push(target);
                  }
                }
              }else{
                if(selectionMode == 'single'){
                  unhighlightTarget(lastSelected[0]);
                  deselectDatas.push(lastSelected[0]);
                  
                  highlightTarget(target);
                  selectDatas.push(target);
                  
                  lastSelected[0] = target;
                }else{
                  
                  selectDatas.push(target);
                  highlightTarget(target);
                  
                  lastSelected.push(target);
                }
              }
            }
          }
          
          if(selectDatas.length > 0){
            fireSelectDataEvent(selectDatas);
          }
          
          if(deselectDatas.length > 0){
            fireDeselectDataEvent(deselectDatas);
          }
          
        }
    };
    
    mouseEventHandler['touchstart'] = mouseEventHandler['mouseup'];
    
    function fireSelectDataEvent(selectedShapes){
      var selectData = [];
      for(var i=0, len= selectedShapes.length; i < len; i++){
        var tarData = [], value = selectedShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen= value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: selectedShapes[i].__data__.val,
            ctx: selectedShapes[i].__data__.ctx
          });
        }
        selectData.push({
          target: selectedShapes[i],
          data: tarData
        });
      }
      
      eDispatch.selectData({
        name: Constants.Module.Event.SelectData.name,
        data: selectData
      });
    };
    
    function fireDeselectDataEvent(deselectShapes){
      var deselectData = [];
      for(var i=0, len= deselectShapes.length; i < len; i++){
        var tarData = [], value = deselectShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen=value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: deselectShapes[i].__data__.val,
            ctx: deselectShapes[i].__data__.ctx
          });
        }
        deselectData.push({
          target: deselectShapes[i],
          data: tarData
        });
      }
      
      eDispatch.deselectData({
        name: Constants.Module.Event.DeSelectData.name,
        data: deselectData
      });
    };
    
    function parseOptions(){
      selectionMode = props.selectability.mode;
      supportedEventNames = props.supportedEventNames;
      enableMouseMove = props.enableMouseMove;
      enableMouseOver = props.enableMouseOver;
      enableMouseOut = props.enableMouseOut;
      supportLassoEvent = props.supportLassoEvent;
      holdSelection = props.holdSelection;
      preserveSelectionWhenDragging = props.preserveSelectionWhenDragging;

    }
    selection.properties = function(_){
      if(!arguments.length){
        return props;
      }
      Objects.extend(true, props, _);
      lasso.properties(props);
      parseOptions();
    };
    
    selection.module = function(_){
      if(!arguments.length){
        return m;
      }
      reset();//clear flag to have another chance to register event
      m = _, g = m.parent();
      lasso.module(_);
      return selection;
    };
    return selection;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.controller.interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.controller.interaction',
    'name' : 'selection',
    'base' : "sap.viz.modules.controller.base",
    'description': 'Settings for the interactions of the chart.',
    'properties' : {
      'selectability' : {
        'name' : 'selectability',
        'supportedValueType': 'Object',
        'supportedValues': {
          mode: {
             'name' : 'mode',
            'supportedValueType' : 'List',
            'supportedValues' : [ 'single', 'multiple', 'none' ],
            'defaultValue' : 'multiple',
            'description' : 'Set the selection mode. Single means you only can select one at the same time. Multiple means you can select several ones. None means you can not select anything. '
          },
          selectWithCtrlKey: {
            name:"selectWithCtrlKey",
            supportedValueType:"Boolean",
            defaultValue: false,
            description: "Set whether lasso selection needs ctrl key pressed.",
            isExported: false
          }
        },
        'description': 'Settings for selectability.'
      },
      supportedEventNames:{
        name: "supportedEventNames",
        supportedValueType: "StringArray",
        supportedValues: ['mouseup','mousemove','mouseout','mouseover','touchstart'],
        defaultValue:['mouseup', 'mousemove', 'mouseout', 'mouseover','touchstart'],
        description: "Set supported event names.",
        isExported: false
      },
      enableMouseMove:{
        name: "enableMouseMove",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether mouse move is enabled.",
        isExported: false
     },
      enableMouseOver:{
        name: "enableMouseOver",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether mouse over is enabled.",
        isExported: false
      },
      enableMouseOut:{
        name: "enableMouseOut",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether mouse out is enabled.",
        isExported: false
      },
      supportLassoEvent:{
        name: "supportLassoEvent",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether support lasso event is enabled.",
        isExported: false
      },
      holdSelection:{
        name: "holdSelection",
        supportedValueType: "Boolean",
        defaultValue:false,
        description: "Set whether hold selection is enabled.",
        isExported: false
      },
      preserveSelectionWhenDragging:{
        name: "preserveSelectionWhenDragging",
        supportedValueType: "Boolean",
        defaultValue:false,
        description: "Set whether preserve selection when dragging is enabled.",
        isExported: false
      }
    },
    'fn' : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.tooltip',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(Dispatch, Objects, formatManager, TypeUtils, ObjectUtils, langManager) {
  var tooltip =  function(manifest, ctx) {
    var _display = {
      singleMeasure : {
        label : {
          font : 'bold 11px sans-serif',
          color : '#333333'
        },
        value : {
          font : 'bold 14px sans-serif',
          color : '#333333'
        },
        padding : {
          vertical : 9,
          horizontal : 10
        }
      },
      multipleMeasure : {
        label : {
          font :  "12px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        value : {
          font : "12px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        padding : {
          vertical : 8,
          horizontal : 10,
          inline : 6,
          symbolGap : 7,
          defaultSpace : 8
        }
      },
      title : {
        color : '#333333',
        font : "bold 13px 'Open Sans', Arial, Helvetica, sans-serif",
        formatString : ''
      },
      footer : {
        label : {
          font :  "bold 10.5px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        value : {
          font : "10.5px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        padding : {
          inline : 6
        }
      },
      valueFormat : [],
      labelFormat : [],
      maxDimensionLabelWidth : 150,
      maxMeasureLabelWidth : 80
    };

    var _shapeLayout = {
      padding : 5,
      radius : 4,
      markerWidth : 12,
      markerHeight : 8,
      borderWidth : 2
    };

    var _shapes = {
      tooltip : null,
      tooltipRB : null,
      dimensionLabel : null,
      separateLine : null,
      measureLabels : [],
      measureMarks : [],
      valueLabels : []
    };

    var _currentValue = {
      offset : undefined
    };

    var _defaultToolTipColors = {
      backgroundColor : '#ffffff',
      borderColor : '#000000',
      separateLineColor : [ '#ffffff', '#8a8a8a', '#ffffff' ],
      separateLineSingleColor : '#AAAAAA',
      guideLineColor : '#AAAAAA'
    };

    var _svgPathCommand = {
      arcA : 'A',
      lineToA : 'L',
      moveToA : 'M',
      closePath: 'z'
    };
    
    var _symbol = {
      symbolSize : 8,
      hasSymbol : false
    };
    
    var _symbolClassName = 'tooltipsymbol', _paragraphTitleClassName = 'tooltipparagraphtitle', _paragraphLabelTextClassName = 'tooltipparagraphlabel', _paragraphValueTextClassName = 'tooltipparagraphvalue', _footerLabelClassName = 'tooltipfooterlabel', _footerValueClassName = 'tooltipfootervalue';
    
    var vis = null, gWrapper = null;
    var tooltipWidth = 0, tooltipHeight = 0, textMaxWidth = 0, effectManager = ctx.effectManager,
    zone = {
        width : 200,
        height : 100
    },
    
    plotArea = {
        width: 160,
          height: 70,
          x: 0,
          y: 0
    },
    
    _properties = {},
    
    //tooltip border marker orientation
    _orientation = null,

    //variables are for tooltip content truncation case
    _truncationParameter = {
      isTruncated : false,
      currentFooterIndex : -1,
      currentBodyIndex : -1,
      defaultValue : '...',
      font : 'bold 20px Arial',
      color : '#000000'
    };
    
    var defaultString = langManager.get('IDS_ISNOVALUE');

    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };
    
    function clearTruncationParameter() {
      _truncationParameter.isTruncated = false;
      _truncationParameter.currentFooterIndex = -1;
      _truncationParameter.currentBodyIndex = -1;
    }
    
    function tooltip(selection) {
      vis = d3.select(selection).append('svg').style('position', 'absolute').attr('pointer-events', 'none').attr('width', '0').attr('height', 0).attr('class','tooltip');
      
      return tooltip;
    }

    function getTooltipHeightV2(vis, data) {
      var bodyInline = _display.multipleMeasure.padding.inline, 
        multipleVertical = _display.multipleMeasure.padding.vertical,
        multipleLabelFont = _display.multipleMeasure.label.font,
        multipleValueFont = _display.multipleMeasure.value.font,
        footerInline = _display.footer.padding.inline,
        footerLabelFont = _display.footer.label.font,
        titleFont = _display.title.font;
      var tooltipHeight = 0, tooltipBody = data.body, tooltipFooter = data.footer;
       
        
        //First rule, make sure the content contains the first paragraph title and footer if the tooltip height is beyond zone height.
        if (tooltipBody && tooltipBody.length > 0) {
            tooltipHeight = multipleVertical;
          
            if (tooltipFooter && tooltipFooter.length > 0) {
              var firstPlaceHolderHeight = 0;
              if (tooltipBody[0].name !== null) {
                firstPlaceHolderHeight =  getTextBox(vis, tooltipBody[0].name,  titleFont).height + bodyInline + getTextBox(vis, _truncationParameter.defaultValue,  _truncationParameter.font).height;
              }
              
              if (tooltipFooter[0].label !== null) {
                var footerlabelBox1 = getTextBox(vis, tooltipFooter[0].label, footerLabelFont);
                
                tooltipHeight += multipleVertical * 3;
                
                tooltipHeight += (tooltipFooter.length * footerlabelBox1.height + footerInline * (tooltipFooter.length - 1));
            
                tooltipHeight += firstPlaceHolderHeight;
                if (tooltipHeight > zone.height) {
                  _truncationParameter.isTruncated = true;
                  _truncationParameter.currentBodyIndex = 0;
                  
                  var num1 = 0;
                  while (tooltipHeight > zone.height) {
                    tooltipHeight -= footerlabelBox1.height;
                    tooltipHeight -= footerInline;
                    num1++;
                  }
                  _truncationParameter.currentFooterIndex = tooltipFooter.length - num1 - 1;
                  
                  return tooltipHeight;
                }
                
                tooltipHeight -= firstPlaceHolderHeight;
              }
            } else {
              tooltipHeight += multipleVertical;
            }
            
            var paragraphTitleNum = 0, paragraphLineNum = 0;
          for (var i = 0; i < tooltipBody.length; i++) {
            paragraphTitleNum++;
            paragraphLineNum += tooltipBody[i].val.length;
          }
          
          if (tooltipBody[0].name !== null) {
            tooltipHeight += (paragraphTitleNum * getTextBox(vis, tooltipBody[0].name,  titleFont).height);
          }
          
        var maxValue = 0;
          if (tooltipBody[0].val.length > 0) {
            if (tooltipBody[0].val[0].label !== null) {
              maxValue = getTextBox(vis, tooltipBody[0].val[0].label,  multipleLabelFont).height;
            }
            
            if (tooltipBody[0].val[0].value !== null) {
              var valueHeight = getTextBox(vis, tooltipBody[0].val[0].value,  multipleValueFont).height;
              if (valueHeight > maxValue) {
                maxValue = valueHeight;
              }
            }
            
            tooltipHeight += (paragraphLineNum * maxValue);
          }
            
          tooltipHeight += (bodyInline * (paragraphTitleNum + paragraphLineNum - 1));
          
            if (tooltipHeight > zone.height) {
              _truncationParameter.isTruncated = true;
              
              var num2 = 0;
              while (tooltipHeight > zone.height) {
                tooltipHeight -= maxValue;
                tooltipHeight -= bodyInline;
                num2++;
              }
              
              _truncationParameter.currentBodyIndex = paragraphTitleNum + paragraphLineNum - num2 - 2;
              var defaultValueBox1 = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
              
              return tooltipHeight + (defaultValueBox1.height - maxValue);
            }
        } else  if (tooltipFooter && tooltipFooter.length > 0) {
          if (tooltipFooter[0].label !== null) {
            var footerlabelBox2= getTextBox(vis, tooltipFooter[0].label, footerLabelFont);
            
            tooltipHeight += multipleVertical;
            
            tooltipHeight += (tooltipFooter.length * footerlabelBox2.height + footerInline * (tooltipFooter.length - 1));
        
              if (tooltipHeight > zone.height) {
                _truncationParameter.isTruncated = true;
                var num = 0;
                while (tooltipHeight > zone.height) {
                  tooltipHeight -= footerlabelBox2.height;
                  tooltipHeight -= footerInline;
                  num++;
                }
                
                _truncationParameter.currentFooterIndex = tooltipFooter.length - num - 1;
                var defaultValueBox2 = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
                
                return tooltipHeight + (defaultValueBox2.height - footerlabelBox2.height);
              }
          }
        }    
        
        return tooltipHeight;
    }
        
    function getTooltipWidthV2(vis, data) {
        var tooltipWidth = 0, multipleHorizontal = _display.multipleMeasure.padding.horizontal, symbolGap = _display.multipleMeasure.padding.symbolGap, defaultSpace = _display.multipleMeasure.padding.defaultSpace, symbolSize = _symbol.symbolSize;
        
        tooltipWidth = textMaxWidth + (multipleHorizontal * 2) + defaultSpace;
        if (_symbol.hasSymbol) {
          tooltipWidth += symbolSize + symbolGap;
        }
        return tooltipWidth;
    }
        
    function getTextMaxWidthV2(vis, data) {
      var maxValue = 0, tmpWidth = 0, tooltipBody = data.body, tooltipFooter = data.footer;
      
      if (tooltipBody) {
        for (var i = 0; i < tooltipBody.length; i++) {
          if (tooltipBody[i].name !== null) {
            tmpWidth = getTextBox(vis, tooltipBody[i].name, _display.title.font).width;
            if (tmpWidth > maxValue) {
              maxValue = tmpWidth;
            }
          }
      
          var paragraphValue = tooltipBody[i].val;
          if (paragraphValue) {
            if (paragraphValue.length === 1 && (paragraphValue[0].value !== null)) {
              var valueBox = getTextBox(vis, paragraphValue[0].value, _display.multipleMeasure.value.font);
              _symbol.symbolSize = valueBox.height * 0.8;
              _symbol.hasSymbol = true;
              if (valueBox.width > maxValue) {
                maxValue = valueBox.width;
              }
            } else if (paragraphValue.length > 1) {
              if (paragraphValue[0].label !== null) {
                if (paragraphValue[0].shape !== null && paragraphValue[0].color !== null) {
                  _symbol.symbolSize = getTextBox(vis, paragraphValue[0].label, _display.multipleMeasure.label.font).height * 0.8;
                  _symbol.hasSymbol = true;
                }
              }
              
              if (paragraphValue[0].value !== null) {
                if (paragraphValue[0].shape !== null && paragraphValue[0].color !== null) {
                  _symbol.symbolSize = getTextBox(vis, paragraphValue[0].value, _display.multipleMeasure.value.font).height * 0.8;
                  _symbol.hasSymbol = true;
                }               
              }
              
              for (var j = 0; j < paragraphValue.length; j++) {
                if ((paragraphValue[j].label !== null) && (paragraphValue[j].value !== null)) {
                  tmpWidth = getTextBox(vis, paragraphValue[j].label, _display.multipleMeasure.label.font).width + getTextBox(vis, paragraphValue[j].value, _display.multipleMeasure.value.font).width;
                  if (tmpWidth > maxValue) {
                    maxValue = tmpWidth;
                  }
                } else if (paragraphValue[j].label !== null) {
                  tmpWidth = getTextBox(vis, paragraphValue[j].label, _display.multipleMeasure.label.font).width;
                  if (tmpWidth > maxValue) {
                    maxValue = tmpWidth;
                  }                    
                } else if (paragraphValue[j].value !== null) {
                  tmpWidth = getTextBox(vis, paragraphValue[j].value, _display.multipleMeasure.value.font).width;
                  if (tmpWidth > maxValue) {
                    maxValue = tmpWidth;
                  }                    
                }
              }
            }
          }
        }
      }
      
      if (tooltipFooter) {
        for (var m = 0; m < tooltipFooter.length; m++) {
          var item = tooltipFooter[m];
          
          if (item.label && item.value) {
            tmpWidth = getTextBox(vis, item.label, _display.footer.label.font).width + getTextBox(vis, item.value, _display.footer.value.font).width;
        if (tmpWidth > maxValue) {
          maxValue = tmpWidth;
        }
          }
        }
      }
    
      return maxValue;
    }
        
    function getSymbolPath(type, size){
      var symbolPath = '', r, rx, ry; 
      switch(type){
        case 'circle' :
          r = size / 2;
          symbolPath = "M0," + r + "A" + r + "," + r + " 0 1,1 0," + (-r) + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
          break;
        case "cross" :
          rx = size / 6;
          ry = size / 6;
          symbolPath = "M" + -3 * rx + "," + -ry + "H" + -rx + "V" + -3 * ry + "H" + rx + "V" + -ry + "H" + 3 * rx + "V" + ry + "H" + rx + "V" + 3 * ry + "H" + -rx + "V" + ry + "H" + -3 * rx + "Z";
          break;
        case "triangle-down" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
          break;
        case "triangle-up" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
          break;
        case "diamond" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
          break;
        case 'squareWithRadius' : 
          r = size / 2;
          var radius = r - 3;
          symbolPath = "M0," +  -r + "L" + -radius + ","+ -r + "Q" + -r +"," + -r + " " + -r + "," + -radius + "L" + -r +"," + radius + "Q" + -r + "," + r + " " + -radius + "," + r + "L" + radius + "," + r +"Q" + r + "," + r + " " + r + "," +radius + "L" + r +"," + -radius + "Q" + r + "," + -r + " "+ radius + "," + -r +"Z";
          break;
        case 'square' :
          r = size / 2;
          symbolPath = "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
          break;
        case "triangle-left" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M" + -rx + ",0L" + rx + "," + ry + " " + rx + "," + -ry + "Z";
          break;
        case "triangle-right" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M" + rx + ",0L" + -rx + "," + ry + " " + -rx + "," + -ry + "Z";
          break;
        case "intersection" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M" + rx + ',' + ry + ' ' +  rx/3 + ',0 ' + rx + ',' + -ry + ' ' + rx / 2 + ',' + -ry + ' 0,' + -ry/3 + ' ' + -rx / 2 + ',' + -ry + ' ' + -rx + ',' + -ry + ' ' + -rx/3 + ',0 ' + -rx + ',' + ry + ' ' + -rx/2 + ',' + ry + ' 0,' + ry/3 + ' ' + rx/2 + ',' + ry;
          break;
      }
      
      return symbolPath;
    }
      
    function drawSymbolV2(vis, pos, symbolType, color, symbolSize, className) {
      var parameter = {
        drawingEffect: _properties.drawingEffect,
        fillColor : color,
        graphType : symbolType,
        direction : 'vertical'
      };
        
      var fillId =  effectManager.register(parameter);
      vis.append('path').attr('d', getSymbolPath(symbolType, symbolSize)).attr('transform', 'translate(' + pos.x + ',' + pos.y + ')').attr('fill', fillId).attr('class', className);
    } 
        
    function drawContentV2(vis, pos, data, markerPos) {
      //Because yStart starts at a offset radius in function drawShape, to substract radius here.
      var xStart = pos.x, yStart = pos.y - _shapeLayout.radius / 2;
      //var markerPos = properties.orientation;
      var markerWidth = _shapeLayout.markerWidth, markerHeight = _shapeLayout.markerHeight;
      
      if (markerPos === 'left') {
        xStart += markerHeight;
      }
      if (markerPos === 'top') {
        yStart += markerHeight;
      }
  
      var multipleHorizontal = _display.multipleMeasure.padding.horizontal, multipleVertical = _display.multipleMeasure.padding.vertical, multipleInline = _display.multipleMeasure.padding.inline, symbolGap = _display.multipleMeasure.padding.symbolGap, 
          defaultSpace = _display.multipleMeasure.padding.defaultSpace;
      var symbolSize = _symbol.symbolSize, hasSymbol = _symbol.hasSymbol;
      var titleColor = _display.title.color, titleFont = _display.title.font;
      var multipleLabelFont = _display.multipleMeasure.label.font, multipleLabelColor = _display.multipleMeasure.label.color, 
          singleLabelFont = _display.singleMeasure.label.font, singleLabelColor = _display.singleMeasure.label.color;
      var multipleValueFont = _display.multipleMeasure.value.font, multipleValueColor = _display.multipleMeasure.value.color, 
          singleValueFont = _display.singleMeasure.value.font, singleValueColor = _display.singleMeasure.value.color;
      var footerInline = _display.footer.padding.inline, footerLabelFont = _display.footer.label.font, 
          footerValueFont = _display.footer.value.font, footerLabelColor = _display.footer.label.color, 
          footerValueColor = _display.footer.value.color;
      var tooltipBody = data.body, tooltipFooter = data.footer;
      var currentBodyIndex = -1, currentFooterIndex = -1;
      var rowPos = {
                x : 0,
                y : 0
            };
        
      var isBreak = false;
        
        if (tooltipBody) {

          for (var i = 0; i < tooltipBody.length; i++) {
            
            if (isBreak) {
              break;
            }
            
            var paragraph = tooltipBody[i];
            if (paragraph.name) {
              var titleBox = getTextBox(vis, paragraph.name, titleFont);
              var titleHeight = titleBox.height;          
              rowPos.x = xStart + multipleHorizontal;
              if (i === 0) {
                rowPos.y = yStart + titleHeight + multipleVertical;
              }
              else {
                rowPos.y += (yStart + titleHeight + multipleInline);
              }
              
              drawTextV2(vis, rowPos, paragraph.name, titleColor, titleFont, _paragraphTitleClassName);
              currentBodyIndex++;
              if (_truncationParameter.isTruncated && currentBodyIndex === _truncationParameter.currentBodyIndex) {
                var valueBox1 = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
                rowPos.x = xStart + (tooltipWidth - valueBox1.width - multipleHorizontal);
                rowPos.y += (multipleInline + valueBox1.height);
                drawTextV2(vis, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);    
                break;
              }
            }
            
            if (paragraph.val.length > 0) {
              
              if (paragraph.val.length > 1) {
                var labelBox = null, valueBox = null, offset = null;
                for (var j = 0; j < paragraph.val.length; j++) {
                  
                  if ((paragraph.val[j].shape !== null) && (paragraph.val[j].color !== null) && (paragraph.val[j].label !== null) && (paragraph.val[j].value !== null)) {                     
                    labelBox = getTextBox(vis, paragraph.val[j].label, multipleLabelFont);
                    valueBox = getTextBox(vis, paragraph.val[j].value, multipleValueFont);
                    offset = (labelBox.height >= valueBox.height) ? labelBox.height: valueBox.heigth;
                    
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    rowPos.y += (multipleInline + offset);
                    //drawSymbol
                    drawSymbolV2(vis, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape,  paragraph.val[j].color, symbolSize, _symbolClassName);
                    
                    rowPos.x = xStart + multipleHorizontal + symbolSize + symbolGap;
                    drawTextV2(vis, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);
                    
                    rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
                    drawTextV2(vis, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);                          
                  } else if ((paragraph.val[j].shape !== null) && (paragraph.val[j].color !== null) && (paragraph.val[j].label !== null)) {
                    labelBox = getTextBox(vis, paragraph.val[j].label, multipleLabelFont);
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    rowPos.y += (multipleInline + labelBox.height);
                    //drawSymbol
                    drawSymbolV2(vis, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape, paragraph.val[j].color, symbolSize, _symbolClassName);
                    
                    rowPos.x = xStart + multipleHorizontal + symbolSize + symbolGap;
                    drawTextV2(vis, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);

                  } else if ((paragraph.val[j].shape !== null) && (paragraph.val[j].color !== null) && (paragraph.val[j].value !== null)) {
                    valueBox = getTextBox(vis, paragraph.val[j].value, multipleValueFont);
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    rowPos.y += (multipleInline + valueBox.height);
                    //drawSymbol
                    drawSymbolV2(vis, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape, paragraph.val[j].color, symbolSize, _symbolClassName);
                    
                    rowPos.x = xStart + tooltipWidth - valueBox.width - multipleHorizontal;
                    drawTextV2(vis, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                  
                  } else if ((paragraph.val[j].label !== null) && (paragraph.val[j].value !== null)) {
                    labelBox = getTextBox(vis, paragraph.val[j].label, multipleLabelFont);
                    valueBox = getTextBox(vis, paragraph.val[j].value, multipleValueFont);
                    offset = (labelBox.height >= valueBox.height) ? labelBox.height: valueBox.heigth;
     
                    rowPos.x = xStart + multipleHorizontal;
                    rowPos.y += (multipleInline + offset);
                    drawTextV2(vis, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);
                    
                    rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
                    drawTextV2(vis, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                  }
                  
                  currentBodyIndex++;
                  if (_truncationParameter.isTruncated && currentBodyIndex === _truncationParameter.currentBodyIndex) {
                    var valueBox2 = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
                    rowPos.x = xStart + (tooltipWidth - valueBox2.width - multipleHorizontal);
                    rowPos.y += (multipleInline + valueBox2.height);
                    drawTextV2(vis, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);
                    isBreak = true;
                    break;
                  }  
                }
                
              } else if (paragraph.val.length === 1) {
                if (paragraph.val[0].value !== null) {
                  var tempValueBox = getTextBox(vis, paragraph.val[0].value, multipleValueFont);
                  rowPos.y += (multipleInline + tempValueBox.height);
                  
                  if (_properties.chartType === 'heatmap' || _properties.chartType === 'treemap' || _properties.chartType === 'tagcloud' || _properties.chartType === 'geo' ||_properties.chartType === 'mekko') {
                    rowPos.x = xStart + (tooltipWidth - tempValueBox.width - multipleHorizontal);

                  } else if (paragraph.val[0].shape !== null && paragraph.val[0].color !== null) {
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    drawSymbolV2(vis, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[0].shape, paragraph.val[0].color, symbolSize, _symbolClassName);
                    rowPos.x = xStart + (tooltipWidth - tempValueBox.width - multipleHorizontal);
                    
                  }
                  drawTextV2(vis, rowPos, paragraph.val[0].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                  
                  currentBodyIndex++;
                  if (_truncationParameter.isTruncated && currentBodyIndex === _truncationParameter.currentBodyIndex) {
                    var valueBox3 = getTextBox(vis, _truncationParameter.defaultValue, multipleValueFont);
                    rowPos.x = xStart + (tooltipWidth - valueBox3.width - multipleHorizontal);
                    rowPos.y += (multipleInline + valueBox3.height);
                    drawTextV2(vis, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);    
                    break;
                  }
                }
              }
            }
          }
        }
        
        if (tooltipFooter && tooltipFooter.length > 0) {
          //draw seperated line
                var separateLineStart = {
                      x: xStart,
                      y: rowPos.y + multipleVertical
                    };
 
                var separateLineEnd = {
                      x: xStart + tooltipWidth,
                      y: rowPos.y + multipleVertical
                    };
                
                vis.append('line').attr('x1', separateLineStart.x + 1).attr('y1', separateLineStart.y).attr('x2', separateLineEnd.x - 1).attr('y2', separateLineEnd.y).style('stroke',  _defaultToolTipColors.separateLineSingleColor).style('stroke-width', 1).style('shape-rendering', 'crispEdges');
            rowPos.y += (multipleVertical * 2);
        
            //draw footer
            for (var k = 0; k < tooltipFooter.length; k++) {
              if (TypeUtils.isExist(tooltipFooter[k].label) && TypeUtils.isExist(tooltipFooter[k].value)) {
                var footerLabelBox = getTextBox(vis, tooltipFooter[k].label, footerLabelFont), footerValueBox = getTextBox(vis, tooltipFooter[k].value, footerValueFont);
                rowPos.x = xStart + multipleHorizontal;
                if (k > 0) {
                  rowPos.y += footerInline;
                }
                
                rowPos.y += (footerLabelBox.height);
                //draw label
                drawTextV2(vis, rowPos, tooltipFooter[k].label, footerLabelColor, footerLabelFont, _footerLabelClassName);
                
                rowPos.x = xStart + (tooltipWidth - footerValueBox.width - multipleHorizontal);
                //draw value
                drawTextV2(vis,rowPos, tooltipFooter[k].value, footerValueColor, footerValueFont, _footerValueClassName);
                
                currentFooterIndex++;
                if (_truncationParameter.isTruncated && currentFooterIndex === _truncationParameter.currentFooterIndex) {
                  break;
                }
              }
            }
        }            
    }
        
    var formatTooltipData = function(data){
      if(TypeUtils.isExist(_properties.formatString)){
        var body = data.body, ibody, valueAxis0sum = 1, valueAxis0Count = 0, valueAxis1sum = 1, valueAxis1Count =0, t0count = data.valueAxis0Count, t1count = data.valueAxis1Count;
        var indexAxis0 = 0, indexAxis1 = 0;
        var formatString = _properties.formatString;
        var iFormatString,indexOfFS;
        if(TypeUtils.isExist(body)){
          for(var i=0, len=body.length; i< len; i++){
            ibody = body[i];
            if(TypeUtils.isExist(ibody.val[0].valueAxis)){
              indexOfFS = ibody.val[0].valueAxis;
            }
            else {
              indexOfFS = 0;
            }
            iFormatString = formatString[indexOfFS];
            //if formatstring is unll or undefined ,we will use the default value
            if(TypeUtils.isExist(iFormatString)){
              var indexOfiFS = 0;
              if(indexOfFS===0){
                indexOfiFS = indexAxis0 >= iFormatString.length ? iFormatString.length -1 : indexAxis0;
                indexAxis0++;
              }
              else if(indexOfFS===1){
                indexOfiFS = indexAxis1 >= iFormatString.length ? iFormatString.length -1 : indexAxis1;
                indexAxis1++;
              }
              for(var j=0, jlen= ibody.val.length; j < jlen; j++){
                          ibody.val[j].value = formatManager.format(ibody.val[j].value, iFormatString[indexOfiFS]);
              }
            }
            
          }
        }
      }
      return data;
    };
    
    tooltip.showTooltip = function (eventData) {
      var data = ObjectUtils.extend(true, {}, eventData.data);
      data = formatTooltipData(data);
      if(gWrapper !== null){
        gWrapper.remove();
      }
      
      if (_properties.visible) {
        if (data.plotArea) {
            tooltip.plotArea(data.plotArea);
        }
        
        _orientation = _properties.orientation;
        gWrapper = vis.append('svg:g');
        updateTooltipStyle();
      
        textMaxWidth = getTextMaxWidthV2(vis, data);
        tooltipWidth = getTooltipWidthV2(gWrapper, data);
        tooltipHeight = getTooltipHeightV2(gWrapper, data);
          
        var tmpWidth = tooltipWidth, tmpHeight = tooltipHeight;
        if (_orientation === 'top' || _orientation === 'bottom') {
          tmpHeight += _shapeLayout.markerHeight;
        }
        
        if (_orientation === 'left' || _orientation === 'right') {
          tmpWidth += _shapeLayout.markerHeight;
        }
        vis.attr('width', tmpWidth + _shapeLayout.padding).attr('height', tmpHeight + _shapeLayout.padding);
        
        //appendLinearGradient(gWrapper);
  
        var tooltipPos = calculatePos(data.point, plotArea, zone, tooltipWidth, tooltipHeight);
        drawShape(gWrapper, {x:0,y:0, absoluteMarkerOffset : tooltipPos.absoluteMarkerOffset}, tooltipWidth, tooltipHeight, _orientation);
        drawContentV2(gWrapper, {x:0,y:0}, data, _orientation);
        vis.style('left', tooltipPos.x + 'px').style('top', tooltipPos.y + 'px');
        clearTruncationParameter();
      }
    };  
    
    tooltip.hideTooltip = function () {
      if (gWrapper !== null) {
        gWrapper.remove();
        vis.attr('width', 0).attr('height', 0);
        gWrapper = null;
        }
    };
    
    function calculateSymbolSize(data) {
      if (data.labels) {
        _symbol.symbolSize = getTextBox(vis, data.labels[0].label, _display.multipleMeasure.label.font).height;
      }
    }
    
      function calculatePos(point, plotArea, zone, tooltipWidth, tooltipHeight) {
      var tooltipPos = {
          x: 0,
          y: 0,
          absoluteMarkerOffset: 0
      };
      
      var chartType = _properties.chartType;
      var markerHeight = _shapeLayout.markerHeight, markerWidth = _shapeLayout.markerWidth;
      var rightOffset = 0,  leftOffset = 0, topOffset = 0, bottomOffset = 0;

//      if (tooltipWidth > zone.width || tooltipHeight > zone.height) {
//        return tooltipPos;
//      } 
      
      if (_properties.chartType === undefined) {
        tooltipPos.x = point.x;
        tooltipPos.y = point.y - tooltipHeight/2;
      } else if (chartType === 'heatmap' || chartType === 'treemap' || chartType === 'tagcloud') {
        
        if (_orientation === 'bottom') {
          var upBorder = zone.height - point.y + tooltipHeight + markerHeight;
          if (upBorder > zone.height) {
            _orientation = 'top';
            tooltipPos.y = point.y;
          } else {
            tooltipPos.y = point.y - tooltipHeight - markerHeight;
          }
        }
        
        var tooltipPosX;
        if (chartType === 'heatmap' || chartType === 'treemap' || chartType === 'tagcloud') 
        {
            tooltipPosX = calculateTooltipPosXForMBCCharts(point, plotArea, zone, tooltipWidth);
        }
        else
        {
            tooltipPosX = calculateTooltipPosX(point, plotArea, zone, tooltipWidth);
        }

        tooltipPos.x = tooltipPosX.x;
        tooltipPos.absoluteMarkerOffset = tooltipPosX.absoluteMarkerOffset;
        
      } else if (chartType === 'line' || chartType === 'verticalboxplot' || chartType === 'verticalbar') {
        if (_orientation === 'left') {
          var rightBorder = point.x + tooltipWidth + markerHeight;
          if (rightBorder > zone.width) {
            _orientation = 'right';
            tooltipPos.x = point.x - tooltipWidth - markerHeight;
          } else {
            tooltipPos.x = point.x + markerHeight;
          }
        }
        if (tooltipHeight / 2 < plotArea.y) {
          //tooltip marker is over chart top border.
          tooltipPos.y = plotArea.y - (tooltipHeight - markerWidth) / 2;
        } else {
          tooltipPos.y = 0;
        }
        
      } else if (chartType === 'radar') {
        rightOffset = 0;
        leftOffset = 0;
        topOffset = 0;
        bottomOffset = 0;
        var x = 0, y = 0;
        
        _orientation = point.orientation;
        tooltipPos.x = point.x;
        tooltipPos.y = point.y - tooltipHeight / 2;
        
        if (point.orientation === 'right') {
          tooltipPos.x -= (tooltipWidth + markerHeight);
        }
        
        if (point.orientation === 'left') {
          rightOffset = point.x + tooltipWidth + markerHeight - zone.width;

        }
        
        if (point.orientation === 'right') {
          leftOffset = point.x - tooltipWidth - markerHeight;
        }
        
        topOffset = point.y - tooltipHeight / 2;
        bottomOffset = point.y + tooltipHeight / 2 - zone.height;
        
        if (rightOffset <= 0 && leftOffset >= 0 && topOffset >= 0 && bottomOffset <= 0) {
          return tooltipPos;
        }
        
        if (rightOffset > 0 &&  rightOffset > point.range.x) {
          return tooltipPos;
        }
        
        if (leftOffset < 0 && Math.abs(leftOffset) > point.range.x) {
          return tooltipPos;
        }
        
        if (topOffset < 0 && Math.abs(topOffset) > point.range.y) {
          return tooltipPos;
        }
        
        if (bottomOffset > 0 && bottomOffset > point.range.y) {
          return tooltipPos;
        }
        
        var angle = point.angle * 180 / Math.PI, radian = point.angle;
        
        if (angle >= 0) {

          if (angle === 0 && rightOffset > 0) {
            tooltipPos.x -= rightOffset;
          } else if (angle === 90 && topOffset < 0) {
            tooltipPos.y -= topOffset;
          } else if (angle === 180 && leftOffset < 0) {
            tooltipPos.x -= leftOffset;
          } else if (angle > 0 && angle < 90) {
            if (topOffset < 0 && rightOffset > 0) {
              //both tooltip top and right border cross chart top and right border
              var  topOffsetAbs1 = Math.abs(topOffset);
              if (topOffsetAbs1 >= rightOffset) {
                y = topOffsetAbs1;
                x = y / Math.tan(radian);
              } else  {
                x = rightOffset;
                y = x * Math.tan(radian);
                
              }
            } else if (topOffset < 0 && rightOffset <= 0) {
              //only tooltip top border cross chart top border
              y = Math.abs(topOffset);
              x = y / Math.tan(radian);
            } else if (topOffset >= 0 && rightOffset > 0) {
              //only tooltip right border cross chart right border
              x = rightOffset;
              y = x * Math.tan(radian);
            }
            
            tooltipPos.x -=x;
            tooltipPos.y += y;
            
          } else if (angle > 90 && angle < 180) {
            if (topOffset < 0 && leftOffset < 0) {
              //both tooltip top and left border cross chart top and left border
              var topOffsetAbs2 = Math.abs(topOffset), leftOffsetAbs1 = Math.abs(leftOffset);
              if (topOffsetAbs2 >= leftOffsetAbs1) {
                y = topOffsetAbs2;
                x = y / Math.tan(Math.PI - radian);
              } else {
                x = leftOffsetAbs1;
                y = x * Math.tan(Math.PI - radian);
              }
              
            } else if (topOffset < 0 && leftOffset >= 0) {
              //only tooltip top border cross chart top border
              y = Math.abs(topOffset);
              x = y / Math.tan(Math.PI - radian);
              
            } else if (topOffset >= 0 && leftOffset < 0) {
              //only tooltip left border cross chart left border
              x = Math.abs(leftOffset);
              y = x * Math.tan(Math.PI -radian);
            }
            
            tooltipPos.x +=x;
            tooltipPos.y += y;
          }
          
        } else {
          
          var angleAbs = Math.abs(angle);
          if (angleAbs === 0 && rightOffset > 0) {
            tooltipPos.x -= rightOffset;
          } else if (angleAbs === 90 && bottomOffset > 0) {
            tooltipPos.y -= bottomOffset;
          } else if (angleAbs === 180 && leftOffset < 0) {
            tooltipPos.x -= leftOffset;
          } else if (angleAbs > 0 && angleAbs < 90) {
            if (bottomOffset > 0 && rightOffset > 0) {
              //both tooltip bottom and right border cross chart top and right border
              if (bottomOffset >= rightOffset) {
                y = bottomOffset;
                x = y / Math.tan(Math.abs(radian));
              } else  {
                x = rightOffset;
                y = x * Math.tan(Math.abs(radian));
                
              }
            } else if (bottomOffset > 0 && rightOffset <= 0) {
              //only tooltip bottom border cross chart bottom border
              y = bottomOffset;
              x = y / Math.tan(Math.abs(radian));
            } else if (bottomOffset <= 0 && rightOffset > 0) {
              //only tooltip right border cross chart right border
              x = rightOffset;
              y = x * Math.tan(Math.abs(radian));
            }
            
            tooltipPos.x -=x;
            tooltipPos.y -= y;            
          } else if (angleAbs > 90 && angleAbs < 180) {
            if (bottomOffset > 0 && leftOffset < 0) {
              var leftOffsetAbs2 = Math.abs(leftOffset);
              //both tooltip bottomOffset and left border cross chart top and left border
              if (bottomOffset >= leftOffsetAbs2) {
                y = bottomOffset;
                x = y / Math.tan(Math.PI - Math.abs(radian));
              } else {
                x = leftOffsetAbs2;
                y = x * Math.tan(Math.PI - Math.abs(radian));
              }
              
            } else if (bottomOffset > 0 && leftOffset >= 0) {
              //only tooltip bottom border cross chart bottom border
              y = bottomOffset;
              x = y / Math.tan(Math.PI - Math.abs(radian));
              
            } else if (bottomOffset <= 0 && leftOffset < 0) {
              //only tooltip left border cross chart left border
              x = Math.abs(leftOffset);
              y = x * Math.tan(Math.PI -Math.abs(radian));
            }
            
            tooltipPos.x +=x;
            tooltipPos.y -= y;            
          }      
        }
        
      } else if (chartType === 'geo' && _orientation === 'left'){
        // In this style, tooltip will always point to the plot origin horizontally.
       topOffset = point.y - tooltipHeight / 2;
       bottomOffset = point.y + tooltipHeight / 2 - zone.height;
        
        tooltipPos.y = topOffset;
        
        if (plotArea.x + plotArea.width + tooltipWidth - markerHeight > zone.width) {
          tooltipPos.x = plotArea.x - plotArea.width - tooltipWidth;
          _orientation = 'right';
        } else {
          tooltipPos.x = plotArea.x + plotArea.width - markerHeight;
        }

        if (topOffset < 0) {
          tooltipPos.y = 0;
          tooltipPos.absoluteMarkerOffset = topOffset;
        }
        
        if (bottomOffset > 0) {
          tooltipPos.y = zone.height - tooltipHeight;
          tooltipPos.absoluteMarkerOffset = bottomOffset;
        }
      } else {
        
        if (_properties.orientation === 'left') {
          
          rightOffset = plotArea.x + plotArea.width + tooltipWidth + markerHeight - zone.width;
          topOffset = point.y - tooltipHeight / 2;
          bottomOffset = point.y + tooltipHeight / 2 - zone.height;
          
          tooltipPos.y = point.y - tooltipHeight / 2;
          
          if (rightOffset > 0) {
            tooltipPos.x = zone.width - markerHeight - tooltipWidth;
          } else {
            tooltipPos.x = plotArea.x + plotArea.width - markerHeight;
          }
          
          if (topOffset < 0) {
            tooltipPos.y = 0;
            tooltipPos.absoluteMarkerOffset = topOffset;
          }
          
          if (bottomOffset > 0) {
            tooltipPos.y = zone.height - tooltipHeight;
            tooltipPos.absoluteMarkerOffset = bottomOffset;
          }

        } else if (_properties.orientation === 'bottom') {      
  
          var top = plotArea.y - tooltipHeight;
          if (top < 0) {
            tooltipPos.y = 0;
          } else {
            tooltipPos.y = plotArea.y - tooltipHeight;
          }
          
          var posX;
          if (chartType === 'heatmap' || chartType === 'treemap' || chartType === 'tagcloud') 
          {
              posX = calculateTooltipPosXForMBCCharts(point, plotArea, zone, tooltipWidth);
          }
          else
          {
              posX = calculateTooltipPosX(point, plotArea, zone, tooltipWidth);
          }
          tooltipPos.x = posX.x;
          tooltipPos.absoluteMarkerOffset = posX.absoluteMarkerOffset;
        }
        
      }

      return tooltipPos;
    }
    
    function calculateTooltipPosX(point, plotArea, zone, tooltipWidth) {
      var tooltipPosX = {
          x: 0,
          absoluteMarkerOffset: 0
      };
      
      var leftBorder = tooltipWidth / 2 - (point.x - plotArea.x) + plotArea.width;
      var rightBorder = point.x - plotArea.x + tooltipWidth / 2;
      if (leftBorder > zone.width) {
        tooltipPosX.x = plotArea.x;
        tooltipPosX.absoluteMarkerOffset = point.x - plotArea.x - tooltipWidth / 2;
      } else if (rightBorder > zone.width) {
        tooltipPosX.x = plotArea.x + (plotArea.width - tooltipWidth);
        tooltipPosX.absoluteMarkerOffset = plotArea.width - (point.x - plotArea.x) - tooltipWidth / 2;
      } else {
        tooltipPosX.x = point.x - tooltipWidth / 2;
        tooltipPosX.absoluteMarkerOffset = 0;
      }
      
      return tooltipPosX;
    }

    function calculateTooltipPosXForMBCCharts(point, plotArea, zone, tooltipWidth) {
      var tooltipPosX = {
          x: 0,
          absoluteMarkerOffset: 0
      };
      
      var leftBorder = tooltipWidth - (point.x - plotArea.x) + plotArea.width;
      var rightBorder = point.x - plotArea.x + tooltipWidth;

      if (leftBorder > zone.width) {
        tooltipPosX.x = plotArea.x;
        tooltipPosX.absoluteMarkerOffset = point.x - plotArea.x - tooltipWidth / 2;
      } else if (rightBorder > zone.width) {
        tooltipPosX.x = plotArea.x + (plotArea.width - tooltipWidth);
        
        if(tooltipPosX.x + tooltipWidth > plotArea.width)
        {
            tooltipPosX.absoluteMarkerOffset = point.x - plotArea.x - plotArea.width + tooltipWidth / 2;
        }
        else
        {
            tooltipPosX.absoluteMarkerOffset = plotArea.width - (point.x - plotArea.x) - tooltipWidth / 2;
        }
      } else {
        tooltipPosX.x = point.x - tooltipWidth / 2;
        tooltipPosX.absoluteMarkerOffset = 0;
      }
      
      return tooltipPosX;
    }
    
    function calculateTooltipPosY(point, plotArea, zone, tooltipHeight) {
      var tooltipPosY = {
          y: 0,
          absoluteMarkerOffset: 0
      };
      
      var upBorder = plotArea.height + (tooltipHeight / 2 - (point.y - plotArea.y));
      var downBorder = point.y - plotArea.y + tooltipHeight / 2;
      if (upBorder > zone.height) {
        tooltipPosY.y = plotArea.y;
        tooltipPosY.absoluteMarkerOffset = point.y - plotArea.y - tooltipHeight / 2;
      } else if (downBorder > zone.height) {
        tooltipPosY.y = plotArea.y + plotArea.height - tooltipHeight;
        tooltipPosY.absoluteMarkerOffset = point.y - (plotArea.height - tooltipHeight) - plotArea.y - tooltipHeight / 2;
      } else {
        tooltipPosY.y = point.y - tooltipHeight / 2;
        tooltipPosY.absoluteMarkerOffset = 0;
      }
      
      return tooltipPosY;
    }
    
    function drawShape(vis, pos, width, height, markerPos) {
      
      var xStart = pos.x, yStart = pos.y, offset = pos.absoluteMarkerOffset, radius = _shapeLayout.radius, markerWidth = _shapeLayout.markerWidth, markerHeight = _shapeLayout.markerHeight;
      var space = ' ';
      var lineTo = _svgPathCommand.lineToA, moveTo = _svgPathCommand.moveToA, arc = _svgPathCommand.arcA, closePath = _svgPathCommand.closePath;
      //var markerPos = properties.orientation;
      
      if (markerPos === 'left') {
        xStart += markerHeight;
      }
      if (markerPos === 'top') {
        yStart += markerHeight;
      }

      var path = moveTo + space + xStart + space + (yStart + radius) + space;

      if (markerPos === 'left') {
          path += lineTo + space + xStart + space + (yStart + height / 2 + offset - markerWidth / 2 ) + space;
          path += lineTo + space + (xStart - markerHeight) + space + (yStart + height / 2 + offset ) + space;
          path += lineTo + space + xStart + space + (yStart + height / 2 + offset + markerWidth / 2 ) + space;
      }

      path += lineTo + xStart + space + (yStart + height - radius) + space;

      path += arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + radius) + space + (yStart + height) + space;

      if (markerPos === 'bottom') {
          path += lineTo + space + (xStart + width / 2 + offset - markerWidth / 2) + space + (yStart + height) + space;
          path += lineTo + space + (xStart + width / 2 + offset) + space + (yStart + height + markerHeight) + space;
          path += lineTo + space + (xStart + width / 2 + offset + markerWidth / 2) + space + (yStart + height) + space;
      }

      path += lineTo + space + (xStart + width - radius) + space + (yStart + height) + space;

      path += space + arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + width) + space + (yStart + height - radius) + space;

      if (markerPos === 'right') {
          path += lineTo + space + (xStart + width) + space + (yStart + height / 2 + offset + markerWidth / 2) + space;
          path += lineTo + space + (xStart + width + markerHeight) + space + (yStart + height / 2 - offset) + space;
          path += lineTo + space + (xStart + width) + space + (yStart + height / 2 + offset - markerWidth / 2) + space;
      }

      path += lineTo + space + (xStart + width) + space + (yStart + radius) + space;

      path += space + arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + width - radius) + space + yStart + space;

      if (markerPos === 'top') {
          path += lineTo + space + (xStart + width / 2 + offset + markerWidth / 2) + space + yStart + space;
          path += lineTo + space + (xStart + width / 2 + offset) + space + (yStart - markerHeight) + space;
          path += lineTo + space + (xStart + width / 2 + offset - markerWidth / 2) + space + yStart + space;
      }

      path += lineTo + space + (xStart + radius) + space + yStart + space;

      path += arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + xStart + space + (yStart + radius) + space;

      path += closePath;
      
      vis.append('path').attr('d', path).attr('fill', _defaultToolTipColors.backgroundColor).attr('stroke', _defaultToolTipColors.borderColor).style('stroke-width', 1).style('-webkit-svg-shadow', '3px 3px 8px rgba(0, 0, 0, 0.3)');

    }

    function getCustomlabel(rawObj){
      var ret;
      if(rawObj.info){
        var clobj = rawObj.info.customlabel;
        if(clobj){
          if(clobj.type === 'url'){
            ret = rawObj.val;
          }else if(clobj.type === 'string'){
            ret = clobj.val;
          }
        }else{
          ret = rawObj.val;
        }
      }else{
        ret = rawObj.val;
      }
      ret = handleNull(ret);
      return ret;
    }
    
    function resolveText(rawObj){
      var ret = [];
      if(TypeUtils.isPlainObject(rawObj)){ 
        ret.push(getCustomlabel(rawObj));
      }else if(TypeUtils.isArray(rawObj)){
        rawObj.forEach(function(iter, index){
          ret.push(resolveText(iter));
        }, this);
      }else{
        ret.push(rawObj);
      }
      return ret;
    }
    
    function getTextBox(vis, text, style) {
      /*[Jimmy/1/2/2013]we extend text to also accepts Object with following structure: 
       * {
       *   val: xxxx
       *   info: xxxx
       * }, same structure as we used in module. then we can support additional info like customlabel in tooltip
       * text can also be array, we will compose each member with '/' (hard coded currently) and measure the final result
       */
      var resolvedTexts = resolveText(text);
      var composedText = resolvedTexts.join('*');
      var textHandler = vis.append('svg:text').attr('x', 0).attr('y', 0).attr('visibility', 'hidden').style('font', style).text(composedText);
      var bbox = textHandler.node().getBBox();
      textHandler.remove();
      return bbox;
    }

    function getTextMaxWidth(vis, data) {
      var maxValue = 0, textWidth = 0;
      if (data.title !== null) {
          if (data.labels.length > 0) {
              var bBox = getTextBox(vis, data.title, _display.title.font);
              var currentMax = bBox.width;

              for (var i = 0, len = data.labels.length; i < len; i++) {
                 textWidth = getTextBox(vis, data.labels[i].label, _display.multipleMeasure.label.font).width + getTextBox(vis, data.labels[i].value, _display.multipleMeasure.value.font).width;
                  if (textWidth > currentMax) {
                      currentMax = textWidth;
                  }
              }
              maxValue = currentMax;
          }
      } else {
          maxValue = getTextBox(vis, data.labels[0].label, _display.singleMeasure.label.font).width;
          textWidth = getTextBox(vis, data.labels[0].value, _display.singleMeasure.value.font).width;

          if (textWidth > maxValue) {
              maxValue = textWidth;
          }
      }
      return maxValue;
    }

    function getTooltipWidth(vis, data) {
      var tooltipWidth = 0, symbolSize = _symbol.symbolSize;
      var singleHorizontal = _display.singleMeasure.padding.horizontal, multipleHorizontal = _display.multipleMeasure.padding.horizontal, symbolGap = _display.multipleMeasure.padding.symbolGap, defaultSpace = _display.multipleMeasure.padding.defaultSpace;
      if (data.title !== null) {
        tooltipWidth = textMaxWidth + (multipleHorizontal * 2) + defaultSpace; //+ radius * 2;
        if (data.shapes && data.colors) {
          tooltipWidth +=  symbolSize + symbolGap;
        }
      } else {
        tooltipWidth = textMaxWidth + (singleHorizontal * 2); 
      }
      return tooltipWidth;
    }

    function getTooltipHeight(vis, data) {
      var inline = _display.multipleMeasure.padding.inline, multipleVertical = _display.multipleMeasure.padding.vertical, singleVertical = _display.singleMeasure.padding.vertical;
      var multipleValueFont = _display.multipleMeasure.value.font, singleValueFont = _display.singleMeasure.value.font;
      var titleFont = _display.title.font;
      var tooltipHeight = 0;
        if (data.title !== null) {
            tooltipHeight = (multipleVertical * 3) + (inline * (data.labels.length - 1)) + getTextBox(vis, data.title, titleFont).height + getTextBox(vis, data.labels[0].value, multipleValueFont).height * data.labels.length;

        } else {
            tooltipHeight = (singleVertical * 3 ) + getTextBox(vis, data.labels[0].value, singleValueFont).height;
        }
        return tooltipHeight;
    }
        
    function appendLinearGradient(vis) {
      var gradient = vis.append('svg:defs').append('svg:linearGradient').attr('id', 'tooltipGradient1').attr('x1', '0%').attr('y1', '0%').attr('x2', '80%').attr('y2', '0%').attr('x3', '100%').attr('y3', '0%');
      gradient.append('svg:stop').attr('offset', '30%').attr('style', 'stop-color:' + _defaultToolTipColors.separateLineColor[0]);
      gradient.append('svg:stop').attr('offset', '60%').attr('style', 'stop-color:' + _defaultToolTipColors.separateLineColor[1]);
      gradient.append('svg:stop').attr('offset', '100%').attr('style', 'stop-color:' + _defaultToolTipColors.separateLineColor[2]);          
    }
  
    function drawSymbol(vis, pos, symbolSize, symbolType, color) {
      var symbolPath = d3.svg.symbol().type(symbolType).size(symbolSize * symbolSize);
      var parameter = {
          drawingEffect: _properties.drawingEffect,
          fillColor : color,
        graphType : symbolType,
          direction : 'vertical'
      };
      var fillId =  effectManager.register(parameter);
      vis.append('path').attr('d', symbolPath).attr('transform', 'translate(' + pos.x + ',' + pos.y + ')').attr('fill', fillId);
    } 
        
    function drawText(vis, pos, text, color, style) {
      vis.append('text').attr('x', pos.x).attr('y', pos.y).attr('fill', color).style('font', style).text(text);
    }
        
    function drawTextV2(vis, pos, text, color, style, className) {
      /*[Jimmy/1/2/2013]we extend text to also accepts Object with following structure: 
       * {
       *   val: xxxx
       *   info: xxxx
       * }, same structure as we used in module. then we can support additional info like customlabel in tooltip
       * text can also be array, we will compose each member with '/' (hard coded currently) and measure the final result
       */
      var resolvedTexts = resolveText(text);
      var composedText = resolvedTexts.join('/');
      vis.append('text').attr('x', pos.x).attr('y', pos.y).attr('fill', color).style('font', style).text(composedText).attr('class', className);
    }
    
    function drawContent(vis, pos, data) {}
        
    tooltip.zone = function(_){
      if(!arguments.length){
        return zone;
      }
      zone = _;
      return this;
    };
  
    tooltip.plotArea = function(_){
      if(!arguments.length){
        return plotArea;
      }
      plotArea = _;
      return this;
    };
        
    tooltip.properties = function (_) {
      if (!arguments.length){
          return _properties;
       }
      Objects.extend(true, _properties, _);
      return this;
    };
    
    function updateTooltipStyle() {
      var cssDef;
      
      cssDef = ctx.styleManager.query('viz-tooltip-background');
      if (cssDef && (cssDef['fill']) && (_defaultToolTipColors.backgroundColor !== cssDef['fill'])) {
        _defaultToolTipColors.backgroundColor = cssDef['fill'];
      }
      
      cssDef = ctx.styleManager.query('viz-tooltip-title');
      if (cssDef && (cssDef['fill']) && (_display.title.color !== cssDef['fill'])) {
        _display.title.color = cssDef['fill'];
      }

      cssDef = ctx.styleManager.query('viz-tooltip-label');
      if (cssDef && cssDef['fill']) {
        _display.singleMeasure.label.color  = cssDef['fill'];
        _display.multipleMeasure.label.color = cssDef['fill'];
      }

      cssDef = ctx.styleManager.query('viz-tooltip-value');
      if (cssDef && cssDef['fill']) {
        _display.singleMeasure.value.color  = cssDef['fill'];
        _display.multipleMeasure.value.color = cssDef['fill'];
      } 
    }
    
    _properties = manifest.props(null);
    return tooltip;
  };
  return tooltip;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tooltip',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.tooltip',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'tooltip',
    'description': 'Settings for the tooltip that appears when the user hovers over a series or point.',
    'properties' : {
      'visible' : {
        'name' : 'visible',
          'supportedValueType' : 'Boolean',
          'defaultValue' : true,
          'description' : 'Set visibility of tooltip.'
      },
     'drawingEffect':{
       'name' : 'drawingEffect',
       'supportedValueType' : 'List',
       'supportedValues' : [ 'normal', 'glossy' ],
           'defaultValue' : 'normal',
           'description' : 'Set drawing effect of Tooltip.',
           'isExported' : true
    },
	'formatString': {
	'name' : 'formatString',
	'supportedValueType': 'Two-Dimensions-Array',
  'defaultValue' : null,
	'description' : 'Set format string of tooltip. As we may have dual axis with serveral measures, the first array is applied to primary axis and the second one is applied to the second one.'
		+'If the length of format string list is less than the length of data series, the last format string in the list will be applied to exceeded data series.' 
	}
      },
    'css' : {
      '.viz-tooltip-background' : {
        'description' : 'Define style for the tooltip background.',
        'value' : {
          'fill' : '#ffffff'
        }
      },
      '.viz-tooltip-title' : {
        'description' : 'Define style for the tooltip title.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.viz-tooltip-label' : {
        'description' : 'Define style for the tooltip label.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.viz-tooltip-value' : {
        'description' : 'Define style for the tooltip value.',
        'value' : {
          'fill' : '#333333'
        }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.background',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var visibleObj = {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of background.'
      };
  var module = {
    'id' : 'sap.viz.modules.background',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'background',
    'description': 'Settings for the background for the outer chart area.',
    'properties' : {
      'visible' : visibleObj,
    'border' : {
        'name' : 'border',
      'description' : 'Settings for border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : { 
      'left' : {
        'name' : 'left',
        'description' : 'Set left border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'right' : {
        'name' : 'right',
        'description' : 'Set right border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'top' : {
        'name' : 'top',
        'description' : 'Set top border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'bottom' : {
        'name' : 'bottom',
        'description' : 'Set bottom border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          },
          },
    },
        'drawingEffect':{
          'name' : 'drawingEffect',
            'description' : 'Set drawing effect of background.',
          'supportedValueType' : 'List',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'isExported' : true,
        },
        'direction':{
          'name' : 'direction',
            'description' : 'Set gradient direction of background.',
          'supportedValueType' : 'List',
            'supportedValues' : [ 'horizontal', 'vertical' ],
            'defaultValue' : 'vertical',
        }
    },
    'css' : {
      '.viz-plot-background' : {
        'description' : 'Define style for the plot background.',
        'value' : {
          'fill' : '#ffffff',
        }
      },
      '.viz-plot-background-border' : {
        'description' : 'Define style for the plot background border.',
        'value' : {
          'stroke' : '#d8d8d8',
      'stroke-width' : 1,
      'shape-rendering' : 'crispEdges',
        }
      },
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.Vector',
  version : '4.0.0'},
[

],
function Setup(Point) {
  function Vector() {
    this.values = [];
    for ( var i = 0, len = arguments.length; i < len; i++) {
      this.values.push(arguments[i]);
    }
  }

  Vector.prototype.dotProduct = function(v) {
    var dimension = v.dimension();
    if (dimension !== this.dimension()) {
      throw new Error(
          "The vectors to be dot-producted must have same dimension, but the dimension of this vector is " +
              this.dimension + " and another one is " + dimension + ".");
    }
    var sum = 0;
    for ( var i = 0; i < dimension; i++) {
      sum += this.value(i) * v.value(i);
    }
    return sum;
  };

  Vector.prototype.dimension = function(v) {
    return this.values.length;
  };

  Vector.prototype.value = function(i, d) {
    if (arguments.length >= 2) {
      this.values[i] = d;
    }
    return this.values[i];
  };

  return Vector;
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.Vector4D',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.threeD.Vector',
  version : '4.0.0'
}
],
function Setup(Vector) {
  function Vector4D(p1, p2, p3, p4) {
    Vector.apply(this, arguments);
  }

  Vector4D.prototype = Object.create(Vector.prototype);

  return Vector4D;
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.threeD.Vector4D',
  version : '4.0.0'
}
],
function Setup(Vector4D) {
  var dimension = 4;
  var length = dimension * dimension;

  function radian(deg) {
    return deg * Math.PI / 180;
  }

  var matrixBuilder = function() {
    var values = new Array(length);

    var matrix = {
      unit : function() {
        for ( var i = 0; i < length; i++) {
          values[i] = (i % (dimension + 1) === 0) ? 1 : 0;
        }
        return matrix;
      },

      value : function(row, col, v) {
        var index = row * dimension + col;
        if (arguments.length >= 3) {
          values[index] = v;
          return matrix;
        }
        return values[index];
      },

      row : function(row) {
        var array = [];
        var start = row * dimension;
        for ( var i = 0; i < dimension; i++) {
          array[i] = values[start + i];
        }
        return new Vector4D(array[0], array[1], array[2], array[3]);
      },

      col : function(col) {
        var array = [];
        for ( var i = 0; i < dimension; i++) {
          array[i] = values[dimension * i + col];
        }
        return new Vector4D(array[0], array[1], array[2], array[3]);
      },

      translate : function(tx, ty, tz) {
        return matrix.transform(matrixBuilder().value(0, 3, tx || 0).value(1,
            3, ty || 0).value(2, 3, tz || 0));
      },

      scale : function(tx, ty, tz) {
        return matrix.transform(matrixBuilder().value(0, 0, tx || 0).value(1,
            1, ty || 0).value(2, 2, tz || 0));
      },

      rotateX : function(deg) {
        var r = radian(deg);
        var sin = Math.sin(r);
        var cos = Math.cos(r);
        return matrix.transform(matrixBuilder().value(1, 1, cos).value(1, 2,
            -sin).value(2, 1, sin).value(2, 2, cos));
      },

      rotateY : function(deg) {
        var r = radian(deg);
        var sin = Math.sin(r);
        var cos = Math.cos(r);
        return matrix.transform(matrixBuilder().value(0, 0, cos).value(0, 2,
            sin).value(2, 0, -sin).value(2, 2, cos));
      },
      
      rotateZ : function(deg){
        var r = radian(deg);
        var sin = Math.sin(r);
        var cos = Math.cos(r);
        return matrix.transform(matrixBuilder().value(0, 0, cos).value(0, 1,
            -sin).value(1, 0, sin).value(1, 1, cos));
      },
      
      transform : function(m) {
        if (m) {
          var rows = [], cols = [];
          for ( var i = 0; i < dimension; i++) {
            rows.push(m.row(i));
            cols.push(matrix.col(i));
          }
          for ( var i = 0; i < dimension; i++) {
            var start = i * dimension;
            for ( var j = 0; j < dimension; j++) {
              var index = start + j;
              values[index] = rows[i].dotProduct(cols[j]);
            }
          }
        }
        return matrix;
      },

      clone : function() {
        var newMatrix = matrixBuilder();
        for ( var i = 0; i < dimension; i++) {
          for ( var j = 0; j < dimension; j++) {
            newMatrix.value(i, j, matrix.value(i, j));
          }
        }
        return newMatrix;
      },

      projection : function() {
        return "matrix(" + matrix.value(0, 0) + "," + matrix.value(1, 0) + "," +
            matrix.value(0, 1) + "," + matrix.value(1, 1) + "," +
            matrix.value(0, 3) + "," + matrix.value(1, 3) + ")";
      },

      translatedProjection : function(){
        return "translate(" + this.value(0,3) + "," + this.value(1,3) +")";
      },
      
      toString : function() {
        var str = "";

        for ( var i = 0; i < length; i++) {
          if (i % 4 !== 0) {
            str += ", ";
          }
          str += values[i];
          if ((i - 3) % 4 === 0) {
            str += "\n";
          }
        }

        return str;
      }
    };

    return matrix.unit();
  };

  return matrixBuilder;
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.threeD.Vector4D',
  version : '4.0.0'
}
],
function Setup(Vector4D) {
  function Point(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  Point.prototype.transform = function(m) {
    var vector = new Vector4D(this.x, this.y, this.z, 1);
    this.x = m.row(0).dotProduct(vector);
    this.y = m.row(1).dotProduct(vector);
    this.z = m.row(2).dotProduct(vector);
    return this;
  };

  return Point;
});sap.riv.module(
{
  qname : 'sap.viz.modules.axis.categoryAxisCore',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.0'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.0'
}
],
function Setup(TextUtils, NumberUtils, Objects, langManager, TypeUtils, Point, matrix, FormatManager) {

  return function() {
        
        var m_position;
        var m_axScale;

        var m_textOffset = 6;
        var m_tickSize = 5;
        
        var m_styleLineSrokeWidth = 1;
        var m_styleGridLineColor = "#d8d8d8";

        var m_disableSpaceLimit = false;
        
        var m_style = null; //used to hold style passed from axis
        var m_props = 
        { 
            "title": {"visible": false, "text": undefined,},
            "gridline": {"visible": false, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true, "formatString": "", hideStrategy : '' },
            "position": "left",
            "color": "#333333",
            "shapeRendering": true,
            "forceVerticalFont": false
        }; 

        var m_matrix = matrix(), labelAngle = null, labelAlign=null, angle = null, tickAngle = null;
        
        var m_spaceLimit = -1;
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;

            if(!m_disableSpaceLimit)
            {
                m_spaceLimit = _spaceLimit;
            }

            return axis;
        }

        var adjustScale = function()
        {
            //we have to adjust the scale because we may not draw all the levels.
            var scaleToDraw = [];
            var isMutilayer = m_axScale.length > 1 ? true : false;
            
            for(var iScale = 0; iScale < m_axScale.length; iScale++)
            {
                var axDomain = m_axScale[iScale].domain;//["a", "b"]
                var axRange = m_axScale[iScale].range;//[[0, 100], [100. 200], ...]

                //count the max text size
                var re = maxLabelTextHeight(axDomain, axRange);
                var isVertical = re.isVertical;

                if(m_position == "left" || m_position == "right")
                {
                    m_axScale[iScale].labelsToDraw = buildLeftRightToDrawLabels(axDomain, axRange, isMutilayer);
                }
                else
                {
                    m_axScale[iScale].labelsToDraw = buildTopBottomToDrawLabels(axDomain, axRange, isVertical, isMutilayer);
                }
                
                if(iScale === 0){
                  scaleToDraw.push(m_axScale[iScale]);
                }
                else if(m_axScale[iScale].labelsToDraw.length == m_axScale[iScale].domain.length)
                {
                  scaleToDraw.push(m_axScale[iScale]);
                }
                //for mekko chart ,the scale is not equal. So if a label can be draw, we should draw the whole layer.
                else if(m_axScale[iScale].labelsToDraw.length > 0 && TypeUtils.isExist(m_axScale.noEqual)&&m_axScale.noEqual === true )
                {
                  scaleToDraw.push(m_axScale[iScale]);
                }
            }
            return scaleToDraw;
        }
        
        var drawGridLine = function(selection, x1, y1, x2, y2){
          var gridline = selection.append("line")
                          .attr("y1", y1)
                          .attr("y2", y2)
                          .attr("x1", x1)
                          .attr("x2", x2)
                          .attr("stroke", m_props.gridline.color)
                          .attr("stroke-width", m_props.gridline.size)
                          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
          if(m_props.gridline.type == "dotted")
          {
               gridline.attr("stroke-dasharray", "3, 2");
          }                        
        };

        function axis(selection)
        {
            //we have to adjust the scale
            var scaleToDraw = adjustScale();

            //---we should dicide show or hide somethings because of the spaceLimit
            if(m_spaceLimit >= 0)
            {
                var scaleToAdjust = [];
                var spacings = axis.getPreferredSize().spacings;
                var spaceLeft = m_spaceLimit;


                for(var i = 0; i < spacings.length; i++)
                {
                    if(spaceLeft >= spacings[i])
                    {
                        scaleToAdjust.push(scaleToDraw[i]);
                        spaceLeft -= spacings[i];
                    }
                    else
                    {
                        break;
                    }
                }

                if(scaleToAdjust.length == 0 && scaleToDraw.length > 0)
                {
                    //scaleToAdjust.push(scaleToDraw[0]);//always draw one
                    var lastDomain = [];
                    for (var i = 0; i < scaleToDraw[0].domain.length; i++) {
                        lastDomain.push('');
                    }
                    scaleToAdjust.push({
                            domain : lastDomain, 
                            range : scaleToDraw[0].range
                        });
                }

                scaleToDraw = scaleToAdjust;
            }
            //------------------------------------------------------
            var isMutilayer = scaleToDraw.length > 1 ? true : false;
            if(m_position == "left")
            {
                var iDraw = 0;
                var lastLevelWidth = 0;
                
                for(var iScale = 0; iScale < scaleToDraw.length; iScale++, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextWidth(axDomain, axRange);
                    var maxTextWidth = re.maxLabelTextWidth;
                    //var isVertical = re.isVertical;

                    if(!m_props.label.visible)
                    {
                        maxTextWidth = 0;
                    }
                    
                    
                      
                    if(iScale == (scaleToDraw.length-1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                  axRange[axRange.length-1][1], 
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                  axRange[axRange.length-1][1]);
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                  axRange[0][0], 
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                  axRange[0][0]);
                        }
                    }

                    ///////////////drawing the most inner vertical line////////////////
                    if( scaleToDraw.length == 1 ) {
                        ////////////////in single case, also include the first and last tick////////
                        //<path d="M150 0 L75 200 L225 200 Z" />
                        var x1 = lastLevelWidth + (maxTextWidth + 2*m_textOffset);
                        var x2 = lastLevelWidth + (maxTextWidth + 2*m_textOffset);
                        var y1 = axRange[0][0];
                        var y2 = axRange[axRange.length-1][1];

                        var dPath  = "M" + (x1-m_tickSize) + " " + y1
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2-m_tickSize) + " " + y2;

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");

                    }else if(scaleToDraw.length >= 2 && (iScale == scaleToDraw.length -1)) {
                        var axLine = selection.append("line")
                                    .attr("x1", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                                    .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                                    .attr("y1", axRange[0][0])
                                    .attr("y2", axRange[axRange.length-1][1])
                                    .attr("class", "domain")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    /////////////// end of drawing the most inner vertical line////////////////


                    ///////////////drawing vertical line for each level, based on lastLevelWidth///// 
                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", lastLevelWidth)
                        .attr("x2", lastLevelWidth)
                        .attr("y1", axRange[0][0])
                        .attr("y2", axRange[axRange.length-1][1])
                        .attr("class", "domain")
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    ///////////////end of drawing vertical line for each level, based on lastLevelWidth/////

                    //draw gridline in the last scaleToDraw///////////////////////
                    //FIXME Jimmy/9/22/2012 currently the grid line only used for
                    //multi charts. we have a bug for the last gridline here, if for example
                    //we draw gridline for yaxis on [i][1], then the last gridline
                    //will override xaxis. so we have to seperate last gridline
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][0], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][0]);
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][1], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][1]);
                        }
                      }
                      //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
                      drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length,
                                axRange[0][0], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length,
                                axRange[i - 1][1]
                                );
                    }
                    //end draw gridline in the last scaleToDraw///////////////////////


                    for(var i = 0; i < axDomain.length; i++)
                    {
                        /////////////////////////////draw tick for single case, horizontal line for multi case////////
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                          //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][0] will not be equal with axRange[i-1][1]?
                          if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                          {
                              var axTick1 = selection.append("line")
                                          .attr("x1", (maxTextWidth + 2*m_textOffset) - m_tickSize)
                                          .attr("x2", (maxTextWidth + 2*m_textOffset))
                                          .attr("y1", axRange[i][0])
                                          .attr("y2", axRange[i][0])
                                          .attr("stroke", m_props.color)
                                          .attr("stroke-width", m_props.lineSize)
                                          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");

                          }
                          
                          ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                          if(i != (axDomain.length - 1)){
                            var axTick2 = selection.append("line")
                                        .attr("x1", (maxTextWidth + 2*m_textOffset) - m_tickSize)
                                        .attr("x2", (maxTextWidth + 2*m_textOffset))
                                        .attr("y1", axRange[i][1])
                                        .attr("y2", axRange[i][1])
                                        .attr("stroke", m_props.color)
                                        .attr("stroke-width", m_props.lineSize)
                                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                          }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", lastLevelWidth)
                            .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                            .attr("y1", axRange[i][0])
                            .attr("y2", axRange[i][0])
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", m_props.lineSize)
                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            
                            //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", lastLevelWidth)
                              .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                              .attr("y1", axRange[i][1])
                              .attr("y2", axRange[i][1])
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto"); 
                            }
                        }
                        /////////////////////////////draw tick for single case, horizontal line for multi case////////
                    }

                    var labelsToDraw = scaleToDraw[iScale].labelsToDraw;
                    var customlabelCfg;
                    for(var i = 0; i < labelsToDraw.length; i++)
                    {
                      customlabelCfg = labelsToDraw[i].custom;
                      if(customlabelCfg && customlabelCfg.type === 'url'){
                        //draw as an icon, same size as text
                      }else{
                        var m_label = TypeUtils.isExist(labelsToDraw[i].text)? labelsToDraw[i].text:'';
                        if(m_props.label.visible)
                        {
                            //selection.append("circle").attr("cx", lastLevelWidth + maxTextWidth - m_textOffset).attr("cy", axRange[i][0] + (axRange[i][1] - axRange[i][0])/2). attr("r", 3);
                            var axLabels = selection.append("text")
                                          .attr("x", lastLevelWidth + maxTextWidth + m_textOffset)
                                          .attr("y", labelsToDraw[i].y)
                                          .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                          .attr("text-anchor", "end") // text-align
                                          .text(m_label)
                                          .attr("fill", m_style.label.fill)
                                          .attr("font-size", m_style.label['font-size'])
                                          .attr("font-weight", m_style.label['font-weight'])
                                          .attr("font-family", m_style.label['font-family']); 

                            adjustLabelForIE(axLabels);
                        }   
                      }
                    }

                    lastLevelWidth += (maxTextWidth + 2*m_textOffset);
                }
            }
            else if(m_position == "right")
            {
                var iDraw = 0;
                var lastLevelWidth = 0;
                
                for(var iScale = (scaleToDraw.length-1); iScale >= 0; iScale--, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextWidth(axDomain, axRange);
                    var maxTextWidth = re.maxLabelTextWidth;
                    //var isVertical = re.isVertical;

                    if(iScale == (scaleToDraw.length-1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth, 
                                  axRange[axRange.length-1][1], 
                                  lastLevelWidth-m_props.gridline.length, 
                                  axRange[axRange.length-1][1]);
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth, 
                                  axRange[0][0], 
                                  lastLevelWidth-m_props.gridline.length, 
                                  axRange[0][0]);
                        }
                    }

                    if((scaleToDraw.length == 1) )
                    {
                        //<path d="M150 0 L75 200 L225 200 Z" />
                        var x1 = lastLevelWidth;
                        var x2 = lastLevelWidth;
                        var y1 = axRange[0][0];
                        var y2 = axRange[axRange.length-1][1];

                        var dPath  = "M" + (x1+m_tickSize) + " " + y1
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x1+m_tickSize) + " " + y2;

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    else if(scaleToDraw.length >= 2 && (iScale == (scaleToDraw.length-1)) ) 
                    {
                        var axLine = selection.append("line")
                                    .attr("x1", lastLevelWidth)
                                    .attr("x2", lastLevelWidth)
                                    .attr("y1", axRange[0][0])
                                    .attr("y2", axRange[axRange.length-1][1])
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }

                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                        .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                        .attr("y1", axRange[0][0])
                        .attr("y2", axRange[axRange.length-1][1])
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][0], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][0]);
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][1], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][1]);
                        }
                      }

                    }

                    for(var i = 0; i < axDomain.length; i++)
                    {
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                            if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                            {
                                var axTick1 = selection.append("line")
                                            .attr("x1", 0)
                                            .attr("x2", m_tickSize)
                                            .attr("y1", axRange[i][0])
                                            .attr("y2", axRange[i][0])
                                            .attr("stroke", m_props.color)
                                            .attr("stroke-width", m_props.lineSize)
                                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            if(i != (axDomain.length - 1)){
                              var axTick2 = selection.append("line")
                                          .attr("x1", 0)
                                          .attr("x2", m_tickSize)
                                          .attr("y1", axRange[i][1])
                                          .attr("y2", axRange[i][1])
                                          .attr("stroke", m_props.color)
                                          .attr("stroke-width", m_props.lineSize)
                                          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", lastLevelWidth)
                            .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                            .attr("y1", axRange[i][0])
                            .attr("y2", axRange[i][0])
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", 1)
                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", lastLevelWidth)
                              .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                              .attr("y1", axRange[i][1])
                              .attr("y2", axRange[i][1])
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        }
                    }

                    var labelsToDraw = scaleToDraw[iScale].labelsToDraw;
                    var customlabelCfg;
                    for(var i = 0; i < labelsToDraw.length; i++)
                    {
                      customlabelCfg = labelsToDraw[i].custom;
                      if(customlabelCfg && customlabelCfg.type === 'url'){
                        //draw as an icon, same size as text
                      }else{
                        var m_label = TypeUtils.isExist(labelsToDraw[i].text)? labelsToDraw[i].text:'';
                        if(m_props.label.visible)
                        {
                            //selection.append("circle").attr("cx", lastLevelWidth + 100000).attr("cy", axRange[i][0] + (axRange[i][1] - axRange[i][0])/2). attr("r", 3);
                            var axLabels = selection.append("text")
                                          .attr("x", lastLevelWidth + m_textOffset)
                                          .attr("y", labelsToDraw[i].y)
                                          .attr("text-anchor", "start") // text-align
                                          .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                          .text(m_label)
                                          .attr("fill", m_style.label.fill)
                                          .attr("font-size", m_style.label['font-size'])
                                          .attr("font-weight", m_style.label['font-weight'])
                                          .attr("font-family", m_style.label['font-family']); 

                            adjustLabelForIE(axLabels);
                        }
                      }
                    }
                    
                    lastLevelWidth += (maxTextWidth + 2*m_textOffset);
                }
            }
            else if(m_position == "bottom")
            {
                var iDraw = 0;
                var lastLevelHeight = 0;
                
                for(var iScale = (scaleToDraw.length - 1); iScale >= 0; iScale--, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextHeight(axDomain, axRange);
                    var maxTextHeight = re.maxLabelTextHeight;
                    var isVertical = re.isVertical;

                    if(iScale == (scaleToDraw.length - 1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  axRange[0][0],  
                                  lastLevelHeight, 
                                  axRange[0][0],
                                  lastLevelHeight-m_props.gridline.length
                                  );
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  axRange[axRange.length-1][0],  
                                  lastLevelHeight, 
                                  axRange[axRange.length-1][0],
                                  lastLevelHeight-m_props.gridline.length
                                  );
                        }
                    }

                    if(scaleToDraw.length == 1)
                    {
                        var x1 = axRange[0][0];
                        var x2 = axRange[axRange.length-1][1];
                        var y1 = lastLevelHeight;
                        var y2 = lastLevelHeight;

                        var dPath  = "M" + x1 + " " + (y1+m_tickSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2+m_tickSize);

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                        
                        if(angle){
                          var aAngle = angle * Math.PI /180;
                          var cosAngle = Math.cos(aAngle);
                          var sinAngle = (45 == angle)? cosAngle: Math.sin(aAngle); 
                          dPath = 'M ' + axRange[0][0] + ' ' + lastLevelHeight;
                          dPath += 'L' + (axRange[0][0] + axRange[axRange.length-1][1] * sinAngle) + ' ' + (lastLevelHeight - axRange[axRange.length-1][1] * cosAngle);
                          dPath += 'Z';
                          
                          axLine.attr('d', dPath);
                        }
                    }
                    else if( scaleToDraw.length >= 2 && (iScale == scaleToDraw.length-1) )
                    {
                        var axLine = selection.append("line")
                                    .attr("x1", axRange[0][0])
                                    .attr("x2", axRange[axRange.length-1][1])
                                    .attr("y1", lastLevelHeight)
                                    .attr("y2", lastLevelHeight)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }

                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", axRange[0][0])
                        .attr("x2", axRange[axRange.length-1][1])
                        .attr("y1", lastLevelHeight + maxTextHeight + 2*m_textOffset)
                        .attr("y2", lastLevelHeight + maxTextHeight + 2*m_textOffset)
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    
                    //draw gridline in the last scaleToDraw///////////////////////
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset),
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset), 
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        }
                      }
                    }
                    //end draw gridline in the last scaleToDraw///////////////////////


                    for(var i = 0; i < axDomain.length; i++)
                    {
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                            if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                            {
                                var axTick1 = selection.append("line")
                                            .attr("x1", axRange[i][0])
                                            .attr("x2", axRange[i][0])
                                            .attr("y1", 0)
                                            .attr("y2", m_tickSize)
                                            .attr("stroke", m_props.color)
                                            .attr("stroke-width", m_props.lineSize)
                                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            if(i != (axDomain.length - 1)){
                              var axTick2 = selection.append("line")
                                          .attr("x1", axRange[i][1])
                                          .attr("x2", axRange[i][1])
                                          .attr("y1", 0)
                                          .attr("y2", m_tickSize)
                                          .attr("stroke", m_props.color)
                                          .attr("stroke-width", m_props.lineSize)
                                          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                              
                              if(angle){
                                var aAngle = angle * Math.PI /180;
                                var cosAngle = Math.cos(aAngle);
                                var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                                var tAngle = tickAngle * Math.PI / 180;
                                var cosTAngle = Math.cos(tAngle);
                                var sinTAngle = Math.sin(tAngle);
                                
                                var tickStartX  =   axRange[i][1] * sinAngle;
                                tickStartY =  -axRange[i][1] * cosAngle;
                                var x2 = tickStartX + m_tickSize * cosTAngle,
                                  y2 = tickStartY + m_tickSize * sinTAngle;
                                  
                                axTick2.attr('x1', tickStartX).attr('y1', tickStartY).attr('x2', x2).attr('y2', y2);  
                                }
                              
                            }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", axRange[i][0])
                            .attr("x2", axRange[i][0])
                            .attr("y1", lastLevelHeight)
                            .attr("y2", lastLevelHeight + 2*m_textOffset + maxTextHeight)
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", m_props.lineSize)
                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                             
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", axRange[i][1])
                              .attr("x2", axRange[i][1])
                              .attr("y1", lastLevelHeight)
                              .attr("y2", lastLevelHeight + 2*m_textOffset + maxTextHeight)
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        }
                    }

                    var labelsToDraw = scaleToDraw[iScale].labelsToDraw;
                    drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length != 1);

                    lastLevelHeight += (maxTextHeight + 2*m_textOffset);
                }
            }
            else if(m_position == "top")
            {
                var iDraw = 0;
                var lastLevelHeight = 0;
                
                for(var iScale = 0; iScale < scaleToDraw.length; iScale++, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextHeight(axDomain, axRange);
                    var maxTextHeight = re.maxLabelTextHeight;
                    var isVertical = re.isVertical;

                    if(!m_props.label.visible)
                    {
                        maxTextHeight = 0;
                    }

                    if(iScale == (scaleToDraw.length-1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  axRange[0][0],  
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight, 
                                  axRange[0][0],
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight+m_props.gridline.length
                                  );
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  axRange[axRange.length-1][1],  
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight, 
                                  axRange[axRange.length-1][1],
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight+m_props.gridline.length
                                  );
                        }
                    }

                    if( (scaleToDraw.length == 1) )
                    {
                        var x1 = axRange[0][0];
                        var x2 = axRange[axRange.length-1][1];
                        var y1 = maxTextHeight + 2*m_textOffset + lastLevelHeight;
                        var y2 = maxTextHeight + 2*m_textOffset + lastLevelHeight;

                        var dPath  = "M" + x1 + " " + (y1-m_tickSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2-m_tickSize);

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    else if( scaleToDraw.length >= 2 && (iScale == scaleToDraw.length-1) )
                    {
                        var axLine = selection.append("line")
                                    .attr("x1", axRange[0][0])
                                    .attr("x2", axRange[axRange.length-1][1])
                                    .attr("y1", maxTextHeight + 2*m_textOffset + lastLevelHeight)
                                    .attr("y2", maxTextHeight + 2*m_textOffset + lastLevelHeight)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }

                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", axRange[0][0])
                        .attr("x2", axRange[axRange.length-1][1])
                        .attr("y1", lastLevelHeight)
                        .attr("y2", lastLevelHeight)
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    
                    //draw gridline in the last scaleToDraw///////////////////////
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset),
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset), 
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        }
                      }
                      //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
                      drawGridLine(selection,
                                axRange[0][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i - 1][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                    }
                    //end draw gridline in the last scaleToDraw///////////////////////

                    for(var i = 0; i < axDomain.length; i++)
                    {
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                            if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                            {
                                var axTick1 = selection.append("line")
                                            .attr("x1", axRange[i][0])
                                            .attr("x2", axRange[i][0])
                                            .attr("y1", (maxTextHeight + 2*m_textOffset))
                                            .attr("y2", (maxTextHeight + 2*m_textOffset)-m_tickSize)
                                            .attr("stroke", m_props.color)
                                            .attr("stroke-width", m_props.lineSize)
                                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            
                            ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                          if(i != (axDomain.length - 1)){
                            var axTick2 = selection.append("line")
                                        .attr("x1", axRange[i][1])
                                        .attr("x2", axRange[i][1])
                                        .attr("y1", (maxTextHeight + 2*m_textOffset))
                                        .attr("y2", (maxTextHeight + 2*m_textOffset)-m_tickSize)
                                        .attr("stroke", m_props.color)
                                        .attr("stroke-width", m_props.lineSize)
                                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                          }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", axRange[i][0])
                            .attr("x2", axRange[i][0])
                            .attr("y1", lastLevelHeight)
                            .attr("y2", lastLevelHeight + (maxTextHeight + 2*m_textOffset))
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", m_props.lineSize)
                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                             
                            //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", axRange[i][1])
                              .attr("x2", axRange[i][1])
                              .attr("y1", lastLevelHeight)
                              .attr("y2", lastLevelHeight + (maxTextHeight + 2*m_textOffset))
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        }
                    }

                    var labelsToDraw = scaleToDraw[iScale].labelsToDraw;
                    drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length != 1);
                    lastLevelHeight += (maxTextHeight + 2*m_textOffset);
                }
            }

        };

        var adjustLabelForIE = function(text)
        {
            if(jQuery.browser.msie)
            {
                //dominant-baseline does not work
                var textHeight = m_style.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        }

        //get customlabel text from from the rawObj, if the type is url, return the original text
        var getCustomlabelText = function(rawObj){
          var ret;
          if(rawObj.info){
            var clobj = rawObj.info.customlabel;
            if(clobj){
              if(clobj.type === 'url'){
                ret = rawObj.val;
              }else if(clobj.type === 'string'){
                ret = clobj.val;
              }
            }else{
              ret = rawObj.val;
            }
          }else{
            ret = rawObj.val;
          }
          //so we will first resolve customlabel and then do format
          ret = isInvalidString(ret) ? langManager.get('IDS_ISNOVALUE'): ret;
          ret = FormatManager.format(ret, m_props.label.formatString);
          return ret;
        };
        
        var getCustomlabelCfg = function(rawObj){
          if(rawObj.info && rawObj.info.customlabel){
            return rawObj.info.customlabel;
          }
        };
        
        var buildLeftRightToDrawLabels = function(allLabels, allLabelsLocation, isMutilayer)
        {
          //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
            //we always draw the bottom label for yAxis.

            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < allLabels.length; i++)
            {
                var item = {};
                item.text = getCustomlabelText(allLabels[i]);
                item.custom = getCustomlabelCfg(allLabels[i]);
                //count y1 and y2
                var itemMeasure = fastMeasure (item.text, m_style.label);
                var centerY = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0])/2;
                item.width = itemMeasure.width;
                item.height = itemMeasure.height;
                item.y = centerY;
                item.y1 = centerY - item.height/2;
                item.y2 = centerY + item.height/2;
                allTicksLabels.push(item);
            }

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];
            if(m_props.label.hideStrategy != 'greedy'){
                for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
                {
                    var isDrawable = true;
                    for(var i = (allTicksLabels.length - 1); i >= 0 ; i-=(iBeyond+1))
                    {   
                        var item = allTicksLabels[i];
                        if(i != (allTicksLabels.length - 1))
                        {
                            var previousIndex = i + (iBeyond+1);

                                if(allTicksLabels[i].y2 >= allTicksLabels[previousIndex].y1)
                                {
                                    isDrawable = false;
                                    break;
                                }
                        }
                        ticksLabelsToDraw.push(item);
                    }
                    if(isDrawable) //iBeyond = (allTicksLabels.length - 1) is always drawable
                    {
                        break;
                    }
                    else
                    {
                        ticksLabelsToDraw = [];
                    }
                }
            }else{
                
              for(var previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >=0; iBeyond--){
                    var item = allTicksLabels[iBeyond];
                     
                     if(previousIndex === iBeyond&&allLabelsLocation[iBeyond][1]!=allLabelsLocation[iBeyond][0]){
                          if(isMutilayer && item.y1>allLabelsLocation[iBeyond][0]&&item.y2<allLabelsLocation[iBeyond][1]){
                            ticksLabelsToDraw.push(item);
                          }else if(!isMutilayer){
                            ticksLabelsToDraw.push(item);
                          }
                     }else{
                        if(item.y2 <= allTicksLabels[previousIndex].y1&&allLabelsLocation[iBeyond][1]!=allLabelsLocation[iBeyond][0]){
                            if(isMutilayer)
                            {
                              //if have more than one layers, need to detecte whether the label is between gridlines
                              if(item.y1>allLabelsLocation[iBeyond][0]&&item.y2<allLabelsLocation[iBeyond][1])
                              {
                                ticksLabelsToDraw.push(item);
                                previousIndex = iBeyond;
                              }
                            }
                            else
                            {
                            //if have only one layer , just need to detecte whether overlap is exist
                              ticksLabelsToDraw.push(item);
                              previousIndex = iBeyond;
                            }
                        }
                     }
                  }
            }

            return ticksLabelsToDraw;
        }

        var buildTopBottomToDrawLabels = function(allLabels, allLabelsLocation, isVertical, isMutilayer)
        {
          //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
            //we always draw the first label for xAxis.

            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < allLabels.length; i++)
            {
                var item = {};
                item.text = getCustomlabelText(allLabels[i]);
                item.custom = getCustomlabelCfg(allLabels[i]);
                //count x1 and x2
                var itemMeasure = fastMeasure (item.text, m_style.label);
                if(isVertical)
                {
                    item.width = itemMeasure.height;
                    item.height = itemMeasure.width;
                }
                else
                {
                    item.width = itemMeasure.width;
                    item.height = itemMeasure.height;
                }

                var centerX = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0])/2;

                item.x = centerX;
                item.x1 = centerX - item.width/2;
                item.x2 = centerX + item.width/2;
                
                allTicksLabels.push(item);
            }

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];
            if(m_props.label.hideStrategy != 'greedy'){
              for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
              {
                  var isDrawable = true;
                  for(var i = 0; i < allTicksLabels.length; i+=(iBeyond+1))
                  {   
                      var item = allTicksLabels[i];
                      if(i != 0)
                      {
                          var previousIndex = i - (iBeyond+1);

                          if(allTicksLabels[i].x1 <= allTicksLabels[previousIndex].x2 || allLabelsLocation[iBeyond][1] === allLabelsLocation[iBeyond][0])
                          {
                              isDrawable = false;
                              break;
                          }
                      }
                      ticksLabelsToDraw.push(item);
                  }
                  if(isDrawable) //iBeyond = (allTicksLabels.length - 1) is always drawable
                  {
                      break;
                  }
                  else
                  {
                      ticksLabelsToDraw = [];
                  }
              }
            }else{

              for(var previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >=0; iBeyond--){
                    var item = allTicksLabels[iBeyond];
                     
                     if(previousIndex === iBeyond && allLabelsLocation[iBeyond][1] != allLabelsLocation[iBeyond][0]){
                        if(isMutilayer && item.x1 > allLabelsLocation[iBeyond][0] && item.x2 < allLabelsLocation[iBeyond][1]){
                          ticksLabelsToDraw.push(item);
                        }else if(!isMutilayer){
                          ticksLabelsToDraw.push(item);
                        }
                     }else{
                        if(item.x2 <= allTicksLabels[previousIndex].x1&&allLabelsLocation[iBeyond][1]!=allLabelsLocation[iBeyond][0]){
                        if(isMutilayer)
                        {
                            //if have more than one layers, need to detecte whether the label is between gridlines
                            if(item.x1>allLabelsLocation[iBeyond][0]&&item.x2<allLabelsLocation[iBeyond][1])
                            {
                              ticksLabelsToDraw.push(item);
                              previousIndex = iBeyond;
                            }
                          }
                          else
                          {
                          //if have only one layer , just need to detecte whether overlap is exist
                            ticksLabelsToDraw.push(item);
                            previousIndex = iBeyond;
                          }
                        }
                     }
                  }
            }

            //console.log(ticksLabelsToDraw);

            return ticksLabelsToDraw;
        }

        var drawTopBottomLabels = function(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, isHierarchical)
        {
            if (labelsToDraw === undefined) {
              return;
            }

            for(var i = 0; i < labelsToDraw.length; i++)
            {
              var label = TypeUtils.isExist(labelsToDraw[i].text)? labelsToDraw[i].text:'';
                if(m_props.label.visible)
                {
                  if(angle){
                    var aAngle = angle * Math.PI /180;
                    var cosAngle = Math.cos(aAngle);
                    var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                    var tAngle = tickAngle * Math.PI / 180;
                    var cosTAngle = Math.cos(tAngle);
                    var sinTAngle = Math.sin(tAngle);
                    
                    var tickStartX  =   labelsToDraw[i].x * sinAngle;
                    tickStartY =  - labelsToDraw[i].x * cosAngle;
                    
                    var axLabels = selection.append("text")
                            .attr("x", tickStartX + m_textOffset * cosTAngle)
                            .attr("y", tickStartY + lastLevelHeight + m_textOffset * sinTAngle)
                            .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                            .attr("text-anchor", 'start') // text-align
                            .text(label)
                            .attr("fill", m_style.label.fill)
                            .attr("font-size", m_style.label['font-size'])
                            .attr("font-weight", m_style.label['font-weight'])
                            .attr("font-family", m_style.label['font-family']); 
                    
                    if(tickAngle > 90){
                      axLabels.attr("text-anchor", 'end').attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' +axLabels.attr("x") + ' ' +axLabels.attr("y") + ')');
                    }else{
                    axLabels.attr('transform', 'rotate( ' + (tickAngle) + ' ' +axLabels.attr("x") + ' ' +axLabels.attr("y") + ')');
                    }
                  }else{
                    //selection.append("circle").attr("cx", axRange[i][0] + (axRange[i][1] - axRange[i][0])/2).attr("cy", lastLevelHeight + maxTextHeight/2 + m_textOffset). attr("r", 5);                               
                    var axLabels = selection.append("text")
                                    .attr("x", labelsToDraw[i].x)
                                    .attr("y", lastLevelHeight + maxTextHeight/2 + m_textOffset)
                                    .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                    .attr("text-anchor", "middle") // text-align
                                    .text(label)
                                    .attr("fill", m_style.label.fill)
                                    .attr("font-size", m_style.label['font-size'])
                                    .attr("font-weight", m_style.label['font-weight'])
                                    .attr("font-family", m_style.label['font-family']); 
                      
                      if(isVertical)
                      {
                          if(!isHierarchical){
                            if(m_position == 'top'){
                              axLabels.attr('text-anchor', 'start')
                              .attr("y", lastLevelHeight + maxTextHeight + m_textOffset);
                            }else if(m_position == 'bottom'){
                              axLabels.attr("y", lastLevelHeight + m_textOffset).attr('text-anchor', 'end');
                            }
                          }
                          
                          var ac = "-90";
                          axLabels.attr("transform","rotate( " + ac + " " + axLabels.attr("x") + " "  + axLabels.attr("y") + " )");
                         
                      }
                      adjustLabelForIE(axLabels);
                  }
                }
            }
        };


        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = Objects.extend(true, m_props, _properties);
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.getPreferredSize = function() {

            var scaleToDraw = adjustScale();

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];

            for(var i = 0; i < scaleToDraw.length; i++)
            {
                if(!m_props.label.visible && i != (scaleToDraw.length-1))
                {
                    continue;
                }

                var axDomain = scaleToDraw[i].domain;//["a", "b"]
                var axRange = scaleToDraw[i].range;//[[0, 100], [100. 200], ...]

                if(axDomain.length === 0 || axRange.length === 0)
                {
                    continue;
                }

                if(m_position == "bottom" || m_position == "top")
                {
                    axisWidth = Math.abs(axRange[axRange.length-1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
                    
                    var offsetHeight = 0;
                    if(m_props.label.visible)
                    {
                        offsetHeight += maxLabelTextHeight(axDomain, axRange).maxLabelTextHeight;
                    }

                    offsetHeight += 2*m_textOffset;
                    axisHeight += offsetHeight;

                    axisSpacings.push(offsetHeight);
                }
                else if(m_position == "left" || m_position == "right")
                {
                    var offsetWidth = 0;

                    if(m_props.label.visible)
                    {
                        offsetWidth += maxLabelTextWidth(axDomain, axRange).maxLabelTextWidth;
                    }
                    offsetWidth += 2*m_textOffset;

                    axisWidth += offsetWidth;
                    axisSpacings.push(offsetWidth);

                    axisHeight = Math.abs(axRange[axRange.length-1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
                }
            }

            //--------------
            if(m_spaceLimit >= 0)
            {
                var spacings = axisSpacings;
                var spaceLeft = m_spaceLimit;

                var spacingToDraw = 0;


                for(var i = 0; i < spacings.length; i++)
                {
                    if(spaceLeft >= spacings[i])
                    {
                        spacingToDraw += spacings[i];
                        spaceLeft -= spacings[i];
                    }
                    else
                    {
                        break;
                    }
                }

                if(spacingToDraw == 0 && spacings.length > 0)
                {
                    spacingToDraw += spacings[0];
                }


                if(m_position == "bottom" || m_position == "top")
                {
                    axisHeight = spacingToDraw;
                }
                else if(m_position == "left" || m_position == "right")
                {
                    axisWidth = spacingToDraw;
                }
            }

            //------------------------------------

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,
            };
        };

        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = _;
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle = _;
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = _;
          return axis;
        };
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        var resolveMaxAndMinInDomain = function(domain, rangeArray){
          var heightArray = [];
          var widthArray = [];
          var isVerticalFont = false;
          for(var i = 0; i < domain.length; i++)
          {
              var tSize = fastMeasure( getCustomlabelText(domain[i]) , m_style.label);

              var tHeight = tSize.height;
              var tWidth = tSize.width;
              var interval = rangeArray[i][1]-rangeArray[i][0];

              if((tHeight < tWidth) && interval!=0 && tWidth > interval )
              {
                  if(m_position == "top" || m_position == "bottom")
                  {
                      isVerticalFont = true;
                  }
              }

              heightArray.push(tHeight);
              widthArray.push(tWidth);
          }
          
          return {
            'heights' : heightArray,
            'widths' : widthArray,
            'isVerticalFont' : isVerticalFont
          };
        };
        
        var maxLabelTextHeight = function (domain, rangeArray)
        {
          //Jimmy/10/26/2012 we extend domain from string array to object to support customlabel
            var re = {"maxLabelTextHeight": 0, "isVertical": false};
            var maxTextHeight = 0;
            var isVerticalFont = false;
            var sizes = resolveMaxAndMinInDomain(domain, rangeArray);
            isVerticalFont = m_props.forceVerticalFont === true ? true: sizes.isVerticalFont;
            
            for(var i = 0; i < domain.length; i++)
            {
                if(isVerticalFont)
                {
                    if(maxTextHeight < sizes.widths[i])
                    {
                        maxTextHeight = sizes.widths[i];
                    }
                }
                else
                {
                    if(maxTextHeight < sizes.heights[i])
                    {
                        maxTextHeight = sizes.heights[i];
                    }
                }
            }
            re.maxLabelTextHeight = maxTextHeight;
            re.isVertical = isVerticalFont;
            return re;
        };

        var maxLabelTextWidth = function (domain, rangeArray)
        {
            var re = {"maxLabelTextWidth": 0, "isVertical": false};
            var maxTextWidth = 0;
            var isVerticalFont = false;
            var sizes = resolveMaxAndMinInDomain(domain, rangeArray);
            isVerticalFont = m_props.forceVerticalFont === true ? true: sizes.isVerticalFont;
            
            for(var i = 0; i < domain.length; i++)
            {
                if(isVerticalFont)
                {
                    if(maxTextWidth < sizes.heights[i])
                    {
                        maxTextWidth = sizes.heights[i];
                    }
                }
                else
                {
                    if(maxTextWidth < sizes.widths[i])
                    {
                        maxTextWidth = sizes.widths[i];
                    }
                }
            }

            re.maxLabelTextWidth = maxTextWidth;
            re.isVertical = isVerticalFont;

            return re;
        };
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.fastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        };
        
        var isInvalidString = function(str){
           if( typeof (str) != "string" && NumberUtils.isNoValue(str))
             {
                   return true;
             }
           return false;
        }

        return axis;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.axis.valueAxisCore',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.0'
}
],
function Setup(TextUtils, NumberUtils, Objects, FormatManager, Point, matrix) {

    return function() {
   
        var m_position;
        var m_axScale = null;

        var m_tickSize = 5;
        var m_textOffset = 4;

        var m_axDefaultTickNum = 7;

        var m_styleLineSrokeWidth = 1;
        var m_styleAxisColor = "#6c6c6c";
        var m_styleGridLineColor = "#d8d8d8";
        var m_styleGridIncisedLineColor = "#ffffff";
        var m_styleAxisLabelColor = "#333333";
        
        var m_style = null;
        var m_props = { 
            "title": {"visible": false, "text": undefined,},
            "gridline": {"visible": true, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true, "numberFormat" : "","formatString": "", },
            "position": "left",
            "color": m_styleAxisColor,
            "axisline" : {"visible": true},
            "shapeRendering": true
        };

        var m_matrix = matrix(), labelAngle = null, labelAlign = null, angle = null, tickAngle = null;
        
        var m_spaceLimit = -1;
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;
            m_spaceLimit = _spaceLimit;
            return axis;
        }

        function axis(selection) {
                
                var axRange = m_axScale.range();//[0, 500]
                var axDomain = m_axScale.domain();//[-100, 2000]

                if(axRange[0] == 0 && axRange[1] == 0)
                {
                    return;//do not draw value axis
                }

                var axTicksLabels = getTicksLabel();

                if(m_position == "bottom")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if  ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", 0)
                                    .attr("y2", m_tickSize + 1)//line contains the first but not the last point
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        if(angle){
                            var aAngle = angle * Math.PI /180;
                            var cosAngle = Math.cos(aAngle);
                            var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                            var tAngle = tickAngle * Math.PI / 180;
                            var cosTAngle = Math.cos(tAngle);
                            var sinTAngle = Math.sin(tAngle);
                            
                            var tickStartX  =   m_axScale(axTicksLabels[i].value) * sinAngle;
                            tickStartY =  -m_axScale(axTicksLabels[i].value) * cosAngle;
                            var x2 = tickStartX + ( m_tickSize + 1) * cosTAngle,
                              y2 = tickStartY + ( m_tickSize + 1) * sinTAngle;
                              
                            axTick.attr('x1', tickStartX).attr('y1', tickStartY).attr('x2', x2).attr('y2', y2);  
                          }
                        
                        var drawLine = function()
                        {
                             var line = selection.append("line")
                            .attr("x1", m_axScale(axTicksLabels[i].value))
                            .attr("x2", m_axScale(axTicksLabels[i].value))
                            .attr("y1", -m_props.gridline.length)
                            .attr("y2", 0)
                            .attr("stroke", m_props.gridline.color)
                            .attr("stroke-width", m_props.gridline.size)
                            .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 line.attr("stroke-dasharray", "3, 2");
                            }
                            
                            if(m_props.gridline.type == "incised")
                            {
                                var line = selection.append("line")
                                .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                .attr("y1", -m_props.gridline.length)
                                .attr("y2", 0)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "Bottom", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = 0;
                        var y2 = 0;

                        var endSize = 0;//m_tickSize

                        var dPath  = "M" + x1 + " " + (y1 + endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 + endSize);

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                        
                        if( angle ){
                          var aAngle = angle * Math.PI /180;
                          var cosAngle = Math.cos(aAngle);
                          var sinAngle = (45 == angle)? cosAngle: Math.sin(aAngle); 
                          dPath = 'M ' + axRange[1]  + ' ' + y1;
                          dPath += 'L' + (axRange[1] + axRange[0] * sinAngle) + ' ' + ( y1 - axRange[0] * cosAngle);
                          dPath += 'Z';
                          
                          axLine.attr('d', dPath);
                        }
                    }
                }
                else if(m_position == "top")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }
                    
                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", maxTextHeight + nOffset*m_textOffset)
                                    .attr("y2", maxTextHeight + nOffset*m_textOffset + m_tickSize)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                                        .attr("x1", m_axScale(axTicksLabels[i].value))
                                        .attr("x2", m_axScale(axTicksLabels[i].value))
                                        .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                        .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                        .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                        .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                        .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                        .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                        .attr("stroke", m_styleGridIncisedLineColor)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "Top", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = maxTextHeight + m_tickSize + nOffset*m_textOffset;
                        var y2 = maxTextHeight + m_tickSize + nOffset*m_textOffset;

                        var endSize = 0;//m_tickSize
                        var dPath  = "M" + x1 + " " + (y1 - endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 - endSize);

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }

                }
                else if(m_position == "left")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels);

                    //count the max text width
                    var maxTextWidth = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }

                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", maxTextWidth + nOffset*m_textOffset)
                                    .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                        .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                        .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                        .attr("stroke", m_styleGridIncisedLineColor)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                        
                        //selection.append("circle").attr("cx", maxTextWidth).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection.append("text")
                           .attr("x", maxTextWidth + m_textOffset)
                           .attr("y", m_axScale(axTicksLabels[i].value))
                           .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                           .attr("text-anchor", "end") // text-align
                           .text(axTicksLabels[i].text)
                           .attr("fill", m_style.label.fill)
                           .attr("font-size", m_style.label['font-size'])
                           .attr("font-weight", m_style.label['font-weight'])
                           .attr("font-family", m_style.label['font-family']);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var x2 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 - endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 - endSize) + " " + y2;
                        
                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }
                }
                else if(m_position == "right")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels);
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", 0)
                                    .attr("x2", m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", -m_props.gridline.length)
                                        .attr("x2", 0)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }
                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("x1", -m_props.gridline.length)
                                        .attr("x2", 0)
                                        .attr("stroke", m_styleGridIncisedLineColor)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }

                        //selection.append("circle").attr("cx", m_tickSize + m_textOffset).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection.append("text")
                            .attr("x", m_tickSize + m_textOffset)
                            .attr("y", m_axScale(axTicksLabels[i].value))
                            .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                            .attr("text-anchor", "start") // text-align
                            .text(axTicksLabels[i].text)
                            .attr("fill", m_style.label.fill)
                            .attr("font-size", m_style.label['font-size'])
                            .attr("font-weight", m_style.label['font-weight'])
                            .attr("font-family", m_style.label['font-family']);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = 0;
                        var x2 = 0;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 + endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 + endSize) + " " + y2;

                        var axLine = selection.append("path")
                                .attr("d", dPath)
                                .attr("fill", "none")
                                .attr("stroke", m_props.color)
                                .attr("stroke-width", m_props.lineSize)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }
                }
            };

        var adjustLabelForIE = function(text)
        {
            if(jQuery.browser.msie)
            {
                //dominant-baseline does not work
                var textHeight = m_style.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        }

        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = _;
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle = _;
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = _;
          return axis;
        };
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = extendObj(m_props, _properties);
            return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.startPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = getTicksLabel();
                
                var labelSize = 0;
                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[0].text, m_style.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.endPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = getTicksLabel();

                var labelSize = 0;

                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[axTicksLabels.length-1].text, m_style.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.getPreferredSize = function() {

            var axDomain = m_axScale.domain();//[0, 100]
            var axRange = m_axScale.range();//[0, 200]

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];

            if( !(axRange[0] == 0 && axRange[1] == 0) )
            {
                if(m_position == "bottom" || m_position == "top")
                {
                    axisWidth = Math.abs(axRange[1] - axRange[0]) + m_styleLineSrokeWidth;
                    if(m_props.label.visible)
                    {
                        var axTicksLabels = getTicksLabel();
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        axisHeight = maxLabelTextHeight(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    else
                    {
                        axisHeight = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisHeight);
                }
                else if(m_position == "left" || m_position == "right")
                {
                    if(m_props.label.visible)
                    {
                        var axTicksLabels = getTicksLabel();
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        axisWidth = maxLabelTextWidth(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    else
                    {
                        axisWidth = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisWidth);

                    axisHeight = Math.abs(axRange[1] - axRange[0]) + m_styleLineSrokeWidth;
                }
            }

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,

            };
        };

        var buildToDrawLabels = function(axTicksLabels)
        {
            if(axTicksLabels.length > 0)
            {
                if(m_axScale (axTicksLabels[0].value) > m_axScale (axTicksLabels[axTicksLabels.length-1].value))
                {
                    axTicksLabels.reverse();
                }
            }
            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {   
              if(!NumberUtils.isNoValue(axTicksLabels[i].value)){
                var item = {};
                item.value = axTicksLabels[i].value;
                item.text = axTicksLabels[i].text;

                //count y1 and y2
                var itemHeight = fastMeasure (item.text, m_style.label).height;
                var centerY = m_axScale (item.value);

                item.start =  centerY - itemHeight/2;
                item.end =   centerY + itemHeight/2;
                
                allTicksLabels.push(item);
              }
            }
            //console.log(allTicksLabels);

            var ticksLabelsToDraw = [];
            ticksLabelsToDraw = calculateLabelsToDraw(allTicksLabels);

            //console.log(ticksLabelsToDraw);
            return ticksLabelsToDraw;
        };

        var drawTopBottomLabels = function(selection, type, ticksLabels, maxTextHeight)
        {
            if(ticksLabels.length == 0)
            {
                return;
            }

            if(ticksLabels.length > 0)
            {
                if(m_axScale (ticksLabels[0].value) > m_axScale (ticksLabels[ticksLabels.length-1].value))
                {
                    ticksLabels.reverse();
                }
            }
            //build the "todraw" array
            //count all the labels x1 and x2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < ticksLabels.length; i++)
            {   
                var item = {};
                item.value = ticksLabels[i].value;
                item.text = ticksLabels[i].text;

                //count x1 and x2
                var itemWidth = fastMeasure (item.text, m_style.label).width;
                var centerX = m_axScale (item.value);

                item.start = centerX - itemWidth/2;
                item.end = centerX + itemWidth/2;

                allTicksLabels.push(item);
            }

            var ticksLabelsToDraw = [];
            ticksLabelsToDraw = calculateLabelsToDraw(allTicksLabels);

            //console.log(ticksLabelsToDraw);
            for(var i = 0; i < ticksLabelsToDraw.length; i++)
            {
              if(angle){
                var aAngle = angle * Math.PI /180;
                var cosAngle = Math.cos(aAngle);
                var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                var tAngle = tickAngle * Math.PI / 180;
                var cosTAngle = Math.cos(tAngle);
                var sinTAngle = Math.sin(tAngle);
                
                var tickStartX  =    m_axScale(ticksLabelsToDraw[i].value) * sinAngle;
                tickStartY =  -  m_axScale(ticksLabelsToDraw[i].value) * cosAngle;
                
                var item = selection.append('text')
                  .attr('x', tickStartX + m_textOffset * cosTAngle)
                  .attr('y', tickStartY + m_textOffset * sinTAngle)
                  .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                  .attr("text-anchor", 'start') // text-align
                  .text(ticksLabelsToDraw[i].text)
                  .attr("fill", m_style.label.fill)
                  .attr("font-size", m_style.label['font-size'])
                  .attr("font-weight", m_style.label['font-weight'])
                  .attr("font-family", m_style.label['font-family']); 
          
                  if(tickAngle > 90){
                    item.attr("text-anchor", 'end').attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }else{
                    item.attr('transform', 'rotate( ' + (tickAngle) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }
              }else{
              //selection.append("circle").attr("cx", m_axScale(axTicksLabels.value[i])).attr("cy", m_textOffset + m_tickSize). attr("r", 3);
                var item = selection.append("text")
                 .attr("x", m_axScale(ticksLabelsToDraw[i].value))
                 .attr("y", m_textOffset + m_tickSize)
                 .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")
                 .attr("text-anchor", "middle") // text-align
                 .text(ticksLabelsToDraw[i].text)
                 .attr("fill", m_style.label.fill)
                 .attr("font-size", m_style.label['font-size'])
                 .attr("font-weight", m_style.label['font-weight'])
                 .attr("font-family", m_style.label['font-family']);

                //IE does not support dominant-baseline
                item.attr("dominant-baseline", "auto");
                item.attr("y", maxTextHeight + m_textOffset);
              }
            }
        };

        var calculateLabelsToDraw = function(allTicksLabels)
        {
            var labelsToDraw = [];
            
            if(allTicksLabels.length > 0)
            {
                //split allTicksLabels if it is required.
                if( !(allTicksLabels[0].value >= 0 && allTicksLabels[allTicksLabels.length - 1].value >= 0) 
                  &&!(allTicksLabels[0].value <= 0 && allTicksLabels[allTicksLabels.length - 1].value <= 0)
                  )
                {
                    var negativeArray = [];
                    var positiveArray = [];
                    for(var i = 0; i < allTicksLabels.length; i++)
                    {
                        if(allTicksLabels[i].value <= 0)
                        {
                            negativeArray.push(allTicksLabels[i]);
                        }

                        if(allTicksLabels[i].value >= 0)
                        {
                            positiveArray.push(allTicksLabels[i]);
                        }
                    }
                    negativeArray = calculateLabelsToDrawHelper(negativeArray);
                    positiveArray = calculateLabelsToDrawHelper(positiveArray);

                    var compareValue = function (firstObj, secondObj)
                    {
                        return firstObj.value - secondObj.value;
                    }
                    negativeArray.sort(compareValue);
                    positiveArray.sort(compareValue);

                    if( negativeArray[negativeArray.length -1].value == 0
                        && positiveArray[0].value == 0)
                    {
                        negativeArray.pop();
                    }

                    //console.log(negativeArray);
                    labelsToDraw = negativeArray.concat(positiveArray);
                }
                else
                {
                    labelsToDraw = calculateLabelsToDrawHelper(allTicksLabels);
                }
            }

            //BITVIZA-454 [label management] When the height/width of 
            //vertical/horizontal axis is small that can only hold one axis label, the label 
            //should be hidden.
            if(labelsToDraw.length <= 1)
            {
                labelsToDraw = [];
            }

            return labelsToDraw;
        }

        var calculateLabelsToDrawHelper = function(allTicksLabels)
        {
            //allTicksLabels:
            //[0, X]
            //[-X, 0]
            //[X1, X2] (X1>0, X2>0)
            //[X1, X2] (X1<0, X2<0)

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];

            for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
            {
                var isDrawable = true;
                for(var i = 0; i < allTicksLabels.length-1; i+=(iBeyond+1))
                {
                    var item = allTicksLabels[i];
                    if(i != 0)
                    {
                        var previousItem = ticksLabelsToDraw[ticksLabelsToDraw.length-1];
                        if (allTicksLabels[i].start <= previousItem.end)
                        {
                            //for [0.9,1,2,3....], if cannot draw second axis label, just ignore second, then continue
                            if (ticksLabelsToDraw.length > 1) {
                                isDrawable = false;
                                break;
                            }
                        } else {
                            ticksLabelsToDraw.push(item);
                        }
                    } else {
                        //add the first axis tick label
                        ticksLabelsToDraw.push(item);
                    }
                }
                //for [.....5,5.1], always draw the last axis tick label
                var lastItem = allTicksLabels[allTicksLabels.length-1];
                if (lastItem.start < ticksLabelsToDraw[ticksLabelsToDraw.length-1].end) {
                    ticksLabelsToDraw.pop();
                }
                ticksLabelsToDraw.push(lastItem);
                
                if(isDrawable) {//find the labels
                    break;
                } else {
                    ticksLabelsToDraw = [];
                }
            }
            
            return ticksLabelsToDraw;
        }

        var getTicksLabel = function ()
        {
            var axDomain = m_axScale.domain();//[-100, 2000]

            var tickNum = m_axDefaultTickNum;
            if(m_axScale.tickHint)//after perfect
            {
                tickNum = m_axScale.tickHint;
            }

            var axTicksLabels = m_axScale.ticks(tickNum);//[0, 2000, 4000, ...]
            // [21-Sep-2012 Nick ] FIXME Comment out this part to fix bug BITVIZA-383, any particular reason to filter ticks?
            // if it is yes, what kind of criteria should be taken?
//            if(axTicksLabels.length > 20)
//            {
//                //too many ticks. filter some ticks
//                var tempTicks = [];
//                for(var i = 0; i < axTicksLabels.length; i++)
//                {
//                    if(axTicksLabels[i].toString().substr(0,1) == "1"
//                      || axTicksLabels[i].toString().substr(0,1) == "2"
//                      || axTicksLabels[i].toString().substr(0,1) == "5")
//                    {
//                        tempTicks.push(axTicksLabels[i]);
//                    }
//                }
//                axTicksLabels = tempTicks;
//            }

            for(var i=0; i < axTicksLabels.length; i++){
              axTicksLabels[i] = parseFloat( axTicksLabels[i].toFixed(8));
            }
            var beginLabel;
            var endLabel;
            if(axDomain[0] <= axDomain[axDomain.length -1])
            {
                beginLabel = axDomain[0];
                endLabel = axDomain[axDomain.length -1];
            }
            else
            {
                beginLabel = axDomain[axDomain.length -1];
                endLabel = axDomain[0];
            }

            if(axTicksLabels.length > 0)
            {
                if(axTicksLabels[0] != beginLabel) {
                    //the first label is not the first doamin. Add it.
                    axTicksLabels.unshift(beginLabel);
                }
                
                if(axTicksLabels[axTicksLabels.length -1] != endLabel) {
                    //the last label is not the end. Add it.
                    axTicksLabels.push(endLabel);
                }
            }

            var ticks = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {
                var tickItem = {};
                tickItem.value = axTicksLabels[i];
                if(m_props.isPercentMode)
                {
                    tickItem.text = parseFloat((axTicksLabels[i]*100).toFixed(8)).toString();
                }
                else
                {
                    tickItem.text = parseFloat(axTicksLabels[i].toFixed(8)).toString();
                }
                ticks.push(tickItem);
            }

          //format value label by d3
            if(m_props.label)
            {
                if(!m_props.label.formatString && m_props.label.numberFormat){
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var formatFun = d3.format(m_props.label.numberFormat);
                        ticks[i].text = (formatFun(axTicksLabels[i]));
                    }
                }else if(m_props.label.formatString){
                    var formatString = m_props.label.formatString;
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        ticks[i].text = (FormatManager.format(axTicksLabels[i], formatString));
                    }
                }
                
            }
            
            return ticks;
        }

        var maxLabelTextHeight = function (textArray)
        {
            var maxTextHeight = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen = fastMeasure(textArray[i], m_style.label).height;
                if(maxTextHeight < tLen)
                {
                    maxTextHeight = tLen;
                }
            }
            return maxTextHeight;
        }

        var maxLabelTextWidth = function (textArray)
        {
            var maxTextWidth = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen = fastMeasure(textArray[i], m_style.label).width;
                if(maxTextWidth < tLen)
                {
                    maxTextWidth = tLen;
                }
            }
            return maxTextWidth;
        }
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.fastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        }        

        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };
        
        return axis;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.axis',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.axis.valueAxisCore',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.axis.categoryAxisCore',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TextUtils, Objects, valueAxisCore, categoryAxisCore, langManager, NumberUtils, dispatch, FormatManager, matrix, BoundUtil) {

    return function(manifest, ctx) {
        //we should build the axis Data Module, and then draw the axis.
        var m_AxisDM = null;

        var parent = null;
        var m_width = 0;
        var m_height = 0;

        var m_isDrawBody = true;

        var m_spaceLimit = -1;

        var m_axClassName = "viz-axis";
        var m_axBodyClassName = "viz-axis-body";
        var m_axTitleClassName = "viz-axis-title";
        var m_axLabelClassName = "viz-axis-label";

        var m_titleOffset = 11;

        var m_data = { };
        var m_dataAxis = { };
        
        var m_isTitleVisible = true;
        
        var m_props = manifest.props(null);
        
        var m_drawable = true;

        var eDispatch = new dispatch('initialized');
        
        var m_defaultColor = m_props.color;

        var m_scale = null;

        var m_effectManager;
        if(ctx)
        {
           m_effectManager = ctx.effectManager;
        }
        
        var m_title = null;
        
        var m_style = {};
        
        
        var getThemeStyleDef = function () {
          if(ctx)  {
              m_style.title = ctx.styleManager.query(m_axTitleClassName);
              m_style.label = ctx.styleManager.query(m_axLabelClassName);
              if (m_props.title.applyAxislineColor){
                m_style.title.fill = m_props.color;
              }
          }
        };

        var m_matrix = matrix(), labelAngle = null, labelAlign = null, angle = null, tickAngle = null;
        
        var drawAll = function()
        {
            if(!m_drawable)
            {
                //do not draw bacause of smart layout
                return false;
            }
            else
            {
                if(!drawBody() && !drawTitle())
                {
                    return false;
                }
            }

            return true;
        };

        var drawTitle = function() 
        {
            return m_props.title.visible && m_props.visible;
        };

        var drawBody = function() 
        {
            if(!m_isDrawBody)
            {
                return false;
            }

            var rangeArray = m_scale.range();
            var domainArray = m_scale.domain();
            var rangeBand = null;
            if(m_props.type === "category")
            {
                rangeBand = m_scale.rangeBand();
            }

            var hasData = false;
            if(!m_props.isIndependentMode)
            {
                if(m_dataAxis)
                {
                    hasData = true;
                }
            }
            else
            {
                if(m_data)
                {
                    hasData = true;
                }
            }

            return !(!m_props.visible ||
                   (rangeArray[0] === 0 && rangeArray[rangeArray.length-1] === 0 && rangeArray.length >=2 ) ||
                   (rangeArray.length === 1 && rangeArray[0] === 0 &&
                    domainArray.length === 1 && domainArray[0] === 0 && m_props.type === "value") ||
                   ((!rangeBand || !hasData) && rangeArray.length === 1 && rangeArray[0] === 0 &&
                     domainArray.length === 1 && domainArray[0] === 0 && m_props.type === "category")    
                );
        };

        var axis = function (selection) {
                var pre = axis.getPreferredSize();
                BoundUtil.drawBound(selection, pre.width, pre.height);
          
                parent = selection;
                //in axis, we cannot use data driven way like
                //        var e = selectDIV.selectAll("p")
                //.data(pdata,function(d){return d;});
             
                //e.enter().append("p")
                //.text(function(d){return d;});

                //e.exit().remove();
                //to control the redraw, because axis is not based on data, but based on scale

                //there should be only one axis Class
                var axisClass = selection.select("." + m_axClassName);

                var rangeArray = m_scale.range();
                var domainArray = m_scale.domain();
                if(!drawAll())
                {
                    //remove all the axis 
                    //to improve the performance, we should remove as less elements as possible.
                    axisClass.remove();
                }
                else
                {
                    //---we should dicide show or hide somethings because of the spaceLimit
                    var spacings = axis.getPreferredSize().spacings;

                    var titleSpace = spacings[0];
                    var bodySpace = 0;
                    for(var i = 1; i < spacings.length; i++)
                    {
                        bodySpace += spacings[i];
                    }

                    if(m_spaceLimit >= 0 && m_spaceLimit < (titleSpace + bodySpace))
                    {
                        m_isTitleVisible = false;
                    }

                    prepareProperties();

                    var core;
                    var coreScale;
                    var re = getCoreAndScale();
                    core = re.core;
                    coreScale = re.coreScale;

                    //the axis body
                    var axisCore = core()
                                  .properties(m_props)
                                  .style(m_style)
                                  .position(m_props.position)
                                  .axScale(coreScale)
                                  .spaceLimit(m_spaceLimit)
                                  .matrix(m_matrix)
                                  .labelAngle(labelAngle)
                                  .labelAlign(labelAlign)
                                  .angle(angle)
                                  .tickAngle(tickAngle);

                    var axisBody;
                    if(axisClass.empty())
                    {
                        axisClass = selection.append("g")
                                 .attr("class", m_axClassName);

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName);
                    }
                    else
                    {
                        //redraw axis body
                        var e=axisClass.select("." + m_axBodyClassName).remove();

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName);

                        axisBody = axisClass.select("." + m_axBodyClassName);
                    }

                    if(drawBody())
                    {
                        axisBody.call(axisCore);
                    }

                    //build axis title Text
                    var title = "";
                    if(m_props.title.text !== undefined && m_props.title.text !== null)
                    {
                        title = m_props.title.text;
                    }
                    else
                    {
                        if(m_props.type === "value")
                        {
                            if(m_title) 
                            {
                                title = m_title;
                            }
                            else
                            {
                                title = langManager.get('IDS_ISNOVALUE');
                            }
                        }
                        else //let us build the title!
                        {
                            var dataset = [];
                            if(m_props.isIndependentMode)
                            {
                                if(m_data)
                                {
                                    for(var dataObj in m_data)
                                    {
                                        if (m_data.hasOwnProperty(dataObj))
                                        {
                                            dataset = m_data[dataObj].values;
                                            break;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if(m_dataAxis)
                                {
                                    dataset = m_dataAxis.values;
                                }
                            }

                            for(var k = 0 ; k < dataset.length; k++)
                            {
                                if(dataset[k].type)
                                {
                                    if(dataset[k].type === "MND" && k === 0)
                                    {
                                        title += langManager.get('IDS_DEFAULTMND') + ((dataset.length === 1)? "" : " - ");
                                    }
                                    else if(dataset[k].type === "MND" && k === (dataset.length-1))
                                    {
                                        title += " - " + langManager.get('IDS_DEFAULTMND');
                                    }
                                }
                                else
                                {
                                    if(dataset[k].col.val)
                                    {
                                        title += dataset[k].col.val;
                                    }
                                    else
                                    {
                                        title += langManager.get('IDS_ISNOVALUE');
                                    }

                                    if(k !== (dataset.length-1) && !dataset[k+1].type)
                                    {
                                        title += " / ";
                                    }
                                }
                            }
                        }
                    }
                    

                    //redraw axis title
                    var titleOffset = m_titleOffset;
                    axisClass.select("." + m_axTitleClassName).remove();

                    if(drawTitle())
                    {
                        if(m_props.title.visible && m_isTitleVisible)
                        {  
                            var pSize = axisCore.getPreferredSize();
                            var axTitle = axisClass.append("g")
                                  .attr("class", m_axTitleClassName)
                                  .append("text")
                                  .attr("text-anchor", "middle")
                                  .attr("fill", m_style.title.fill)
                                  .attr("font-size", m_style.title['font-size'])
                                  .attr("font-weight", m_style.title['font-weight'])
                                  .attr("font-family", m_style.title['font-family']); // text-align
                                  
                            if(m_props.position === "bottom")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }
                                  axTitle.attr("x", pSize.width/2)
                                         .attr("y", pSize.height + titleOffset)
                                         .attr("dominant-baseline", "hanging");//"auto")//"hanging")//"central");
                                    
                                  if(jQuery.browser.msie)
                                  {
                                      //dominant-baseline does not work
                                      var textHeight = m_style.title['font-size'].toString();
                                      var indexPX = textHeight.indexOf("px");
                                      if(indexPX >= 0)
                                      {
                                          textHeight = textHeight.substr(0, indexPX);
                                      }
                                      axTitle.attr("y", Number(axTitle.attr("y")) + textHeight/2);
                                      axTitle.attr("dominant-baseline", "auto");
                                  }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.title.toString());
                            }
                            else if(m_props.position === "top")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }

                                titleHieght = fastMeasure(title, m_style.title).height;

                                axisBody.attr("transform", "translate(0, " + (titleHieght + titleOffset) + ")");

                                axTitle.attr("x", pSize.width/2)
                                  .attr("y", titleHieght)
                                  .attr("dx", "0") // padding-right
                                  .attr("dy", "0") // vertical-align: middle?
                                  .attr("dominant-baseline", "auto");//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.title.toString());
                            }
                            else if(m_props.position === "left")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                titleWidth = fastMeasure(title, m_style.title).height;

                                axisBody.attr("transform", "translate(" + (titleWidth + titleOffset) + ", " + 0 + ")");

                                var centerX = titleWidth;
                                var centerY = pSize.height/2;
                                var ac = "-90";

                                //axisClass.append("circle").attr("cx", centerX).attr("cy", centerY). attr("r", 5);
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY)
                                  .attr("dominant-baseline", "auto");//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.title.toString());
                            }
                            else// if(m_props.position == "right")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                titleWidth = fastMeasure(title, m_style.title).height;
                                
                                centerX = pSize.width + titleWidth/2 + titleOffset;
                                centerY = pSize.height/2;
                                var ac = "-90";

                                //axisClass.append("circle").attr("cx", centerX).attr("cy", centerY). attr("r", 5);
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY - titleWidth/2)
                                  .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")

                                if(jQuery.browser.msie)
                                {
                                    //dominant-baseline does not work
                                    var textHeight = m_style.title['font-size'].toString();
                                    var indexPX = textHeight.indexOf("px");
                                    if(indexPX >= 0)
                                    {
                                        textHeight = textHeight.substr(0, indexPX);
                                    }

                                    centerY = Number(pSize.height/2) + textHeight/2;
                                    axTitle.attr("y", centerY);
                                    axTitle.attr("dominant-baseline", "auto");
                                }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.title.toString());
                            }
                        }
                    }
                    m_isTitleVisible = true;
                }
                
            eDispatch.initialized();
            
            return axis;
        };
        
        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = pmod( _, 360);
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle =pmod( _, 360);
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = pmod( _, 360);
          return axis;
        };
        
        function pmod(a,m)
        {
          var ret = a % m;
          if (0 > ret)
            ret += m;
          return ret;
        }
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.parent = function (_) {
          if ( !arguments.length ) return parent;
          parent = _;
          return axis;
        };

        axis.width = function(_width) {
            if (arguments.length == 0) {
                return m_width;
            }
            else {
                m_width = _width;

                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(m_height)
                    {
                        m_spaceLimit = m_height;

                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(m_width)
                    {
                        m_spaceLimit = m_width;
                    }
                }

                return axis;
            }
        };

        axis.height = function(_height) {
            if (arguments.length == 0)
                return m_height;
            
            m_height = _height;
            if(m_props.position == "bottom" || m_props.position == "top")
            {
                if(m_height)
                {
                    m_spaceLimit = m_height;

                }
            }
            else if(m_props.position == "left" || m_props.position == "right")
            {
                if(m_width)
                {
                    m_spaceLimit = m_width;
                }
            }

            
            return axis;
        };

        axis.gridlineLength = function(_gridlineLength) {
            if (arguments.length == 0)
                return m_props.gridline.length;
            m_props.gridline.length = _gridlineLength;
            return axis;
        };

        axis.startPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .startPadding();
            }
            return padding;
        };

        axis.endPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .endPadding();
            }
            return padding;
        };

        axis.size = function(_size) {
            if (arguments.length == 0)
                return {
                           "width" : m_width,
                           "height": m_height,
                       };
            m_width = _size.width;
            m_height = _size.height;
            return axis;
        };
        
        /*
         * Jimmy/9/22/2012 if axis works under independentMode(boxplot for now)
         * it doesn't rely on the data passed through this API from container, instead, boxplot
         * will pass calculated data through dependency 
         */
        axis.independentData = function(_data) {
          if(m_props.isIndependentMode) {
            if (arguments.length == 0)
                return m_data;
            m_data = _data;
          }
        },

        axis.data = function(_data) {
            if (arguments.length == 0)
                return m_data;
            
            if(!m_props.isIndependentMode)
            {
              m_data = _data;
              if(_data.getAnalysisAxisDataByIdx)
              {
                m_dataAxis = m_data.getAnalysisAxisDataByIdx(0);
              }
            }
            return axis;
        };

        axis.title = function(_title) {
            if (arguments.length == 0)
                return m_title;
            m_title = _title;
            return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0){
                return m_props;
            }

            Objects.extend(true, m_props, _properties);

            if(_properties.color)
            {
                m_props.customizedColor = _properties.color;
            }

            return axis;
        };

        axis.range = function() {
            var range = null;
            if ((m_props.type === "value") && (m_props.scale.fixedRange)) {
                if ((m_props.scale.maxValue !== null) && (m_props.scale.minValue !== null)) {
                    range = {
                        max : m_props.scale.maxValue,
                        min : m_props.scale.minValue,
                        from : 'axis'
                    };
                }
            }
            return range;
        }

        axis.scale = function(_scale) {
            if (arguments.length == 0)
                return m_scale;

            m_scale = _scale;
            return axis;
        };

        axis.isDrawBody = function(_isDrawBody) {
            if (arguments.length == 0)
                return m_isDrawBody;

            m_isDrawBody = _isDrawBody;
            return axis;
        };

        axis.color = function(_color) {
          if (arguments.length == 0)
              return m_props.color;
          if (m_props.customizedColor){
            _color = m_props.customizedColor;              
          }
          if(!_color){
              _color = m_defaultColor;
          }

          m_props = Objects.extend(true, m_props, {"color":_color});

          if (m_props.title.applyAxislineColor && _color) {
            m_style.title.fill = _color;
          }

          return axis;
        };

        axis.drawable = function(_drawable) {
            //drawable or not because of smart layout
            if (arguments.length == 0)
                return m_drawable;

            m_drawable = _drawable;

            return axis;
        };

        axis.getPreferredSize = function() {
            getThemeStyleDef();
            var rangeArray = [0];
            var domainArray = [0];
            if(m_scale)
            {
                rangeArray = m_scale.range();
                domainArray = m_scale.domain();
            }

            if(!m_scale || (!drawAll()) )            
            {
                return {
                    width : 0,
                    height : 0,
                    manual: false,
                };
            }
            else {
                //body size && title size
                var reCS = getCoreAndScale();
                var axisCore = (reCS.core)()
                              .properties(m_props)
                              .style(m_style)
                              .position(m_props.position)
                              .axScale(reCS.coreScale)
                              .spaceLimit(m_spaceLimit);
                
                var title, resultSize;
                if(m_props.title.visible && m_props.visible)
                {
                    //console.log(m_props.title.text);
                    if(m_props.title.text !== undefined && m_props.title.text !== null)
                    {
                        title = m_props.title.text;
                    }
                    else
                    {
                        title = "Value";
                    }
                }
                
                var titleHieght = 0;
                var titleWidth = 0;
                var titleOffset = 0;
                var axisSpacings = [];

                var sizeCore = axisCore.getPreferredSize();

                
                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(!drawBody())
                    {
                        sizeCore.height = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible && m_props.visible)
                    {
                        titleHieght = fastMeasure(title, m_style.title).height; 
                        titleOffset = m_titleOffset;
                    }

                    var titleSpace = titleHieght + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullHeight = titleSpace + bodySpace;
                    var realHeight = fullHeight;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullHeight)
                    {
                        realHeight = sizeCore.height;//no title
                    }

                    resultSize = {
                        maxSizeConstant : 0.5,
                        width: sizeCore.width,
                        height: fullHeight,
                        realHeight: realHeight,
                        spacings: axisSpacings,
                        manual: false,
                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(!drawBody())
                    {
                        sizeCore.width = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible && m_props.visible)
                    {
                        //title is vertical
                        titleWidth = fastMeasure(title, m_style.title).height; 
                        titleOffset = m_titleOffset;
                    }

                    var titleSpace = titleWidth + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullWidth = bodySpace + titleSpace;
                    var realWidth = fullWidth;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullWidth)
                    {
                        realWidth = sizeCore.width;//no title
                    }
                    

                    resultSize = {
                        maxSizeConstant : 0.5,
                        width: fullWidth,
                        realWidth: realWidth,
                        height: sizeCore.height,
                        spacings: axisSpacings,
                        manual: false,
                    }
                }
                if ((m_props.layoutInfo.width > 0) && (m_props.layoutInfo.height > 0) ) {
                    resultSize.width = m_props.layoutInfo.width;
                    resultSize.realWidth = m_props.layoutInfo.width;
                    resultSize.height = m_props.layoutInfo.height;
                    resultSize.realHeight = m_props.layoutInfo.height;
                    resultSize.manual = true;
                }
                return resultSize;
            }
        };

        axis.dispatch = function(_){
          if(!arguments.length)
            return eDispatch;
          eDispatch = _;return axis;
        };
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.fastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        };

        //Alex Su: to build a hierarchical structure basing on raw data.
        function hasMND(data){
          if (data[0].type === 'MND' || data[data.length - 1].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function hasOnlyMND(data){
          if (data.length === 1 && data[0].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function isMNDBefore(data){
          if (data[0].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function getMNDData(data){
          if (! hasMND(data)){
            return;
          }
          if (isMNDBefore(data)){
            return data[0];
          } else {
            return data[data.length - 1];
          }
        }
        
        function processRawData(data){
          if (! hasMND(data) || hasOnlyMND(data)){
            return data;
          }
          var newData = [];
          var i, j, k;
          for (i = 0; i < data.length; ++i){
            newData.push({
              col: data[i].col,
              rows: []
            });
          }
          var mndData = getMNDData(data);
          var mndLength = mndData.rows.length;
          var cateLength;
          if (isMNDBefore(data)){
            cateLength = data[1].rows.length;
            for (i = 0; i < mndLength; ++i){
              for (j = 0; j < cateLength; ++j){
                newData[0].rows.push(data[0].rows[i]);
              }
            }
            for (i = 1; i < data.length; ++i){
              for (j = 0; j < mndLength; ++j){
                newData[i].rows = newData[i].rows.concat(data[i].rows);
              }
            }
          } else {
            cateLength = data[0].rows.length;
            for (i = 0; i < cateLength; ++i){
              newData[newData.length - 1].rows = newData[newData.length - 1].rows.concat(data[data.length - 1].rows);
            }
            for (i = 0; i < data.length - 1; ++i){
              for (j = 0; j < cateLength; ++j){
                for (k = 0; k < mndLength; ++k){
                  newData[i].rows.push(data[i].rows[j]);
                }
              }
            }
          }
          return newData;
        }
        
        function buildHierarchicalData(data){
          var i,j;
          var categoryHierarchicalData = [];
          var rowData, cellData, spaceCount;
          var tempCellCount, tempSpaceCount;
          for (i = 0; i < data.length; ++i){
            rowData = [];
            spaceCount = 0;
            tempSpaceCount = 0;
            tempCellCount = 0;
            for (j = 0; j < data[i].rows.length; ++j){
              cellData = {};
              if (i === data.length - 1){
                cellData.value = data[i].rows[j];
                cellData.space = 1;
              } else {
                ++spaceCount;
                ++tempSpaceCount;
                if (i > 0 && tempSpaceCount >= categoryHierarchicalData[i - 1][tempCellCount].space){
                  cellData.value = data[i].rows[j];
                  cellData.space = spaceCount;
                  spaceCount = 0;
                  tempSpaceCount = 0;
                  ++tempCellCount;
                }
                else {
                  if (j + 1 < data[i].rows.length && data[i].rows[j].val === data[i].rows[j + 1].val){
                    continue;
                  }
                  else {
                    cellData.value = data[i].rows[j];
                    cellData.space = spaceCount;
                    spaceCount = 0;                  
                  }
                }                
              }
              rowData.push(cellData);
            }
            categoryHierarchicalData.push(rowData);
          }
          return categoryHierarchicalData;
        }
                
        function processData(data){
          var newData = processRawData(data);
          var hierarchicalData = buildHierarchicalData(newData);
          return hierarchicalData;
        }
        
        function reverseHierarchicalData(hData){
          for (var i = 0; i < hData.length; ++i){
            hData[i].reverse();
          }
        }
        
        var getCoreAndScale = function()
        {
            var re = { };
            var coreScale;
            if(m_props.type == "category") //a new scale is required
            {
                coreScale = [];
                //build labels (domain)
                var dataset = [];
                if(m_props.isIndependentMode) {
                    for(dataObj in m_data) {
                        dataset = m_data[dataObj].values;
                    }
                } else {
                    if(m_dataAxis) {
                        dataset = m_dataAxis.values;
                    }
                }
                var hierarchicalData = [];
                if (dataset && dataset.length){
                  hierarchicalData = processData(dataset);
                }
                //reverse domain or not,
                var oRange = m_scale.range();
                //by yuanhao 2012-12-17 ,
                if(oRange[0] > oRange[oRange.length -1 ])
                {
                    reverseHierarchicalData(hierarchicalData);
                }
                //if orRangeBand is 0, which means module do not use ordinal scale like normal, the scale is not equal every unit.
                var dataCount = hierarchicalData.length === 0 ? 0 : hierarchicalData[hierarchicalData.length - 1].length;
                var orRangeBand = m_scale.rangeBand(), orRangeBands = [];
                
                //Alex Su. Handling for boxplot.
                var isBoxPlotWithSingleAAFeed = false;
                if (dataset && dataset.length > 0 && dataset[0].rows.length === 0){
                  isBoxPlotWithSingleAAFeed = true;
                  dataCount = 1;
                  var cellData = {
                      value: {},
                      space: 1
                  };
                  cellData.value = {
                      val: m_dataAxis.values[0].col.val,
                      ctx:null
                  };
                  hierarchicalData = [[cellData]];
                }
                
                var di;
                if(!m_scale.noEqual){
                  if (! hasOnlyMND(dataset) && ! isBoxPlotWithSingleAAFeed){
                    for(di = 0; di < dataCount; di++){
                        orRangeBands[di] = orRangeBand;
                    }
                  } else {
                    var tickSpace = parseInt(oRange.length / dataCount, 10);
                    for(di = 0; di < dataCount; di++){
                      orRangeBands[di] = orRangeBand * tickSpace;
                    }
                  }
                }else{
                  for(di = 0; di < dataCount; di++){
                      orRangeBands[di] = Math.abs(oRange[di] - oRange[di+1]);
                  }
                }
                
                function getRangeEnd(endIndex){
                    var sum = 0;
                    for(var ix = 0; ix < endIndex; ix++){
                        sum +=orRangeBands[ix];
                    }
                    return sum;
                }
                var coreScaleItem = {};
                var cgDomain = [];
                var cgRange = [];
                var i, j, spaceCount = 0;
                var rangeStart, rangeEnd;
                for (i = 0; i < hierarchicalData.length; ++i){
                  cgDomain = [];
                  cgRange = [];
                  spaceCount = 0;
                  for (j = 0; j < hierarchicalData[i].length; ++j){
                    cgDomain.push(hierarchicalData[i][j].value);
                    
                    spaceCount += hierarchicalData[i][j].space;
                    rangeStart = j > 0 ? cgRange[j - 1][1] : 0;
                    rangeEnd = getRangeEnd(spaceCount);
                    cgRange.push([rangeStart, rangeEnd]);
                  }
                  var coreScaleItem = { 
                      "domain": cgDomain, 
                      "range":  cgRange,
                   };
       
                  coreScale.push(coreScaleItem);//add to the latest
                }
                
                core = categoryAxisCore;
            }
            else //value axis
            {   
                core = valueAxisCore;
                coreScale = m_scale;
            }
            re.core = core;
            re.coreScale = coreScale;
            re.coreScale.noEqual = m_scale.noEqual;
            return re;
        }
        
        function prepareProperties()
        {
            if (!m_effectManager) return;

            if(m_props.customizedColor) {
                m_props.color = m_props.customizedColor;
            }
            var parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_props.color,
            };
            m_props.color = m_effectManager.register(parameter);

            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.label.fill,
            };
            m_style.label.fill = m_effectManager.register(parameter);

            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.title.fill,
            };
            m_style.title.fill = m_effectManager.register(parameter);
        }

        return axis;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.axis',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.axis',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'axis',
    'properties' : {
      'isIndependentMode' : {
        'name' : 'isIndependentMode',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether axis works on independent mode, currently it is used specially for boxplot chart.',
        'isExported' : false
      },
      'isPercentMode' : {
        'name' : 'isPercentMode',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Show the label 0.1 as 10',
        'isExported' : false
      },
    'lineSize' : {
        'name' : 'lineSize',
        'supportedValueType' : 'String',
        'defaultValue' : '1',
        'description' : 'Set line size of axis.',
        'isExported' : true,
      },
      'title' : {
        'name' : 'title',
      'description' : 'Settings for axis title.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set visibility of axis title.'
        }, 
        'text' : {
        'name' : 'text',
        'supportedValueType' : 'String',
        'defaultValue' : null,
        'description' : 'Set text of axis title.'
        },
        'applyAxislineColor' : {
        'name' : 'applyAxislineColor',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set title color same with axisline color.',
        'isExported' : false,
        },
      },
      },
      'gridline' : {
        'name' : 'gridline',
      'description' : 'Settings for axis gridline.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible': {
          'name' : 'visible',
          'supportedValueType' : 'Boolean',
          'defaultValue' : true,
          'description' : 'Set visibility of axis gridline.'
        },
        showFirstLine : {
              'name' : 'showFirstLine',
              'supportedValueType' : 'Boolean',
              'defaultValue' : false,
              'description' : 'Set enabled/disabled the first line of gridlines.',
              'isExported' : false,
        },
        showLastLine : {
              'name' : 'showLastLine',
              'supportedValueType' : 'Boolean',
              'defaultValue' : false,
              'description' : 'Set enabled/disabled the last line of gridlines.',
              'isExported' : false,
        },
        'type' : {
          'name' : 'type',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'line', 'dotted', 'incised'],
          'defaultValue' : 'line',
          'description' : 'Set type of gridline.',
          'isExported' : true,
        },
        'color' : {
          'name' : 'color',
          'supportedValueType' : 'String',
          'defaultValue' : '#d8d8d8',
          'description' : 'Set color of gridline.',
          'isExported' : true,
        },
        'size' : {
          'name' : 'size',
          'supportedValueType' : 'String',
          'defaultValue' : '1',
          'description' : 'Set line size of gridline.',
          'isExported' : true,
        },        
          },
      }, 
    'color' : {
        'name' : 'color',
        'supportedValueType' : 'String',
        'defaultValue' : '#6c6c6c',
        'description' : 'Set color of axisline.',
          'isExported' : true,
      },
      'axisline' : {
        'name' : 'axisline',
      'description' : 'Settings for axisline.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of axisline.'
        },
      },
      },    
      'type' : {
        'name' : 'type',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'value', 'category', ],
        'defaultValue' : 'value',
        'description' : 'Set type of axis.',
          'isExported' : false,
      },
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of axis.',
      },
      'label' : {
        'name' : 'label',
      'description' : 'Settings for axis label.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of axis label.'
        }, 
        'numberFormat' : {
        'name' : 'numberFormat',
        'supportedValueType' : 'String',
        'defaultValue' : '',
        'description' : 'Set number format of value axis.'
        },
        'formatString' : {
         'name' : 'formatString',
         'supportedValueType' : 'String',
         'defaultValue' : null,
         'description' : 'Set format string of value axis. If number format and format string are both set, number format will be ignored. '
        }
      },
      },
      'position' : {
        'name' : 'position',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'left', 'right', 'top', 'bottom' ],
        'defaultValue' : 'bottom',
        'description' : 'Set position of axis.',
          'isExported' : false,
      },
      'scale' : {
        'name' : 'scale',
        'description' : 'Set scale for yAxis.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
            'fixedRange' : {
                'name' : 'fixedRange',
                'supportedValueType' : 'Boolean',
                'defaultValue' : false,
                'description' : 'Enable/disable fixed axis range according minValue and maxValue.',
                'isExported' : false
            },
            'minValue' : {
                'name' : 'minValue',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set minValue of yAxis.',
                'isExported' : false
            },
            'maxValue' : {
                'name' : 'maxValue',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set maxValue of yAxis.',
                'isExported' : false
            }
        },
        'isExported' : false
      },
      'layoutInfo' : {
        'name' : 'layoutInfo',
        'description' : 'Settings layoutInfo for axis.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
            'width' : {
                'name' : 'width',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set width of xAxis.',
                'isExported' : false
            }, 
            'height' : {
                'name' : 'height',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set height of xAxis.',
                'isExported' : false
            }
        },
        'isExported' : false
      }
    },
    'css' : {
      '.viz-axis-title' : {
        'description' : 'Define style for the axis title.',
        'value' : {
          'fill' : 'black',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '14px',
          'font-weight' : 'bold'
        }
      },
      '.viz-axis-label' : {
        'description' : 'Define style for the axis label.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      }
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.data.handler.MultiChartDataHandler',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.MeasureDataHandler',
  version : '4.0.0'
}
],
 function Setup(FunctionUtils, MultiAxesDataAdapter, MeasureDataHandler){
    
   function initSubChartAxes(axes){
     
       var sub = axes.slice(0);
       sub.sort(function(a,b){return a.index -b.index;});
       sub.shift();  
       
       return sub;
   }
   
   function initMeasureValueAxisIndexForMeasure(bindingInfo){
     if(bindingInfo[0] === true){
       if(bindingInfo[1] === true){
          return [1,2];
       }else{
         return [1];
       }
      
     }else if(bindingInfo[1] === true){
       return [2];
     }else{
       return [1]; 
     }
     
   }
   
   function initMeasureValueAxisIndex(bindingInfo){
     
      //axis 1 has been feeded with crosstable
      if(bindingInfo[0] === true){
         if(bindingInfo[1] === true){
            return [1];
         }else if(bindingInfo[2] === true){
            if(bindingInfo.length > 3){
               return [1];//Multi Radar,pass crosstable to radar as single chart handler
            }else{
               return [2];
            }
         }else if(bindingInfo[3] === true){// Multi Radar, aa 4 could not be feeded
            FunctionUtils.error("Not Supported");
         }else{
            return [1];
         }
      }else if(bindingInfo[1] === true){
         if(bindingInfo[2] === true){
            return [1, 2];
         }else if(bindingInfo[3] === true){
            FunctionUtils.error("Not Supported");
         }else{
            return [1];
         }
      }else if(bindingInfo[2] === true){
        if(bindingInfo[3] === true){
           FunctionUtils.error("Not Supported");
        }
        else{
          if(bindingInfo.length > 3){
             return [1];//Multi Radar,pass crosstable to radar as single chart handler
          }else{
             return [2];
          }
        }
      }else{
        for(var i = 0; i< bindingInfo.length;i++){
          if(bindingInfo[i] === true){
             FunctionUtils.error("could not determin measure value axis index");
          }
        }
        //all false
        return [1];
      }
      
      FunctionUtils.error("could not determin measure value axis index");
     
     } 
   
   function MultiChartDataHandler(dataAdapter, type){
        this._dataAdapter =  dataAdapter;
        this._aa = this._dataAdapter.getAnalysisAxisDataByIdx();
        this._mg = this._dataAdapter.getMeasureValuesGroupDataByIdx();
        this._subAxes = initSubChartAxes(this._aa);
        this._type = type;
        
        if(this._type === undefined){
           this._measureValueAxisIndex = initMeasureValueAxisIndex(this._dataAdapter.getBindingInfo());
           this._maxMeasureAxis = 2;
        }else if(this._type === "measures"){
           this._measureValueAxisIndex = initMeasureValueAxisIndexForMeasure(this._dataAdapter.getBindingInfo());
           this._maxMeasureAxis = this._dataAdapter.getBindingInfo().length ;
        }
      
   }
   
   MultiChartDataHandler.prototype.getSubDataAdapter = function(ctx){
       if(this._type === undefined){
          return this.getSubDataAdapterByContext(ctx);
       }else if(this._type === "measures"){
          return this.getSubDataAdapterByMeasures(ctx);
       }
       
       return null;
     
   };
   
   MultiChartDataHandler.prototype.getSubDataAdapterByContext = function(ctx){
     var dataAdapter, subAxis, i, mvg;
     if(ctx){
        //Multiplier with MND
        if(ctx.path.mg !== undefined && ctx.path.mi !== undefined){
          if(ctx.path.di !== undefined && ctx.path.dii !== undefined){ // Mulitplier with Dimension and MND
             dataAdapter = new MultiAxesDataAdapter();
            
            for(i = 0; i < this._subAxes.length; i++){
              subAxis = this._subAxes[i];
              dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
            }
            
            mvg = this._mg[ctx.path.mg];
            dataAdapter.addMeasureValuesGroup({index: 0, values: MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxMeasureAxis, true)});
            
            
            return dataAdapter;

          }else{//Multiplier with MND only
           dataAdapter = new MultiAxesDataAdapter();
           
           for(i = 0; i < this._subAxes.length; i++){
             subAxis = this._subAxes[i];
             dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
           }
           
           mvg = this._mg[ctx.path.mg];
           //MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxAxisCount
           dataAdapter.addMeasureValuesGroup({index: 0, values:MeasureDataHandler.makeMeasureValues(null, {"values":[mvg.values[ctx.path.mi]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
           
           return dataAdapter;
          }
          
        }else{ //Multiplier without MND
          dataAdapter = new MultiAxesDataAdapter();
        
          for(i = 0; i < this._subAxes.length; i++){
            subAxis = this._subAxes[i];
            dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
          }
          
          for(i = 0; i < this._mg.length; i++){
            mvg = this._mg[i];
            dataAdapter.addMeasureValuesGroup({index: mvg.index, values:  MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
          }
          
          return dataAdapter;
          }
       }
     
     return null;
   };
   
   MultiChartDataHandler.prototype.getSubDataAdapterByMeasures = function(ctx){
     var dataAdapter = new MultiAxesDataAdapter();
      
     for(var i = 0; i < this._aa.length; i++){
        dataAdapter.addAnalysisAxis(this._aa[i]);
     }
      
     var mg = this._mg[0];
     
     dataAdapter.addMeasureValuesGroup({index : 0, values : MeasureDataHandler.makeMeasureValues(null, {"values":[mg.values[ctx.row]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
     dataAdapter.addMeasureValuesGroup({index : 1, values : MeasureDataHandler.makeMeasureValues(null, {"values":[mg.values[ctx.col]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
     
     return dataAdapter;
   };
   
   
   return MultiChartDataHandler;
   
 });sap.riv.module(
{
  qname : 'sap.viz.modules.util.DimensionalInfoHandler',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(langManager) {
  //fake dataset
  return function(props, multiplier) {
    var data_ = multiplier;
    var props_ = props;
    var dimInCol_;
    var dimInRow_;
    var rowDimension_ = {
      'values' : []
    };

    var colDimension_ = {
      'values' : []  
    };
    var ctx_ = [];
    var rowCount_;
    var colCount_;
    var mndDefaultString = langManager.get('IDS_DEFAULTMND');
    var my = function() {

    };


    my.setData = function(data)
    {
      data_ = data;
      return my;
    };

    my.setProperties = function(props)
    {
      props_ = props;
      return my;
    };

    my.getColumnDimensionData = function()
    {
      return  colDimension_;
    };

    my.getRowDimensionData = function()
    {
      return rowDimension_;
    };

    my.getContexts = function()
    {
      return ctx_;
    };

    function buildIndexMeasuresOnly()
    {
      var i = 0;
      if(dimInCol_ > 0)
      {
        rowCount_ = 1;
        colCount_ = data_.values[0].rows.length;
        ctx_.push([]);
        var colDimVals = colDimension_.values;
        colDimVals[0] = { 
            'col':{
          'val': mndDefaultString
        },
        'rows':[]
        };

        for(i = 0; i < data_.values[0].rows.length; ++i)
        {
          colDimVals[0].rows.push({ 
            'val': data_.values[0].rows[i].val,
            'info': data_.values[0].rows[i].info
          });
          ctx_[0].push(data_.values[0].rows[i].ctx);
        }
      }
      else
      {
        rowCount_ = data_.values[0].rows.length;
        colCount_ = 1;
        var rowDimVals = rowDimension_.values;
        rowDimVals[0] = { 
            'col':{
        'val': mndDefaultString
        },
        'rows':[]
        };
        for(i = 0; i < data_.values[0].rows.length; ++i)
        {
          rowDimVals[0].rows.push({
            'val': data_.values[0].rows[i].val,
            'info': data_.values[0].rows[i].info
          });
          ctx_.push([data_.values[0].rows[i].ctx]);
        }
      }
    }

    function initilize()
    {
      rowDimension_.values = [];
      colDimension_.values = [];
      rowCount_ = 0;
      colCount_ = 0;
      ctx_ = [];
    }
    // compare tow title is the same
    function compare(index, preIndex, startDim, dimNum)
    {
      for(var i = startDim; i < startDim + dimNum; ++i)
      {
        if(data_.values[i].rows[index].val !== data_.values[i].rows[preIndex].val){
          return false;
        }
      }
      return true;
    }

    //  
    function buildUniqueIndexes(uniqueIndex, index, startDim, dimNum)
    {
      var start = 0;
      var end = uniqueIndex.length;
      var isFound = true;
      for ( var level = 0; isFound && level < dimNum; ++level) {
        var nextStart = end;
        var nextEnd = start;
        isFound = false;
        for ( var pos = start; pos < end; ++pos) {
          if (data_.values[startDim + level].rows[uniqueIndex[pos]].val=== data_.values[startDim + level].rows[index].val) {
            isFound = true;
            if (pos < nextStart){
              nextStart = pos;
            }
            if (pos >= nextEnd){
              nextEnd = pos + 1;
            }
          }
        }

        if (isFound) {
          start = nextStart;
          end = nextEnd;
        }
      }

      if (!isFound)
      {
        if (end < uniqueIndex.length){
          uniqueIndex.splice(end, 0, index);
        } else {
          uniqueIndex.push(index);}
      }       
    }

    // use one array to stroe one column header title
    function buildOneHeader(index, startDim, dimNum)
    {
      var result = [];
      for(var i = startDim; i < startDim + dimNum; ++i)
      {
        result.push(data_.values[i].rows[index].val);
      }
      return result;
    }

    // generate hashmap map from name to col index
    function generateIndexMap(allUniqueColIndex, startDim, dimNum)
    {
      var map = {};
      for(var i = 0; i < allUniqueColIndex.length; ++i)
      {
        map[buildOneHeader(allUniqueColIndex[i], startDim, dimNum)] = i;
      }
      return map;
    }

    function processColHeader(startDim, dimNum)
    {
      var colIndex = [];
      var allUniqueColIndex = [];
      allUniqueColIndex.push(0);
      var i;
      var element = {};
      for(i = 1; i < data_.values[startDim].rows.length; ++i)
      {
        buildUniqueIndexes(allUniqueColIndex, i, startDim, dimNum);
      }

      //build column dimension data set
      var colDimVals = colDimension_.values;
      for(i = 0; i < dimNum; ++i)
      {
        element = {};
        element.col = data_.values[startDim + i].col;
        element.rows = [];
        element.rows[0] = {
          'val': data_.values[startDim + i].rows[0].val,
          'info': data_.values[startDim + i].rows[0].info
        };
        colDimVals.push(element);
      }
      for(i = 0; i < allUniqueColIndex.length; ++i)
      {
        for(var j = 0; j < dimNum; j++)
        {
          colDimVals[j].rows[i] = {
            'val': data_.values[startDim + j].rows[allUniqueColIndex[i]].val,
            'info': data_.values[startDim + j].rows[allUniqueColIndex[i]].info
          };
        }

      }
      // to solve performance issue
      var hashMap = generateIndexMap(allUniqueColIndex, startDim, dimNum);
      for(i = 0; i < data_.values[startDim].rows.length; ++i)
      {
        element = buildOneHeader(i, startDim, dimNum);
        colIndex[i] = hashMap[element];
      }
      colCount_ = allUniqueColIndex.length;
      return colIndex;
    }
    
    
    function cloneOneContext(ctx)
    {
      if(!ctx) {return null;}
      return {
        'type': ctx.type,
        'path':{
          'aa': ctx.path.aa,
          'di': ctx.path.di,
          'dii': ctx.path.dii
        }
      };
    }
    
    function cloneOneRowContext(row)
    {
      var clones = [];
      for(var i = 0; i < row.length; ++i)
      {
        clones.push(cloneOneContext(row[i]));
      }
      return clones;
    }

    function addMeasureContext(row, ctx)
    {
      
      for(var i = 0; i < row.length; ++i)
      {
        if(!row[i]) {row[i] = {path:{}};}
        row[i].path.mg = ctx.path.mg;
        row[i].path.mi = ctx.path.mi;
      }
    }

    function expendContexts(num)
    {
      var totalRow = ctx_.length;
      for(var i = 0; i < num; ++i)
      {
        for(var j = 0; j < totalRow; ++j)
        {
          ctx_.push(cloneOneRowContext(ctx_[j]));
        }
      }
    }

    function addMND(bMNDInner, bMNDInRow, dimInRow, dimInCol)
    {
      var indexMND = bMNDInner ? data_.values.length - 1 : 0;
      var measures = data_.values[indexMND].rows;
      //new dimension to add row or column
      var row = {};
         row.col = data_.values[indexMND].col;
         row.rows = []; 
      var dimVals = bMNDInRow ? rowDimension_.values :colDimension_.values;
      var dimNums = bMNDInRow ? dimInRow : dimInCol;
      var i, j, k;
      var element;
      
      //1 MND in row and no dimension in row
      if(bMNDInRow && dimInRow === 0)
      {
        dimVals[0] = { 
            'col':{
            'val': mndDefaultString
          },
          'rows':[]
        };
        addMeasureContext(ctx_[0], measures[0].ctx);
        //Jimmy,12/27/2012 we don't have additional info for MND for now
        dimVals[0].rows.push({ 'val': measures[0].val});
        for(i = 1; i < measures.length; ++i)
        {
          dimVals[0].rows.push({ 'val': measures[i].val});
          ctx_.push(cloneOneRowContext(ctx_[0]));
          addMeasureContext(ctx_[i], measures[i].ctx);
        }
        rowCount_ = measures.length;
        return;
      }
      
      //2 MND in column and no dimension in column
      if(!bMNDInRow && dimInCol === 0)
      {
        //create column dimension and set value
        dimVals[0] = { 
            'col':{
            'val': mndDefaultString
            },
            'rows':[]
        };
        for(i = 0; i < measures.length; ++i)
        {
          dimVals[0].rows.push({'val' : measures[i].val});
        }
        
        // expand context  
        for(i = 0; i < ctx_.length; ++i)
        {
          ctx_[i][0].path.mg = measures[0].ctx.path.mg;
          ctx_[i][0].path.mi = measures[0].ctx.path.mi;
          for(j = 1; j < measures.length; ++j)
          {
            ctx_[i].push(cloneOneContext(ctx_[i][0]));
            ctx_[i][j].path.mg = measures[j].ctx.path.mg;
            ctx_[i][j].path.mi = measures[j].ctx.path.mi;
          }
        }
        return;
      }
      var count = bMNDInRow ? rowCount_ : colCount_;
      // 3 have dimensions in column and have dimensions in row
      if( bMNDInner)
      {
        // add measure data
        for(i = 0; i < count; ++i)
        {
          for(j = 0; j < dimVals.length; ++j)
          {
            for(k = 1; k < measures.length; ++k)
            {
              element =  {
                'val': dimVals[j].rows[i * measures.length + k - 1].val,
                'info': dimVals[j].rows[i * measures.length + k - 1].info
              };
              dimVals[j].rows.splice(i * measures.length + k, 0, element);
            }
          }
        }

        //add MND dimension to row/column
        for(i = 0; i < count; ++i)
        {
          for(j = 0; j < measures.length; ++j)
          {
            element =  {'val': measures[j].val};
            row.rows.push(element);
          }
        }
        dimVals.push(row);

        if(bMNDInRow)
        {
          rowCount_ *= measures.length;
          for(i = 0; i < rowCount_; i += measures.length)
          {
            addMeasureContext(ctx_[i], measures[0].ctx);
            for(j = 1; j < measures.length; ++j)
            {
              var oneRow = cloneOneRowContext(ctx_[i]);
              ctx_.splice(i + j, 0, oneRow);
              addMeasureContext(ctx_[i + j],  measures[j].ctx);
            }
          }

        }else{      
          colCount_ *= measures.length;
          for(i = 0; i < ctx_.length; ++i)
          {
            for(j = 0; j < colCount_; j+= measures.length)
            {
              ctx_[i][j].path.mg = measures[0].ctx.path.mg;
              ctx_[i][j].path.mi = measures[0].ctx.path.mi;    
              for(k = 1; k < measures.length; ++k)
              {
                ctx_[i].splice(j + k, 0, cloneOneContext(ctx_[i][j]));
                ctx_[i][j + k].path.mg = measures[k].ctx.path.mg;
                ctx_[i][j + k].path.mi = measures[k].ctx.path.mi;
              }
            }
          }
        }
        return;
      }
      else {

        //expand value first; 
        for(i = 1; i < measures.length; ++i)
        {
          for(j = 0; j < dimNums; ++j)
          {
            for(k = 0; k < count; ++k)
            {
              element = {
                'val': dimVals[j].rows[k].val,
                'info': dimVals[j].rows[k].info
              };
              dimVals[j].rows.push(element);
            }
          }
        }

        //add 
        for(j = 0; j < measures.length; ++j)
        {
          for(i = 0; i < count; ++i)
          {
            element =  {'val': measures[j].val};
            row.rows.push(element);
          }
        }
        dimVals.splice(0, 0, row);
        if(bMNDInRow)
        {
          rowCount_ *= measures.length;
          expendContexts(measures.length - 1);
          for(i = 0; i < rowCount_; ++i)
          {
            addMeasureContext(ctx_[i], measures[rowCount_ % measures.length].ctx);
          }
        }else{
          colCount_ *= measures.length;

          for(i = 0; i < ctx_.length; ++i)
          {
            var rows = [];
            addMeasureContext(ctx_[i], measures[0].ctx);
            for(j = 1; j < measures.length; ++j)
            {
              var addedRow = cloneOneRowContext(i);
              addMeasureContext(addedRow, measures[0].ctx);
              rows = rows.concat(cloneOneRowContext(i));
            }
            ctx_[i] = ctx_[i].concat(rows);
          }
        }
      }
    }
    
    function buildRowDimension(dimInRow, startIndex, rowIndexs){

      var rowDimVals = rowDimension_.values;
      var i = 0;
      for(i = 0; i < dimInRow; ++i)
      {
        var element = {};
        element.col = data_.values[startIndex + i].col;
        element.rows = [];
        element.rows[0] = {
          'val': data_.values[startIndex + i].rows[0].val,
          'info': data_.values[startIndex + i].rows[0].info
        };
        rowDimVals.push(element);
      }
      for (i = 1; i < data_.values[startIndex].rows.length; ++i)
      {
        if (compare(i, i - 1, startIndex, dimInRow)){
          rowIndexs[i] = rowCount_;
        }else {  
          ++rowCount_;
          for(var j = 0; j < dimInRow; j++)
          {
            rowDimVals[j].rows[rowCount_] = {
              'val': data_.values[startIndex + j].rows[i].val,
              'info': data_.values[startIndex + j].rows[i].info
            };
          }
          rowIndexs[i] = rowCount_;
        }
      }
      ++rowCount_;
    }
    
    // Mix MND and dimension case
    function processDimsWithMeasure()
    {
      var startIndex = 0,
        endIndex = data_.values.length;
      var dimInRow = dimInRow_,
        dimInCol = dimInCol_;
      var bMNDInner = false,
        bMNDInRow = true;
      var i;
      if(data_.values[0].type === "MND")
      {
        ++startIndex;
        if(dimInRow > 0){ 
          --dimInRow;
        } else {
          --dimInCol;
          bMNDInRow = false;
        }
      }

      if(data_.values[endIndex - 1].type === "MND")
      {
        bMNDInner = true;
        --endIndex;
        if(dimInCol > 0)
        {
          --dimInCol;
          bMNDInRow = false;
        }else{
          bMNDInRow = true;
          --dimInRow;
        }
      }

      //process no MND cases first
      if(startIndex < endIndex)
      {
        //some dimension in row and some in column 
        var rowIndexs = [];
        if(dimInCol > 0 || dimInRow > 0)
        {
          //process row dimension first
          rowIndexs[0] = 0;
          rowCount_ = 0;
          if(dimInRow > 0)
          {
            buildRowDimension(dimInRow, startIndex, rowIndexs);
          }else{
            rowCount_ = 1;
            for(i = 1; i < data_.values[startIndex].rows.length; ++i){
              rowIndexs[i] = 0;
            }
          }
          
          //build column dimensions and indexes
          var colIndexs = [];
          if(dimInCol > 0)
          {
            colIndexs = processColHeader(startIndex + dimInRow, dimInCol);
          }else{
            colCount_ = 1;
            for(i = 0; i < data_.values[startIndex].rows.length; ++i){
              colIndexs[i] = 0;
            }
          }
          
          //generate data context for each sub chart
          ctx_ = new Array(rowCount_);
          for(i = 0; i < rowCount_; ++i)
          {
            ctx_[i] = [];
            for(var j = 0; j < colCount_; ++j){
              ctx_[i][j] = null;
            }
          }

          for(i = 0 ; i < data_.values[startIndex].rows.length; ++i)
          {
            ctx_[rowIndexs[i]][colIndexs[i]] = data_.values[startIndex + dimInRow + dimInCol - 1].rows[i].ctx;
          }
        }
        
        //process measure names at last
        if(dimInRow < dimInRow_ || dimInCol < dimInCol_)
        {
          addMND(bMNDInner, bMNDInRow, dimInRow, dimInCol);
        }
      }
    }

    my.process = function()
    {
      initilize();
      if(!data_ || !data_.values || data_.values.length === 0) {return;}
      dimInCol_ =  props_ && props_["numberOfDimensionsInColumn"] !== undefined ?  props_["numberOfDimensionsInColumn"] : 1;
      if(!dimInCol_ || dimInCol_ < 0) { dimInCol_ = 0;}
      if(dimInCol_ > data_.values.length) {dimInCol_ = data_.values.length;}
      dimInRow_ = data_.values.length - dimInCol_;
      if(dimInRow_ < 0){ dimInRow_ = 0;}

      if(data_.values.length === 1 && data_.values[0].type === "MND")
      {
        buildIndexMeasuresOnly();
      }else{
        processDimsWithMeasure();
      }
    };

    return my;

  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.tablecontainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.DimensionalInfoHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.MultiChartDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup ( TypeUtils, Objects, Functions, layout, DIHandler, MCHandler, Manifest, MultiAxesDataAdapter,dispatch, boundUtil) {
  
  var retfn =  function (manifest, ctx) {
    var width = 0, 
        height = 0,
        centerWidth = 0, //size for the real table area without table headers
        centerHeight = 0, 
        properties = {},
        //for containers we use properties to hold any properties we have to pass to sub
        //then we use this internalProps to hold properties for container itself
        internalProps = manifest.props(null),
        internalRange = {}, //used for data range merge
        multiData = {
          
        },//used to save raw data process result
        subModuleNames = [], //used to update sub modules while data updating
        subControllerNames = [], //used to update controllers while data updating  
        data = null,
        config = {},
        modules = {},
        selections = {},
        parent = null, // a d3 selection
        rows = 3,
        columns = 2,
        xCategoryScale = d3.scale.ordinal(),
        yCategoryScale = d3.scale.ordinal(),
        eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), avaPlotCount = 0, avaModulesCount = 0;
    
    //for container, we won't extract properties exactly for it. so we have to
    //get property by ourselves. the property category should be consistent with
    //module definition
    var PROPERTYCATEGORY = 'multiLayout';
    
    function load(moduleId) {
      return Manifest.module.get(moduleId).execute(ctx);
    }
    
    function initialize() {
      if ( TypeUtils.isEmptyObject(config) ) {
        Functions.error('Container configuration missing');
      }
      
      processRawData();
      avaPlotCount = 0, avaModulesCount = 0;
      //Jimmy/9/13/2012 we only support yAxis and xAxis2 for now, the other two won't be initialized
      initAxis(config, 'xAxis', multiData.columnData);
      initAxis(config, 'yAxis', multiData.rowData);
      initAxis(config, 'xAxis2', multiData.columnData);
      initAxis(config, 'yAxis2', multiData.rowData);
      
      initializePlots();
      updateProperties("plot");
      updateProperties("xAxis2");
      updateProperties("yAxis");        
      updatePlotData();
      initializePlotElements();
      
      avaModulesCount = avaModulesCount + avaPlotCount;
    }
    
    function processRawData() {
      delete multiData.contexts;
      delete multiData.columnData;
      delete multiData.rowData;
      delete multiData.dataHandler;
      //get dimensional info
      //FIXME jimmy/8/8/2012, we assume to use dimensional layout by default
      //we may need support other layouts
      //FIXME jimmy/8/8/2012, how to know which feed is for multiplier?
      var dih = DIHandler({
        'numberOfDimensionsInColumn' : internalProps.numberOfDimensionsInColumn
      }, data.getAnalysisAxisDataByIdx(0));//data['sap.viz.multiplier']);
      
      dih.process();
      
      var rowD = dih.getRowDimensionData();
      var columnD = dih.getColumnDimensionData();
      var contexts = dih.getContexts();
      rows = contexts.length;
      columns = rows > 0 ? contexts[0].length : columns;
      
      var columnData = new MultiAxesDataAdapter();
      columnData.addAnalysisAxis({key:columnData.key, index : 0, values: columnD.values});
      var rowData = new MultiAxesDataAdapter();
      rowData.addAnalysisAxis({key:rowD.key, index : 0, values: rowD.values});
      
      multiData.contexts = contexts;
      multiData.columnData = columnData;
      multiData.rowData = rowData;
      multiData.dataHandler = new MCHandler(data);
    }
    
    function initAxis( config, id , axisData) {
      if ( !config.modules[id] ) {
        return;
      }
      
      var axisConfig = config.modules[id],
          axis = modules[id] = load(axisConfig.id); // Saves references to axis function.
      
      updateAxisData(id, axisData);
          
      var props = {}, usrProps, sysProps;
      if ( axisConfig.configure ) {
        usrProps = properties[axisConfig.configure.propertyCategory] || {};
        sysProps = axisConfig.configure.properties || {};
        Objects.extend( true, props, sysProps, usrProps );
        axis.properties(props);
      }
      
      if(axis.dispatch && axis.dispatch()['initialized']){
        avaModulesCount++;
        axis.dispatch().on('initialized.tablecontainer', initialized);
      }
      
      selections[id] = parent.append('g').attr('class', id);
    }
    
    function updateAxisData (id, axisData) {
      if(modules[id]){
        modules[id].data(axisData);
      }
    }
    
    function initializePlots() {
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) {
        return;
      }
      
      cleanSubControllers();
      cleanSubModules();

      //we will create multi plot here
      var contexts = multiData.contexts;
      var plots = modules.plot = [];
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          //contexts returned from dimensionalInfoHandler is rows*column
          var ctxI = contexts[rowI][colI];
          //[Jimmy/8/28/2012]we won't create sub plots when ctxI is undefined. but do we need
          //filter them out of the array? currently we will still have the full-size array with
          //some of them undefined. other parts who need read them should pay attention to (like
          //dependency resolving, and controller etc.)
          if(ctxI){
            
            var i = colI * rows + rowI;
            var plotI = plots[i] = load(plotConfig.id);
            plotI.config(plotConfig);

            if(plotI.dispatch){
              avaPlotCount++;
              var dis =  plotI.dispatch();
                 if(dis.initialized) {
                   dis.on('initialized.tablecontainer', initialized);
                 }
                 if(dis.showTooltip) {
                   dis.on('showTooltip.tablecontainer', showTooltip);
                 }
                 if(dis.hideTooltip) {
                   dis.on('hideTooltip.tablecontainer', hideTooltip);
                 }
            }
            
          }
        }
      }
    }
    
    function updatePlotProperties() {
      var plots = modules.plot;
      if(plots){
        var plotConfig = config.modules.plot;
        if ( !plotConfig ) {
          return;
        }
        //Jimmy/8/23/2012 pay attention to the property structure, for container we will pass
        //all properties instead of properties under propsCat only.
        //FIXME currently it's hard coded here we assume the plot is container, actually we should
        //check the plot type
        var props = null, usrProps, sysProps;
        var nodeConfig = plotConfig.configure;
        if ( nodeConfig ) {
          sysProps = {};
          if ( nodeConfig.propertyCategory ) {
            sysProps[nodeConfig.propertyCategory]  = nodeConfig.properties;
          }
          usrProps = properties;
          props = {};
          Objects.extend( true, props, sysProps, usrProps ); 
        }else{
          props = properties;
        }
        
        for(var i = 0, len = plots.length; i < len; i++){
          if(props && plots[i]){
            plots[i].properties(props);
          }
        }
      }
    }
    //TO FIX: remove this work around.
    function updateProperties(moduleId){
      if (moduleId === 'plot'){
        updatePlotProperties();
      }
      else{
        var module = modules[moduleId];
        if(module){
          var moduleConfig = config.modules[moduleId];
          if ( !moduleConfig ) {
            return;
          }
          var props;
          var nodeConfig = moduleConfig.configure;
          if ( nodeConfig ) {
            props = Objects.extend(true, {}, properties[ nodeConfig.propertyCategory ]);
          }else{
            props = properties;
          }
         module.properties(props); 
        }
      }
    }
    
    function updatePlotData() {
      var dataHandler = multiData.dataHandler;
      var contexts = multiData.contexts;
      var plots = modules.plot;
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          //contexts returned from dimensionalInfoHandler is rows*column
          var ctxI = contexts[rowI][colI];
          if(ctxI){
            var i = colI * rows + rowI;
            var dataI = dataHandler.getSubDataAdapter(ctxI);
            if(plots[i]){
              plots[i].data(dataI);
            }  
          }
        }
      }
    }
    
    function initializePlotElements() {
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) {
        return;
      }
           
      var plots = modules.plot;
      var splots = selections.plot = [];
      if(selections.plotRoot){
        selections.plotRoot.remove();
      }
      var plotRoot = selections.plotRoot = parent.append('g').attr('class', 'plot');
      
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          var i = colI * rows + rowI;
          if(plots[i]){
            var plotI = plots[i];
            
            //create svg elements
            splots[i] = plotRoot.append('g').attr('class', 'plot' + i);
            plotI.parent(splots[i]);
            
            if(plotI.modules){
              var subModules = plotI.modules();
              var sname;
              for ( var m in subModules ){
                if ( subModules.hasOwnProperty(m) ){
                  sname = 'plot[' + i + ']' + '.' + m;
                  subModuleNames.push(sname);
                  modules['plot[' + i + ']' + '.' + m] = subModules[m];
                }
              }  
            }
            
             //Jimmy/8/22/2012 we introduce controller module which can be configured to any module (except controller module of course)
            //as for now, we only add the support to container. TODO
           
            var nodeController = plotConfig.controllers;
            if(nodeController){
              for(var nc in nodeController){
                if(nodeController.hasOwnProperty(nc)){
                  var controllerConfig = nodeController[nc];
                  var controller = load(controllerConfig.id);
                  controller().module(plotI);
                  var props = {};
                  var propsCat = controllerConfig.propertyCategory;
                  var usrProps = properties[ propsCat ];
                  var sysProps = controllerConfig.properties;
                  Objects.extend( true, props, sysProps, usrProps );
                  controller.properties(props);
                  subControllerNames.push('plot[' + i + ']' + '.' + nc);
                  modules['plot[' + i + ']' + '.' + nc] = controller;
                }
              }
            }
          }
        }
      }
    }
    
    function cleanSubControllers() {
      //clean all current submodules
      for(var i = 0, len = subControllerNames.length; i < len; i++){
        delete modules[subControllerNames[i]];
      }
      subControllerNames = [];
    }
    
    function cleanSubModules () {
      //clean all current submodules
      for(var i = 0, len = subModuleNames.length; i < len; i++){
        delete modules[subModuleNames[i]];
      }
      subModuleNames = [];
    }

    function relayout() {
      if ( TypeUtils.isEmptyObject(modules) || !width || !height ) {
        return;
      }
      
      var prefs = {};
      if ( modules.xAxis ) {
          modules.xAxis.drawable(true);
          prefs.south = { size : modules.xAxis.getPreferredSize() };
      }
      if ( modules.yAxis ) {
          modules.yAxis.drawable(true);
          prefs.west = { size : modules.yAxis.getPreferredSize() };
      }
      if ( modules.xAxis2 ) {
          modules.xAxis2.drawable(true);
          prefs.north = { size : modules.xAxis2.getPreferredSize() };
      }
      if ( modules.yAxis2 ) {
          modules.yAxis2.drawable(true);
          prefs.east = { size : modules.yAxis2.getPreferredSize() };
      }
      if ( modules.plot ) {
        prefs.center = {};
      }
      
      var solution = layout({
        type : 'border',
        bias : 'none',
        size : { width : width, height : height },
        prefs : prefs
      });
      
      centerWidth = solution.center.bounds.width;
      centerHeight = solution.center.bounds.height;
      
      //JIMMY/8/8/2012, WHY WE NEED DO THIS HERE?
      //the first time layout, we haven't set scale to axis (as dependency resolve happens after
       // the first layout), so the preferred size we get from axis is 0. then during dependency
       //resolving, we return scale to axis based on this inaccurate preferred size.
       
       //then during rendering, we will do layout again, this time we get a new preferred size from
       //axis as axis has scale now. but with this new preferred size, the scale has also to be updated,
       //but we won't do dependency resolving anymore. so we have to update the scale here. as axis
       //has the same reference of the scale, it can also get the new scale value.
       
       //so the preferred size returned by axis is actually based on the old scale and thus inaccurate. why
       //it doesn't affect the rendering result? for horizontal axis, the scale only matters the width of the axis
       //which we don't care, we only care height for horizontal axis. for vertical axis, the scale only matters
       //the height of the axis while we only care the width of it during layout.
       
       //so that's why we need layout again before rendering. we want to get the preferredsize from axis
       //even with a wrong scale. if axis can return preferredsize without scale (it's only possible for one
       //direction which is exactly we care during layout), we don't need do this.  
      xCategoryScale.rangeBands([0, centerWidth]);
      yCategoryScale.rangeBands([0, centerHeight]);
      
      if ( solution.north ) {
        // Modifies xAxis width and coordinate to handle horizontal offset
        // to ensure joints with yAxis.
        var xAxis2Width = 0, xAxis2X = 0;
        if ( solution.west ) {
          xAxis2Width = solution.north.bounds.width - solution.west.bounds.width;
          xAxis2X = solution.north.bounds.x + solution.west.bounds.width;
        }
        if ( solution.east ) {
          xAxis2Width = solution.north.bounds.width - solution.east.bounds.width;
        }
        
        selections.xAxis2.attr('transform', 
          'translate(' + xAxis2X + ',' + solution.north.bounds.y + ')');
        
        modules.xAxis2
          .width(xAxis2Width)
          .height(solution.north.bounds.height);
      
        modules.xAxis2.gridlineLength(solution.center.bounds.height);  
      } else if (modules.xAxis2) {
          modules.xAxis2.drawable(false);
      }
      
      if ( solution.east ) {
        selections.yAxis2.attr('transform', 
          'translate(' + solution.east.bounds.x + 
          ',' + solution.east.bounds.y + ')');
        modules.yAxis2
          .width(solution.east.bounds.width)
          .height(solution.east.bounds.height);
          
        modules.yAxis2.gridlineLength(solution.center.bounds.width);    
      } else if (modules.yAxis2) {
          modules.yAxis2.drawable(false);
      }
      
      if ( solution.south ) {
        // Modifies xAxis width and coordinate to handle horizontal offset
        // to ensure joints with yAxis.
        var xAxisWidth = 0, xAxisX = 0;
        if ( solution.west ) {
          xAxisWidth = solution.south.bounds.width - solution.west.bounds.width;
          xAxisX = solution.south.bounds.x + solution.west.bounds.width;
        }
        if ( solution.east ){
          xAxisWidth = solution.south.bounds.width - solution.east.bounds.width;
        }
        
        selections.xAxis.attr('transform', 
          'translate(' + xAxisX + ',' + solution.south.bounds.y + ')');
        
        modules.xAxis
          .width(xAxisWidth)
          .height(solution.south.bounds.height);

        modules.xAxis.gridlineLength(solution.center.bounds.height);
      } else if (modules.xAxis) {
          modules.xAxis.drawable(false);
      }
      
      if ( solution.west ) {
        selections.yAxis.attr('transform', 
          'translate(' + solution.west.bounds.x + 
          ',' + solution.west.bounds.y + ')');
        modules.yAxis
          .width(solution.west.bounds.width)
          .height(solution.west.bounds.height);
      
        modules.yAxis.gridlineLength(solution.center.bounds.width);       
      } else if (modules.yAxis) {
          modules.yAxis.drawable(false);
      }
      
      if ( solution.center ) {
        selections.plotRoot.attr('transform', 
          'translate(' + solution.center.bounds.x + 
          ',' + solution.center.bounds.y + ')');
          
        var centersolution = layout({
          type : 'table',
          bias : 'none',
          size : { width : solution.center.bounds.width, height : solution.center.bounds.height },
          columns : columns,
          rows : rows,
          cellpadding : internalProps.cellPadding,
          paddingThreshold : internalProps.paddingThreshold
        });
        
        for(var colI = 0; colI < columns; colI++){
          for(var rowI = 0; rowI < rows; rowI++){
            var plotI = modules.plot[colI * rows + rowI];
            if(plotI){
              var csi = centersolution[colI][rowI];
              var splotI = selections.plot[colI * rows + rowI];
              plotI.width(csi.bounds.width).height(csi.bounds.height);
              splotI.attr('transform', 
                  'translate(' + csi.bounds.x + 
                  ',' + csi.bounds.y + ')');
            }
          }
        }
      }
    }
    
    
    function dataRange(type) {
        return function(range) {
            if (!arguments.length) {
                return internalRange[type];
            } else {
                if (!internalRange[type]) {
                    internalRange[type] = range;
                } else {
                    var currentRange = internalRange[type];
                    if (range.distinctValuesObj) {
                        for (var i in range.distinctValuesObj) {
                            if (range.distinctValuesObj.hasOwnProperty(i)){
                              currentRange.distinctValuesObj[i] = range.distinctValuesObj[i];
                            }
                        }
                    }
                    
                    if (range.min < currentRange.min) {
                        currentRange.min = range.min;
                    }
                    if (range.max > currentRange.max) {
                        currentRange.max = range.max;
                    }
                    
                    if (range.hasNoValue) {
                      currentRange.hasNoValue = true;
                    }

                }
            }
        };
    }

    
    function resolveMergeDataRange (types){
      //for each type we will generate a function to set/get data range
      for(var i = 0, len = types.length; i < len; i++){
        container[types[i] + 'DataRange'] = dataRange(types[i]);
      }
    }
    
    function parseProperties (props){
      properties = props;
      if(props[PROPERTYCATEGORY]){
        if(props[PROPERTYCATEGORY].mergeDataRange){
          internalProps.mergeDataRange = props[PROPERTYCATEGORY].mergeDataRange;
          resolveMergeDataRange(internalProps.mergeDataRange);
        }
        var formerDimsInCol = internalProps.numberOfDimensionsInColumn;
        Objects.extend(true, internalProps, props[PROPERTYCATEGORY]);
        if (modules.plot && formerDimsInCol !== internalProps.numberOfDimensionsInColumn){
          processRawData();
          internalRange = {};
          updateAxisData('xAxis', multiData.columnData);
          updateAxisData('yAxis', multiData.rowData);
          updateAxisData('xAxis2', multiData.columnData);
          updateAxisData('yAxis2', multiData.rowData);
          updatePlotData();
          relayout();
        }
      }
    }
    
    function buildXCateScale(){
      var domain = [];
      for (var i = 0; i < columns; i++){
         domain.push(i);
      }
      var xAxis = modules.xAxis ? modules.xAxis : modules.xAxis2;
      xCategoryScale.domain(domain).rangeBands([0, centerWidth]);
    }
    
    function buildYCateScale(){
      var domain = [];
      for (var i = 0; i < rows; i++){
         domain.push(i);
      }
      var yAxis = modules.yAxis ? modules.yAxis : modules.yAxis2;
      yCategoryScale.domain(domain).rangeBands([0, centerHeight]);
    }

    function container( selection ) {
      selection.each(function ( data ) {
        parent = selection;
        boundUtil.drawBound(selection, width, height);
        if ( TypeUtils.isEmptyObject(modules) ){ 
          initialize();
        }
        render();
      });
      return container;
    }
    
    container.width = function (_) {
      if ( !arguments.length ) {
        return width;
      }
      width = _;
      //Jimmy,8/20/2012, as a container, you don't know whether your
      //sub elements need relayout even if the container size remains
      //the same. so here we just give a chance to sub elements to relayout
      relayout();
      return container;
    };
    
    container.height = function (_) {
      if ( !arguments.length ) {
        return height;
      }
      height = _;
      //see @width
      relayout();
      return container;
    };
    
    container.size = function(_) {
      if ( !arguments.length ) {
        return {
          'width' : width,
          'height' : height
        };
      }
      height = _.height;
      width = _.width;
      //see @width
      relayout();
      return container;
    };
    
    container.data = function (_) {
      if ( !arguments.length ) {
        return data;
      }
      data = _;
      
      //clean internal data range
      for(var i in internalRange){
        if(internalRange.hasOwnProperty(i)){
          delete internalRange[i];
        }
      }
      
      if(!TypeUtils.isEmptyObject(modules)){
        processRawData();

        avaModulesCount = avaModulesCount - avaPlotCount;
       
        updateAxisData('xAxis', multiData.columnData);
        updateAxisData('yAxis', multiData.rowData);
        updateAxisData('xAxis2', multiData.columnData);
        updateAxisData('yAxis2', multiData.rowData);
        
        avaPlotCount = 0;
        //Jimmy/9/13/2012 we may have chance to split data update and data
        //schema update in the future
        initializePlots();
        updateProperties("plot");
        updateProperties("xAxis2");
        updateProperties("yAxis");        
        updatePlotData();
        initializePlotElements();
        
        avaModulesCount = avaModulesCount + avaPlotCount;
      }
      return container;
    };
    
    container.properties = function (_) {
      if ( !arguments.length ) {
        return internalProps;
      }
      //FIXME JIMMY/8/8/2012, columns/rows may be different with different properties
      parseProperties(_);
      //update properties of sub plots
      if(!TypeUtils.isEmptyObject(modules)){
        //Jimmy/9/19/2012, we may need deal with internalProps.numberOfDimensionsInColumn update
        //we don't need recreate plots but we need rearrange plots and change data
        updateProperties("plot");
        updateProperties("xAxis2");
        updateProperties("yAxis");        
      }
      return container;
    };
    
    container.config = function (_) {
      if ( !arguments.length ) {
        return config;
      }
      config = _;
      return container;
    };
    
    container.xCategoryScale = function (_) {
      if ( !arguments.length ) {
        buildXCateScale();
        return xCategoryScale;
      }
      xCategoryScale = _;
      return container;
    };
    
    container.yCategoryScale = function (_) {
      if ( !arguments.length ) {
        buildYCateScale();
        return yCategoryScale;
      }
      yCategoryScale = _;
      return container;
    };
    
    container.modules = function (_) {
      if ( !arguments.length ) {
        if ( TypeUtils.isEmptyObject(modules) ) {
          initialize();
        } 
        return modules;
      }
      modules = _;
      return container;
    };
    
    container.parent = function (_) {
      if ( !arguments.length ) {
        return parent;
      }
      parent = _;
      return container;
    };
    
    container.dispatch = function(_){
      if( !arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return container;
    };

    container.infoForSizeLegend = function() {
      var plot;
      for ( var i = -1, j = modules.plot.length; ++i < j;) {
        plot = modules.plot[i];
        if (plot){
          break;
        }
      }
      return {
        space : plot ? (width - centerWidth + plot.infoForSizeLegend().space * columns) : 0,
        number : columns,
        plotHeight : plot ? plot.height() : 0
      };
    };
    
    container.plotRegion = function () {
      return {
        selection: selections.plotRoot,
        width: centerWidth,
        height: centerHeight
      };
    };
    
    function renderAxis (id){
      if(selections[id]){
        parent.select('.' + id).datum(modules[id].data()).call(modules[id]);
      }
    }
    
    function render() {
      renderAxis('xAxis');
      renderAxis('xAxis2');
      renderAxis('yAxis');
      renderAxis('yAxis2');
      
      if(selections.plot){
        for(var i = 0, len = selections.plot.length; i < len; i++){
          if(selections.plot[i]){
            selections.plot[i].datum(modules.plot[i].data()).call(modules.plot[i]);
          }
        }
      }
    }
    
    var initializedPlots = 0;
    function initialized(){
      if(++initializedPlots === avaModulesCount){
        initializedPlots = 0;
        eDispatch.initialized();
      }
    }
    
    function showTooltip(evt){
      eDispatch.showTooltip(evt);
    }
    
    function hideTooltip(evt){
      eDispatch.hideTooltip(evt);
    }
    
    return container;
  };
  
  return retfn;
  
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tablecontainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, moduleConstants, fn, feedConstants, Constants) {
    var multiplierFeed = {
    'id' : 'multiplier',
    'name' : 'Chart Multiplier',
    'type' : feedConstants.Type.Dimension,
    'min' : 1,
    'max' : 1,
    'aaIndex' : 1,
    'acceptMND' : 0
  };

  var module = {
    'id' : 'sap.viz.modules.tablecontainer',
    'type' : moduleConstants.Type.Container,
    'name' : 'table container',
    'description': 'Settings for the subcharts layout of multiple charts.',
    //TODO support different layout: row/column/dimensional
    'properties' : {
      'mergeDataRange' : {
        'name' : 'mergeDataRange',
        'supportedValueType' : 'List',
        'supportedValues' : ['ANY DATA RANGE NAME'],
        'defaultValue' : null,
        'description' : 'Set mergeDataRange. Specify names of data range you want to merge, we will generate corresponding functions in this module to do the real merge. for example, if \'primary\' and \'second\' are specified here, two functions will be generated: \'primaryDataRange\' and \'secondDataRange\'. the function name is the range name plus \'DataRange\'. these generated functions support both getter and setter, for setter, you can pass any number of ranges {min:NUM, max:NUM} to it to merge, then you can get the merged result through the getter.',
        'isExported' : false
      },
      'numberOfDimensionsInColumn' : {
        'name' : 'numberOfDimensionsInColumn',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 1,
        'description' : 'Set the specified number of dimensions, retrieved from the end of the dimension list in multiplier, will be put in column when doing multiple layout.'
      },
      'cellPadding' : {
        'name' : 'cellPadding',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 15,
        'description' : 'Set padding between cells of sub plots. If cellPadding value exceeds containerSize * threshold, we set it to 0.'
      },
      'paddingThreshold' : {
        'name' : 'paddingThreshold',
        'supportedValueType' : 'Number',
        'defaultValue' : 0.2,
        'description' : 'Set paddingThreshold, if cellPadding value exceeds the containerSize * threshold, we set it to 0.',
        'isExported' : false
      }
    },
  'events' : {
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
   },
    //TODO
    'css' : null,
    'feeds' : [multiplierFeed],
    'fn' : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.xycontainer',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.xycontainer',
    'type' : Constants.Module.Type.Container,
    'name' : 'single container',
    'properties' : null,
    'css' : null,
    'configure' : null,
    'events' : {
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.datalabel',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
}
],
function Setup(TextUtils, TypeUtils, formatManager, Manifest,Objects){
    var dataLabel = function(manifest, ctx){
      var fontSize = '12px', fontColor = '#333333', fontFamily = '"Open Sans" Arial, Helvetica, sans-serif', fontWeight = 'normal';
      var properties = manifest.props(null);
      var dataLabel,                      // labels of each datashapesgroup
          dataLabels,                     // all labels, it must be two-dimension array
          originalLabels;                 // used for smartLayout, it must be one-dimension array
      var gPlot, parentNodeBBox;
      var labelStyle;
      var _SVGRoot;
      
      /*
       * Properties that needed for different charts.
       * Data label is designed as a general module, but different charts do have different requirements. Most of these properties are used for this reason.
       */
      var labelOrientation = 'horizontal',  // label can be horizontal or vertical
          orientation,                      // chart orientation, it is used during smart layout. if it is vertical, the move is from middle to top or bottom; if it is horizontal, the move is from middle to left or right.
          paintingMode,                     // the kind of coordinate system
          visible,                          // show or hide data label
          position,                         // data label can be inside or outside
          automaticInOutside,               // if the data label is longer than its owner element, move label out of it.
          formatString, isPercentMode, isStackMode, showZero, outsideVisible, outsidePosition, positionPreference,
          isGeoChart,     
          type;                             // label type, for now, two types, 1, value 2 label and value
      var isDonut = false;
      var heatMapLabelFontColor = '#ffffff', isHeatMap = false, isOneCategoryHeatmap = false, padding = 2, isTreeMap = false, treeMapLabelFontColor = '#ffffff';

      function label (){}
      
      label.removeLabel = function(){
        if(TypeUtils.isExist( gPlot.parent())){
          gPlot.parent().selectAll('g.datalabel').remove();
        }
      };
      
      /**
       * [08-Jan-2012 Nick]
       */
      label.showLabel = function(){
        if(visible && gPlot.parent()){
          getCSSSetting();
          gPlot.parent().selectAll('g.datalabel').remove();
          parentNodeBBox = gPlot.parent().node().getBoundingClientRect();
          prepareLabel();
          if(dataLabel.length === 0){
            return;
          }
          if (isHeatMap) {
            fontColor = heatMapLabelFontColor;
          } else if (isTreeMap) {
            fontColor = treeMapLabelFontColor;
          }
          labelStyle = 'fill:' + fontColor + '; font-family: ' + fontFamily + '; font-weight: ' + fontWeight +'; font-size: '+ fontSize +"; text-anchor:start";
          var datashapesgroups = gPlot.parent().selectAll('.datashapesgroup');
              datashapesgroups.each(function(d,i){
                var labelGroup =  d3.select(this).selectAll('g.datalabel').data([dataLabels[i]]);
                    labelGroup.enter().append('g').attr('class','datalabel');
                    labelGroup.each(function(labels, index){
                      var dLabel = d3.select(this).selectAll('text.datalabel').data(labels);
                      var text = dLabel.enter().append('g')
                                   .attr('transform',function(label){
                                       return label.transformString;
                                   });
                      text.each(function(d, i){
                        //we can also find main shape through data
                        var currd = gPlot.parent().selectAll('.datapoint').data()[i];
                        //register decoration to main shape
                        if(TypeUtils.isExist(currd.decoras)){
                          currd.decoras.push(this);
                        }
                      });
                      text = text.append('text');
                      text.text(function(d) {
                        return d.value;
                      });
                      text.attr('class','datalabel').attr('visibility', 'hidden');
                      text.attr('fill', fontColor)
                          .attr('x', function(d){
                            return d.x;
                          })
                          .attr('style',labelStyle)
                          .attr('y', function (d) {
                            return d.y;
                          });
                   
                      if(labelOrientation === 'vertical'){
                        text.attr('transform',function(d){
                          return 'rotate(270 '+d.centerX + ',' + d.centerY + ')';
                        });
                      }
                      
                    });
              });
              smartLayout();
        }
      };
      
      function smartLayout() {
        var gElements = gPlot.parent().selectAll('text.datalabel')[0];//gPlot.parent().selectAll('rect.viz-event-sub-layer')[0][0].getBoundingClientRect();
        var labels = [], label, plotArea = {};
        var i;
        for (i = 0; i < gElements.length; i++) {
          label = {};
          var elementBBox = gElements[i].getBoundingClientRect();
          label.top = elementBBox.top; //- parentNodeBBox.top;
          label.left = elementBBox.left; //- parentNodeBBox.left;
          label.right = elementBBox.right; //- parentNodeBBox.left;
          label.bottom = elementBBox.bottom; //- parentNodeBBox.top;
          label.visible = true;
          label.needMove = false;
          label.x = 0;
          label.y = 0;
          labels.push(label);
        }
        
        plotArea.top = parentNodeBBox.top;
        plotArea.left = parentNodeBBox.left;
        plotArea.right = parentNodeBBox.right;
        plotArea.bottom = parentNodeBBox.bottom;
        
        automaticLayout(originalLabels, labels, plotArea);
        removeUnqualifiedLabels(labels, plotArea);
        
        for (i = 0; i < labels.length; i++) {
          if (labels[i].visible) {
            if (labels[i].needMove) {
              gElements[i].setAttribute('x', labels[i].x);
              gElements[i].setAttribute('y', labels[i].y);
            }
            gElements[i].setAttribute('visibility', 'visible');
          } else {
            gElements[i].parentNode.parentNode.removeChild(gElements[i].parentNode);
          }
        }
      }
      
      function getCSSSetting() {
        var dataLabelStyle = ctx.styleManager.query('viz-datalabel');
        if(dataLabelStyle){
          if(dataLabelStyle['fill']){
            fontColor = dataLabelStyle['fill'];
          }
          if(dataLabelStyle['font-family']){
            fontFamily = dataLabelStyle['font-family'];
          }
          if(dataLabelStyle['font-size']){
            fontSize = dataLabelStyle['font-size'];
          }
          if(dataLabelStyle['font-weight']){
            fontWeight = dataLabelStyle['font-weight'];
          }
//          labelStyle = 'fill:' + fontColor + '; font-family: ' + fontFamily + '; font-size: '+ fontSize +";";
        }
      }
      
      function formatDataLabel(value,dataPoint){
        if(TypeUtils.isExist(formatString)){
          var formatedValue, iFormatString, indexOfiFS, indexOfctx;
          //for bubble ,val is an array , datalebel will display y .so just format the y value.
          if(TypeUtils.isArray(dataPoint.__data__.val)){
            iFormatString = formatString[0];
            indexOfctx = isGeoChart ?  0 : 1;
            indexOfiFS = dataPoint.__data__.ctx[indexOfctx].path.mi >= iFormatString.length ? iFormatString.length -1 : dataPoint.__data__.ctx[indexOfctx].path.mi;
            formatedValue = formatManager.format(value, iFormatString[indexOfiFS]);
          }else{
            iFormatString = formatString[dataPoint.__data__.ctx.path.mg];
            //if this array is null of undefined, we will use default value
            if(TypeUtils.isExist(iFormatString)){
              indexOfiFS = dataPoint.__data__.ctx.path.mi >= iFormatString.length ? iFormatString.length -1 : dataPoint.__data__.ctx.path.mi;
              formatedValue = formatManager.format(value, iFormatString[indexOfiFS]);
            }else{
              formatedValue = value;
            }
          }
          return formatedValue;
        }
        return value;
      }

      
      
      var automaticLayout = function(srcLabels, desLabels, plotArea) {
        
        if (srcLabels !== null && desLabels !== null) {
          for (var i = 0; i < srcLabels.length; i++) {
            if (i < desLabels.length) {
              if (!isStackMode && !isPercentMode && automaticInOutside  && orientation === 'horizontal') {
                if (showZero && srcLabels[i].value === 0) {
                  var bbox1 = srcLabels[i].datapointRect;
//                  desLabels[i].xAdjust = true;
//                  desLabels[i].x = (srcLabels[i].ownerWidth > 0) ? srcLabels[i].ownerWidth : 1;
                  desLabels[i].needMove = true;
                  desLabels[i].x = srcLabels[i].outsideX;
                  desLabels[i].y = srcLabels[i].outsideY;
                  desLabels[i].left = bbox1.right;
                  desLabels[i].right = bbox1.right + srcLabels[i].width;
                } else if (position === 'inside') {
                  if (srcLabels[i].width > srcLabels[i].ownerWidth || isCrossBorder(desLabels[i], plotArea)) {
//                    desLabels[i].xAdjust = true;
                    desLabels[i].needMove = true;
                    desLabels[i].x = srcLabels[i].outsideX;
                    desLabels[i].y = srcLabels[i].outsideY;
                    var boundingBox1 = srcLabels[i].datapointRect; 
                    if (srcLabels[i].value > 0) {
//                      desLabels[i].x = srcLabels[i].ownerWidth;
                      desLabels[i].left = boundingBox1.left + srcLabels[i].ownerWidth;
                      desLabels[i].right = boundingBox1.right + srcLabels[i].width;
                    } else {
//                      desLabels[i].x = - srcLabels[i].width;
                      desLabels[i].left =  boundingBox1.left - srcLabels[i].width;
                      desLabels[i].right = boundingBox1.right - srcLabels[i].ownerWidth;
                    }
                  }
                  
                  if (isCrossBorder(desLabels[i], plotArea)) {
                    desLabels[i].visible = false;
                  }
                } else if (position === 'outside') {
                  if (isCrossBorder(desLabels[i], plotArea)) {
                    if (srcLabels[i].width <= srcLabels[i].ownerWidth) {
//                      desLabels[i].xAdjust = true;
                      desLabels[i].needMove = true;
                      desLabels[i].x = srcLabels[i].insideX;
                      desLabels[i].y = srcLabels[i].insideY;
                      var boundingBox2 = srcLabels[i].datapointRect;
                      if (srcLabels[i].value > 0) {
//                        desLabels[i].x = srcLabels[i].x - (srcLabels[i].ownerWidth + srcLabels[i].width) / 2;
                        desLabels[i].left = boundingBox2.left + (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;
                        desLabels[i].right = boundingBox2.right - (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;                      
                      } else {
//                        desLabels[i].x = (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;
                        desLabels[i].left = boundingBox2.left + (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;
                        desLabels[i].right = boundingBox2.right - (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;
                      }
                      
                      if (isCrossBorder(desLabels[i], plotArea)) {
                        desLabels[i].visible = false;
                      }
                    } else {
                      desLabels[i].visible = false;
                    }
                  }
                }
              } else if (!isStackMode && !isPercentMode && automaticInOutside && orientation === 'vertical') {
                if (showZero && srcLabels[i].value === 0) {
//                  desLabels[i].yAdjust = true;
//                  desLabels[i].y -= (srcLabels[i].ownerHeight > 0) ? srcLabels[i].ownerHeight : 1;
                  desLabels[i].needMove = true;
                  desLabels[i].x = srcLabels[i].outsideX;
                  desLabels[i].y = srcLabels[i].outsideY;  
                  var bbox2 = srcLabels[i].datapointRect;
                  desLabels[i].top = bbox2.top + srcLabels[i].height;
                  desLabels[i].bottom = bbox2.top;
                } else if (position === 'inside') {
                  if (srcLabels[i].height > srcLabels[i].ownerHeight || isCrossBorder(desLabels[i], plotArea)) {
//                    desLabels[i].yAdjust = true;
                    desLabels[i].needMove = true;
                    desLabels[i].x = srcLabels[i].outsideX;
                    desLabels[i].y = srcLabels[i].outsideY;
                    var boundingBox3 = srcLabels[i].datapointRect;
                    if (srcLabels[i].value >= 0) {
//                      desLabels[i].y = srcLabels[i].y - ((srcLabels[i].height - srcLabels[i].ownerHeight) / 2 + srcLabels[i].ownerHeight);
                      desLabels[i].top =  boundingBox3.top - srcLabels[i].height;
                      desLabels[i].bottom =  boundingBox3.bottom - srcLabels[i].ownerHeight;   
                    } else {
//                      desLabels[i].y = srcLabels[i].y + ((srcLabels[i].height - srcLabels[i].ownerHeight) / 2 + srcLabels[i].ownerHeight);
                      desLabels[i].top = boundingBox3.top + srcLabels[i].ownerHeight;
                      desLabels[i].bottom = boundingBox3.bottom + srcLabels[i].height;               
                    }
                  }
                  
                  if (isCrossBorder(desLabels[i], plotArea)) {
                    desLabels[i].visible = false;
                  }
                } else if (position === 'outside') {
                  if (isCrossBorder(desLabels[i], plotArea)) {
                    if (srcLabels[i].height <= srcLabels[i].ownerHeight) {
//                      desLabels[i].yAdjust = true;
                      desLabels[i].needMove = true;
                      desLabels[i].x = srcLabels[i].insideX;
                      desLabels[i].y = srcLabels[i].insideY;   
                      var boundingBox4 = srcLabels[i].datapointRect;
                      if (srcLabels[i].value > 0) {
//                        desLabels[i].y = srcLabels[i].y + (srcLabels[i].ownerHeight + srcLabels[i].height) / 2;
                        desLabels[i].top = boundingBox4.top + (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;
                        desLabels[i].bottom =  boundingBox4.bottom - (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;                      
                      } else {
//                        desLabels[i].y = srcLabels[i].y - (srcLabels[i].ownerHeight + srcLabels[i].height) / 2;
                        desLabels[i].top = boundingBox4.top + (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;
                        desLabels[i].bottom =  boundingBox4.bottom - (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;                     
                      }               
                      if (isCrossBorder(desLabels[i], plotArea)) {
                        desLabels[i].visible = false;
                      }
                    } else {
                      desLabels[i].visible = false;
                    }
                  }
                }
              } else if (!isStackMode && !isPercentMode && !automaticInOutside) {
                if (orientation === 'horizontal') {
                  if (showZero && srcLabels[i].value === 0 && !isGeoChart && srcLabels[i].width === 0) {
                    var bbox3 = srcLabels[i].datapointRect;
                    desLabels[i].left = bbox3.right;
                    desLabels[i].right = bbox3.right + srcLabels[i].width;
                  } else if (!outsideVisible && srcLabels[i].width > srcLabels[i].ownerWidth) {
                    desLabels[i].visible = false;
                  }
                  
                } else if (orientation === 'vertical') {
                  if (showZero && srcLabels[i].value === 0 && !isGeoChart && srcLabels[i].height === 0) {
                    var bbox4 = srcLabels[i].datapointRect;
                    desLabels[i].top = bbox4.top + srcLabels[i].height;
                    desLabels[i].bottom = bbox4.top;
                  } else if (!outsideVisible) {
                    if (isHeatMap || isTreeMap) {
                      if (isOneCategoryHeatmap || isTreeMap) {
                        if (srcLabels[i].height > srcLabels[i].ownerHeight/2) {
                          desLabels[i].visible = false;
                        }
                      } else {
                        if (srcLabels[i].height > srcLabels[i].ownerHeight) {
                          desLabels[i].visible = false;
                        }
                      }
                      
                      if (srcLabels[i].width > srcLabels[i].ownerWidth) {
                        desLabels[i].visible = false;
                      }
                    } else if (srcLabels[i].height > srcLabels[i].ownerHeight) {
                      desLabels[i].visible = false;
                    }
                  }
                }
                
                if (showZero && srcLabels[i].value === 0 && position === 'inside' && !isGeoChart) {
                  desLabels[i].needMove = true;
                  desLabels[i].x = srcLabels[i].outsideX;
                  desLabels[i].y = srcLabels[i].outsideY;
                } else if (!showZero && srcLabels[i].value === 0) {
                  desLabels[i].visible = false;
                }
 
                /**
                 * The following logic is for some case that 0 value is shown at X axis in Scatter chart.
                 * The data label bounding rectangle is in plot area in this case, so half of data label will be shown
                 *  at X axis. But the correct behavior is that value 0 is only shown at Y axis when data label is above
                 *  scatter point.
                 */
                if (!isHeatMap && !isTreeMap && paintingMode === 'rectCoordinate' && orientation === 'vertical' && outsidePosition === 'up') {
                  var bbox5 = srcLabels[i].datapointRect;
                  if ((bbox5.left === plotArea.left)) {
                    desLabels[i].visible = false;
                  }
                }
                
                if (isCrossBorder(desLabels[i], plotArea)) {
                  desLabels[i].visible = false;
                }
                
              } else if (isStackMode) {
                if (orientation === 'horizontal') {
                  if (isCrossBorder(desLabels[i], plotArea) || (srcLabels[i].width > srcLabels[i].ownerWidth) || srcLabels[i].value === 0) {
                    desLabels[i].visible = false;
                  }
                } else if (orientation === 'vertical') {
                  if (isCrossBorder(desLabels[i], plotArea) || (srcLabels[i].height > srcLabels[i].ownerHeight) || srcLabels[i].value === 0) {
                    desLabels[i].visible = false;
                  }
                }
              } else if (isPercentMode) {
                if (isCrossBorder(desLabels[i], plotArea)) {
                  desLabels[i].visible = false;
                }
              }
            }
          }
          resetFlags();
        }
      };

      var resetFlags = function() {
        isHeatMap = false;
        isOneCategoryHeatmap = false;
        isTreeMap = false;
      };
      
      var parseOptions = function(props){
        orientation = TypeUtils.isExist(props.orientation) ? props.orientation : orientation;
        paintingMode = TypeUtils.isExist(props.paintingMode) ? props.paintingMode : paintingMode;
        visible = TypeUtils.isExist(props.visible) ? props.visible : visible;
        position = TypeUtils.isExist(props.position) ? props.position : position;
        automaticInOutside = TypeUtils.isExist(props.automaticInOutside) ? props.automaticInOutside : automaticInOutside;
        formatString = TypeUtils.isExist(props.formatString) ? props.formatString : formatString;
        isPercentMode = TypeUtils.isExist(props.isPercentMode) ? props.isPercentMode : isPercentMode;
        isStackMode = TypeUtils.isExist(props.isStackMode) ? props.isStackMode : isStackMode;
        isDonut = TypeUtils.isExist(props.isDonut) ? props.isDonut : isDonut;
        showZero = TypeUtils.isExist(props.showZero) ? props.showZero : showZero;
        outsideVisible = TypeUtils.isExist(props.outsideVisible) ? props.outsideVisible : outsideVisible;
        outsidePosition = TypeUtils.isExist(props.outsidePosition) ? props.outsidePosition : outsidePosition;
        isGeoChart = TypeUtils.isExist(props.isGeoChart) ? props.isGeoChart : isGeoChart;
        positionPreference = TypeUtils.isExist(props.positionPreference) ? props.positionPreference : positionPreference;
        type = TypeUtils.isExist(props.type) ? props.type : type;
      };
      
      //get customlabel text from from the rawObj, if the type is url, return the original text
      var getCustomlabelText = function(rawObj){
        var ret;
        if(rawObj.info){
          var clobj = rawObj.info.customlabel;
          if(clobj){
            if(clobj.type === 'url'){
              ret = rawObj.val;
            }else if(clobj.type === 'string'){
              ret = clobj.val;
            }
          }else{
            ret = rawObj.val;
          }
        }else{
          ret = rawObj.val;
        }
        return ret;
      };
      
      var prepareLabel = function(){
        _SVGRoot = gPlot.parent()[0][0].ownerSVGElement;
        dataLabel = [], dataLabels = [], originalLabels = [];
        if( _SVGRoot !== null && _SVGRoot.getBBox().width === 0){
          return;
        }
        var i = 0, j = 0, label, plotOffset, tempElement;
        var datashapeOffset, labelSize, percentageValue;
        
        var boundarySelection = gPlot.parent().selectAll('.datashapesgroup');
        if(boundarySelection[0].length === 0){
          boundarySelection = gPlot.parent();
        }
        var gElements = boundarySelection.selectAll('.datapoint');
        
        if(paintingMode === 'polarCoordinate'){
          for( i = 0 ; i < boundarySelection[0].length; i++){
            plotOffset = boundarySelection[0][i].getTransformToElement(_SVGRoot);
            dataLabel = [];
            for( j = 0 ; j < gElements[i].length; j++){
              label = {};
              tempElement = gElements[i][j];
              datashapeOffset = tempElement.getTransformToElement(_SVGRoot);
              /**
               *  [07-Jan-2012 Nick] 
               *  FIX FOR IE, in some cases, datashapesOffset is null here.
               *  So if it is null, the logic should jump out of here.
               */
              if(!TypeUtils.isExist(datashapeOffset)){
                  break;
              }
              label.dataShape = tempElement;
              var dimensions = '';
              percentageValue = (tempElement.__data__.endAngle - tempElement.__data__.startAngle) / ( 2 * Math.PI);
              percentageValue = formatDataLabel(percentageValue, tempElement);
              /*
               * [18-Dec-2012 Nick] Combine measures and dimensions into one label. (for pie only)
               */
              if(type === 'label and value'){
                var dimensionObjects = tempElement.__data__.dimValueObjects;
                for(var k=0; k < dimensionObjects.length; k++){
                  dimensions += getCustomlabelText(dimensionObjects[k]);
                  if(k !== (dimensionObjects.length - 1)){
                    dimensions += '/';
                  }
                }  
              }
              label.value = dimensions + ' (' + percentageValue + ')';
              
              label.transformString = ('translate(' + (datashapeOffset.e - plotOffset.e) + ',' + (datashapeOffset.f - plotOffset.f) + ')' );

              labelSize = TextUtils.fastMeasure(label.value, fontSize, fontWeight, fontFamily);
              var r = tempElement.__data__.r;           
              var mAngle = (tempElement.__data__.endAngle + tempElement.__data__.startAngle)/ 2;        
              var sinLabelAngle = Math.sin(mAngle);
              var cosLabelAngle = Math.cos(mAngle);
            
              var labelCenterX, labelCenterY;
            
              if(isDonut){
                labelCenterX = 0.65 * r * sinLabelAngle;
                labelCenterY = 0.65 * r * cosLabelAngle;
              }else{
                labelCenterX = 0.5 * r * sinLabelAngle;
                labelCenterY = 0.5 * r * cosLabelAngle;
              }
            
              label.x = 0 + labelCenterX * datashapeOffset.a - labelSize.width/2;
              label.y = 0 - labelCenterY * datashapeOffset.d + labelSize.height/2;
              label.centerX = labelCenterX;
              label.centerY = labelCenterY;
              label.datapointRect = tempElement.getBoundingClientRect();
            
              dataLabel.push(label);
              originalLabels.push(label);
            }
            dataLabels.push(dataLabel);
          }
        }else if(paintingMode === 'rectCoordinate'){
          for( i = 0; i < boundarySelection[0].length; i++){
            plotOffset = boundarySelection[0][i].getTransformToElement(_SVGRoot);
            dataLabel = [];
            for( j = 0 ; j < gElements[i].length; j++){
              label = {};
              tempElement = gElements[i][j];
              datashapeOffset = tempElement.getTransformToElement(_SVGRoot);
              
              /**
               *  [07-Jan-2012 Nick] 
               *  FIX FOR IE, in some cases, datashapesOffset is null here,
               *  so if it is null, the logic should jump out of here.
               */
              if(!TypeUtils.isExist(datashapeOffset)){
                  break;
              }
              label.dataShape = tempElement;
              var bbox = tempElement.getBBox();        
              /*
               * [18-Dec-2012 Nick] 
               * For different charts, the requirements of showing label are different.
               * 1. Geo bubble/chorolopeth chart, it has an array of values in __data__.val, but the array only has one object
               * 2. Bubble and scatter has more than one object in __data__.val, but only y member is displayed.
               * 3. for the other charts, show val directly.
               */
              var originalValue;
              if(TypeUtils.isArray(tempElement.__data__.val)){
                if(isGeoChart){
                  originalValue = tempElement.__data__.val[0];
                }else{
                  originalValue = tempElement.__data__.y;
                }
              }else{
                if(isPercentMode && type === 'value'){
                  originalValue = tempElement.__data__.value;
                }else{
                  originalValue = tempElement.__data__.val;
                }
              }
              if(type !== 'value' && tempElement.__data__.isNegative){
                originalValue = '-' + originalValue;
              }
              var heatMapLabelWidth = 0, heatMapLabelHeight = 0;
              if (tempElement.__data__.isOnlyOneCategory !== undefined) {
                isHeatMap = true;
                if (tempElement.__data__.isOnlyOneCategory) {
                  isOneCategoryHeatmap = true;
                  var heatMapLabel = gPlot.parent().selectAll('text.heatmapdatalabel')[0][0];
                  if (heatMapLabel) {
                    var heatmapLabelBBox = heatMapLabel.getBBox();
                    heatMapLabelWidth = heatmapLabelBBox.width;
                    heatMapLabelHeight = heatmapLabelBBox.height;
                  }
                }
              }
              
              var treeMapLabelWidth = 0, treeMapLabelHeight = 0;
              if (tempElement.__data__.isTreeMap !== undefined) {
                isTreeMap = true;
                var treeMapLabel = gPlot.parent().selectAll('text.treemapdatalabel')[0][0];
                if (treeMapLabel) {
                  var treeMapLabelBBox = treeMapLabel.getBBox();
                  treeMapLabelWidth = treeMapLabelBBox.width;
                  treeMapLabelHeight = treeMapLabelBBox.height;
                }
              }
        
              label.value =  formatDataLabel(originalValue, tempElement);
              if(type === 'label and value'){
                label.value = tempElement.__data__.label + ' (' + label.value + ')';
              }
              var x = bbox.x * datashapeOffset.a, y = bbox.y * datashapeOffset.d, width = bbox.width* datashapeOffset.a, height = bbox.height* datashapeOffset.d;    
              /**
               *  [18-Dec-2012 Nick] 
               *  plotOffset means the offset between g.datashapesgroup and svg root element
               *  datashapeOffset means the offset between element.datapoint and svg root element
               *  so the difference between them means the offset between element.datapoint and g.datashapesgroup
               */
              label.transformString = ('translate(' + (datashapeOffset.e - plotOffset.e) + ',' + (datashapeOffset.f - plotOffset.f) + ')' );
              var insideCenterX = 0, insideCenterY = 0, outsideUpCenterX = 0, outsideUpCenterY = 0, outsideDownCenterX = 0, outsideDownCenterY = 0, outsideLeftCenterX = 0, outsideRightCenterX = 0, outsideLeftCenterY = 0, outsideRightCenterY = 0;
              if (isHeatMap || isTreeMap) {
                var labelValue = label.value;
                if (TypeUtils.isNumber(labelValue)){
                  labelValue = labelValue.toString();
                }
                var dataLabeFontColor = null;
                if (isHeatMap) {
                  dataLabeFontColor = heatMapLabelFontColor;
                } else if (isTreeMap) {
                  dataLabeFontColor = treeMapLabelFontColor;
                }
                label.value = TextUtils.ellipsis(labelValue, null, width - 3,  "fill:" + dataLabeFontColor + ";font-family:" + fontFamily + ";font-size:" + fontSize);
              }
              labelSize = TextUtils.fastMeasure(label.value, fontSize, fontWeight, fontFamily);
 
              if(orientation === 'horizontal'){
                label.centerX = x + width/2;
                label.centerY = y + height/2;
                /**
                 * [07-Jan-2012 Nick]
                 * if the label value is negative, set outsidePosition to left, so make sure it is listed on the left sideof data shape element
                 */
                if (positionPreference && position === 'outside') {
                  if (outsidePosition === 'right'){
                    label.centerX = label.centerX  + width/2 + labelSize.width/2;
                  }
                } else {
                  if(position === 'outside'){
                    if( outsidePosition === 'left' || (!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)){
                      label.centerX = label.centerX - (width/2 + labelSize.width/2);
                    }else if (outsidePosition === 'right'){
                      label.centerX = label.centerX  + width/2 + labelSize.width/2;
                    }
                  }
                }
                insideCenterX = x + width/2;
                insideCenterY = y + height/2;

                if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                  outsideRightCenterX = label.centerX  + width/2 + labelSize.width/2;
                  outsideRightCenterY = y + height/2;
                } else {
                  outsideLeftCenterX = label.centerX - (width/2 + labelSize.width/2);
                  outsideLeftCenterY = y + height/2;
                }

              }else{
                label.centerX = x + width/2;
                label.centerY = y + height/2;
                /**
                 * [07-Jan-2012 Nick]
                 * if the label value is negative, set outsidePosition to down, so make sure it is listed below the data shape element
                 */
                if(tempElement.__data__.isNegative){
                  outsidePosition = 'down';
                }   
                if (isHeatMap && isOneCategoryHeatmap) {
                  label.centerY += labelSize.height/2;
                } else if (isTreeMap) {
                  label.centerY += (treeMapLabelHeight/2 + labelSize.height/2);
                }
                
                if (positionPreference && position === 'outside') {
                  if (outsidePosition === 'up'){
                    label.centerY = label.centerY - height/2 - labelSize.height/2;
                  }
                } else {
                  if(position === 'outside'){
                    if( outsidePosition === 'down' || (!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)){
                      label.centerY = label.centerY + height/2 + labelSize.height/2;
                    }else if (outsidePosition === 'up'){
                      label.centerY = label.centerY - height/2 - labelSize.height/2;
                    } 
                  }
                }
	
                insideCenterY = y + height/2;
                insideCenterX = x + width/2;
                
                if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                  outsideUpCenterY = label.centerY - height/2 - labelSize.height/2;
                  outsideUpCenterX = x + width/2;
                } else {
                  outsideDownCenterY = label.centerY + height/2 + labelSize.height/2;
                  outsideDownCenterX = x + width/2;
                }
              }
              label.x = label.centerX - labelSize.width/2;
              label.y = label.centerY - labelSize.y/2;
              label.width = labelSize.width;
              label.height = labelSize.height;
              label.ownerWidth = width;
              label.ownerHeight = height;
              label.datapointRect = tempElement.getBoundingClientRect();
              label.insideX = insideCenterX - labelSize.width/2;
              label.insideY = insideCenterY - labelSize.y/2;
              if (orientation === 'horizontal') {
                if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                  label.outsideX = outsideRightCenterX - labelSize.width/2;
                  label.outsideY = outsideRightCenterY - labelSize.y/2;
                } else {
                  label.outsideX = outsideLeftCenterX - labelSize.width/2;
                  label.outsideY = outsideLeftCenterY - labelSize.y/2;
                }
              } else if (orientation === 'vertical') {
                if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                  label.outsideX = outsideUpCenterX - labelSize.width/2;
                  label.outsideY = outsideUpCenterY - labelSize.y/2;
                } else {
                  label.outsideX = outsideDownCenterX - labelSize.width/2;
                  label.outsideY = outsideDownCenterY - labelSize.y/2;
                }
              }
              dataLabel.push(label);
              originalLabels.push(label);
            }
            dataLabels.push(dataLabel);
          }
        }
      };
      
      var isOverlappedWith = function(srcLabel, desLabel) {
//        var left1 = srcLabel.x, top1 = srcLabel.y - srcLabel.height, right1 = srcLabel.x + srcLabel.width, bottom1 = srcLabel.y;
//        var left2 = desLabel.x, top2 = desLabel.y - desLabel.height, right2 = desLabel.x + desLabel.width, bottom2 = desLabel.y;
        
        var left1 = srcLabel.left, top1 = srcLabel.top, right1 = srcLabel.right, bottom1 = srcLabel.bottom;
        var left2 = desLabel.left, top2 = desLabel.top, right2 = desLabel.right, bottom2 = desLabel.bottom;
        
        // the source label is inside target label
        // left2 + top2
        if (left1 <= left2 && left2 <= right1 && top1 <= top2 && top2 <= bottom1) {
            return true;
        }
        // right2 + top2
        if (left1 <= right2 && right2 <= right1 && top1 <= top2 && top2 <= bottom1) {
            return true;
        }
        // left2 + bottom2
        if (left1 <= left2 && left2 <= right1 && top1 <= bottom2 && bottom2 <= bottom1) {
            return true;
        }
        // right2 + bottom2
        if (left1 <= right2 && right2 <= right1 && top1 <= bottom2 && bottom2 <= bottom1) {
            return true;
        }
        
        // the target label is inside the source label
        // left1 + top1
        if (left2 <= left1 && left1 <= right2 && top2 <= top1 && top1 <= bottom2) {
            return true;
        }
        // right1 + top1
        if (left2 <= right1 && right1 <= right2 && top2 <= top1 && top1 <= bottom2) {
            return true;
        }
        // left1 + bottom1
        if (left2 <= left1 && left1 <= right2 && top2 <= bottom1 && bottom1 <= bottom2) {
            return true;
        }
        // right1 + bottom1
        if (left2 <= right1 && right1 <= right2 && top2 <= bottom1 && bottom1 <= bottom2) {
            return true;
        }
        
        // test the segment intersection
        if (left1 <= left2 && left2 <= right1 && top2 <= top1 && top1 <= bottom2) {
            return true;
        }
        if (left1 <= left2 && left2 <= right1 && top2 <= bottom1 && bottom1 <= bottom2) {
            return true;
        }
        if (left1 <= right2 && right2 <= right1 && top2 <= top1 && top1 <= bottom2) {
            return true;
        }
        if (left1 <= right2 && right2 <= right1 && top2 <= bottom1 && bottom1 <= bottom2) {
            return true;
        }
        
        return false;        
      };
      
      var removeUnqualifiedLabels = function(labels, plotArea) {

        if (labels === null || plotArea === null) {
          return;
         }
            
         for (var i = 0; i < labels.length; i++) {
           
           var srcLabel = labels[i];
           
//           if (isCrossBorder(srcLabel, plotArea)) {
//             srcLabel.visible = false;
//             continue;
//           }
           if (!srcLabel.visible) {
             continue;
           }
           for (var j = i + 1; j < labels.length; j++) {
             var desLabel = labels[j];
             if (!desLabel.visible) {
               continue;
             }
             if (isOverlappedWith(srcLabel, desLabel)) {
               desLabel.visible = false;
             }
           }
         }
         
      };
      
      var isCrossBorder = function(label, plotArea) {
//        if (label.x < 0 || label.y < 0) {
//          return true;
//        }
//        
//        if (label.x + label.width > plotArea.width) {
//          return true;
//        }
//       
//        if (label.y > plotArea.height) {
//          return true;
//        }
//
//        return false;
        
        if (label.top < plotArea.top || label.left < plotArea.left || label.right > plotArea.right || label.bottom > plotArea.bottom) {
          return true;
        }
        
        return false;
      };
     
      label.plot = function(_){
        if(!arguments.length){
          return gPlot;
        }
        gPlot = _;
      };

      label.parent = function(){};
      
      label.properties = function(_){
        if(!arguments.length){
          return properties;
        }        
        Objects.extend(true,properties, _);
        parseOptions(properties);
      };
      
      return label;
    };
    return dataLabel; 
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.DataLabel',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.datalabel',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.datalabel',
    'name' : 'datalabel',
    'type' : Constants.Module.Type.Supplementary,
    'properties' : {  
      'visible': {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether data label is visible.',
     },
     'isDonut': {
       'name' : 'isDonut',
       'supportedValueType' : 'Boolean',
       'defaultValue' : false,
       'description' : 'Set for donut chart only.',
       'isExported': false
    },
    'type' : {
      'name' : 'type',
      'supportedValueType' : 'String',
      'defaultValue' : 'value',
      'description' : 'Set the type of label',
      'isExported': false
    },
    'automaticInOutside': {
      'name' : 'automaticInOutside',
      'supportedValueType' : 'Boolean',
      'defaultValue' : true,
      'description' : 'if it is true, the data label will be automatically placed outside when data label postion property is inside and vice versa.',
      'isExported': false    
    },
    'showZero': {
      'name' : 'showZero',
      'supportedValueType' : 'Boolean',
      'defaultValue' : true,
      'description' : 'if it is true, the value zero will be shown in data label.',
      'isExported': false    
    },
    'isGeoChart': {
      'name' : 'isGeoChart',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'if it is true, it is a geo chart.',
      'isExported': false    
    },
    'isStackMode': {
      'name' : 'isStackMode',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'Set for stack chart only.',
      'isExported': false    
    },
    'isPercentMode': {
      'name' : 'isPercentMode',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'Set for percent chart only.',
      'isExported': false    
    },
    'positionPreference': {
      'name' : 'positionPreference',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'If it is true, the data label position is defined by property outsidePosition no matter whether data label value is negative.',
      'isExported': false    
    },
    'outsideVisible': {
      'name' : 'outsideVisible',
      'supportedValueType' : 'Boolean',
      'defaultValue' : true,
      'description' : 'when data label is oustide, it can control whether it is visible or not.',
      'isExported': false    
    },
    'outsidePosition': {
      'name' : 'outsidePosition',
      'supportedValueType' : 'List',
      'supportedValues': ['up','down', 'left', 'right'],
      'defaultValue' : 'up',
      'description' : 'when data label is oustide, its position is above the element.',
      'isExported': false    
    },
        'paintingMode': {
           'name' : 'paintingMode',
           'supportedValueType' : 'List',
           'supportedValues': ['rectCoordinate','polarCoordinate'],
           'defaultValue' : 'rectCoordinate',
           'description' : 'Set painting mode of data labels.',
           'isExported' : false
        },
        'position': {
           'name' : 'position',
           'supportedValueType' : 'List',
           'supportedValues' : ['inside','outside'],
           'defaultValue' : 'inside',
           'description' : 'Set position of data labels.'
        },
        'orientation': {
           'name' : 'orientation',
           'supportedValueType' : 'List',
           'supportedValues' : ['horizontal', 'vertical'],
           'defaultValue' : 'vertical',
           'description' : 'Set orientation of data labels.',
           'isExported' : false
        },
        'formatString': {
        	'name' : 'formatString',
        	'supportedValueType': 'Two-Dimensions-Array',
          'defaultValue' : null,
        	'description' : 'Set format string of datalabel.As we may have dual axis with serveral measures,the first array is applied to primary axis and the second one is applied to the second axis.'
        		+'If the length of format string list is less than the length of data series, the last format string in the list will be applied to exceeded data series.' 
        	}
      },
      'css' : {
        '.viz-datalabel' : {
          'description' : 'Define style for the data label',
          'value' : {
            'fill' : '#333333',
            'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
            'font-size' : '12px',
            'font-weight' : 'normal'
          }
        }
      },
      configure: null,
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend.mbcLegendArea',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(TextRuler, langManager,FormatManager,TypeUtils) {
  var mbcLegendArea = function(ctx){
    
    var width = 400, height = 200, valueLabelFont = {
        'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
        'fontsize' : '12px',
        'fontweight' : 'normal',
        'color' : '#333333'
      }, chartData, colors = [], markerSize = {width: 18, height : 20}, valuePaddingLeft = 10, paddingBottom = 1,
        selectedItem = [], selectionMode = 'selectionMode', posInfo = {
        markerPaddingRight : 0.5,
        paddingTop : 1,
        maxValueSpace : 1.6,
        minValueSpace : 0.5,
        minMarkerHeight : 10,  //10pixel
        space : 0
      }, nullLabelIndex = -1, textHeight = 20, minimized = false, noValueString = langManager.get('IDS_ISNOVALUE'), options;
    var effectManager = null;
        
    var chart = function(selection){
      selection.each(function(){
        getThemeStyleDef();
        
        //Calculate marker size.
        _calMarkerSize();
        
        var labelsData = chartData, textElements, y = 0, visible = 'visible', j, jlen;
        var wrap = d3.select(this);
        
        var indicatedRectElement = wrap.selectAll('rect.indicatedRect');
        if(indicatedRectElement.empty()){
          indicatedRectElement = wrap.append('rect').attr('class', 'indicatedRect');
        }
        indicatedRectElement.attr('visibility', 'hidden')
          .attr('width', markerSize.width + 8).attr('height', markerSize.height+2);
        
        var gWrap = wrap.selectAll('g.row').data(labelsData, function(d, i){
          return d.val;
        });
        
        gWrap.exit().remove();
        var gEnterWrap = gWrap.enter().append('g').attr('class', 'row');
        gEnterWrap.append('rect').attr('class', function(d, i){
          return 'marker ID_' + i;
        });
        gEnterWrap.append('text');

        var rectElements = gWrap.selectAll('rect.marker').attr('width', markerSize.width).attr('height', markerSize.height);
        var parameter, fillID;
        for(j = 0, jlen = rectElements.length; j < jlen; j++){
          y = (markerSize.height + paddingBottom) * ((nullLabelIndex !== -1) ? (j-1) : j);
          if(labelsData[j].val === 'N/A'){
            y = (markerSize.height + paddingBottom)*(jlen > 1 ? jlen : 0);
          }
          rectElements[j][0].setAttribute('y', y);
          
          parameter = {
            drawingEffect : 'normal',
            fillColor : colors[labelsData.length - j - 1]
          };
          fillID = effectManager.register(parameter);
          rectElements[j][0].setAttribute('fill', fillID);
        }

        textElements = gWrap.selectAll('text').text(function(d, i){
          var txt = d.val;
          if(txt === 'N/A'){
            txt = noValueString;
          }
          if(TypeUtils.isExist(options.formatString)){
              txt = FormatManager.format(txt , options.formatString );
          }
          return txt;
        }).attr('x', markerSize.width + valuePaddingLeft);
        y = 0;
        for(j = 0, jlen = textElements.length; j < jlen; j++){
          y = markerSize.height*((nullLabelIndex !== -1) ? j : (j+1)) + textHeight/2;
          if(labelsData[j].val === 'N/A'){
            y = (markerSize.height + paddingBottom)*(jlen > 1 ? jlen : 0) + textHeight/2 + markerSize.height/2;
          }
          if(minimized && j !== jlen-1 && (labelsData[j].val !== 'N/A')){
            visible = 'hidden';
          }else {
            visible = 'visible';
          }
          
          textElements[j][0].setAttribute('y', y);
          textElements[j][0].setAttribute('visibility', visible);
        }
        
        
        if(labelsData.length > 1){
          //Add top text
          var topTextElements = wrap.selectAll('text.topText');
          if(topTextElements.empty()){
            topTextElements = wrap.append('text').attr('class', 'topText');
          }
          var topTextLabel;
          if(nullLabelIndex !== -1){
            topTextLabel = labelsData[1].ctx.ranges.endValue;
          }else{
            topTextLabel = labelsData[0].ctx.ranges.endValue;
          }
          if(TypeUtils.isExist(options.formatString)){
            topTextLabel = FormatManager.format(topTextLabel, options.formatString);
          }
          topTextElements.text(topTextLabel).attr('x', markerSize.width + valuePaddingLeft).attr('y', textHeight/2);
        }else if(labelsData.length === 1){
          textElements[0][0].setAttribute('y', textHeight/2 + markerSize.height/2);
        }
        
        wrap.attr('style', 'font-size: '+valueLabelFont.fontsize+'; font-family:'+valueLabelFont.fontfamily+'; font-weight:'+valueLabelFont.fontweight+'; fill: '+valueLabelFont.color+";");
        wrap.on('mouseover', hoverHandler).on('mouseout', blurHandler).on('mousedown', itemClicked).on('mouseup', blurHandler);
      });
    };
    
    var hoverHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        return;
      }
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1){
          return;
        }
        var x = item.attr('x'), y = item.attr('y');
        
      var indicatedItem = d3.selectAll('.indicatedRect');
      indicatedItem.attr('visibility', 'visible').attr('fill', '#cccccc').attr('x', x - 4).attr('y', y- 1);
    };
    
    var blurHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        return;
      }
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1){
          return;
        }
        
      var indicatedItem = d3.selectAll('.indicatedRect');
      indicatedItem.attr('visibility', 'hidden');
    };
    
    var itemClicked = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        return;
      }
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1){
          return;
        }
        var x = item.attr('x'), y = item.attr('y');
        
      var indicatedItem = d3.selectAll('.indicatedRect');
      indicatedItem.attr('visibility', 'visible').attr('fill', '#808080').attr('x', x - 4).attr('y', y- 1);
    };
    
    chart.clickHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        return;
      }
      
      if(d3.event.type === 'touchstart'){
        //VD effect
        itemClicked();
      }  
      
      var isSelected = false;
      
      if(_contains(selectedItem, d3.event.target)){
        //has been selected.
        isSelected = true;
      }else{
        //New selected item
        selectedItem.push(d3.event.target);
      }
      return isSelected;
    };
    
    chart.width = function(_) {
      if(!arguments.length){
        return width;
      }
      width = _;
      return chart;
    };

    
    chart.height = function(_) {
      if(!arguments.length){
        return height;
      }
      height = _;
      return chart;
    };
    
    chart.properties = function(properties) {
      if(!arguments.length){
        return options;
      }
      //TODO use extends...
      options = properties;
      return chart;
    };
    
    chart.data = function(_){
      if(!arguments.length){
        return chartData;
      }
      chartData = _;
      return chart;
    };
    
    chart.setSelectionMode = function(_){
      selectionMode = _;
    };
    
    chart.getPreferredSize = function() {
      var maxWidth = 0, maxHeight = 0, minHeight = 0, data = chartData;
      if(data){
        //reset N/A flag
        nullLabelIndex = -1;
        
        getThemeStyleDef();
        
        var maxValueWidth = -1, valueSize, labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
        var len = data.length;
        for ( var i = 0; i < len; i++) {
          if(data[i].val === 'N/A'){
            valueSize = TextRuler.measure(noValueString, labelFont);
            nullLabelIndex = i;
          }else{
            var value = data[i].val;
            if(TypeUtils.isExist(options.formatString)){
                value = FormatManager.format(value , options.formatString );
              }
            valueSize = TextRuler.measure(value, labelFont);
            
          }
          if ((valueSize === undefined) || (valueSize.width > maxValueWidth)) {
            maxValueWidth = valueSize.width;
          }
        }
        
        textHeight = parseInt(valueLabelFont.fontsize, 10); //1em
        var h = (posInfo.maxValueSpace + 1) * textHeight;
        
        maxWidth = markerSize.width + posInfo.markerPaddingRight * textHeight + maxValueWidth;
        if(nullLabelIndex !== -1){
          maxHeight = (h + paddingBottom) * (len+1) + textHeight;
          minHeight = (posInfo.minMarkerHeight + paddingBottom) * (len+1) + textHeight;
        }else{
          maxHeight = (h + paddingBottom) * len + textHeight;
          minHeight = (posInfo.minMarkerHeight + paddingBottom) * len + textHeight;
        }
      }
      return {
        minHeight: minHeight,
        minWidth: maxWidth,
        width: maxWidth,
        height: maxHeight
      };
    };
    
    chart.color = function(_) {
      if(!arguments.length){
        return colors;
      }
      colors = _;  
      return chart;
    };
    
    chart.effectManager = function(_) {
      if(!arguments.length){
        return effectManager;
      }
      effectManager = _;

      return chart;
    };
    
    var _calMarkerSize = function(){
      var len = chartData.length, h = 0, space = 0;
      minimized = false;
      if(nullLabelIndex !== -1){
        space = (height - (len + 2) * textHeight)/(len+1);
      }else{
        space = (height - (len + 1) * textHeight)/len;
      }
      h = space + textHeight;
      
      var maxValueSpace = posInfo.maxValueSpace * textHeight;
      if(space > maxValueSpace){
        space = maxValueSpace;
        h = space + textHeight;
      }else {
        var minValueSpace = posInfo.minValueSpace * textHeight;
        if(space < minValueSpace){
          h = posInfo.minMarkerHeight;
          space = 0;
          minimized = true;
        }
      }
      posInfo.space = space;
      markerSize.height = h;
    };
    
    //Utility method.
    var _contains = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return true;
            }
        }
        return false;
    };
    
    var getThemeStyleDef = function(){
      var valueLabelStyle = ctx.styleManager.query('viz-legend-valueLabel');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    return chart;
  };
  return mbcLegendArea;
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend.sizeLegendArea',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(TextRuler, langManager,FormatManager,TypeUtils) {
  var colorLegendArea = function(ctx){
    
    var width = 400, height = 200, valueLabelFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '14px',
      'fontweight' : 'normal',
      'color' : '#333333'
    }, chartData=[0, 0, 0], scale, colors, shapes, guildeLineWidth = 10, valuePaddingLeft = 15, valueLabelHeight = 0, options;
    
    var effectManager  = null;
    
    var chart = function(selection){
      selection.each(function(){
        if(scale === undefined){
          return;
        }
        
        getThemeStyleDef();
        
        //Smart value label management.
        var visibleData = [], labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
        if(valueLabelHeight === 0){
          valueLabelHeight = TextRuler.measure('M', labelFont).height;
        }
        var visibleCount = Math.round(height / valueLabelHeight);
        switch(visibleCount){
        case 0:
        case 1:
        case 2:
        case 3:
          visibleData.push(chartData[0]);
          break;
        case 4:
          visibleData.push(chartData[0]);
          if(chartData.length > 1){
            visibleData.push(chartData[chartData.length -1]);
          }
          break;
        default :
          visibleData = chartData;
        }
        
        var bubbleSizeArr = [], maxWidth = -1, dataWidth, value;
        for(var i = 0, len = visibleData.length; i < len; i++){
          bubbleSizeArr.push(scale(visibleData[i])/2);
          value = _isNullValue(visibleData[i]);
          if(TypeUtils.isExist(options.formatString)){
              value = FormatManager.format(value , options.formatString );
            }
          dataWidth = TextRuler.measure(value, labelFont).width;
          if(dataWidth > maxWidth){
            maxWidth = dataWidth;
          }
        }
        var maxBubbleSize = bubbleSizeArr[0];
        var wrap = d3.select(this);
        var textHeight = parseInt(valueLabelFont.fontsize, 10); //1em
        var circlesWrap = wrap.selectAll('g.legend-circles');
        if(circlesWrap.empty()){
          circlesWrap = wrap.append('g').attr('class', 'legend-circles').data([bubbleSizeArr]);
        }
        circlesWrap.attr('transform', 'translate(' + maxBubbleSize + ',' + (maxBubbleSize+textHeight)+ ')');
        
        var parameter = {
          drawingEffect : options.drawingEffect,
          graphType : 'circle',
          fillColor : '#748CB2'
        };
        var fillID = effectManager.register(parameter);
        var circleElements = circlesWrap.selectAll('circle').data(bubbleSizeArr, function(d, i){
          return d;
        });
        circleElements.exit().remove();
        circleElements.enter().append('circle').attr('stroke', 'white').attr('stroke-width', 1).attr('fill', fillID).attr('opacity', '0.85');
        circleElements.attr('r', function(d, i){ return d;})
          .attr('cx', function(d, i){
            return 0;
          }).attr('cy', function(d, i){
            return maxBubbleSize-d;
          });
        
        var labelsWrap = wrap.selectAll('g.legend-valueLabels');
        if(labelsWrap.empty()){
          labelsWrap = wrap.append('g').attr('class', 'legend-valueLabels').data([visibleData]);
        }
        var labelX = (maxBubbleSize*2+valuePaddingLeft+guildeLineWidth+maxWidth) > width ? width : (maxBubbleSize*2+valuePaddingLeft+guildeLineWidth+maxWidth);
        labelsWrap.attr('transform', 'translate('+ labelX +', '+(maxBubbleSize+textHeight*3/2)+')');
        var valueElements = labelsWrap.selectAll('text').data(visibleData, function(d, i){
          return d;
        });
        valueElements.exit().remove();
        valueElements.enter().append('text').attr('text-anchor', 'end');
        valueElements.attr('font-family', valueLabelFont.fontfamily).attr('font-size', valueLabelFont.fontsize)
          .attr('font-weight', valueLabelFont.fontweight).attr('fill', valueLabelFont.color).text(function(d, i){
            var value = _isNullValue(d);
            if(TypeUtils.isExist(options.formatString)){
              value = FormatManager.format(value , options.formatString );
            }
            return value;
          }).attr('dx', 0).attr('dy', function(d, i){
            var dy = (i-1)*maxBubbleSize - 2;
            if(visibleData.length === 2 && i === 1){
              dy = maxBubbleSize - 2;
            }
            return dy;
          });
        
        var guidelineWrap = wrap.selectAll('g.legend-guideLines');
        if(!guidelineWrap.empty()){
          //Empty
          guidelineWrap.remove();
        }
        guidelineWrap = wrap.append('g').attr('class', 'legend-guideLines').attr('transform', 'translate(' + maxBubbleSize + ',' + (maxBubbleSize+textHeight)+ ')');
        if(visibleData.length > 0){
          guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ -maxBubbleSize +' L '+(maxBubbleSize+guildeLineWidth)+" "+ -maxBubbleSize);
        }
        if(visibleData.length > 1){
          guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ maxBubbleSize +'L'+(maxBubbleSize+guildeLineWidth)+" "+ maxBubbleSize);
        }
        if(visibleData.length > 2){
          guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ (maxBubbleSize - bubbleSizeArr[1]) +' L '+maxBubbleSize+" 0"+  ' M '+ maxBubbleSize + " 0 " + " L "+ (maxBubbleSize + guildeLineWidth) +" 0");
        }
      });
        
    };
    
    chart.width = function(_) {
      if(!arguments.length){
        return width;
      }
      width = _;
      return chart;
    };

    chart.height = function(_) {
      if(!arguments.length){
        return height;
      }
      height = _;
      return chart;
    };
    
    chart.color = function(_) {
      if(!arguments.length){
        return colors;
      }
      return chart;
    };

    chart.shapes = function(_) {
      if(!arguments.length){
        return shapes;
      }
      return chart;
    };
    
    chart.properties = function(properties) {
      if(!arguments.length){
        return options;
      }
      //TODO use extends...
      options = properties;
      return chart;
    };
    
    chart.data = function(_){
      if(!arguments.length){
        return chartData;
      }
      chartData = _;
      return chart;
    };
    
    chart.scale = function(_){
      if(!arguments.length){
        return scale;
      }
      scale = _;
      return chart;
    };
    
    chart.effectManager = function(_) {
      if(!arguments.length){
        return effectManager;
      }

      effectManager = _;
      return chart;
    };
    
    var getThemeStyleDef = function(){
      var valueLabelStyle = ctx.styleManager.query('viz-legend-valueLabel');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    chart.getPreferredSize = function(chartSize, layoutSpace, legendSpace, containerInfo, bubbleScale, bubbleSpace, hasHeightFeed){
      if(chartSize){
        getThemeStyleDef();
      }
      var maxWidth = 0, maxHeight = 0, minWidth = 0;
      if(scale && layoutSpace){
        valueLabelHeight = 0;
        
        var maxValueWidth = -1, maxBubbleSize, valueSize, value = null,
          data = chartData, labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
        for(var i = 0, len = data.length; i < len; i++){
          value = _isNullValue(data[i]);
          if(TypeUtils.isExist(options.formatString)){
              value = FormatManager.format(value , options.formatString );
            }
          valueSize = TextRuler.measure(value, labelFont);
          if((valueSize === undefined) || (valueSize.width > maxValueWidth)) {
            maxValueWidth = valueSize.width;
          }
        }
        
        var space =  maxValueWidth + valuePaddingLeft + guildeLineWidth;
        maxBubbleSize = chartSize ? (chartSize.width - layoutSpace - legendSpace - space - containerInfo.space - containerInfo.number * bubbleSpace) / (1 + (1 / bubbleScale) * containerInfo.number) : scale(data[0]);
          valueLabelHeight = valueSize.height;
        

        if (!hasHeightFeed && containerInfo.plotHeight) {
          maxBubbleSize = Math.min((containerInfo.plotHeight - bubbleSpace) * bubbleScale, maxBubbleSize);
        }
        
        maxHeight = maxBubbleSize + valueSize.height * 2;
        maxWidth = maxBubbleSize + space;
        minWidth = maxWidth;
      }
      
      return {
        minHeight: maxHeight,
        minWidth: minWidth,
        height: maxHeight,
        width: maxWidth
      };
    };
    
    return chart;
  };
    
  var _isNullValue = function(value){
    return (value === null) ? langManager.get('IDS_ISNOVALUE') : value;
  };
  
  return colorLegendArea;
});sap.riv.module(
{
  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'},
[

],

function Setup() {

  var DrawUtil = {

  };

  /**
   *  props = {
   *    type: 
   *    rx:
   *    ry:
   *  }
   *  @return path "d" for D3 
   */
  DrawUtil.createMarkerData = function (props){
    // TODO Maybe we can use hashmap to cache here
    //if(symbolMap[props]) return symbolMap[props];
    var result;
    var temp = props.borderWidth / 2;
    switch(props.type)
    {
    case "circle" :
      result = "M" + (-props.rx - temp)  + ",0 A" + (props.rx + temp) + "," + (props.ry + temp) + " 0 1,0 " + (props.rx + temp) + ",0 A";
      result += (props.rx + temp) + "," + (props.ry + temp) + " 0 1,0 " + (-props.rx -temp) + ",0z";
      break;
    case "cross" :
      result = "M" + (-props.rx - temp) + "," + (-props.ry/3 - temp) + "H" + (-props.rx/3  - temp) + "V" + (-props.ry - temp)+ "H" + (props.rx/3 +temp);
      result += "V" + (-props.ry/3 - temp) + "H" + (props.rx + temp) + "V" + (props.ry/3 + temp) + "H" + (props.rx/3 + temp);
      result += "V" + (props.ry +temp) + "H" + (-props.rx/3 - temp) + "V" + (props.ry/3 + temp) + "H" + (-props.rx -temp) + "Z";
      break;
    case "diamond" :
      result = "M0," + (-props.ry -temp)  + "L" + (props.rx + temp) + ",0" + " 0," + (props.ry + temp) + " " + (-props.rx -temp) + ",0" + "Z";
      break;
    case "square" :
      result = "M" + (-props.rx - temp) + "," + (-props.ry - temp) + "L" + (props.rx + temp) + ",";
      result += (-props.ry - temp) + "L" + (props.rx + temp) + "," + (props.ry + temp) + "L" + (-props.rx - temp) + "," + (props.ry + temp) + "Z";
      break;
    case "triangle-down" :
      result = "M0," + (props.ry + temp) + "L" + (props.rx + temp) + "," + -(props.ry + temp) + " " + -(props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "triangle-up" :
      result =  "M0," + -(props.ry + temp) + "L" + (props.rx + temp) + "," + (props.ry + temp) + " " + -(props.rx + temp) + "," + (props.ry + temp) + "Z";
      break;
    case "triangle-left" :
      result = "M" + -(props.rx + temp) + ",0L" + (props.rx + temp) + "," + (props.ry + temp) + " " + (props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "triangle-right" :
      result = "M" + (props.rx + temp) + ",0L" + -(props.rx + temp) + "," + (props.ry + temp) + " " + -(props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "intersection" :
      result = "M" + (props.rx + temp) + "," + (props.ry + temp) + "L" +  (props.rx/3 + temp) + ",0L" + (props.rx + temp) + "," + -(props.ry +temp) + "L";
      result += (props.rx / 2 - temp) + "," + -(props.ry + temp) + "L0," + (-props.ry/3 - temp) + "L" + (-props.rx / 2 + temp) + "," + -(props.ry + temp) + "L";
      result += -(props.rx + temp) + "," + -(props.ry +temp) + "L" + -(props.rx/3 + temp) + ",0L" + -(props.rx + temp) + "," + (props.ry + temp) + "L";
      result += (-props.rx/2 + temp) + "," + (props.ry + temp) + "L0," + (props.ry/3 + temp) + "L" + (props.rx/2 - temp) + "," + (props.ry + temp) + "Z";
      break;
    case 'squareWithRadius' : 
      var r = props.rx;
      var radius = r - 3;
      result = "M0," +  -r + "L" + -radius + ","+ -r + "Q" + -r +"," + -r + " " + -r + "," + -radius + "L" + -r +"," + radius + "Q" + -r + "," + r + " " + -radius + "," + r;
      result += "L" + radius + "," + r +"Q" + r + "," + r + " " + r + "," +radius + "L" + r +"," + -radius + "Q" + r + "," + -r + " "+ radius + "," + -r +"Z";
      break;
    }
    //symbolMap[props] = result;
    return result;

  };

  function getAnimationInitData(props)
  {
    var result;
    switch(props.type)
    {
    case "circle" :
      result = "M0,0A0,0 0 1,0 0,0A0,0 0 1,0 0,0z"; 
      break;
    case "cross" :
      result = "M0,0H0V0H0V0H0V0H0V0H0V0H0Z";
      break;
    case "diamond" :
      result = "M0,0L0,0 0,0 0,0Z";
      break;

    case "triangle-down" :

    case "triangle-up" :
    case "triangle-left" :
    case "triangle-right" :  
      result = "M0,0L0,0 0,0Z";
      break;
    case "intersection" :
      result = "M0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0Z";
      break;
    case 'squareWithRadius' : 
      result = "M0,0L0,0Q0,0 0,0L0,0Q0,0 0,0L0,0Q0,0 0,0L0,0Q0,0 0,0Z";
      break;  
    case "square" :
      result = "M0,0L0,0L0,0L0,0Z";
      break;
    default:
      result = "M0,0L0,0L0,0L0,0Z";
      break;
    }
    return result;
  }
  
  DrawUtil.createElements = function(d3Enter, props)
  {
    return d3Enter.append("path").attr("class", props.className);
  };
  
  DrawUtil.createElement = function(d3Parent, props, effectManager)
  {
    var d3Element = d3Parent.append("path").attr("class", props.className);
    props.node = d3Element;
    DrawUtil.drawGraph(props, effectManager);
    return d3Element;
  };

  /**
   * props = {
   *   node: current d3 svg element,
   *  graphType : marker type
   *  drawingEffect: drawingEffect
   *  direction : direction
   *   rx : size
   *  ry: size
   *  fillColor: color
   *  borderWidth:
   *  borderColor,
   *  visibility: "visible" or "hidden"
   *  animateTime: total time for animation in ms 
   *  strokeOpacity: opacity for border line
   *  endFunc: callback function, when animation complete, it will be called
   * }
   *  effectManager: current effectManager
   */
  DrawUtil.drawGraph =  function (props, effectManager)
  {
    var para = {
        type: props.graphType,
        rx:Math.round(props.rx),
        ry:Math.round(props.ry),
        borderWidth: props.borderWidth ? Math.round(props.borderWidth) : 0
    };
    var data = DrawUtil.createMarkerData(para);

    var fillId = effectManager.register(props);
    props.node.attr("fill", fillId).attr("stroke-width", props.borderWidth).attr("stroke", props.borderColor)
       .attr("visibility", props.visibility).attr("stroke-opacity", props.strokeOpacity);
    if(props.animateTime && props.animateTime > 0) {
      props.node.attr("d", getAnimationInitData(para));
      props.node.transition().duration(props.animateTime).attr("d", data).each('end', props.endFunc);
    } else {
      props.node.attr("d", data);
    }
    return  props.node;
  };
  
  return DrawUtil;
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend.colorLegendArea',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
}
],
function Setup(TextRuler, dispatch, DrawUtil, Repository) {
  var colorLegendArea = function(ctx){
    var width = 400, height = 200, valueLabelFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '12px',
      'fontweight' : 'normal',
      'color' : '#333333'
    }, options = {
      isHierarchy : undefined,
      position : 'right',
      legendType : 'ColorLegend'
    }, colorLabelSize = 1, shapes = [], colors = [], colorFeedLength = 0, shapeFeedLength = 0, 
    textHeight = 20, colorLabelMarginRight = 0.5, rowMarginBottom = 0.6, selectedItem = [], selectionMode = 'multiple';
    
    var effectManager = null;
    
    //alex su
    //These are two cursors to depict legend rows to be shown.
    var randomSuffix = Repository.newId();
    var startRow = 0;
    var endRow = Infinity;
    
    //Each row's position [{x: 10, y: 10}, {...}...]
    var rowPosArr = [], chartData = {};
    
    var chart = function(selection){
      selection.each(function(){
        getThemeStyleDef();
        
        var labelsData = getLabelData();  

        var isItemsOverflow =  false;
        if(labelsData.length > 0 && labelsData.length < chartData.length){
          isItemsOverflow = true;
        }

        var wrap = d3.select(this);
        wrap.attr('style', 'font-family:'+valueLabelFont.fontfamily+'; font-size:'+valueLabelFont.fontsize+'; font-weight:'+valueLabelFont.fontweight+';fill:'+valueLabelFont.color+";");
        //Create each row
        var gEnterRow = wrap.selectAll('g.row').data(labelsData, function(d, i){
          return d.val;
        });
        gEnterRow.exit().remove();
        
        var rectEnterRow = gEnterRow.enter().append('g').attr('class', function(d, i) {
          return randomSuffix+' row ID_' + i;
        });
        
        
        //alex su
        //Add 'rect' element to indicate selected/hover item.
        var indicatedItems = rectEnterRow.append('rect').attr('class', function(d, i){
          return 'legend-indicatedRect-'+randomSuffix+'-ID_' +i;
        });
        var rectMargin = rowMarginBottom * textHeight/2;
        indicatedItems.attr('width', width+10).attr('height', textHeight + rectMargin*2).attr('fill', 'rgba(255, 255, 255, 0)').attr('x', -5).attr('y', -rectMargin);

        var i, j, len, jLen, rowWrap;
        if((options.legendType !== 'BubbleColorLegend') && options.isHierarchy) {
          //Legend with hierarchy
          var labelItem, rowItems, lastRowLabel = [], itemXPos = 0, itemYPos = 0;

          for(i = 0, len = labelsData.length; i < len; i++) {
            itemXPos = 0, itemYPos = 0;
            
            //'China / 2001 / Car - Profit' TO ['China', '2001', 'Car', 'Profit']
            labelItem = labelsData[i].val;
            labelItem = labelItem.replace('-', '/');
            rowItems = labelItem.split(' / ');
            rowWrap = d3.select(this).select("g.row.ID_" + i);
            //Create each row's sub elements.
            var isShowWholeItem = false;
            for(j = 0, jLen = rowItems.length - 1; j < jLen; j++) {
              if(lastRowLabel[j] !== rowItems[j]) {
                //Only with last label and color label
                isShowWholeItem = true;
                break;
              }
            }
            
            var t = rowWrap.selectAll('g').data(rowItems);
            t.enter().append('g').attr('class', function(d, i) {
              return randomSuffix+' label ID_' + i;
            });

            for(j = 0, jLen = rowItems.length; j < jLen; j++) {
              var gWrap;
              if(j === jLen - 1) {
                //With legend marker
                gWrap = createRowWithColorLabel(rowWrap.select('g.label.ID_'+j), i, true, rowItems[j]);
                gWrap.attr('transform', function(d, index) {
                  itemXPos = 10 * j;
                  if(isShowWholeItem){
                    itemYPos = textHeight + itemYPos + rowMarginBottom * textHeight;                    
                  }
                  return 'translate(' + itemXPos + ',' + itemYPos + ')';
                });
              } else {
                if(isShowWholeItem) {
                  //No legend marker
                  gWrap = createRowWithColorLabel(rowWrap.select('g.label.ID_'+j), i, false, rowItems[j]);
                  gWrap.attr('transform', function(d, index) {
                    itemXPos = 10 * j;
                    if(j > 0){
                      itemYPos = textHeight + itemYPos + rowMarginBottom * textHeight;
                    }
                    return 'translate(' + itemXPos + ',' + itemYPos + ')';
                  });
                }
              }
              if(gWrap){
                gWrap.attr('visibility', function(d, index){
                  var visible = 'visible';
                  if((rowPosArr[i] === undefined) || (rowPosArr[i].y + itemYPos > height - textHeight)){
                    visible = 'hidden';
                    isItemsOverflow = true;
                  }
                  return visible;
                });
              }
              lastRowLabel[j] = rowItems[j];
            }
          }
          
          gEnterRow.attr('transform', function(d, i){
            if(rowPosArr[i]){
              return 'translate('+ rowPosArr[i].x + ',' + rowPosArr[i].y + ')';
            }
          });
        } else {
          //Create each row
          for(i = 0, len = labelsData.length; i < len; i++) {
            rowWrap = d3.select(this).selectAll("g.row.ID_" + i);
            createRowWithColorLabel(rowWrap, i, true, labelsData[i].val);
          }

          //Each row position
          gEnterRow.attr('transform', function(d, i) {
            if(rowPosArr[i]){
              return 'translate(' + rowPosArr[i].x + ',' + rowPosArr[i].y + ')';
            }
          }).attr('visibility', function(d, index){
            var visible = 'visible';
            if((rowPosArr[index] === undefined) || (rowPosArr[index].y > height - 2*textHeight)){
              visible = 'hidden';
              isItemsOverflow = true;
            }
            return visible;
          });
        }
        
        //Add 'rect' element to handle click event.
        var eventItems = rectEnterRow.append('rect').attr('class', function(d, i){
          return 'legend-eventRect-'+randomSuffix+'-ID_' +i;
        });
        eventItems.attr('width', width).attr('height', textHeight).attr('fill', 'rgba(255, 255, 255, 0)');
        
        //Much items ellipsis
        var itemsEllipsis = d3.select(this).selectAll('text.itemsEllipsis');
        if(itemsEllipsis.empty()){
          itemsEllipsis = d3.select(this).append('text').attr('class', 'itemsEllipsis').text('...')
            .attr('text-anchor', 'middle');
        }
        itemsEllipsis.attr('dx', width/2).attr('dy', height).attr('visibility', function(){
          var visible = 'hidden';
          if(isItemsOverflow){
            visible = 'visible';
          }
          return visible;
        });
        
        d3.select(this).on('mouseover', hoverHandler).on('mouseout', blurHandler)
          .on('mousedown', itemClicked).on('mouseup', blurHandler).on('touchend', blurHandler);
      });
    };
    
    chart.width = function(_) {
      if(!arguments.length){
        return width;
      }
      width = _;
      return chart;
    };

    chart.height = function(_) {
      if(!arguments.length){
        return height;
      }
      height = _;
      return chart;
    };
    
    chart.color = function(_) {
      if(!arguments.length){
        return colors;
      }
      colors = _;  
      return chart;
    };

    chart.shapes = function(_) {
      if(!arguments.length){
        return shapes;
      }
      shapes = _;
      return chart;
    };
    
    chart.colorFeedLength = function(_){
      colorFeedLength = _;
      return chart;
    };
    
    chart.shapeFeedLength = function(_){
      shapeFeedLength = _;
      return chart;
    };
    
    chart.data = function(_){
      if(!arguments.length){
        return chartData;
      }
      chartData = _;
      return chart;
    };
    
    chart.properties = function(properties) {
      if(!arguments.length){
        return options;
      }
      //TODO use extends...
      options = properties;
      return chart;
    };
    
    chart.getPreferredSize = function(wholeSize) {
      getThemeStyleDef();
      return _calculateRowPosition(wholeSize);
    };
    
    chart.setSelectionMode = function(_){
      selectionMode = _;
    };
    
    chart.effectManager = function(_) {
      if(!arguments.length){
        return effectManager;
      }
      effectManager = _;

      return chart;
    };
    
    var getLabelData = function(){
      var labelsData = [], len = rowPosArr.length;
      if(chartData.length > 0){
        //Split items
        labelsData = chartData.slice(0, len);
        startRow = 0;
        endRow = len;
      }
      return labelsData;
    };
    
    var getThemeStyleDef = function(){
      var valueLabelStyle = ctx.styleManager.query('viz-legend-valueLabel');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    var hoverHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){ 
        return;
      }
      
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('eventRect') === -1){
          return;
        }
        
      var id = clickedItemClass.split('ID_')[1];
      var indicatedItem = d3.selectAll('.legend-indicatedRect-'+randomSuffix+'-ID_'+id);
      indicatedItem.attr('fill', '#cccccc');
    };
    
    var blurHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        return;
      }
      
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('eventRect') === -1){
          return;
        }
        
        var id = clickedItemClass.split('ID_')[1];
        var indicatedItem = d3.selectAll('.legend-indicatedRect-'+randomSuffix+'-ID_'+id);
      indicatedItem.attr('fill', 'rgba(0,0,0,0)');
    };
    
    var itemClicked = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        return;
      }
      
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('eventRect') === -1){
          return;
        }
        
        var id = clickedItemClass.split('ID_')[1];
        var indicatedItem = d3.selectAll('.legend-indicatedRect-'+randomSuffix+'-ID_'+id);
      indicatedItem.attr('fill', '#808080');
    };
    
    chart.clickHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        return;
      }
      
      //TODO
      if(d3.event.type === 'touchstart'){
        //VD effect
        itemClicked();
      }  
      
      var isSelected = false;
      
      if(_contains(selectedItem, d3.event.target)){
        //has been selected.
        isSelected = true;
      }else{
        //New selected item
        selectedItem.push(d3.event.target);
      }
      return isSelected;
    };
    
    chart.deselectByCtx = function(deselectedData){
      if(!deselectedData){
        //deslected All items. Remove all selected legend items.
        selectedItem = [];
//        d3.selectAll('.indicatedRect').attr('fill', 'rgba(0,0,0,0)');
      }else{
        var itemData, isSame = true;
        for(var i = 0, len = selectedItem.length; i < len; i++){
          isSame = true;
          itemData = selectedItem[i].__data__.ctx.path;
          if(!itemData){
            itemData = selectedItem[i].__data__.ctx.ranges;
            if(itemData !== deselectedData.ctx.ranges){
              isSame = false;
            }
          }else{
            for(var k in itemData){
              if(deselectedData.ctx.path[k] !== undefined){
                if(deselectedData.ctx.path[k].length > 0){
                  if(deselectedData.ctx.path[k] !== itemData[k]){
                    isSame = false;
                  }
                }else{
                  if(deselectedData.ctx.path[k] !== itemData[k]){
                    isSame = false;
                  }
                }
              }
            }
          }
          
          if(isSame === true){
            //remove the deselected item.
            selectedItem.splice(i, 1);
            break;
          }
        }
      }
    };
    
    //Utility method.
    var _contains = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return true;
            }
        }
        return false;
    };
    
    /*
     * Calculate legend row position and return legend max size. 
     */
    var _calculateRowPosition = function(wholeSize) {
      var maxHeight = 0, maxWidth = 0, minWidth = 0,
        maxRowTextSize = {'width':0, 'height':0}, 
        labelsData = chartData,
        maxRowWidth = 0;
      if(labelsData && labelsData.length > 0){
        var labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
        
        var rowLabelSize = [], xPos = 0, yPos = 0; //each row text width
        textHeight = parseInt(valueLabelFont.fontsize, 10); //1em
        rowPosArr = [];
        
        var i, j, len, jLen;
        //Measure labels size
        //If colors feed don't have MND, can't show legend in hierarchy.
        if((options.legendType !== 'BubbleColorLegend') && options.isHierarchy){
          //Measure hierarchy legend
          var labelItem, rowItems, rowItemSize, maxRowItemSize = {'width' : 0, 'height': 0}, lastRowLabel = [];
          for(i = 0, len = labelsData.length; i < len; i++) {
            //'China / 2001 / Car - Profit' TO ['China', '2001', 'Car', 'Profit']
            labelItem = labelsData[i].val;
            labelItem = labelItem.replace('-', '/');
            rowItems = labelItem.split(' / ');
            
            //Create each row's sub elements.
            var isShowWholeItem = false;
            for(j = 0, jLen = rowItems.length - 1; j < jLen; j++) {
              if(lastRowLabel[j] !== rowItems[j]) {
                //Only with last label and color label
                isShowWholeItem = true;
                break;
              }
            }
            
            //Calculate each row's max item size
            var itemHeight = 0;
            for(j = 0, jLen = rowItems.length; j < jLen; j++) {
              rowItemSize = TextRuler.measure(rowItems[j], labelFont);
              if(j === jLen - 1){
                rowItemSize.width = rowItemSize.width + (colorLabelSize + colorLabelMarginRight)*textHeight;
                itemHeight = itemHeight + (rowMarginBottom+1) * textHeight;
              }else if(isShowWholeItem){
                itemHeight = itemHeight + (rowMarginBottom+1) * textHeight;
              }
              rowItemSize.width = rowItemSize.width + 10*j;
              if(rowItemSize.width > maxRowItemSize.width){
                maxRowItemSize = rowItemSize; 
              }
              lastRowLabel[j] = rowItems[j];
            }
            if(maxRowItemSize.width > maxRowWidth){
              maxRowWidth = maxRowItemSize.width;
            }
            rowLabelSize.push(itemHeight);
            
            //Calculate each row's position
            // if(options.position === 'left' || options.position === 'right') {
              if(i > 0){
                yPos = yPos + rowLabelSize[i-1];              
              }
              if(yPos + textHeight > wholeSize.height){
                break;
              }
            // }else{
  //             
            // }
            rowPosArr.push({x: xPos, y: yPos});
          }
          maxWidth = xPos + maxRowWidth;
          maxHeight = yPos + rowLabelSize[rowLabelSize.length - 1];
          
          minWidth = TextRuler.measure('M...', labelFont).width;
        }else{
          var labelText, rowTextSize;
          //Calculate each row's position
          if(options.position === 'left' || options.position === 'right') {
            var rowTextLength;
            for(i = 0, len = labelsData.length; i < len; i++){
              //Set Y-Position
              if(i > 0){
                yPos = yPos + textHeight + textHeight*rowMarginBottom;
              }
              if(yPos + textHeight > wholeSize.height){
                break;
              }
              rowPosArr.push({x: xPos, y: yPos});
              
              //Set max text length
              labelText = labelsData[i].val;
              if(labelsData[i].size === undefined){
                labelsData[i].size = TextRuler.measure(labelText, labelFont);
              }
              rowTextLength = labelsData[i].size;
              if(rowTextLength.width > maxRowTextSize.width){
                maxRowTextSize = rowTextLength;
              }
              
//              rowTextLength = labelText.length;
//              //Get longest text item
//              if(rowTextLength > maxRowTextLength){
//                maxRowTextLength = rowTextLength;
//                maxRowTextIndex = i;
//              } else if(rowTextLength === maxRowTextLength){
//                var a = TextRuler.measure(labelsData[maxRowTextIndex].val, labelFont).width;
//                var b = TextRuler.measure(labelsData[i].val, labelFont).width;
//                if(b > a){
//                  maxRowTextIndex = i;
//                }
//              }
            }
//            if(labelsData[maxRowTextIndex]){
//              maxRowTextSize = TextRuler.measure(labelsData[maxRowTextIndex].val, labelFont);
//            }
          }else{
            for(i = 0, len = labelsData.length; i < len; i++){
              labelText = labelsData[i].val;
              rowTextSize = TextRuler.measure(labelText, labelFont);
              rowLabelSize.push(rowTextSize.width);
              
              //Calculate each row's position
              if(i > 0){
                xPos = xPos + (colorLabelSize + colorLabelMarginRight) * textHeight + rowLabelSize[i-1];              
              }
              if(xPos + textHeight > wholeSize.height){
                break;
              }
              rowPosArr.push({x: xPos, y: yPos});
            }
          }
          
          //Calculation final row text size.
          maxRowWidth = (colorLabelSize + colorLabelMarginRight) * textHeight + maxRowTextSize.width;
          if(options.position === 'left' || options.position === 'right') {
            maxWidth = xPos + maxRowWidth;
            maxHeight = yPos + textHeight;
          }else{
            maxWidth = xPos + rowLabelSize[rowLabelSize.length -1] + (colorLabelSize + colorLabelMarginRight) * textHeight;
            maxHeight = maxRowTextSize.height;          
          }
          minWidth = xPos + (colorLabelSize + colorLabelMarginRight) * textHeight + TextRuler.measure('M...', labelFont).width; 
        }
      }
      if(minWidth > maxWidth){
        minWidth = maxWidth;
      }
      return {
        minHeight : 2 * textHeight,
        minWidth: minWidth,
        height: maxHeight,
        width: maxWidth
      };
    };
    
    var createRowWithColorLabel = function(wrap, index, isShowColorLabel, labelText) {
      var dx = 0, colorLabelType;
      var markerSize = colorLabelSize * textHeight;

      if(isShowColorLabel) {
        if(shapeFeedLength > 0){
          colorLabelType = shapes[index % (shapes.length > shapeFeedLength ? shapeFeedLength : shapes.length)];
        }else{
          if(options.legendType === 'BubbleColorLegend'){
            colorLabelType = (shapes[0] === undefined) ? 'square' : shapes[0];
          }else{
            var tmpShape = shapes[index % shapes.length];
            colorLabelType = (tmpShape === undefined) ? 'square' : tmpShape;
            if(colorLabelType === 'square'){
              colorLabelType = "squareWithRadius";
            }
          }
        }
        
        var centerPos = textHeight / 2; 
        var path = wrap.selectAll('path').data([labelText]);
        DrawUtil.createElements(path.enter(),{shape: colorLabelType, className: null} );
        path.attr("transform", function(d,i)
        {
          var color;
          if(shapeFeedLength > 0) {
            i = Math.floor(index / shapeFeedLength);
            var t = colors.length > colorFeedLength ? colorFeedLength : colors.length;
            if(t > 0){
              color = colors[i % t];
            }else{
              color = colors[0];
            }
          } else {
            color = colors[index % (colors.length > colorFeedLength ? colorFeedLength : colors.length)];
          }
          var parameter = {
              drawingEffect:options.drawingEffect,
              graphType:colorLabelType,
              fillColor : color,
              direction : 'vertical',
              rx: markerSize / 2,
              ry: markerSize / 2,
              borderWidth: 0,
              borderColor: "transparent",
              node:d3.select(this)
//              visibility: "visible"
          };
          DrawUtil.drawGraph(parameter, effectManager);
          return 'translate(' + centerPos + ',' + centerPos + ')';
          
        });
        dx = markerSize + colorLabelMarginRight * textHeight;
      }
      // item text label
      var text = wrap.selectAll('text').data([labelText]);
      text.enter().append('text');
      text.attr('x', dx).attr('y', textHeight).text(function(d) {
          return d;
        });
      
      var labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
      text.each(function(d) {
        TextRuler.ellipsis(d, this, width-dx, labelFont);
      });
      return wrap;
    };
    return chart;
  };
    
  return colorLegendArea;
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.legend.colorLegendArea',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.legend.sizeLegendArea',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.legend.mbcLegendArea',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(Manifest, TextRuler, TypeUtils, dispatch, ObjectUtils, ColorLegendArea, SizeLegendArea, MBCLegendArea, langManager,Objects, BoundUtil) {
  var legend = function(manifest, ctx) {
    var width, height, preferenceSize = {width: 200, height: 200}, position = 'right', titleFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '14px',
      'fontweight' : 'bold',
      'color' : '#333333'
    }, valueLabelFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '12px',
      'fontweight' : 'normal',
      'color' : '#333333'
    },options = {}, isVisible = true, isHidden = false, shapes = [], colors = [], textHeight = 20, 
    margin = {
      top : 0,
      right : 0,
      bottom : 0,
      left : 1.15
    }, titleMarginBottom = 0.5, legendAreaPos = {x:0, y:0}, sizeScale, sizeBubbleScale, sizeBubbleSpace, sizeBubbleHasHeightFeed, colorScale, hideTitle = false;
    
    //Each row's position [{x: 10, y: 10}, {...}...]
    var chartData = {title:'', labels:''}, bubleSizeData = [], data = null, shapeFeeds = [], colorFeeds = [], colorFeedLength = 0, shapeFeedLength = 0, relayout = true;
    var legendArea = ColorLegendArea(ctx);
    var eDispatch = new dispatch('highlightedByLegend');
    var effectManager = ctx.effectManager;
    var properties;
    var isHierarchicalChanged = false;
    var chart = function(selection) {
      BoundUtil.drawBound(selection, width, height);
      selection.each(function() {
        if(isColorLegend() || isBubbleColorLegend()){
          if(chartData.labels.length === 0){
            isVisible = false;
          }
        }
        
        if(isVisible && !isHidden){
          getThemeStyleDef();
          
          if(relayout){
            _calculateRowPosition({'width': width, 'height' : height});
          }

          var xPos = margin.left * textHeight, yPos = margin.top * textHeight;
          
          var wrap = d3.select(this).selectAll('g.legend-content').data([chartData]);
          wrap.enter().append('g').attr('class', 'legend-content');//.attr('clip-path', 'url(#legend-edge-clip)');
          if (isHierarchicalChanged){
            isHierarchicalChanged = false;
            wrap.selectAll('.legend .row').remove();
          }
          //Legend Title
          if(options.isShowTitle && !hideTitle) {
            var titleTextHeight = parseInt(titleFont.fontsize, 10);
            var titleStyle = 'font-weight: ' + titleFont.fontweight +'; fill:' + titleFont.color + '; font-family: ' + titleFont.fontfamily + '; font-size: '+titleFont.fontsize+";";
            var titleLabel = (options.titleText===undefined || options.titleText === null) ? chartData.title : options.titleText;
            
            var labelTitleElement = wrap.selectAll('text.legend-labelTitle');
            if(labelTitleElement.empty()){
              labelTitleElement = wrap.append('text').attr('class', 'legend-labelTitle');
            }
            labelTitleElement.text(titleLabel).attr('dx', xPos).attr('dy', yPos + titleTextHeight).attr('style', titleStyle).attr('visibility', 'visible');
            
            //Show ... in title 
            labelTitleElement.each(function(d) {
              TextRuler.ellipsis(titleLabel, this, width-xPos, titleStyle);
            });
          }else{
            wrap.selectAll('text.legend-labelTitle').attr('visibility', 'hidden');
            if (hideTitle) {
                hideTitle = false;
            } 
          }
  
          var labelsData = chartData.labels;
          // Create Legend Groups
          var gEnterCol = wrap.selectAll('g.legend-groups').data([labelsData]);
          gEnterCol.enter().append('g').attr('class', 'legend-groups');
          gEnterCol.attr('transform', 'translate('+legendAreaPos.x+','+legendAreaPos.y+')');
  
          var tmpWidth = ((width===undefined) ? preferenceSize.width : width) - xPos;
          var tmpHeight = ((height===undefined) ? preferenceSize.height : height) - yPos;
          //TODO Need to handle legend in the top/bottom side.
          legendArea.properties(options).width(tmpWidth).height(tmpHeight-legendAreaPos.y).effectManager(effectManager);
          if(isSizeLegend()){
            legendArea.data(bubleSizeData).scale(sizeScale);
          }else if(isMeasureBasedColoringLegend()){
            legendArea.data(labelsData).color(colorScale.range());
          }else{
            legendArea.data(labelsData).color(colors).colorFeedLength(colorFeedLength).shapeFeedLength(shapeFeedLength);
          }
          //Bind click handler in legend labels
          gEnterCol.call(legendArea).on('click', clickHandler).on('touchstart', clickHandler);
          
          //Vertical align to center
          if(options.position === 'left' || options.position === 'right') {
            switch(options.alignment){
              case 'end':
                wrap.attr('transform', 'translate(0, '+(((height-preferenceSize.height) > 0) ? ((height-preferenceSize.height)) : 0)+')');
                break;
              case 'middle':
                wrap.attr('transform', 'translate(0, '+(((height-preferenceSize.height)/2 > 0) ? ((height-preferenceSize.height)/2) : 0)+')');
                break;
            }
          }
        }else{
          //Handle visible is false.
                    var elements = d3.select(this).selectAll('g.legend-content');
                    if (!elements.empty()) {
                        elements.remove();
                    }
//          var clipPathWrap = d3.select(this).select('#legend-edge-clip');
//          if(!clipPathWrap.empty()){
//            clipPathWrap.remove();
//          }
        }
        isHidden = false;
      });
    };

    var clickHandler = function(data){
      if(options.isHierarchy) {
        return;
      }
      
      var className = d3.select(d3.event.target).attr('class');
      //TODO Use class name to check clicked item. Color legend and mbc legend use the same class name.
      if(className){
        var isSelected = legendArea.clickHandler();
        var index = parseInt(d3.select(d3.event.target).attr('class').split('ID_')[1], 10);
        if(chartData.labels[index] !== undefined){
          eDispatch.highlightedByLegend(chartData.labels[index], isSelected);
        }
      }
    };
    
    chart.deselectLegend = function(deselectedData){
      //TODO MBC support legend interaction.
      if(!(isMeasureBasedColoringLegend() || isSizeLegend())){
        legendArea.deselectByCtx(deselectedData);
      }
    };
    
    chart.width = function(_) {
      if(!arguments.length){
        return width;
      }
      width = _;
      relayout = true;
      return chart;
    };

    chart.height = function(_) {
      if(!arguments.length){
        return height;
      }
      height = _;
      relayout = true;
      return chart;
    };

    chart.position = function(_) {
      if(!arguments.length){
        return position;
      }
      position = _;
      return chart;
    };

    chart.colorPalette = function(_) {
      if(!arguments.length){
        return colors;
      }
      colors = _;  
      legendArea.color(_);
      return chart;
    };

    chart.shapes = function(_) {
      if(!arguments.length){
        return shapes;
      }
      shapes = _;
      legendArea.shapes(_);
      return chart;
    };

    chart.properties = function(props) {
      if(!arguments.length){
        return properties;
      }
      //TODO use extends...
      if (properties && props && properties.isHierarchical !== props.isHierarchical){
        isHierarchicalChanged = true;
      }
      Objects.extend(true, properties, props);
      options.visible = properties.visible;
      isVisible = options.visible;
      options.isShowTitle = properties.title.visible;
      options.titleText = properties.title.text;
      options.isHierarchy = properties.isHierarchical;
      options.position = properties.position;
     
      options.formatString = properties.formatString;
      
      if(options.legendType !== properties.type){
        options.legendType = properties.type;
        if(data && chartData.labels){
          parseFeedsData(data);
          legendArea.data(chartData.labels);
        }
      }
      options.alignment = properties.alignment;
      options.drawingEffect = properties.drawingEffect;
      
      if(isSizeLegend()){
        legendArea = SizeLegendArea(ctx);
        
      }else if (isMeasureBasedColoringLegend()){
        legendArea = MBCLegendArea(ctx);
      }
      legendArea.properties(options);
      return chart;
    };

    chart.getPreferredSize = function(wholeSize, layoutSpace, containerInfo) {
      getThemeStyleDef();
      return _calculateRowPosition(wholeSize, layoutSpace, containerInfo);
    };
    
    chart.data = function(_) {
      if(!arguments.length){
        return data;
      }
      data = _;
      parseFeedsData(_);
      legendArea.data(chartData.labels);
      return chart;
    };
    
    chart.sizeLegendInfo = function(_){
      if(!arguments.length){
        return sizeScale;
      }
      //Size scale
      sizeScale = _.scale;
      legendArea.scale(sizeScale);
      
      sizeBubbleScale = _.bubbleScale;
      
      sizeBubbleSpace = _.space;
      
      sizeBubbleHasHeightFeed = _.hasHeightFeed;
      
      //Size data
      if(_.data.length === 0){
        isVisible = false;
      }else{
        isVisible = options.visible;
        bubleSizeData = _.data;
        legendArea.data(bubleSizeData);
      }
      
      //Size legend title
      chartData.title = handleNull(_.title);
      
      return chart;
    };
    
    chart.hideTitle = function() {
        hideTitle = true;
        return chart;
    },
    
    chart.hide = function(_) {
        isHidden = _;
        return chart;
    },
    
    /*
     * Measure based coloring
     */
    chart.mbcLegendInfo = function(_){
      if(!arguments.length){
        return colorScale;
      }
      if(_.colorScale === undefined){
        isVisible = false;
      }else{
        isVisible = options.visible;
        colorScale = _.colorScale;
        //Legend title
        chartData.title = handleNull(_.title);
        _parseMeasureBasedColoringLegend();
        legendArea.data(chartData.labels);
      }
      return chart;
    };
    
    chart.setSelectionMode = function(_){
      if(!(isMeasureBasedColoringLegend() || isSizeLegend())){
        legendArea.setSelectionMode(_);
      }
    };
    
    /**
     * get/set your event dispatch if you support event
     */
      chart.dispatch = function(_){
        if(!arguments.length){
          return eDispatch;
        }
        eDispatch = _;
        return chart;
      };
    
      //alex su
      chart.isVisible = function(){
        return isVisible;
      };
      
    var getThemeStyleDef = function(){
      var titleStyle = ctx.styleManager.query('viz-legend-title');
      if(titleStyle){
        if(titleStyle['fill']){
          titleFont.color = titleStyle['fill'];
        }
        if(titleStyle['font-family']){
          titleFont.fontfamily = titleStyle['font-family'];
        }
        if(titleStyle['font-size']){
          titleFont.fontsize = titleStyle['font-size'];
        }
        if(titleStyle['font-weight']){
          titleFont.fontweight = titleStyle['font-weight'];
        }
      }
      
      var valueLabelStyle = ctx.styleManager.query('viz-legend-valueLabel');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    var buildColorShapeFeeds = function(feed){
      if(isColorFeeds(feed.key)) {
        colorFeeds = feed.values;
      } else {
        if(isShapeFeeds(feed.key)) {
          shapeFeeds = feed.values;
        }
      }
    };
    
    var parseFeedsData = function(data) {
      if(!data){
        return;
      }
      colorFeeds = [];
      shapeFeeds = [];
      var aa = data.getAnalysisAxisDataByIdx(0);
      if(aa){ 
        colorFeeds = aa.values;
      }
      
      aa = data.getAnalysisAxisDataByIdx(1);
      if(aa){
        shapeFeeds = aa.values;
      }
      
      if(isBubbleColorLegend()){
        _parseBubbleColorLegendFeeds();
      }else if(!(isSizeLegend())){
        _parseColorLegendFeeds();
      }
    };
    
    var _parseMeasureBasedColoringLegend = function(){
      var labels = [], item = {
        'val' : undefined,
        'ctx' : {}
      };
      var mbcDomains = colorScale.domain();
      for(var len = mbcDomains.length, i = 0, j = len-1; i < len; i++){
        if(mbcDomains[i].length > 0){
//          item.val = '[ ' + mbcDomains[i][0] + ' ; ' + mbcDomains[i][1] + ( i===len-1 ? ' ]' : ' [');
          item.val = mbcDomains[i][0];
          item.ctx.ranges = {
            startValue : mbcDomains[i][0],
            endValue : mbcDomains[i][1],
            isRightOpen : true,
            isLeftOpen : false
          };
        }else{
          item.val = 'N/A';
          item.ctx.ranges = {};
          if(labels[j+1] !== undefined){
            labels[j+1].ctx.ranges.isRightOpen = false;
          }
        }
        if(j === 0){
          item.ctx.ranges.isRightOpen = false;
        }
        labels[j] = {};
        ObjectUtils.extend(true, labels[j--], item);
      }
      
      chartData.labels = labels;
    };
    
    var _parseBubbleColorLegendFeeds = function(){
      var labels = [], title ='', tmpVal = '', i, j = 0, len, tmpLabel={
        'val' : undefined,
        'ctx' : {
          'path' : {}
        }
      }, dii;
      colorFeedLength = 0, shapeFeedLength = 0;
      
      if(colorFeeds && colorFeeds.length > 0 && colorFeeds[0].rows.length > 0){
        var firstColorFeed = colorFeeds[0];
        title = handleNull(firstColorFeed.col.val);
        
        dii = 'dii_a'+(firstColorFeed.rows[0].ctx.path.aa+1);
        tmpLabel = {
          'val' : firstColorFeed.rows[0].val,
          'ctx' : {
            'path' : { }
          },
          'info' : firstColorFeed.rows[0].info
        };
        tmpLabel.ctx.path[dii] = [firstColorFeed.rows[0].ctx.path.dii];
        
        for(i = 1, len = firstColorFeed.rows.length; i < len; i++){
          tmpVal = firstColorFeed.rows[i].val;
          if(tmpVal === tmpLabel.val || _containsVal(labels, tmpVal)){
            tmpLabel.ctx.path[dii].push(firstColorFeed.rows[i].ctx.path.dii);
          }else{
            labels[j] = {};
            tmpLabel.val = resolveCustomLabel(tmpLabel);
            ObjectUtils.extend(true, labels[j++], tmpLabel);
            //New color label. Add it to uniqueColorLabel and assign its new color
            tmpLabel.val = tmpVal;
            tmpLabel.ctx = {
              path : { }
            };
            tmpLabel.ctx.path[dii] = [firstColorFeed.rows[i].ctx.path.dii];
          }
        }
        //Add the last one
        labels[j] = {};
        tmpLabel.val = resolveCustomLabel(tmpLabel);
        ObjectUtils.extend(true, labels[j], tmpLabel);
        
        colorFeedLength = labels.length;
      }
      
      if(shapeFeeds && shapeFeeds.length > 0) {
        var firstShapeFeed = shapeFeeds[0], shapeLabels=[];
        title = (title === '') ? handleNull(firstShapeFeed.col.val) : title + " / " + handleNull(firstShapeFeed.col.val);
        
        dii = 'dii_a'+(firstShapeFeed.rows[0].ctx.path.aa+1);
        tmpLabel = {
          'val' : firstShapeFeed.rows[0].val,
          'ctx' : {
            'path' : {}
          },
          'info' : firstShapeFeed.rows[0].info
        }, j = 0;
        tmpLabel.ctx.path[dii] = [firstShapeFeed.rows[0].ctx.path.dii];
        
        for(i = 1, len = firstShapeFeed.rows.length; i < len; i++){
          tmpVal = firstShapeFeed.rows[i].val;
          if(tmpVal === tmpLabel.val || _containsVal(shapeLabels, tmpVal)){
            tmpLabel.ctx.path[dii].push(firstShapeFeed.rows[i].ctx.path.dii);
          }else{
            shapeLabels[j] = {};
            tmpLabel.val = resolveCustomLabel(tmpLabel);
            ObjectUtils.extend(true, shapeLabels[j++], tmpLabel);
            //New shape label. Add it to uniqueColorLabel and assign its new color
            tmpLabel.val = tmpVal;
            tmpLabel.ctx = {
              path : {}
            };
            tmpLabel.ctx.path[dii] = [firstShapeFeed.rows[i].ctx.path.dii];
          }
        }
        //Add the last one
        shapeLabels[j] = {};
        tmpLabel.val = resolveCustomLabel(tmpLabel);
        ObjectUtils.extend(true, shapeLabels[j], tmpLabel);

        shapeFeedLength = shapeLabels.length;
        if(labels.length > 0){
          labels = getCartesian([labels, shapeLabels], ' / ');
        }else{
          labels = shapeLabels;
        }
      }
      
      if(labels.length === 0){
        isVisible = false;
      }else{
        isVisible = options.visible;
      }
       
      chartData = {
        'title' : title,
        'labels' : labels
      };
    };
    
    var _parseColorLegendFeeds = function(){
      var title, labels = [];
      var colorData = _parseLegendFeed(title, colorFeeds, colorFeedLength);
      colorFeedLength = colorData.feedsLength;
      var shapeData = _parseLegendFeed(title, shapeFeeds, shapeFeedLength);
      shapeFeedLength = shapeData.feedsLength;
      
      //Color and Shape Cartesian
      if(shapeData.labels.length > 0){
        if(colorData.labels.length > 0){
          if(colorData.MNDInfo.MNDIndex === undefined && shapeData.MNDInfo.MNDIndex === undefined){
            //Has color and shape feed and no MND. So use '/'
            labels = getCartesian([colorData.labels, shapeData.labels], ' / ');
            title = colorData.title + " / " + shapeData.title;
          }else {
            if((colorData.MNDInfo.MNDIndex !== undefined && !colorData.MNDInfo.hasOnlyMND) || (shapeData.MNDInfo.MNDIndex !== undefined && !shapeData.MNDInfo.hasOnlyMND)){
              labels = getCartesian([colorData.labels, shapeData.labels], ' - ');
              title = colorData.title + " - " + shapeData.title;
            } else if (colorData.MNDInfo.MNDIndex !== undefined && colorData.MNDInfo.hasOnlyMND){
              labels = shapeData.labels;
              title = shapeData.title;
            } else {
              labels = colorData.labels;
              title = colorData.title;
            }
              
          } 
        }else{
          labels = shapeData.labels;
          title = shapeData.title;
        }
      }else{
        labels = colorData.labels;
        title = colorData.title;
      }

      if(labels.length === 0){
        isVisible = false;
      }else{
        isVisible = options.visible;
      }
      chartData = {
        'title' : title,
        'labels' : labels
      };
    };
    
    var _parseLegendFeed = function(title, feeds, feedsLength){
      var labels = [], rows = [], dimensionTag = ' / ', measureTag = ' - ';
      var MNDIndex, hasOnlyMND = false, i, j, len;
      //Handle colors feeds
      if(feeds && feeds.length > 0){
        for(i = 0, len = feeds.length; i < len; i++) {
          if(feeds[i].type !== 'MND') {
            if(title === undefined) {
              title = handleNull(feeds[i].col.val);
            } else {
              title = title + dimensionTag + handleNull(feeds[i].col.val);
            }
            
            rows = feeds[i].rows;
            for(j = 0; j < rows.length; j++) {
              if(labels[j] === undefined) {
                labels[j] = {};
                labels[j].val = resolveCustomLabel(rows[j]);
                labels[j].ctx = {
                  path : _setPathByaa(rows[j].ctx.path)
                };
              } else {
                labels[j].val = labels[j].val + dimensionTag + resolveCustomLabel(rows[j]);
              }
            }
          } else {
            MNDIndex = i;
          }
        }
        feedsLength = labels.length;
      }
      
      //Handle Colors with MND
      if(MNDIndex !== undefined) {
        //Save color feed with MND status.
        if(labels.length > 0){
          if(feeds[MNDIndex].rows.length > 1){
            if(MNDIndex === 0) {
              title = langManager.get('IDS_DEFAULTMND') + measureTag + title; 
              //MND is the first feed type. Legend label should be 'MND - A/B/C'
              labels = getCartesian([handleNullInArray(feeds[MNDIndex].rows), labels], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } else if(MNDIndex === feeds.length - 1) {
              title = title + measureTag + langManager.get('IDS_DEFAULTMND');
              //MND is the last feed type. Legend label should be 'A/B/C - MND'
              labels = getCartesian([labels, handleNullInArray(feeds[MNDIndex].rows)], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } 
          }
        }else{
          title = langManager.get('IDS_DEFAULTMND');
          rows = feeds[MNDIndex].rows;
          for(j = 0; j < rows.length; j++) {
            labels[j] = {};
            labels[j].val = resolveCustomLabel(rows[j]);
            labels[j].ctx = rows[j].ctx;
          }
          feedsLength = rows.length;
          if(rows.length === 1){
            hasOnlyMND = true;
          }
        }
      }
      
      return {
        'title' : title,
        'labels' : labels,
        'feedsLength' : feedsLength,
        'MNDInfo' : {
          'MNDIndex' : MNDIndex,
          'hasOnlyMND': hasOnlyMND //Only has MND, no cartesian
        }
      };
    };
    
    var _setPathByaa = function(path){
      var pathObj = {};
      switch(path.aa){
        case 0:
          pathObj.dii_a1 = path.dii;
          break;
        case 1:
          pathObj.dii_a2 = path.dii;
          break;
        case 2:
          pathObj.dii_a3 = path.dii;
          break;
      }
      return pathObj;
    };
    
    /*
     * Calculate legend row position and return legend max size. 
     */
    var _calculateRowPosition = function(wholeSize, layoutSpace, containerInfo) {
      var maxHeight = 0, maxWidth = 0, minWidth = 0, minHeight = 0, titleSize = {width:0, height:0}, legendAreaSize = {};
      
      //Cal legend size and position.
      if(options.visible){
        var labelFont = "font-size:" + titleFont.fontsize + "; font-weight:" + titleFont.fontweight + "; font-family:" + titleFont.fontfamily;
        
        textHeight = parseInt(valueLabelFont.fontsize, 10); //1em
        
        var xPos = margin.left * textHeight, yPos = margin.top * textHeight;
        
        //Measure title size
        if(options.isShowTitle) {
          titleSize = TextRuler.measure(((options.titleText===undefined || options.titleText === null) ? chartData.title : options.titleText), labelFont);
          if (!hideTitle) {
              yPos = yPos + titleSize.height + titleMarginBottom * textHeight;
          }
        }
        
        //Legend Area Position
        legendAreaPos = { x : xPos, y: yPos};
        
        legendAreaSize = legendArea.getPreferredSize({height: wholeSize.height-xPos, width: wholeSize.width}, layoutSpace, xPos, containerInfo, sizeBubbleScale, sizeBubbleSpace, sizeBubbleHasHeightFeed);
        
        if(legendAreaSize.width > 0 && legendAreaSize.height > 0){
          //Measure labels size
          //If colors feed don't have MND, can't show legend in hierarchy.
          if(!isBubbleColorLegend() && options.isHierarchy){
            maxWidth = xPos + ((titleSize.width > legendAreaSize.width) ? titleSize.width : legendAreaSize.width);
            maxHeight = yPos + legendAreaSize.height;
          }else{
            if(options.position === 'left' || options.position === 'right') {
              maxWidth = xPos + ((titleSize.width > legendAreaSize.width && !isSizeLegend()) ? titleSize.width : legendAreaSize.width);
              maxHeight = yPos + legendAreaSize.height;
            }else{
              maxWidth = xPos + legendAreaSize.width;
              maxHeight = titleSize.height + titleMarginBottom * textHeight + textHeight;          
            }
          }
          minWidth = xPos + (legendAreaSize.minWidth ? legendAreaSize.minWidth : 0);
          minHeight = yPos + (legendAreaSize.minHeight ? legendAreaSize.minHeight : 0);
        }
        
        relayout = false;
      }
      
      //create preference size object.
      preferenceSize = {
          maxSizeConstant : 1 / 3,
          titleSize : titleSize,
          minWidth: minWidth,
        height: maxHeight,
        width: maxWidth
      };
      if(legendAreaSize.minHeight){
        preferenceSize.minHeight = minHeight;
      }
      return preferenceSize;
    };
    
    var _containsVal = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i].val === obj) {
                return true;
            }
        }
        return false;
    };
    
    var getCartesian = function(arrays, symbol) {
      var result = arrays[0];
      var fff = function(arr) {
        var ar = result;
        result = [];
        for(var i = 0; i < ar.length; i++) {
          for(var j = 0; j < arr.length; j++) {
            var t1 = (ar[i].val === undefined) ? ar[i].val : ar[i].val, t2 = (arr[j].val === undefined) ? arr[j].val : arr[j].val;
            var ctx = {
              path : {}
            };
            ObjectUtils.extend(ctx.path, ar[i].ctx.path, arr[j].ctx.path);
            result.push({
              'val': t1 + symbol + t2, 
              'ctx': ctx
            });
          }
        }
      };
      for(var i = 1; i < arrays.length; i++) {
        fff(arrays[i]);
      }

      return result;
    };
    
    var isColorFeeds = function(feedName){
      var result = false;
//      if(Manifest.feeds[feedName].semantic === 'COLOR'){
//        result = true;
//      }
      if(feedName.search('color') !== -1){
        result = true;
      }
      return result;
    };
    
    var isShapeFeeds = function(feedName){
      var result = false;
//      if(Manifest.feeds[feedName].semantic === 'SHAPE'){
//        result = true;
//      }
      if(feedName.search('shape') !== -1){
        result = true;
      }
      return result;
    };
    
    var isColorLegend = function(){
      var result = false;
      if(options.legendType === 'ColorLegend'){
        result = true;
      }
      return result;  
    };
    
    var isSizeLegend = function(){
      var result = false;
      if(options.legendType === 'SizeLegend'){
        result = true;
      }
      return result;  
    };
    
    var isBubbleColorLegend = function(){
      var result = false;
      if(options.legendType === 'BubbleColorLegend'){
        result = true;
      }
      return result;  
    };
    
    var isMeasureBasedColoringLegend = function(){
      var result = false;
      if(options.legendType === 'MeasureBasedColoringLegend'){
        result = true;
      }
      return result;  
    };
    
    //alex su
    var handleNull = function(_){
      var defaultString = langManager.get('IDS_ISNOVALUE');
      if (_ === null || _ === undefined){
        return defaultString;
      }
      else{ 
        return _;
      }
    };
    
    var resolveCustomLabel = function(rawObj){
      var ret;
      if(rawObj.info){
        var clobj = rawObj.info.customlabel;
        if(clobj){
          if(clobj.type === 'url'){
            //Jimmy/12/27/2012 do we still need the orginal value in legend here?
            ret = rawObj.val;
          }else if(clobj.type === 'string'){
            ret = clobj.val;
          }
        }else{
          ret = rawObj.val;
        }
      }else{
        ret = rawObj.val;
      }
      ret = handleNull(ret);
      return ret;  
    };
    
    var handleNullInArray = function(array){
      for (var i = 0; i < array.length; ++i){
        array[i].val = handleNull(array[i].val);
      }
      return array;
    };
    
//    var handleNullInArray = function(array){
//      var newArray = cloneObject(array);
//      for (var i = 0; i < newArray.length; ++i)
//        newArray[i].val = handleNull(newArray[i].val);
//      return newArray;
//    };
//    
//    var cloneObject = function(object){
//
//          if(typeof(object)!='object') return object;
//          if(object==null) return object;
//          
//          var o=Object.prototype.toString.call(object)==='[object Array]'?[]:{};
//
//          for(var i in object){
//                  if(typeof object[i] === 'object'  ){
//                          o[i]=cloneObject(object[i]);
//                  }else o[i]=object[i];
//          }
//          
//          return o;
//    };
    
    properties = manifest.props(null);
    chart.properties(null);
    return chart;
  };
  return legend;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.legend',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.legend',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'legend',
    'description': 'The legend is a box containing a symbol and name for each series item or point item in the chart.',
    'properties' : {
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of legend.'
      },
      'title' : {
        'name' : 'title',
      'description' : 'Settings for legend title.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set visibility of legend title.'
           }, 
          'text':{
            'name' : 'text',
            'supportedValueType' : 'String',
            'defaultValue' : null,
            'description' : 'Set text of legend title.'
           }
        }
      },
      'formatString': {
    		'name' : 'formatString',
    		'supportedValueType': 'String',
    		'defaultValue' : null,
    		'description' : 'Set format string of legend.',
    		'isExported': false
    	},
      'isHierarchical' : {
        'name' : 'isHierarchical',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set hierarchy legend. Supported only when legend is located in the right of chart.',
        'isExported': true
      },
      'position' : {
        'name' : 'position',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'right' ],
        'defaultValue' : 'right',
        'description' : 'Set legend position. Only support legend is located in the right side.',
        'isExported' : false
      },
      'type' : {
        'name' : 'type',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'ColorLegend', 'BubbleColorLegend', 'SizeLegend', 'MeasureBasedColoringLegend' ],
        'defaultValue' : 'ColorLegend',
        'description' : 'Set legend type of Bubble chart. Non-bubble chart is not supported.',
        'isExported' : false
      },
      'alignment' : {
        'name' : 'alignment',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'start', 'middle', 'end' ],
          'defaultValue' : 'start',
          'description' : 'Set alignment of legend.',
          'isExported' : false
      },
      'drawingEffect':{
        'name' : 'drawingEffect',
         'supportedValueType' : 'List',
          'supportedValues' : [ 'normal', 'glossy' ],
          'defaultValue' : 'normal',
          'description' : 'Set drawing effect of legend.',
          'isExported' : true
      }
    },
    'css' : {
      '.viz-legend-title' : {
        'description' : 'Define style for the legend title.',
        'value' : {
          'fill' : 'black',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '14px',
          'font-weight' : 'bold'
        }
      },
      '.viz-legend-valueLabel' : {
        'description' : 'Define style for the legend label.',
        'value' : {
          'fill' : 'black',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      }
    },
    'configure' : null,
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.title',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TextUtils, langManager, Objects, boundUtil) {
  var title = function(manifest, ctx) {
    var width = 500, height = 100; 
    var titleStyle = null;
    
    var options = {}, size = {
      width : 500,
      height : 100
        }, titleText = undefined;
    
    var chart = function(selection) {
      if (options.visible) {
        boundUtil.drawBound(selection, width, height);
        updateTitleStyle();
        var wrapper = this.selectAll('text.chart-title').data([titleText]);
        wrapper.exit().remove();
        wrapper.enter().append('text').attr('class', 'chart-title');
        wrapper.attr('style', titleStyle)
               .attr('text-anchor', function(){
                 if (options.alignment == 'right')
                    return 'end';
                 else if (options.alignment == 'left')
                    return 'start';
                 else
                    return 'middle';   
               })
               .attr('x', function() {
                 if (options.alignment == 'right')
                   return width;
                 else if (options.alignment == 'left')
                   return 0;
                 else
                   return (width) / 2; //"center" anyway
               }).attr('y', height/2);
        TextUtils.ellipsis(titleText, wrapper.node(), width, titleStyle);
      }
      
      return chart;
    };

    chart.width = function(value) {
      if(!arguments.length)
        return width;
      width = value;
      return chart;
    };

    chart.height = function(value) {
      if(!arguments.length)
        return height;
      height = value;
      return chart;
    };
    
    chart.size = function(value) {
      if(!arguments.length)
        return size;
      size = value;
      return chart;
    };

    chart.properties = function(properties) {
      if (!arguments.length)
        return options;

      Objects.extend(true, options, properties);

      if (options.text === undefined || options.text === null) {
        titleText = langManager.get('IDS_DEFAULTCHARTTITLE');
      }else{
        titleText = options.text;
      }

      return chart;
    };
    
    chart.getPreferredSize = function() {
      if (options.visible) {
        updateTitleStyle();
        var titleSize = TextUtils.measure(titleText, titleStyle);
        return {
          hideOversize : true,
          maxSizeConstant : 1 / 3,
          'width' : titleSize.width,
          'height' : titleSize.height
        };
      }
      
      return {
        'width' : 0,
        'height' : 0
      };      
    };
    
    function updateTitleStyle() {
      titleStyle = ctx.styleManager.cssText('viz-title-label');
    }
    
    options = manifest.props(null);
    return chart;
  };
  
  return title;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.title',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.title',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'title',
    'description': "Settings for the chart's main title.",
    'properties' : {
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set visibility of chart title.'
      },
      'text' : {
        'name' : 'text',
        'supportedValueType' : 'String',
        'defaultValue' : null,
        'description' : 'Set chart title text.'
      },
      'alignment' : {
        'name' : 'alignment',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'left', 'center', 'right' ],
        'defaultValue' : 'center',
        'description' : 'Set chart title alignment.'
      }
    },
    'css' : {
      '.viz-title-label' : {
        'description' : 'Define style for the title label.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '16px',
          'font-weight' : 'bold',
          'fill' : '#333333'
        }
      }
    },
    'configure' : null,
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(manifest, ObjectUtils, langManager) {
  /**
   * This is a instantce , which already have been registered into {@link sap.viz.manifest.feeds}.</br>
   * </br>
   * Now, once an item is loaded from {@link sap.viz.manifest.feeds}, it will automatically provide some APIs .</br>
   * </br>
   * @see sap.viz.manifest.feeds#get
   * @class Built-in_Manifest_Objects.feedsManifest
   * @example
   * var pieFeed = manifest.feeds.get(pieId);
   */
  return manifest.registerCategory("feeds", function(obj) {

    var feeds = {};
    obj.feeds.forEach(function(o) {
      feeds[o.id] = o;
      var na = o.name;
      delete o.name;
      Object.defineProperty(o, 'name', {
        get : function() {
          var res = langManager.get(na);
          if (res) {
            return res;
          }
          return na;
        },
        enumerable : true
      });
    });
    /**
     * This is a instantce , which already have been registered into {@link sap.viz.manifest.feeds}.</br>
     * </br>
     * Now, once an item is loaded from {@link sap.viz.manifest.feeds}, it will automatically provide some APIs .</br>
     * </br>
     * @see sap.viz.manifest.feeds#get
     * @class Built-in_Manifest_Objects.feedsManifest
     * @example
     * var pieFeed = manifest.feeds.get(pieId);
     * @ignore
     */
    Object.defineProperty(obj, "feedsMap", {
      value : feeds,
      writable : false,
      enumerable : false,
      configurable : false
    });

    return obj;
  });
});sap.riv.module(
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(manifest, feedsManifest, ObjectUtils, TypeUtils, Objects, constants, module,
    langManager) {
  function getModuleByType(modules, type) {
    for ( var i = 0; i < modules.length; ++i) {
      if (modules[i].module.type === type) {
        return modules[i];
      }
      if (modules[i].subModules) {
        var r = getModuleByType(modules[i].subModules, type);
        if (r) {
            return r;    
        }
          
      }
    }
    return null;
  }
  function overrideProperties (target, overProps){
    if(!overProps){
      return;
    }
    var tempPropName, tempPropObj;
    for(tempPropName in target){
      if(target.hasOwnProperty(tempPropName) && overProps.hasOwnProperty(tempPropName)){
        tempPropObj = target[tempPropName];
        if(tempPropObj.supportedValueType === 'Object'){
          overrideProperties(tempPropObj.supportedValues, overProps[tempPropName]);
        }else{
          tempPropObj.defaultValue = overProps[tempPropName];
        }
      }
    }
  }
  function filterProperties (target, filterInfo){
    var tempPropName, tempPropObj;
    for(tempPropName in target){
      if(target.hasOwnProperty(tempPropName)){
        if (target[tempPropName] === null){
          delete target[tempPropName];
          continue;
        }
        tempPropObj = target[tempPropName];
        /*[Jimmy/11/15/2012]what if we override supportedValueType in the propertyOverride?
         currently we don't know how to deal with it.
         * */
        if(filterInfo){
          Objects.extend(true, tempPropObj, filterInfo[tempPropName]);
        }
        if(tempPropObj.isExported === false){
          delete target[tempPropName];
        }else{
          if(tempPropObj.supportedValueType === 'Object'){
            filterProperties(tempPropObj.supportedValues, filterInfo ? filterInfo[tempPropName] : null);
            //if its type is object and with no children, we just delete it
            if(TypeUtils.isEmptyObject(tempPropObj.supportedValues)){
              delete target[tempPropName];
            } 
          } 
        }
      }
    }
  }
  function loadProperties(allProperties, modules) {
    if(modules){
      //3 properties we need take care of
      //propertyCategory, properties and propertiesOverride
      var mProps/*original module properties*/, 
          mcProps/*properties defined in chart manifest, aka module reference*/,
          moProps/*properties definition override in chart manifest, aka propertiesOverride*/,
          propCate/*property category*/,
          mRef/*module reference name in chart config*/;
      modules.forEach(function(o){//@Alex Su: configure module if module has one.
        if (o.config.configure){
          mRef = o.moduleRef;
          mProps = o.module.properties;
          mcProps = o.config.configure.properties;
          propCate = o.config.configure.propertyCategory;
          moProps = o.config.configure.propertiesOverride;
          allProperties[propCate] = Objects.extend(true, null, mProps);
          //we add a new meta data info here to indicate the reference path in chart configure of each property category        
          Object.defineProperties(allProperties[propCate], { 
            'moduleRefPath':{            
              get : (function(_refName) {
                return function() {
                  return _refName;
                };
              }(mRef)),
              enumerable : false
            }  
          });
          //filter out isExported=false, it can come from moProps or mProps
          filterProperties(allProperties[propCate], moProps);
          //override default values which come from mcProps
          overrideProperties(allProperties[propCate], mcProps);
        }
        loadProperties(allProperties, o.subModules);
      });
    }
  }

  function loadFeeds(allFeeds, modules, aaIndexOffset, mndProOffset) {
    if (modules) {
      modules.forEach(function(o) {
        var feeds = o.module.feeds;
        var newAAIndexOffset = aaIndexOffset;
        var newMNDProOffset = mndProOffset;
        if (feeds) {
          var moduleFeeds;
          var feedsId = feeds.id;
          if (feedsId !== undefined) {
            var feedsConfigure = feeds.configure;
            moduleFeeds = feedsManifest.get(feedsId).feedsMap;
            if (feedsConfigure) { 
              moduleFeeds = ObjectUtils.extend(true, null, moduleFeeds,
                  feedsConfigure);
              }
          } else {
            moduleFeeds = {};
            feeds.forEach(function(feed) {
              moduleFeeds[feed.id] = feed;
            });
          }
     
          var i;
          for (i in moduleFeeds) {
            if(moduleFeeds.hasOwnProperty(i)){
              var feed = moduleFeeds[i];
              if (feed) {
                feed = ObjectUtils.extend(true, null, feed);
                allFeeds[i] = feed;
                if (feed.type === constants.Feed.Type.Dimension) {
                  var aaIndex = feed.aaIndex;
                  aaIndex += aaIndexOffset;
                  if (newAAIndexOffset < aaIndex) {
                      newAAIndexOffset = aaIndex;
                  }
                   
                  feed.aaIndex = aaIndex;
  
                  var mndPro = feed.acceptMND;
                  if (mndPro >= 0) {
                    if (mndProOffset > 0) {
                      mndPro += mndProOffset;  
                    }
                      
  
                    if (newMNDProOffset < mndPro) {
                      newMNDProOffset = mndPro;
                      }
  
                    feed.acceptMND = mndPro;
                  }
                }
              }
            }
          }
          if (newMNDProOffset >= 0) {
              newMNDProOffset += 1;
          }
            

        }
        loadFeeds(allFeeds, o.subModules, newAAIndexOffset, newMNDProOffset);
      });
    }
  }
  /**
     * This is a instantce , which already have been registered into {@link sap.viz.manifest.viz}.</br>
     * </br>
     * Now, once an item is loaded from {@link sap.viz.manifest.viz}, it will automatically provide some APIs .</br>
     * </br>
     * @example
     * 
     * var allFeedOfBar = manifest.viz.get(barType).allFeeds();
     *
     * @see sap.viz.manifest.viz#get
     * @class Built-in_Manifest_Objects.vizManifest
     */
  return manifest
      .registerCategory(
          "viz",
          function(obj) {
            var modules =[];
            var configModules = obj.modules;
            for ( var moduleRefName in configModules) {
              if(configModules.hasOwnProperty(moduleRefName)){
                var moduleRef = configModules[moduleRefName];
                if (moduleRef !== null) {
                  manifest.module.loadModule(modules, moduleRef, moduleRefName);
                }
              }
            }

            var feedsConfigure = obj.feeds;
            var allFeeds, allRequiredFeeds, vizname = obj.name;
            var allProperties;
            delete obj.name;
            Object
                .defineProperties(
                    obj,
                    {
                      /**
                         * get the feeds definition of an item in {@link sap.viz.manifest.viz}
                         * @method Built-in_Manifest_Objects.vizManifest#allFeeds
                         * @return {[Object] allFeeds} all feeds definition of an item
                         * @example
                         * 
                         * var allFeedOfBar = sap.viz.manifest.viz.get('viz/bar').allFeeds();
                         *
                         */
                      allFeeds : {
                        value : function() {
                          if (!allFeeds) {
                            allFeeds = {};
                            loadFeeds(allFeeds, modules, 0, -1);
                            ObjectUtils.extend(true, allFeeds, feedsConfigure);
                            allFeeds = d3.values(allFeeds).filter(function(o) {
                              return o;
                            });
                          }

                          //Data Handler needs to know full feed definition including useless feed for data dispatching
                          var includeUselessFeed = !arguments.length || arguments[0] === false ? false : true;
                          if (includeUselessFeed === false){
                              if (!allRequiredFeeds){
                                  allRequiredFeeds = d3.values(allFeeds).filter(function(o) {
                                  if (o.min === 0 && o.max === 0){
                                      return false;
                                  }else {
                                      return true;
                                  }
                                  
                                  });
                              }
                              return allRequiredFeeds;
                          }else{
                              return allFeeds;
                          }
       
                        }
                      },
                      /**
                         * get all properties definition of an item in {@link sap.viz.manifest.viz}
                         * @method Built-in_Manifest_Objects.vizManifest#allProperties
                         * @return {[Object] allProperties} all properties definition of an item
                         * @example
                         * 
                         * var allPropertiesOfBarChart = sap.viz.manifest.viz.get('viz/bar').allProperties();
                         *
                         */
                      allProperties : {
                        /*we will go through all modules and merge their property definitions with properties override in chart manifest,
                         and return. note all the properties with isExport=false will be filtered out*/
                        value : function() {
                          if(!allProperties) {
                            allProperties = {};
                            loadProperties(allProperties, modules);
                          }
                          return allProperties;
                        }  
                      },
                      getChartPropCate : {
                        value : function() {
                          return getModuleByType(modules, 'CHART').config.configure.propertyCategory;
                        }
                      },
                      /**
                       * get the name of the visualization
                       * @property {String}  Built-in_Manifest_Objects.vizManifest#name
                       * @example
                       * var name = sap.viz.manifest.viz.get('viz/bar').name
                       */
                      name : {
                        get : function() {
                          var res = langManager.get(vizname);
                          if (res) {
                              return res;
                          }
                           
                          return vizname;
                        },
                        enumerable : true
                      }
                    });
            return obj;
          });
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.DataLabel',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'riv/base',
    name : 'IDS_BASECHART',
    'abstract' : true,
    modules : {
      title : {
        id : 'sap.viz.modules.title',
        configure : {
          propertyCategory : 'title'
        }
      },
      legend : {
        id : 'sap.viz.modules.legend',
        configure : {
          propertyCategory : 'legend'
        }
      }
    },
    dependencies : {

    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiChart = {
    id : 'riv/base/multiple',
    name : 'IDS_BASEMULTIPLECHART',
    base : 'riv/base',
    'abstract' : true,
    modules : {
      main : {
        id : 'sap.viz.modules.tablecontainer',
        configure : {
          propertyCategory : 'multiLayout'
        },
        modules: {
          xAxis2 : {
            id : 'sap.viz.modules.axis',
            configure : {
            'description': 'Settings for the column axis of multiple charts.',
              propertyCategory : 'columnAxis',
              properties : {
                title : {
                  visible : false
                },
                gridline : {
                  visible : true
                },
                color : '#d8d8d8',
                type : 'category',
                position : 'top'
              },
        propertiesOverride : {                  
                label : {
                isExported : false
                },
                axisline : {
                isExported : false
               },
              gridline:{
                isExported:false,
                 color: {
                 isExported:false
               },
              size: {
                 isExported:false
               }
            }
        }
            }
          },
          yAxis : {
            id : 'sap.viz.modules.axis',
            configure : {
            'description': 'Settings for the row axis of multiple charts.',
              propertyCategory : 'rowAxis',
              properties : {
                type : 'category',
                position : 'left',
                title : {
                  visible : false
                },
                color : '#d8d8d8',
                gridline : {
                  visible : true
                }
              },
              propertiesOverride : {                  
                label : {
                isExported : false
                },
                axisline : {
                isExported : false
               },
               gridline:{
                 isExported:false,
                 color: {
                      isExported:false
                    },
                 size: {
                      isExported:false
                    }
                 }
           }
            }
          },
          plot : {
            id : 'sap.viz.modules.xycontainer'
          }
        }
      }
    }
  };

  Manifest.register(multiChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiXYChart = {
    id : 'riv/base/multiple/xy',
    name : 'IDS_BASEMULTIPLEXYCHART',
    base : 'riv/base/multiple',
    'abstract' : true,
    modules : {
      tooltip : {
        id : 'sap.viz.modules.tooltip',
        configure : {
          propertyCategory : 'tooltip'
        }
      },
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              background : {
                id : 'sap.viz.modules.background',
                configure : {
                  propertyCategory : 'background',
                  properties : {
                    direction : 'vertical'
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'rectCoordinate',
                    visible : false,
                    position : 'inside',
                    automaticInOutside : true,
                    showZero : true,
                    isStackMode : false,
                    isPercentMode : false,
                    outsideVisible : true
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiXYChart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.XY',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var colorFeed = {
    'id' : 'regionColor',
    'name' : 'IDS_REGIONCOLOR',
    'type' : constants.Type.Dimension,
    'min' : 0,
    'max' : 2,
    'aaIndex' : 2,
    'acceptMND' : 1
  };

  var valueAxis1 = {
    'id' : 'primaryValues',
    'name' : 'IDS_PRIMARYVALUES',
    'type' : constants.Type.Measure,
    'min' : 1,
    'max' : constants.Constraints.INF,
    'mgIndex' : 1
  };

  var valueAxis2 = {
    'id' : 'secondaryValues',
    'name' : 'IDS_SECONDARYVALUES',
    'type' : constants.Type.Measure,
    'min' : 0,
    'max' : constants.Constraints.INF,
    'mgIndex' : 2
  };

  var dimension = {
    'id' : 'axisLabels',
    'name' : 'IDS_AXISLABELS',
    'type' : constants.Type.Dimension,
    'min' : 1,
    'max' : 2,
    'acceptMND' : 0,
    'aaIndex' : 1
  };

  var feeds = {
    id : "xy",
    feeds : [ colorFeed, dimension, valueAxis1, valueAxis2 ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.XY',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants) {
  var module = {
    'id' : 'sap.viz.modules.xy.base',
    'abstract' : true,
    'type' : Constants.Module.Type.Chart,
    'name' : 'xy base module',
    'datastructure' : 'DATA STRUCTURE DOC',
    'properties' : {  
    'colorPalette':
      {
         'name' : 'colorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.SAPColor,
          'description' : 'Set color palette for non_dual chart. Or dual chart\'s color palette if MND is on Category axis.'
      },
        'primaryValuesColorPalette' : {
          'name' : 'primaryValuesColorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.SAPColorDualAxis1,
          'description' : 'Set axis 1 color palette for dual chart.',
            'isExported' : false
        },  
        'secondaryValuesColorPalette' : {
          'name' : 'secondaryValuesColorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.SAPColorDualAxis2,
          'description' : 'Set axis 2 color palette for dual chart.',
            'isExported' : false
        },
        'drawingEffect':{
          'name' : 'drawingEffect',
           'supportedValueType' : 'List',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'description' : 'Set drawing effect of XY.',
            'isExported' : true
        },
    },
    'events' : {
      'initialized': Constants.Module.Event.Initialized.desc,
      'selectData' : Constants.Module.Event.SelectData.desc,
      'deselectData' : Constants.Module.Event.DeSelectData.desc,
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    'feeds' : {
      id : "xy"
    },
    'css' : null,
    'configure' : null
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.area',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(dispatch, MNDHandler, TypeUtils, Scaler, ColorSeries, BoundingBox, NumberUtils, langManager, DrawUtil, TooltipDataHandler, Manifest, Repository, Objects,UADetector, BoundUtil) 
{
  return function(manifest, ctx) 
  {
    var width, height;
    var data_ = null, props;
    //alistar zhu
    var randomSuffix = Repository.newId();
    //alex su
    var tooltipData = null;
    var _tooltipDataHandler;

    var bgColor = "#FFFFFF";
    var hoverColor = "#cccccc";
    var selectedColor = "#333333";
    var xScale = d3.scale.ordinal();
    var mouseMoveLine;
    var preHighLightIndex;
    var g;
    var svgMarkersGroup, svgAreasGroup, svgAreaBgGroup;
    var eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    var effectManager = ctx.effectManager;
    var valueAxis1Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        areas:[],
        bottomValue: null,
        topValue:null
    };

  
    var colorPalette = [];
    var bAnimationComplete = false;
    var enableDataLoadingAnimation = true;

    var selectedMarkerNum = 0;

    // clip defs for enimation

    var clipRect;
    
    var OPACITY = 0.4;
    
    var bDataUpdated = false;
    function area(selection) {
      //selection.each(generate);
      BoundUtil.drawBound(selection, width, height);
      //alex su
      _tooltipDataHandler = TooltipDataHandler();
      
      renderChart(selection);
      return area;
    }

   // For normal stacked area chart, currently we only use globally stacked 
//    function calculateStackedMinMax(axisValue, minMax)
//    {
//    
//      var accuPositiveValues = new Array(axisValue.data[0].length);
//      var accuNegativeValues = new Array(axisValue.data[0].length);
//      var i;
//      for(i = 0; i < accuPositiveValues.length; ++i)
//      {
//        accuPositiveValues[i] = 0;
//        accuNegativeValues[i] = 0;
//      }
//      for(i = 0; i < axisValue.data.length; ++i)
//      {
//        for(var j = 0; j < axisValue.data[i].length; ++j)
//        {
//          if(!NumberUtils.isNoValue(axisValue.data[i][j].val))
//          {
//            if(axisValue.data[i][j].val >= 0)
//            {
//              accuPositiveValues[j] += axisValue.data[i][j].val ;
//            } else {
//              accuNegativeValues[j] += axisValue.data[i][j].val ;
//            }
//          }
//        }
//      }
//      minMax.max = d3.max(accuPositiveValues);
//      minMax.min = d3.min(accuNegativeValues);
//    }
    
    function calculateGloballyStackedMinMax(axisValue, minMax)
    {
    
      var accuValues = new Array(axisValue.data[0].length);
      var i;
      for(i = 0; i < accuValues.length; ++i)
      {
        accuValues[i] = 0;
      }
      for(i = 0; i < axisValue.data.length; ++i)
      {
        for(var j = 0; j < axisValue.data[i].length; ++j)
        {
          if(!NumberUtils.isNoValue(axisValue.data[i][j].val))
          {
              accuValues[j] += axisValue.data[i][j].val;
              if(minMax.min === null)
              {
                minMax.min = accuValues[j];
                minMax.max = accuValues[j];
              }else{
                minMax.min = minMax.min > accuValues[j] ? accuValues[j] : minMax.min;
                minMax.max = minMax.max > accuValues[j] ? minMax.max : accuValues[j];
              }
          }
        }
      }
    }


    function calculateMinMax(axisValue)
    {
      var minMax = {
          min:null,
          max:null
      };
      if(!axisValue.data || axisValue.data.length === 0){
        return minMax;}
      if(props.mode === "percentage"){
        minMax.min = 0;
        minMax.max = 1;
        return minMax;
      }
      /*  for normal stacked chart and non-stacked chart
     if(props.bStacked){
        calculateStackedMinMax(axisValue, minMax);
      }else{
        minMax.max = Number(d3.max(axisValue.data, function(d){
          return d3.max(d, function(_){ return _.val;});
        }));
        minMax.min = Number(d3.min(axisValue.data, function(d){
          return d3.min(d, function(_){ return _.val;});
        }));
      }
      */
      calculateGloballyStackedMinMax(axisValue, minMax);
      if(NumberUtils.isNoValue(minMax.max )) { return null;}
      
      if(minMax.min >= 0)
      {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / (props.orientation === "vertical" ? height :width) ;
      }
      else if(minMax.max <= 0){
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ (props.orientation === "vertical" ? height :width);
      }else{
        var temp = (minMax.max - minMax.min) * 5 / (props.orientation === "vertical" ? height :width);
        minMax.min -= temp;
        minMax.max += temp;
      }
      if(minMax.min === 0 && minMax.max === 0){
        minMax.max = 1;
      }
      return minMax;
    }

    function createColorPalette()
    {
      colorPalette = [];
      var i = 0, j = 0;
      valueAxis1Data.colorPalette = props.colorPalette;
      for(i = 0; i < valueAxis1Data.data.length; ++i)
      {
      colorPalette.push(valueAxis1Data.colorPalette[i% valueAxis1Data.colorPalette.length]);
      }
    }

    function calculateScale(axisValue)
    {
       var range = (props.orientation === "vertical" ? [height, 0] : [0,width])
      if(axisValue.data && axisValue.data.length > 0)
      { 
        if(axisValue.topValue === null || axisValue.topValue === undefined)
        {
          var minMax = calculateMinMax(axisValue);
          if(!minMax) {
            axisValue.scale.domain([0, 0]).range (range);
          }
          else  {
            axisValue.scale.domain([minMax.min, minMax.max]).range(range);
          }
        }
        else{
          axisValue.scale.domain([axisValue.bottomValue, axisValue.topValue]).range(range);
        }
        if (!axisValue.manualRange) {
            axisValue.scale.nice();
            Scaler.perfect(axisValue.scale);
        }
      }
      else{
        axisValue.scale.domain([0,0]).range([0,0]);
      }
      return axisValue.scale;
    }

    function computeScales()
    {
      if(!(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)))
      {
        return;
      }
      var domain = [];
      var categoryNum = valueAxis1Data.data[0].length;
     
      for (var i=0; i < categoryNum; i++){
        domain.push(i);
      }
      xScale.domain(domain).rangeBands(props.orientation === "vertical" ? [0, width] :[height, 0]);
      calculateScale(valueAxis1Data);
    }

    function changeGroupMarker(groupIndex, visible, borderColor)
    {
      if(groupIndex === undefined || groupIndex === null){
        return;
      }
      var seriesIndex = 0;
      for(seriesIndex = 0; seriesIndex < valueAxis1Data.data.length; ++seriesIndex)
      {   
        if(!valueAxis1Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, borderColor, valueAxis1Data);
         if(selectedMarkerNum > 0){
           d3.select(valueAxis1Data.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", visible);
         }else{
          d3.select(valueAxis1Data.markers[seriesIndex][groupIndex]).attr("opacity", 1).attr("visibility", visible);
         }
        }
      }

    }

    function changeOneMarker(seriesIndex, xIndex, borderColor, valueAxis)
    {
      d3.select(valueAxis.markers[seriesIndex][xIndex]).attr("stroke",  borderColor);
    }

    function getCategoryIndex(val)
    {
      var index = val / xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      categoryNum = valueAxis1Data.data[0].length;
      if(index > categoryNum - 1) {index = categoryNum - 1;}
      if(index < 0) { index = 0;}
      return (props.orientation === "vertical" ? index : categoryNum - 1 - index);
    }

    function processOneAxisSelect(valueAxis, marker) {
      var findFlag = false, yi, xi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } //for j
      }//for i

      if (!findFlag) {
        return false;
      }

      if (valueAxis.selectedMarkers[yi][xi]) {
        return true;
      }

      changeOneMarker(yi, xi, selectedColor, valueAxis);
      d3.select(valueAxis.markers[yi][xi]).attr("opacity", 1).attr("visibility", "visible");
      svgAreaBgGroup.selectAll(".areabg").attr("opacity", OPACITY).attr("stroke-opacity", OPACITY);;
      d3.select(valueAxis.areas[yi][xi]).attr("opacity", 1).attr("visibility", "visible");
      valueAxis.selectedMarkers[yi][xi] = true;
      ++selectedMarkerNum;
    }

    function processOneAxisDeselect (valueAxis, marker) {
      var xi = preHighLightIndex;

      var findFlag = false, yi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } 
      }

      if (!findFlag) {
        return false;
      }

      if (!valueAxis.selectedMarkers[yi][xi]){
        return true;
      }

      if(xi === preHighLightIndex){
        changeOneMarker(yi, xi, bgColor, valueAxis);
      }
      else{
        changeOneMarker(yi, xi, props.style.marker.stroke, valueAxis);
      }
      
      d3.select(valueAxis.markers[yi][xi]).attr("opacity", OPACITY);
      d3.select(valueAxis.areas[yi][xi]).attr("visibility", "hidden");
      if(xi !== preHighLightIndex){
        d3.select(valueAxis.markers[yi][xi]).attr("visibility", "hidden");
      }
      valueAxis.selectedMarkers[yi][xi] = false;
  
      --selectedMarkerNum;
      
//      if(selectedMarkerNum <= 0){
//        svgAreaBgGroup.selectAll(".areabg").attr("opacity", 1).attr("stroke-opacity", 1);
//      }
    }
    
//    function processNullValue(axisValue)
//    {
//      var result = {
//          data:[],
//          color:[]
//      };
//      var arr = [];
//      var k;
//      var obj = {};
//      for(var i = 0; i < axisValue.length; ++i)
//      {
//        var preIndex = 0;
//        for(var j = 0; j < axisValue[i].length; ++j)
//        {
//          if(NumberUtils.isNoValue(axisValue[i][j].val))
//          {
//            if(j > preIndex)
//            {
//              arr = [];
//              arr.push({x:preIndex, y:0});
//              for(k = preIndex; k < j; k++)
//              {
//                obj = {};
//                obj.y = axisValue[i][k].val;
//                obj.x = k;  
//                arr.push(obj);
//              }
//              arr.push({x:k-1, y:0});
//              result.data.push(arr);
//              result.color.push(i);
//             }
//             preIndex = j + 1;
//           }
//        }
//        
//        if(preIndex < axisValue[i].length)
//        {
//          arr = [];
//          arr.push({x:preIndex, y:0});
//          for(k = preIndex; k <  axisValue[i].length; k++)
//          {
//            obj = {};
//            obj.y = axisValue[i][k].val;
//            obj.x = k;
//            arr.push(obj);
//          }
//          arr.push({x:k-1, y:0});
//          result.data.push(arr);
//          result.color.push(i);
//        }
//      }
//      return result;
//    }
//    
//    // for normal stacked area chart, currently not used
//    function generateAreaData(axisValue)
//    {
//      var result = {
//          data:[],
//          color:[],
//          accuPositiveVal:[],
//          accuNegativeVal:[]
//      };
//      var arr = [];
//      var i;
//      var topAreaData = [];
//      var bottomAreaData = [];
//      //generate area for all series
//      for(i = 0; i < axisValue.length; ++i)
//      {
//        result.accuPositiveVal[i] = new Array(axisValue[i].length);
//        result.accuNegativeVal[i] = new Array(axisValue[i].length);
//        for(var j = 0; j < axisValue[i].length; ++j)
//        {
//          result.accuPositiveVal[i][j] = (i > 0 ? result.accuPositiveVal[i-1][j] : 0);
//          result.accuNegativeVal[i][j] =  (i > 0 ? result.accuNegativeVal[i-1][j] : 0);
//          if(!NumberUtils.isNoValue(axisValue[i][j].val))
//          {
//            if(axisValue[i][j].val >= 0)
//            {
//              bottomAreaData.push({x:j, y:result.accuPositiveVal[i][j]});
//              result.accuPositiveVal[i][j] += axisValue[i][j].val ;
//              topAreaData.push({x:j, y: result.accuPositiveVal[i][j]});
//              
//            } else if(axisValue[i][j].val < 0){
//              topAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//              result.accuNegativeVal[i][j] += axisValue[i][j].val ;
//              bottomAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//            } 
//            
//            } else {
//            if(j > 0 && !NumberUtils.isNoValue(axisValue[i][j-1].val) )
//            {
//              if(axisValue[i][j - 1].val >= 0)
//              {
//                topAreaData.push({x:j, y: result.accuPositiveVal[i][j]});
//              } else {
//                topAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//              }
//              topAreaData = topAreaData.concat(bottomAreaData.reverse());
//              result.data.push(topAreaData);
//              result.color.push(i);
//              topAreaData = [];
//              bottomAreaData = [];
//            }
//            
//            if( j < axisValue[i].length - 1 &&  !NumberUtils.isNoValue(axisValue[i][j+1].val))
//            {
//              if(axisValue[i][j+1].val >= 0)
//              {
//                topAreaData.push({x:j, y:result.accuPositiveVal[i][j]});
//              }else{
//                topAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//              }
//            }
//          }
//        }
//        
//        if(topAreaData.length > 0)
//        {
//          topAreaData = topAreaData.concat(bottomAreaData.reverse());
//          result.data.push(topAreaData);
//          result.color.push(i);
//          topAreaData = [];
//          bottomAreaData = [];
//        }
//      }
//      return result;
//    }

    function generateGloballyStackedAreaData(axisValue)
    {
      var result = {
          data:[],   // store data for each point which use to highlight one area 
          bgAreaData:[], // draw area background region
          accuVal:[]  // accumulated values for stacked area
      };
      var i , j;
      var topAreaData = [];
      var bottomAreaData = [];
   
      // speical process for percentage chart, divide regions for zero values
      var groupValueNumbers = new Array(axisValue[0].length);
      if(props.mode === "percentage" && bDataUpdated)
      {
        turnToPercentage(axisValue);
        bDataUpdated = false;
      }
      
      for( i = 0; i < groupValueNumbers.length; ++i)
      {
        groupValueNumbers[i] = 0;
      }
      result.bgAreaData = new Array(axisValue.length);
      for(i = 0; i < axisValue.length; ++i)
      {     
        result.bgAreaData[i] = [];
        result.accuVal[i] = new Array(axisValue[i].length);
        for( j = 0; j < axisValue[i].length; ++j)
        {
          result.accuVal[i][j] = (i > 0 ? result.accuVal[i-1][j] : 0);
          if(!NumberUtils.isNoValue(axisValue[i][j].val))
          {
            groupValueNumbers[j] ++;
            result.accuVal[i][j] += (props.mode === "percentage" ? Math.abs(axisValue[i][j].val) : axisValue[i][j].val);
          }
        }
      }
      
      // generate background area shape
      for(i = 0; i < axisValue.length; ++i)
      {
        for(j = 0; j < axisValue[i].length; ++j)
        {      
          if(!NumberUtils.isNoValue(axisValue[i][j].val))
          {
            // there are 0 values in group and group contain 0 and null value only 
              bottomAreaData.push({x:j, y: ( i > 0 ? result.accuVal[i - 1][j] : 0)});
              topAreaData.push({x:j, y: result.accuVal[i][j]});
          } else {
            if(groupValueNumbers[j] > 0)
            {
              if(j > 0 && !NumberUtils.isNoValue(axisValue[i][j-1].val) )
              {
                topAreaData.push({x:j, y: result.accuVal[i][j]}); 
                topAreaData = topAreaData.concat(bottomAreaData.reverse());
                result.bgAreaData[i].push(topAreaData);
                topAreaData = [];
                bottomAreaData = [];
              }

              if( j < axisValue[i].length - 1 &&  !NumberUtils.isNoValue(axisValue[i][j+1].val))
              {
                topAreaData.push({x:j, y:result.accuVal[i][j]});
              }
            }else if(topAreaData.length > 0)
            {
              topAreaData = topAreaData.concat(bottomAreaData.reverse());
              result.bgAreaData[i].push(topAreaData);
              topAreaData = [];
              bottomAreaData = [];
            }
          }         
        }

        if(topAreaData.length > 0)
        {
          topAreaData = topAreaData.concat(bottomAreaData.reverse());
          result.bgAreaData[i].push(topAreaData);
          topAreaData = [];
          bottomAreaData = [];
        }
      }
      
      
      // generate path for every point's area
      var element = {};
      for(i = 0; i < axisValue.length; ++i)
      {
        result.data[i] = [];
        for(j = 0; j < axisValue[i].length; ++j)
        {  
            if( j > 0 )
            {
               if( groupValueNumbers[j - 1] > 0)
               {
                 topAreaData.push({x: j - 0.5, y : (result.accuVal[i][j - 1] + result.accuVal[i][j]) / 2});
                 bottomAreaData.push({x : j - 0.5, y: (i > 0 ? ((result.accuVal[i - 1][j - 1] + result.accuVal[i - 1][j]) / 2) : 0)});
               }
            }
            topAreaData.push({x: j, y : result.accuVal[i][j]});
            bottomAreaData.push({x :j, y: ( i > 0 ? result.accuVal[i - 1][j] : 0)});
            if(j < axisValue[0].length - 1)
            {
              if( groupValueNumbers[j + 1] > 0)
              {
                topAreaData.push({x: j + 0.5, y : (result.accuVal[i][j] + result.accuVal[i][j + 1]) / 2});
                bottomAreaData.push({x : j + 0.5, y: (i > 0 ? ((result.accuVal[i - 1][j] + result.accuVal[i - 1][j + 1]) / 2) : 0)});
              }
            }
            topAreaData = topAreaData.concat(bottomAreaData.reverse());
            result.data[i].push(topAreaData);
            topAreaData = [];
            bottomAreaData = [];
            
        }
      }
      return result;
    }
    
    
    function processOneAxis(axisValue)
    {
      if(!axisValue.data || axisValue.data.length === 0){
        return;
      }
      var result = generateGloballyStackedAreaData(axisValue.data);
      // for normal stacked and non-stacked
//      if(props.bStacked){
//        result = generateAreaData(axisValue.data);
//      } else {
//        result = processNullValue(axisValue.data);
//      }


      var areas = svgAreaBgGroup.selectAll("." + "areagroup").data(result.bgAreaData);
      areas.enter().append("svg:g").attr("class", "areagroup");
      areas.exit().remove();
      // draw area chart
      var line = (props.orientation === "vertical" ?  d3.svg.line().x(function(d,i) { return xScale(d.x) + xScale.rangeBand(
) / 2; }).
      y(function(d) {  return axisValue.scale(d.y); }) :
      d3.svg.line().y(function(d,i) { return xScale(d.x) + xScale.rangeBand() / 2; }).
      x(function(d) {  return axisValue.scale(d.y); }));
      areas.attr("transform", 
          function(d, i) {
            var areaShapes = d3.select(this).selectAll(".areabg").data(d);
            areaShapes.enter().append("svg:path").attr("stroke-linejoin", "round").attr("class", "areabg").attr("opacity", 1).attr("stroke-opacity", 1);
            areaShapes.exit().remove();
            areaShapes.attr("transform", function(areapath, index)
            {
            d3.select(this).attr("d", line(areapath)).attr("stroke", function (){
              var para = { graphType:"line", 
                  fillColor:axisValue.colorPalette[i %  axisValue.colorPalette.length]};
                  return effectManager.register(para);
                  })
            .attr("stroke-width", 1)
            .attr("fill",  function (){
                var para = { 
                  drawingEffect:props.drawingEffect,
                  graphType:"rectangle", 
                  direction : props.orientation,
                  fillColor:axisValue.colorPalette[i %  axisValue.colorPalette.length]};
                  return effectManager.register(para);
                });
            });
      });
      
      line = ( props.orientation === "vertical" ? d3.svg.line().x(function(d,i) { return (d.x + 0.5) * xScale.rangeBand();}).
      y(function(d) {  return axisValue.scale(d.y); }) :
      d3.svg.line().y(function(d,i) { return height - (d.x + 0.5) * xScale.rangeBand();}).
      x(function(d) {  return axisValue.scale(d.y); }));
      axisValue.areas = [];
      areas = svgAreasGroup.selectAll("." + "area").data(result.data);
      areas.enter().append("svg:g").attr("class", "area");
      areas.exit().remove();
      areas.attr("transform", 
          function(d, i) {
            markerArr = [];
            var areaShapes = d3.select(this).selectAll(".areashape").data(d);
            areaShapes.enter().append("svg:path").attr("stroke-linejoin", "round").attr("class", "areashape");
            areaShapes.exit().remove();
            areaShapes.attr("transform",function(point, index){
              markerArr.push(d3.select(this).node());
              d3.select(this).attr("d", line(result.data[i][index])).attr("stroke", function (){
                var para = { graphType:"line", 
                    fillColor:axisValue.colorPalette[i %  axisValue.colorPalette.length]};
                    return effectManager.register(para);
              }).attr("stroke-width", 1).attr("visibility", "hidden").attr("fill",  function (){
                var para = { 
                    drawingEffect:props.drawingEffect,
                    graphType:"rectangle", 
                    direction : props.orientation,
                    fillColor:axisValue.colorPalette[i %  axisValue.colorPalette.length]};
            return effectManager.register(para);
            });

      });
      axisValue.areas.push(markerArr);
      }
     );
      
      axisValue.selectedMarkers = new Array(axisValue.data.length);
      axisValue.markers = [];
      
      // draw markers
      for(var seriesIndex = 0; seriesIndex < axisValue.data.length; ++seriesIndex)
      {
        axisValue.selectedMarkers[seriesIndex] = [];
        for(var dataIndex = 0; dataIndex < axisValue.data[0].length; ++dataIndex)
        {
          axisValue.selectedMarkers[seriesIndex][dataIndex] = false;
        }
      }
 
      var groups = svgMarkersGroup.selectAll("g.marker").data(axisValue.data);
      groups.enter().append("svg:g").attr("class", "marker");
      groups.exit().remove();
      
      var visible = "hidden";
      groups.attr("transform", function(d, i) {
        
        var seriesMarkers = d3.select(this).selectAll(".datashape").data(d);
        var datashape = seriesMarkers.enter().append('g').attr('class','datashape');
        DrawUtil.createElements(datashape,{shape: props.marker.shape, className: "datapoint"} );
        seriesMarkers.exit().remove();
        markerArr = [];
        seriesMarkers.attr("transform",function(point, index)
        {   
          if(NumberUtils.isNoValue(point.val))
          { 
              d3.select(this).remove();
              markerArr.push(null);
              return;
          }
          markerArr.push(d3.select(this).selectAll('path').node());
        
          var parameter = {
              drawingEffect:props.drawingEffect,
              graphType: props.marker.shape,
              fillColor : axisValue.colorPalette[i % axisValue.colorPalette.length],
              direction : 'vertical',
              rx: props.marker.size / 2,
              ry: props.marker.size / 2,
              borderWidth: 2,
              borderColor: props.style.marker.stroke,
              strokeOpacity: 0.3,
              node:d3.select(this).select('path'),
              visibility: visible
          };

          DrawUtil.drawGraph(parameter, effectManager);
 
          return   props.orientation === "vertical"
           ? "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(result.accuVal[i][index]) + ")"
           :  "translate(" + axisValue.scale(result.accuVal[i][index]) + "," + (xScale(index) + xScale.rangeBand() / 2) + ")";
          
//         for non-stacked and normal stacked case
 //         if(props.bStacked)
 //         {
 //           return  "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(point.val >= 0 ? result.accuPositiveVal[i][index] : result.accuNegativeVal[i][index]) + ")"; 
 //         } else {
 //            return  "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(point.val) + ")";  
 //         }
        });

        axisValue.markers.push(markerArr); 
      });
    }

    function processOneAxisDeselectAll(valueAxis, xIndex)
    {
      if(selectedMarkerNum === 0 || !valueAxis.selectedMarkers || valueAxis.selectedMarkers.length === 0){
        return;
      }

      for(var seriesIndex = 0; seriesIndex < valueAxis.selectedMarkers.length; ++seriesIndex)
      {
        for(var groupIndex = 0; groupIndex < valueAxis.selectedMarkers[0].length; ++groupIndex)
        {
          if(!valueAxis.selectedMarkers[seriesIndex][groupIndex]) {continue;}
          d3.select(valueAxis.areas[seriesIndex][groupIndex]).attr("visibility", "hidden");
          if(groupIndex === xIndex)
          {
            changeOneMarker(seriesIndex, groupIndex, bgColor, valueAxis);
            d3.select(valueAxis.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", "visible");
          }
          else
          {
            changeOneMarker(seriesIndex, groupIndex, props.style.marker.stroke, valueAxis);
            d3.select(valueAxis.markers[seriesIndex][groupIndex]).attr("visibility", "hidden");
          }
        
          valueAxis.selectedMarkers[seriesIndex][groupIndex] = false;
        }
      }
    }

    function deselectedAllHandler()
    {
      var xpoint =   props.orientation === "vertical" ? (d3.event ? d3.event.clientX : 0) - g.node().getBoundingClientRect().left 
      :(d3.event ? d3.event.clientY : 0) - g.node().getBoundingClientRect().top;
      var xIndex = getCategoryIndex(xpoint);

      processOneAxisDeselectAll(valueAxis1Data, xIndex);
      selectedMarkerNum = 0;
    }

    
    function renderChart(selection)
    {
      getCSSStyle();
      eDispatch.startToInit();
      if(!g){ g = selection.append("svg:g");}
      if(!svgMarkersGroup)
      {
        svgAreaBgGroup = g.append("svg:g").attr("class", "areasbg");
        svgAreasGroup = g.append("svg:g").attr("class", "areas");
        if(!mouseMoveLine) {mouseMoveLine = g.append("svg:line");}
        svgMarkersGroup = g.append("svg:g").attr("class", "markers datashapesgroup");
      }    
      if( props.orientation === "vertical" )
      {
        mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", height)
       .attr("stroke-width", 1).attr("stroke", hoverColor)
       .attr("visibility", "hidden").attr("stroke-linejoin", "round");
      }else {
        mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", width).attr("y2", 0)
        .attr("stroke-width", 1).attr("stroke", hoverColor)
        .attr("visibility", "hidden").attr("stroke-linejoin", "round");
      }
      selectedMarkerNum = 0;
      lightAll();
      

      if(!clipRect){
        clipRect = g.append("svg:defs").append("svg:clipPath").attr("id", "clip1_" + randomSuffix).append("rect");
      }
      if( props.orientation === "vertical" )
      {
        clipRect
          .attr("x", 0).attr("y", 0).attr("height", height).attr("width", (enableDataLoadingAnimation ? 0 : width));
      }else{
        clipRect.attr("x", 0).attr("y", (enableDataLoadingAnimation ? height : 0)).attr("height", (enableDataLoadingAnimation ? 0 : height)).attr("width", width);
      }

      svgAreaBgGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgMarkersGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      if(enableDataLoadingAnimation )
      {
        bAnimationComplete = true;
        var totalNumber = 0;
        var interval = (props.orientation === "vertical" ? width / 50 : height / 50);
        var func = setInterval(function(d){
          if(totalNumber >= (props.orientation === "vertical" ? width : height))
          {
            clearInterval(func);
            eDispatch.initialized();
            svgMarkersGroup.attr("clip-path", null);
          }
          else
          {
            totalNumber += interval;
            if (props.orientation === "vertical" ){
              clipRect.attr("width", totalNumber);
            } else {
              clipRect.attr("height", totalNumber);
              clipRect.attr("y", height - totalNumber);
            }
          }
        },
        20);
      }else {
          eDispatch.initialized();
          svgMarkersGroup.attr("clip-path", null);
          svgAreaBgGroup.attr("clip-path", null);
      }
        
      processOneAxis(valueAxis1Data);
    }
    
    // turn to percentage for value axis
    function turnToPercentage(data)
    {
      
      if(data === null || data === undefined  || data[0].length === 0)
        return;
      
      var i = 0, j = 0;
      var groupSums = new Array(data[0].length);
      var zeroNumbers = new Array(data[0].length);
      for( i = 0; i < groupSums.length; ++i)
      {
        groupSums[i] = 0;
        zeroNumbers[i] = 0;
      }
      for(i = 0; i < data.length; ++i)
      {
        for(j = 0; j < data[i].length; ++j)
        {
          if(!NumberUtils.isNoValue(data[i][j].val))
          {
            groupSums[j] += Math.abs(data[i][j].val);
            if(data[i][j].val === 0)
            {
              ++zeroNumbers[j];
            }
          }
        }
      }
      
      for(i = 0; i < data.length; ++i)
      {
        for(j = 0; j < data[i].length; ++j)
        {
           data[i][j].value = data[i][j].val;
          if(!NumberUtils.isNoValue(data[i][j].val))
              {
                if(groupSums[j] > 0){
                  data[i][j].val = data[i][j].val / groupSums[j];
                }else if(zeroNumbers[j] > 0){
                  data[i][j].val = 1 / zeroNumbers[j];
                }
              } 
        }
      }

    }
  

    function lightAll() {
      svgAreaBgGroup.selectAll(".areabg").attr("opacity", 1).attr("stroke-opacity", 1);
      svgAreasGroup.selectAll(".areashape").attr("visibility", "hidden");
      svgMarkersGroup.selectAll(".datapoint").attr("opacity", 1);
    }

    function grayAll() {
      svgAreaBgGroup.selectAll(".areabg").attr("opacity", OPACITY).attr("stroke-opacity", OPACITY);
      svgAreasGroup.selectAll(".areashape").attr("visibility", "hidden");
      svgMarkersGroup.selectAll(".datapoint").attr("opacity", OPACITY);
    }
    
    function getCSSStyle() {
      if (!props.style){
        props.style = {};
      } 
      var cssDef;
      cssDef = ctx.styleManager.query('viz-plot-background');
      if (cssDef) {
        if (cssDef['fill']) {
          bgColor = cssDef['fill'];
        }
      }
      
      if (!props.style.marker){
        props.style.marker = {};
      }
      props.style.marker.stroke = "transparent";
     
      cssDef = ctx.styleManager.query('viz-plot-hoverline');
      if(cssDef)
      {
        if (cssDef['stroke']){
          hoverColor = cssDef['stroke'];
        }
      }
    }
    area.width = function(value) {
      if (!arguments.length){
        return width;
      }
      width = value;
      computeScales();
     
      return area;
    };
    
    area.height = function(value) {
      if (!arguments.length){
        return height;
      }
      height = value;
      computeScales();
      return area;
    };
    
    area.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    /*
     * get/set properties
     */
    area.properties = function(_) {
      if (!arguments.length){
        return props;
      } 
      Objects.extend(true, props, _);
      computeScales();
     // if(props.marker.size < 4 || props.marker.size > 32) { props.marker.size = 6;}
     // if(props.width < 1 || props.width > 7) { props.width = 2; }
      props.marker.size = 4;
      props.marker.shape = "circle";
      enableDataLoadingAnimation =  props.animation.dataLoading;
      
      getCSSStyle();

      createColorPalette();
      return area;
    };
    
    area.primaryAxisColor = function(){
          return null;
    };
        
        
    /**
     * get/set your event dispatch if you support event
     */
    area.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;}
      eDispatch = _;
      return area;
    };
    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    area.data = function(value){
      if (!arguments.length){
        return data_;
      }
      allDataIsNaN = true;
      bDataUpdated = true;
      data_ = value;
      var obj = MNDHandler(data_);
      valueAxis1Data.data = obj["MG1"];
      //alex su
      tooltipData = TooltipDataHandler.dataTransform(obj);
      computeScales();
      createColorPalette();
      return area;        
    };
    
    area.dataLabel = function(_){};
      
      area.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined) {
                  title.push(titles.values[i].col);
                } else {
                  title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
     
    /**
     * get color palette
     */
    area.getColorPalette = function() {
      if(colorPalette.length === 0)
      {
        createColorPalette();
      }
      return colorPalette;
    };

    area.shapePalette = function(){
      if(!arguments.length){
        return [props.marker.shape];
      }
      return area;
    };

    area.primaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis1Data.scale;
      }
      valueAxis1Data.scale = scale;
      return area;
    };

    area.categoryScale = function(scale)
    {
      if(!arguments.length)
      {
        return xScale;
      }
      xScale = scale;
      return area;

    };

    area.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis1Data.scale.domain()[0],
          max: valueAxis1Data.scale.domain()[1]
        };
      }
      if (range !== null) {
          valueAxis1Data.topValue = range.max;
          valueAxis1Data.bottomValue = range.min;
          if (range.from === 'axis') {
            valueAxis1Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
            calculateScale(valueAxis1Data);
          }
      }
      return area;
    };

    area.parent = function() { 
      return g;
    };

    /**
     * get/set size
     */
    area.size = function(w, h) {
      if (arguments.length === 0){
        return {
          width : area.width(),
          height : area.height()
        };
      }
      area.width(w).height(h);
      return area;
    };
    
    area.clear = function (gray) {
      deselectedAllHandler();
      if (gray === null || gray === undefined){
        lightAll();
      } else {
        grayAll();
      }
    };

    area.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }

      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        processOneAxisSelect(valueAxis1Data, marker );
      }
    };

    area.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        processOneAxisDeselect(valueAxis1Data, marker);
      }

    };
    
    area.hoverOnPoint = function(point)
    {  
      var point0 = point.x, point1 = point.y;
      if (props.orientation === "vertical" ){
        if(point0 < 0 || point0 > width){
          return;
        }
      } else {
        if(point1 < 0 || point1 > height){
          return;
        }
      }

      var xIndex = getCategoryIndex(props.orientation === "vertical" ? point0 : point1);
      if(preHighLightIndex === xIndex) { return; }
      var xCoord = xScale(xIndex) + xScale.rangeBand() / 2;
      changeGroupMarker(preHighLightIndex, "hidden", props.style.marker.stroke);
      changeGroupMarker(xIndex, "visible", bgColor);  

      preHighLightIndex = xIndex;


      if (props.hoverline.visible) {
        mouseMoveLine.attr( props.orientation === "vertical" ? "x1" : "y1", xCoord).attr(props.orientation === "vertical" ? "x2" : "y2", xCoord);
        mouseMoveLine.attr("visibility", "visible");
      } else {
        mouseMoveLine.attr("visibility", "hidden");
      }

      if (props.tooltip.enabled) {
        var pt = {};
        var matrix = g.node().getTransformToElement(g.node().ownerSVGElement);
        if(props.orientation === "vertical")
        {
          pt.x = xScale(xIndex) + xScale.rangeBand() / 2 + matrix.e;
          pt.y = height / 4 + matrix.f;
        } else {
          pt.x = width * 3 / 4 + matrix.e;
          pt.y = xCoord + matrix.f;
        }
        //var globalPoint = pt.matrixTransform(g.node().parentNode.parentNode.getScreenCTM().inverse());
        //var tData = generateTooltipData(xIndex);
        //alex su
        var tData = _tooltipDataHandler.generateTooltipData(data_, 
               tooltipData, 
               xIndex, 
               colorPalette, 
               [props.marker.shape]);
        tData.point = pt;
        tData.plotArea = {
          x : matrix.e,
          y : matrix.f,
          width : width,
          height : height
        };
        eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }

    };

    area.blurOut = function()
    {  
      mouseMoveLine.attr("visibility", "hidden");
      changeGroupMarker(preHighLightIndex, "hidden", props.style.marker.stroke);
      preHighLightIndex = null;
      if (props.tooltip.enabled) { 
        eDispatch.hideTooltip();
      }
    };
    
    area.dataLabel = function(_){};
    
    props = manifest.props(null);
    return area;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.area',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.area',
    'name' : 'area',
     base : 'sap.viz.modules.xy.base',
    'properties' : {
    'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'mode' : {
        'name' : 'mode',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'comparison', 'percentage' ],
        'defaultValue' : 'comparison',
        'description' : 'Set dispaly mode of area chart.',
         'isExported' : false
      },
      'orientation' : {
        'name' : 'orientation',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'vertical', 'horizontal' ],
        'defaultValue' : 'vertical',
        'description' : 'vertical or horizontal area chart.',
        'isExported' : false
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            }
          },
          'description' : 'Settings for tooltip related properties.'
     },
      'hoverline' : {
          'name' : 'hoverline',
          'supportedValueType' : 'Object',
          'description' : 'Settings for hoverline properties.',
          'supportedValues' : {
            'visible' : {
              'name' : 'visible',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set to enabled/disabled hoverline or not.'
            }
          }
      },
      'marker' : {
        'name' : 'marker',
      'description': 'Settings for marker/data point graphics',
        'supportedValueType' : 'Object',
        'isExported' :false,
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set show marker or not.',
            'isExported' :false
          },
          'shape' : {
            'name' : 'shape',
            'supportedValueType' : 'List',
            'supportedValues' : ['circle', 'diamond', 'triangle-up', 'triangle-down', 'triangle-left', 'triangle-right', 'cross', 'intersection'],
            'defaultValue' : 'circle',
            'description' : 'Set marker shapes for chart.'
          },
          'size' : {
            'name' : 'size',
            'supportedValueType' : 'PositiveInt',
            'defaultValue' : "4",
            'min' : '4',
            'max' : '32',
            'description' : 'Set marker size of data point, range[4,32]. When beyond the range, the marker size is default size 4.'
          }
        }
      }
    },
    'css' : {
     
        '.viz-plot-hoverline': {
          'description' : 'Define style for hoverline in line.',
          'value' : {
            'stroke' : '#cccccc'
          }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiAreaChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiAreaChart = {
    id : 'viz/multi_area',
    name : 'IDS_MULTIAREACHART',
    base : 'riv/base/multiple/xy',
    modules : {
      legend : {
        data : {
          aa : [ 3 ]
        }
      },
      tooltip : {
        configure : {
          properties : {
            chartType : 'line',
            orientation : 'left'
          }
        }
      },
    
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['primary']
          }
        },
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction'
                  }
                }
              },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              xAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  aa : [ 1 ]
                },
                configure : {
                  'description':'Settings for the category axis of an XY chart.',
                  propertyCategory : 'xAxis',
                  properties : {
                    title : {
                      visible : false
                    },
                    gridline : {
                      visible : false
                    },
                    type : 'category',
                    position : 'bottom'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    },
                    gridline : {
                isExported : false
                    },
                    label : {
                      isExported : false
                      },
                      axisline : {
                      isExported : false
                     }
                  }
                }
              },
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis of an XY chart.',
                  propertyCategory : 'yAxis',
                  properties : {
                    type : 'value',
                    position : 'left'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    position : 'outside',
                    orientation : 'vertical',
                    automaticInOutside : false,
                    outsidePosition : 'down'
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.area',
                configure : {
                   'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
      secondaryValues: null,
      axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      }
      ],
      events : [  {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main',
            type : 'showTooltip'
        }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main',
            type : 'hideTooltip'
        } , {
          targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
        }, {
          targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
        }, {
          targetModule : 'main.plot.dataLabel',
          listener : 'showLabel',
          sourceModule : 'main.plot.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'main.plot.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'main.plot.plot',
          type : 'startToInit.datalabel'
        }]
    }
  };

  Manifest.register(multiAreaChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiHorizontalAreaChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiAreaChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiAreaChart = {
    id : 'viz/multi_horizontal_area',
    name : 'IDS_MULTIHORIZONTALAREACHART',
    base : 'viz/multi_area',
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'horizontalline',
            orientation : 'left'
          }
        }
      },  
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              background : {
                configure : {
                  properties : {
                    direction : 'horizontal'
                  }
                }
              },
              xAxis : {
                id : 'sap.viz.modules.axis',
                data : null,
                configure : {
                  'description':'Settings for the value axis of an XY chart.',
                  propertyCategory : 'xAxis',
                  properties : {
                    gridline : {
                      visible : true
                    },
                    type : 'value',
                    position : 'bottom'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    },
                    gridline : {
                      isExported : true
                    },
                    label : {
                      isExported : true
                    },
                      axisline : {
                      isExported : true
                    }
                  }
                }
              },

              yAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  aa : [ 1 ]
                }, 
                configure : {
                  'description':'Settings for the catetory axis of an XY chart.',
                  propertyCategory : 'yAxis',
                  properties : {
                      gridline : {
                      visible : false
                    },
                    type : 'category',
                    position : 'left'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    },
                    gridline : {
                       isExported : false
                    },
                    label : {
                      isExported : false
                    },
                    axisline : {
                      isExported : false
                    }
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    position : 'outside',
                    orientation : 'horizontal',
                    automaticInOutside : false,
                    outsidePosition : 'left'
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },             
              plot : {
                id : 'sap.viz.modules.area',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea',
                   properties : {
                   orientation: 'horizontal'
                  }
                }
              }
            }
            
          }
        }
      }
    },
   
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      }
      ],
      events : [  {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main',
            type : 'showTooltip'
        }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main',
            type : 'hideTooltip'
        } , {
          targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
      }, {
          targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
        }]
    }
  };

  Manifest.register(multiAreaChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPercentageHorizontalAreaChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiHorizontalAreaChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiAreaChart = {
    id : 'viz/multi_100_horizontal_area',
    name : 'IDS_MULTIPERCENTAGEHORIZONTALAREACHART',
    base : 'viz/multi_horizontal_area',
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'horizontalline',
            orientation : 'left',
            formatString: [["0.00%"],["0.00%"]]
          }
        }
      },  
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {

               xAxis : {
                 id : 'sap.viz.modules.axis',
                 configure : {
                   properties : {
                       isPercentMode : true
                   }
                 }
              },

              plot : {
                id : 'sap.viz.modules.area',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea',
                  properties : {
                    mode:'percentage'
                  }
                }
              },         
              dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode: true
                    }
                  }
                }
            }
          }
        }
      }
    }   
  };

  Manifest.register(multiAreaChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPercentageAreaChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiAreaChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_area',
    name : 'IDS_MULTIPERCENTAGEAREACHART',
    base : 'viz/multi_area',
    modules : {
     
      tooltip : {
        configure : {
          properties : {
            chartType : 'line',
            orientation : 'left',
            formatString: [["0.00%"],["0.00%"]]
          }
        }
      },
    
      main : {

        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
           
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  properties : {
                    isPercentMode : true
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.area',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea',
                  properties: {
                  mode : "percentage"
                 }
                }
              },
              
              dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode: true
                    }
                  }
                }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var module = {
    'id' : 'sap.viz.modules.xy.bar.base',
    'name' : 'bar',
    base : "sap.viz.modules.xy.base",
    'abstract' : true,
    'properties' : {
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'isRoundCorner' : {
        'name' : 'isRoundCorner',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set enable/disable round corner of bar.'
      },
      'animation' : {
        'name' : 'animation',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'dataLoading' : {
            'name' : 'dataLoading',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data loading animation of plot area.'
          },
          'dataUpdating' : {
            'name' : 'dataUpdating',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data updating animation of plot area.'
          },
          'resizing' : {
            'name' : 'resizing',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable resize animation of plot area.'
          }
        },
        'description' : 'Settings for animation of plot area.'
      }
    }
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.lassoSelection',
  version : '4.0.0'},
[

],
function Setup() 
{
  return function(){
    var layerPos = {},//point on svg xy-coordinate
      clientPos = {},  //point on client position
      svgBoundingBox = null; //to improve performance, save all the bound of selected shape
    var lassoHelper, //div holder 
      lassoStart, lassoMove, lassoFinish, //lasso handler 
      start = false, 
      gWrapper = null, 
      gSelection = null, hitTestRect = {}, elementFilter, selectees,
      decorativeRect = null;
    //selection should be a svg element, as some function as svg native function. 
    var lassoSelection = function(selection, options){
      
      lassoHelper = $('<div id="lasso-selection-help" style="position:absolute;pointer-events:none;background:#cccccc;"></div>');
      elementFilter = options && options.filter ? options.filter:'.datapoint';
      gSelection = d3.select(selection).select('.main').length > 0  ? d3.select(selection).select('.main')[0][0] :  selection;
      gWrapper = d3.select(gSelection);
      var bbox = gSelection.getBBox();
      //as SVG limitation, you can not get the event info if you click where there is no shape.
      decorativeRect = gWrapper.insert('rect', 'g').attr('width', bbox.width).attr('height', bbox.height).attr('x', 0).attr('y', 0).attr('fill-opacity', 0);
      lassoStart = options.lassoStart ?options.lassoStart: function(){}, 
      lassoMove = options.lassoMove ? options.lassoMove: function(){}, 
      lassoEnd = options.lassoEnd ? options.lassoEnd: function(){};
      //register event on svg element
      gWrapper.on('mousedown', lassoSelection.start);
      gWrapper.on('mousemove', lassoSelection.move);
      gWrapper.on('mouseup', lassoSelection.end);
      return lassoSelection;
    };
    //intersect two rectangle
    function intersect(a, b) {
        return (a.x <= (b.x + b.width) &&
                b.x <= (a.x + a.width) &&
                a.y <= (b.y + b.height) &&
                b.y <= (a.y + a.height));
    };
    
    //filter the selectees to see whether the shape intersect with hitTestRect. 
    var filter = function(point, size){
      
      hitTestRect.x = point.x;
      hitTestRect.y = point.y;
      hitTestRect.height = size.height;
      hitTestRect.width = size.width;
      
      var res = [];
      //to reduce the time to get the bounding value, restore them into variable.
      if(selectees == null){
        selectees = gWrapper.selectAll(elementFilter);;
      }
      
      selectees.filter(function(d, m){
        var bounding = this.getBoundingClientRect();
        var rect = {
          x : bounding.left,
          y : bounding.top,
          width : bounding.width,
          height : bounding.height
        };
        if(intersect(rect , hitTestRect)){
          res.push(this);
        }
      });

      return res;
    };
    
    lassoSelection.start = function(){
      //as the layerX's issue in IE, so use the other way to calculate the x/y point on svg element.
      //layerX = pageX - svgBounding.left
      //layerY = pageY - svgBounding.top
      svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
      clientPos.x = d3.event.clientX, clientPos.y = d3.event.clientY;
      layerPos.x = clientPos.x - svgBoundingBox.left, layerPos.y = clientPos.y - svgBoundingBox.top;
      
      lassoHelper.css({
        "left": layerPos.x,
        "top": layerPos.y,
        "width": 0,
        "height": 0
      });
      
      //insert the background before the svg element in order to draw the background the behind svg
      lassoHelper.insertBefore(gSelection.ownerSVGElement.parentNode);
      
      var candidates = filter({x:clientPos.x, y:clientPos.y}, {width:0, height:0});
      
      lassoStart(candidates);
      
      start = true;
    };
    
    /**
     * when mouse move, only show the background
     */
    lassoSelection.move = function(){
      if(start){
        svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
        var x1 = layerPos.x, y1 = layerPos.y, x2 = d3.event.clientX - svgBoundingBox.left, y2 = d3.event.clientY - svgBoundingBox.top;
        if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }
        if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }
        lassoHelper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});
      }
    };
    
    lassoSelection.end = function(){
      lassoHelper.css({
        width:0,
        height:0
      });
      lassoHelper.remove();
      svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
      var x1 = layerPos.x, y1 = layerPos.y, x2 = d3.event.clientX - svgBoundingBox.left, y2 = d3.event.clientY - svgBoundingBox.top;
      var cx1 = clientPos.x, cy1 = clientPos.y , cx2 = d3.event.clientX, cy2 = d3.event.clientY;
      if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; tmp = cx2; cx2 = cx1; cx1 = tmp;}
      if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; tmp = cy2; cy2 = cy1; cy1 = tmp; }
      //lassoHelper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});
      
      if(x1 === x2 && y1 === y2){
        start = false;
      }else{
        var candidates = filter({x:cx1, y:cy1}, {width: x2-x1, height: y2-y1});
        lassoEnd(candidates);
        start = false;
      }
    };
    
    return lassoSelection;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.bar',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.lassoSelection',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.datalabel',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, tooltipDataHandler, NumberUtils, lassoSelection, Scaler, Repository, dataLabel, Objects, langManager, BoundUtil) {
  var bar = function(manifest, ctx) {
    var  tooltipDataHandlerObj;
    var  data1,                 // data1 for value axis 1
         data2,                 // data2 for value axis 2
         data,                  // data from measure feed
         seriesData = [],             // seriesData is used to draw chart, it is transferred from data
         primaryAxisTopBoundary = 0,       // max value for value axis 1
         primaryAxisBottomBoundary = 0,
         primaryAxisManualRange = false,
         secondaryAxisManualRange = false,
         secondaryAxisTopBoundary = 0,
         secondaryAxisBottomBoundary = 0,      // max value for value axis 2
         gWrapper = null;
    
    var  width,          // chart width
         height,          // chart height
         isDualAxis = false,
         hasMNDonCategoryAxis = false,
         id = Math.floor(Math.random() * 10000),
         colorPalette = [],
         axis1ColorPalette,
         axis2ColorPalette,
         MNDInnerOnColor = false,
         measureOnAxis1 = 0,
         measureOnAxis2 = 0,
         shapePalette = ['squareWithRadius'],      // shape palette for legend
         properties,          // poreperteis that is used to control chart
         eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip','initialized','startToInit');
        
    
    
    var effectManager = ctx.effectManager;
    
    var valueScales = [],
        yScale = d3.scale.ordinal(),    // category scale
        xScale = d3.scale.linear(),      // scale for value axis 1
        xScale2 = d3.scale.linear();    // scale for value axis 2
      
      //variable for event
    var decorativeShape = null,           // the shape to show the effect of mouse move
        lastSelected = [],           // the variable to hold all selected shapes
        lastHovered = null,         // last hovered dimention item index
        tooltipVisible = true,  
        isLasso = false;
      
    var indexforSecondaryAxis = 0,        // if data index of seriesData is bigger than it, which means those data should be scaled by xScale2    
        barNumber,              // the number of bar in each group    
        barGroupNumber,            // the number of bar groups 
        barWidth = [],            // array to store all bars' widths.
        barHeight;              // barHeight is fixed and all bars have the same height.
    
    var enableDataLoadingAnimation = true,   // control initialization animation  
        enableDataUpdatingAnimation = true, // control data updating animation
        enableRoundCorner = false,      // enable/disable round corner bar
        clipEdge = true,          // if it is false, the chart can be drawn out of the plot area.
        totalIntervalTime = 1000,      // animation time limited. all animation must be completed within it.
        isOnlyInitAnimation = false;    // for now, only init animation is supported
    
    var defsEnter = null, 
        roundCornerDefs = null,
        suffix = Repository.newId();
    
    var drawingEffect = 'normal';
    
    var sizeChange = false, dataStructureChange = false, dataValueChange = false;

    var dataLabel;
    
    /**
     * Parse options
     */
    var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        enableDataLoadingAnimation =  properties.animation.dataLoading; 
        enableDataUpdatingAnimation =  properties.animation.dataUpdating; 

        tooltipVisible = properties.tooltip.enabled;
          
        if(isDualAxis && !hasMNDonCategoryAxis){
          axis1ColorPalette = properties.primaryValuesColorPalette;   
          axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
          axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }
        drawingEffect = properties.drawingEffect; 
        
        var colorIndexes = 0;
        if(!hasMNDonCategoryAxis){
          indexforSecondaryAxis = data1.length;
          colorIndexes = seriesData[0].length;   
        }else{
          colorIndexes = seriesData.length * seriesData[0].length;
        }
        colorPalette = [];
        var i = 0;
        if(MNDInnerOnColor){
          var flag = 0, flag2 = 0, j = 0;
          for(i = 0 ; i < indexforSecondaryAxis; i++){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
            flag++;
            if(flag === measureOnAxis1){
              flag2 = 0;
              for(; j <=(colorIndexes-indexforSecondaryAxis); j++){
                if(flag2 >= measureOnAxis2){
                  flag = 0;
                  break;
                }
              colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
              flag2++;
            }
          }
        }
      }else{
        for(i = 0; i < colorIndexes; i++){
          if(i < indexforSecondaryAxis){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
          }else if(isDualAxis && !hasMNDonCategoryAxis){
            colorPalette.push(axis2ColorPalette[(i-indexforSecondaryAxis) % axis2ColorPalette.length]);  
          }
        }
      }
    };
      
    /**
     * Create chart
     */
    function chart(selection){
        BoundUtil.drawBound(selection, width, height);
      
        var countMagnitude = function(number)
        {
            var res = 0;
            //0.0234: 0.01
            //0.234: 0.1
            //2.34: 1
            //23.4: 10
            //234:100
            //234:100
            if(number >= 1)
            {
                res = 1;
                for(;;)
                {
                    if((number / 10) < 1)
                    {
                        break;
                    }
                    else
                    {
                        number /= 10;
                        res *= 10;
                    }
                }
            }
            else if(number < 1)
            {
                res = 0.1;
                for(;;)
                {
                    if((number * 10) >= 1)
                    {
                        break;
                    }
                    else
                    {
                        number *= 10;
                        res /= 10;
                    }
                }
            }
            return res;
        }

        var bestImageNumberRatio = function(seriesData, valueScale, barHeight)
        {
            var res = 1;
            var imageRatioObjs = [];
            for(var i = 0; i < seriesData.length; i++)
            {
                for(var j = 0; j < seriesData[i].length; j++)
                {
                    var ratioItem = {};
                    ratioItem.rectWidth = valueScale(seriesData[i][j].val);
                    ratioItem.rectHeight = barHeight;

                    ratioItem.imageWidth = barHeight;
                    ratioItem.val = seriesData[i][j].val;

                    imageRatioObjs.push(ratioItem);
                }
            }
            //var points = [40,100,1,5,25,10];
            imageRatioObjs.sort(function(a,b){return b.rectWidth-a.rectWidth});
            if(imageRatioObjs.length != 0)
            {
                var bestImageNum = imageRatioObjs[0].rectWidth/imageRatioObjs[0].imageWidth;
                var theVal = imageRatioObjs[0].val;

                var baseMagnitude = countMagnitude(bestImageNum/theVal);

                var imageNumTest1 = Math.abs(baseMagnitude * theVal - bestImageNum);
                var imageNumTest2 = Math.abs(baseMagnitude * 10 * theVal - bestImageNum);
                
                if(imageNumTest1 < imageNumTest2
                    && (baseMagnitude * theVal * imageRatioObjs[0].imageWidth) >= imageRatioObjs[0].rectWidth*0.2)
                {
                    res = baseMagnitude;
                }
                else
                {
                    res = baseMagnitude * 10;
                }
            }

            return res;
        }

        var imageFill = function(barShape, bar, i, barHeight)
        {

            var defIDFun = function(d, itemIndex) {
                    return "defID-" + i + itemIndex;//i is group index
                };

            var pathIDFun = function(d, itemIndex) {
                    return "pathID-" + i + itemIndex;//i is group index
                };

            var urlPathIDFun = function(d, itemIndex) {
                    return "url(#" + pathIDFun(d, itemIndex) + ")";//i is group index
                };

            var urlIDFun = function(d, itemIndex) {
                    return "url(#" + defIDFun(d, itemIndex) + ")";//i is group index
                };

            var rectWidthFun = function(d) {
                    var valueScale = valueScales[d.valueAxis];
                    return valueScale(d.val);
                };

            var imageNumber = function(perDefData)
            {
                var val = perDefData.val;
                if(perDefData.val < 0)
                {
                    val = -val;
                }

                var res = {number:0, interval:barHeight};
                res.number = val*imageNumRatio;

                //to count the interval
                var intNum = Math.floor(res.number);
                var decimalNum = res.number - intNum;

                var rectWidth = rectWidthFun(perDefData);
                var imageWidth = barHeight;
                var lastImageWidth = imageWidth * decimalNum;

                //   imageWidth + (intNum-1)*interval + (interval-imageWidth) + lastImageWidth == rectWidth   //interval >= imageWidth           
                //or imageWidth + (intNum-1)*interval == rectWidth //interval < imageWidth && (lastImageWidth <= interval)
                //or intNum*interval + lastImageWidth == rectWidth //interval < imageWidth && (lastImageWidth > interval)
                var intervalTest1;
                if(intNum == 0)
                {
                    intervalTest1 = 0;
                }
                else
                {
                    if(rectWidth > lastImageWidth)
                    {
                        intervalTest1 = (rectWidth - lastImageWidth)/intNum; 
                    }
                    else
                    {
                        intervalTest1 = 0;
                    }
                }
                
                var intervalTest2;
                if(intNum <= 1)
                {
                    intervalTest2 = rectWidth/2;
                }
                else
                {
                    if(rectWidth > imageWidth)
                    {
                        intervalTest2  = (rectWidth - imageWidth)/(intNum - 1);
                    }
                    else
                    {
                        intervalTest2 = rectWidth/(intNum + 1);
                    }
                }

                var intervalTest3;
                if(intNum === 0)
                {
                    intervalTest3 = 0;
                }
                else if(rectWidth > imageWidth)//imageWidth > lastImageWidth
                {
                    intervalTest3  = (rectWidth - lastImageWidth)/intNum;
                }
                else
                {
                    intervalTest3 = rectWidth/(intNum + 1);
                }


                if(intervalTest1 >= imageWidth)
                {
                    res.interval = intervalTest1;
                }
                else if (intervalTest2 < imageWidth && (lastImageWidth <= intervalTest2))
                {
                    res.interval = intervalTest2;
                }
                else
                {
                    res.interval = intervalTest3;
                }

                return res;
            }

            var imageRatioObjs = [];
            

            var imagesFun = function (perDefData,k)
            {
                var thisObj = d3.select(this);

                var rectWidth = rectWidthFun(perDefData);
                var rectHeight = barHeight;

                var imageNum = imageNumber(perDefData);

                var intNum = Math.floor(imageNum.number);
                var decimalNum = imageNum.number - intNum;

                thisObj.selectAll("image").remove();

                var iImage = 0;
                for(; iImage < intNum; iImage++)
                {
                    thisObj.append("image")
                        .attr("xlink:xlink:href", properties.fillMode.imagePalette[k])
                        .attr("width",rectHeight)
                        .attr("height",rectHeight)
                        .attr("x",iImage*imageNum.interval);
                }

                if(decimalNum)
                {
                    var startX = iImage*imageNum.interval;
                    var imagePath = startX + ",0 ";
                    imagePath += ((startX + rectHeight*decimalNum) + ",0 ");
                    imagePath += ((startX + rectHeight*decimalNum) + "," + rectHeight + " ");
                    imagePath += (startX + "," + rectHeight + " ");

                    //for the decimalNum. add the 
                    thisObj.append("clipPath")
                        .attr("id", pathIDFun)
                        .append("polygon")
                        .attr("points",imagePath);

                    //<clipPath id="hex-mask">
                    //<polygon points="100,0 150,0 150,100 100,100" />
                    //</clipPath>
                    //<image x="100" y="0" clip-path="url(#hex-mask)" opacity="1" height="100" width="100" xlink:href="file:///C:/Users/I052223/Desktop/pics/trunk.png" />

                    thisObj.append("image")
                        .attr("xlink:xlink:href", properties.fillMode.imagePalette[k])
                        .attr("width",rectHeight)
                        .attr("height",rectHeight)
                        .attr("x",startX)
                        .attr("clip-path",urlPathIDFun);
                }
                
            };

            //start of the function
            barShape.selectAll("defs").remove();
            var imageDef = barShape.append("defs").append("pattern")
                .attr("id", defIDFun)
                .attr("patternUnits","userSpaceOnUse")
                //.attr("width",20)//plot width
                //.attr("height",20);//plot height
                .attr("width",rectWidthFun)
                .attr("height",barHeight);

            //we use "each" to access data and index
            //to make the imageNumRatio
            var imageNumRatio = 1;
            imageDef.each( function(d)
            {
                var valueScale = valueScales[d.valueAxis];
                imageNumRatio = bestImageNumberRatio(seriesData, valueScale, barHeight);
            }
            );

            imageDef.each(imagesFun);
            bar.attr('fill',urlIDFun);
        };


      tooltipDataHandlerObj = tooltipDataHandler();
      
      // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
      if(valueScales.length === 0){ 
        return;
      }
      eDispatch.startToInit();
      
      selection.each(function(){
        barNumber = seriesData[0].length;
        barGroupNumber =  seriesData.length;      
        barHeight = 8 * (yScale.rangeBand()) / (9*barNumber +7 );
        
        var svg = (gWrapper = d3.select(this));
 
        //append decorativeShape bar
        if(decorativeShape === null){
          decorativeShape = d3.select(this).append('rect').attr('visibility', 'hidden').attr('width', width).attr('height',  yScale.rangeBand() - barHeight/2).attr(
              'fill', 'rgba(133,133,133, 0.2)');
        }else{
          decorativeShape.attr('width', width).attr('height',  yScale.rangeBand() - barHeight/2).attr('visibility', 'hidden');
        }
        
        if(defsEnter === null){
          defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
        }else{
          defsEnter.attr('width', width).attr('height', height);
        }    
          
        if(roundCornerDefs === null){      
          roundCornerDefs = svg.append('defs');
        }else{
          if( dataStructureChange || sizeChange || dataValueChange || !enableRoundCorner){
            roundCornerDefs.remove();
            roundCornerDefs = svg.append('defs');
          }
        }
          
        var r = Math.log(barHeight)/Math.log(2);
        if( r < 0 ){
          enableRoundCorner = false;
        }
        var valueScale;
        var datashapesgroup = svg.selectAll('g.datashapesgroup');
        if(!TypeUtils.isExist(datashapesgroup[0][0])){
          datashapesgroup = svg.append('g').attr('class', 'datashapesgroup');
        }
        var barGroup = datashapesgroup.selectAll('g.bar').data(seriesData), lastBarGroupIndex = seriesData.length -1;
           barGroup.enter().append('g');
           barGroup.attr('class','bar').each( function (perBarGroup,i) {
                var barTransition, yArray = [];
                // wrap a datashape g for each rect
                var barShape = d3.select(this).selectAll('g.datashape').data(perBarGroup);
                    barShape.enter().append('g').attr('class','datashape').append('rect').attr('class', 'datapoint');
                    barShape.exit().remove();
                    barShape.attr('transform',function(perRectData, m){
                        var x;                   
                        valueScale = valueScales[perRectData.valueAxis];
                        if(perRectData.val < 0){
                          x =  valueScale(perRectData.val) ;
                        }else{
                          x = valueScale(0);
                        }
                        var y = yScale(i) + barHeight * (barNumber - m - 1);
                            y = y + barHeight/8 * (barNumber - m - 1) + barHeight /2;
                            
                        yArray.push(y);
                        return 'translate('+x+','+y+')';         
                    });
                var bar = barShape.select('rect.datapoint'), 
                    lastBarIndex = seriesData[0].length -1;
                

                bar.attr('fill',function(perRectData,i){
                      perRectData.fillColor = colorPalette [ i % colorPalette.length];
                      var parameter = {
                          drawingEffect:drawingEffect,
                          fillColor : perRectData.fillColor,
                          direction : 'vertical'
                      };
                      return effectManager.register(parameter);
                    })
                    .attr('shape-rendering','crispEdges').attr('fill-opacity', 1);

                  if(enableDataLoadingAnimation && !isOnlyInitAnimation ){
                    // [04 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                    // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                    if(dataStructureChange){
                      bar.attr('y', function(perRectData, m){
                            var y = yScale(i) - yArray[m] + barHeight * (barNumber - m  - 1);
                            y = y + barHeight/8 * (barNumber - m - 1) + barHeight /2;
                            return  y;
                          })
                          .attr('x', function(perRectData){
                            valueScale = valueScales[perRectData.valueAxis];
                            if(perRectData.val  > 0){
                              return 0;
                            }else{
                              return valueScale(0) - valueScale(perRectData.val);
                            }
                           })
                           .attr('height', barHeight).attr('width', 0)
                           .attr('class', function(d, m){
                             return 'datapoint series-'+m;
                           });
                      
                      if(enableRoundCorner){
                        bar.attr('clip-path', function(perRectData, m){
                          var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                          var id ='roundCorner-clip' + '-' + m + i  +  suffix;
                          roundCornerDefs.append('clipPath').attr('id', id)
                              .append('rect').attr('rx', r).attr('ry', r)
                              .attr('width', w + r).attr('height', barHeight).attr('y', y).attr('x',x)
                              .transition().delay(function(d,m){return (m + barNumber * i) * interval;})
                              .attr('x', function(){
                                valueScale = valueScales[perRectData.valueAxis];
                                if(perRectData.val < 0){
                                  return 0;
                                }else{
                                  return 0 - r;
                                }
                              })
                              .attr('width',  function(){
                                valueScale = valueScales[perRectData.valueAxis];
                                // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                // the space is reserved
                                if(perRectData.val !== ' ' && perRectData.val !== 0){
                                  var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                  // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                  return  width + r;
                                }else{
                                  return 0;
                                }
                              });
                        return 'url(#' + id + ')'; });
                      }
                  
                      var interval = totalIntervalTime / (barNumber * barGroupNumber);
                      barTransition = bar.transition();
                      barTransition.delay(function(d,m){return (m + barNumber * i) * interval;})
                        .attr('x', 0).attr('y', 0)
                        .attr('width',  function(perRectData){
                          valueScale = valueScales[perRectData.valueAxis];
                          // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                          // the space is reserved
                          if(perRectData.val !== ' ' && perRectData.val !== 0 ){
                            var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                            // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                            return  width;
                          }else{
                            return 0;
                          }
                        })
                        .each('end', function(d, m){
                          if(m === lastBarIndex && i === lastBarGroupIndex){
                            completeAnimation();
                          }
                        });
                    }
                    // [04 - Sep - 2012 Nick] if the size of plot area is changed, re-scale chart
                    else if(sizeChange){
                      if(enableRoundCorner){
                        bar.attr('clip-path', function(perRectData, m){
                          var w = parseFloat(this.getAttribute('width')), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                          var id ='roundCorner-clip' + '-' + m + i  +  suffix;
                          roundCornerDefs.append('clipPath').attr('id', id)
                            .append('rect').attr('rx', r).attr('ry', r)
                            .attr('width', w + r).attr('height', h).attr('y', y).attr('x',x)
                            .transition().duration(totalIntervalTime)
                            .attr('x', function(){
                              if(perRectData.val < 0){
                                return  0;
                              }else{
                                return 0 - r;
                              }
                            })
                            .attr('width',  function(){
                              valueScale = valueScales[perRectData.valueAxis];
                              // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                              // the space is reserved
                              if(perRectData.val !== ' ' && perRectData.val !== 0){
                                var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                return width + r;
                              }else{
                                return 0;
                              }
                            })
                            .attr('height', barHeight)
                            .attr('y', 0);
                          return 'url(#' + id + ')'; });
                      }

                      barTransition = bar.transition();
                      barTransition.duration(totalIntervalTime)
                        .attr('x', 0).attr('y', 0)
                        .attr('width',  function(perRectData, m){
                          valueScale = valueScales[perRectData.valueAxis];
                          if(perRectData.val !== ' ' && perRectData.val !== 0){
                            var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                            // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                            return width;
                          }else{
                            return 0;
                          }
                        })
                        .attr('height', barHeight)
                        .each('end', function(d, m){
                          if(m === lastBarIndex && i === lastBarGroupIndex){
                            completeAnimation();
                          }
                        });
                    }
                    else if(dataValueChange){
                      if(enableRoundCorner){
                        bar.attr('clip-path', function(perRectData, m){
                          var w = parseFloat(this.getAttribute('width')), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                          var id ='roundCorner-clip' + '-' + m + i  +  suffix;
                          roundCornerDefs.append('clipPath').attr('id', id)
                                .append('rect').attr('rx', r).attr('ry', r)
                                .attr('x',  - r).attr('width', w + r).attr('height', h).attr('y', y)
                                .transition().duration(totalIntervalTime)
                                .attr('width',  function(){
                                    valueScale = valueScales[perRectData.valueAxis];
                                  // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                  // the space is reserved
                                    if(perRectData.val !== ' ' && perRectData.val !== 0){
                                    var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                    // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                    return (width + r);
                                  }else{
                                    return 0;
                                  }
                                 })
                                .attr('height', barHeight)
                                .attr('y', function(){
                                  var y = yScale(i) + barHeight * (barNumber - m - 1);
                                  y = y + barHeight/8 * (barNumber - m - 1) + barHeight /2;
                                  return  y;
                                });
                          return 'url(#' + id + ')'; });
                      }
                      
                      //To seperate dataValueChange, as in size change, we calculate more than data value change.
                      //in value change, only change the width, in size, there are height width, y
                      barTransition = bar.transition();
                      barTransition.duration(totalIntervalTime)
                      .attr('width',  function(perRectData){
                        valueScale = valueScales[perRectData.valueAxis];
                        if(perRectData.val !== ' ' && perRectData.val !== 0){
                          var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                          // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                          return width;
                        }else{
                          return 0;
                        }
                      })
                      .attr('x', 0).attr('y', 0)
                      .each('end', function(d, m){
                        if(m === lastBarIndex && i === lastBarGroupIndex){
                          completeAnimation();
                        }
                      });
                    }                      
                    else if(enableRoundCorner){
                      bar.attr('clip-path', function(perRectData, m){
                        var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                        roundCornerDefs.append('clipPath').attr('id', id)
                          .append('rect').attr('rx', r).attr('ry', r)
                          .attr('width', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val !== 0){
                              var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                              return (width + r);
                            }else{
                              return 0;
                            }
                          })
                          .attr('height', barHeight)
                          .attr('y', 0)
                          .attr('x', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            if(perRectData.val < 0){
                              return  0;
                            }else{
                              return 0 - r;
                            }
                          });
                          return 'url(#' + id + ')';
                      });
                    }  
                  }
                  // [04 - Sep - 2012 Nick] if the animation is disabled
                  else{
                    bar.attr('width', function(perRectData){
                        valueScale = valueScales[perRectData.valueAxis];
                        if(perRectData.val !== ' ' && perRectData.val !== 0){
                          var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                          // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                          return width;
                        }else{
                          return 0;
                        }
                      })
                      .attr('x', 0).attr('height', barHeight).attr('y', 0);
                    if(enableRoundCorner){
                      bar.attr('clip-path', function(perRectData, m){
                        var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                        roundCornerDefs.append('clipPath').attr('id', id)
                          .append('rect').attr('rx', r).attr('ry', r)
                          .attr('width', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val !== 0){
                              var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                              return (width + r);
                            }else{
                              return 0;
                            }
                          })
                          .attr('height', barHeight)
                          .attr('y', 0)
                          .attr('x', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            if(perRectData.val < 0){
                              return  0;
                            }else{
                              return 0 - r;
                            }
                          });
                          return 'url(#' + id + ')';
                      });
                    }
                  }

//----------------call image fill functions-----------------------------------------------------
                //barItem: the datashape which has one rect and one defs
                //bar: the bar rect in the barItem
                //i: is group index
                //barHeight: the height of the bar

                if(properties.fillMode.image && !isDualAxis)
                {
                    imageFill(barShape, bar, i, barHeight);
                }
//----------------------------------------------------------------------------------------------
                 // bar.exit().remove();
              });

          barGroup.exit().remove();
        
        //reset status
        sizeChange = false, dataStructureChange = false, dataValueChange = false;
        });
        
        if(!enableDataLoadingAnimation){
          completeAnimation();
        }
        
        return chart;
      }
    
    function completeAnimation(){
        eDispatch.initialized();  
    }
    
    chart.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    
    
    chart.dataLabel = function(label){
      if(!arguments.length){
        return label;
      }
      dataLabel = label;
    };
    /**
     * Mouse over 
     */
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(yOnModule - yScale.rangeBand()*i - 0.5 * yScale.rangeBand() ) <= 0.5 * yScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1) || i < 0) {
        decorativeShape.attr(
            'visibility', 'hidden');
        return;
      }

      decorativeShape.attr(
          'y',
          yScale.rangeBand() * i + barHeight/4).attr(
          'visibility', 'visible');

      if(i !== lastHovered){
        if (tooltipVisible) {      
          lastHovered = i;
          //this.parentNode.parentNode.parentNode point to the main container
          var transform = gWrapper[0][0].getTransformToElement(gWrapper[0][0].ownerSVGElement);
          var yoffset = transform.f;
          
          var tData = tooltipDataHandlerObj.generateTooltipData(data, seriesData, barGroupNumber-1-i, colorPalette, shapePalette);
          tData.point = {
              x: d3.event.layerX,
              y: yScale.rangeBand()*i + 0.5 * yScale.rangeBand() + yoffset
          };
          tData.plotArea = {
            x : transform.e,
            y : transform.f,
            width : width,
            height : height
          };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
        }
      }
      };
      
      chart.parent = function(){
        return gWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
        }else{
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      
      /**
       * TODO: add desc
       */
      chart.blurOut = function(){
        lastHovered = null;
        decorativeShape.attr('visibility', 'hidden');
      if (tooltipVisible) {      
        eDispatch.hideTooltip();
      }
      };
      
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange = (width === value)&&!sizeChange? false:true;
          width = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange? false:true;
        height = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
         return chart;        
      };

      /**
      * set/get data, for some modules like Title, it doesn't need data
      */
      chart.data = function(value){
        if (!arguments.length){
          return data;
         }
        data = value;
        var obj = MNDHandler(data);
        
        data1 = obj["MG1"];
        data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
        
        if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
        }else{
          hasMNDonCategoryAxis = false;
          if(TypeUtils.isExist(data2)){
                isDualAxis = true;
            }else{
                isDualAxis = false;
            }
        }
        
        var _seriesData = dataTransform(data1, data2, obj.color);
        //judge what changed in dataset
        if(seriesData.length !== _seriesData.length || _seriesData[0].length !== seriesData[0].length){
          dataStructureChange = true;
        }else {
          dataValueChange = true;
        }
        seriesData = _seriesData;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      parseOptions();
         return chart;        
      };

      /**
      * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
          return properties;
         }
         Objects.extend(true, properties, props);
            parseOptions();
            
         return chart;        
      };
      
      /**
       * TODO: add desc
       */
      var makeScales = function(){
      var domain = [];
      valueScales = [];
      for (var i=0; i < seriesData.length; i++){
           domain.push(i);
        }
        yScale.domain(domain).rangeBands([height, 0]);
        //when data is all 0 or null, we make the xScale.domain(0,1)
        if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
          xScale.domain([0,1]).range([0, width]);
        }else{
          xScale.domain([primaryAxisBottomBoundary, primaryAxisTopBoundary]).range([0, width]);
        }
        if(TypeUtils.isExist(data2) || isDualAxis){
        //when data of second axis is all 0 or null, we make the xScale2 same with xScale .

          if(secondaryAxisTopBoundary === 0 && secondaryAxisBottomBoundary === 0){
            xScale2.domain(xScale.domain()).range(xScale.range());
          }else{
            xScale2.domain([secondaryAxisBottomBoundary, secondaryAxisTopBoundary]).range([0, width])
            //when data of first axis is all 0 or null, we make the xScale same with xScale2 .
            if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
              xScale.domain(xScale2.domain()).range(xScale2.range());
            }
          }
          if (!secondaryAxisManualRange && !primaryAxisManualRange)
          {
              Scaler.perfectDual(xScale, xScale2);
          }
          else if(!secondaryAxisManualRange && primaryAxisManualRange)
          {
              Scaler.perfect(xScale2);
          }
          else if (secondaryAxisManualRange && !primaryAxisManualRange)
          {
              Scaler.perfect(xScale);
          }
        } else { 
          if (!primaryAxisManualRange) {
            Scaler.perfect(xScale);
          }
          xScale2.range([0, 0]);
        }
        valueScales.push(xScale);
        valueScales.push(xScale2);
      };
      
      /**
       * TODO: add desc. please don't leave empty otherwise jsdoc will complain.
       */
      chart.categoryScale = function(scale){
        if (!arguments.length){
          return yScale;
         }
        yScale = scale;
         return chart;
      };
     
      chart.primaryScale = function(scale){
        if (!arguments.length){
          return xScale;
         }
        xScale = scale;
        valueScales[0] = xScale;
         return chart;
      };
      
      chart.secondScale = function(scale){
        if (!arguments.length){
          return xScale2;
         }
        xScale2 = scale;
        valueScales[1] = xScale2;
         return chart;
      };
      
      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(!hasMNDonCategoryAxis){
          return colorPalette[seriesData[0].length - 1];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };     
      
      chart.primaryDataRange = function(range){
        if (!arguments.length){
          return {
            min: primaryAxisBottomBoundary,
            max: primaryAxisTopBoundary
          };
        }
        if (range !== null) {
            primaryAxisTopBoundary = range.max;
            primaryAxisBottomBoundary = range.min;
            if (range.from === 'axis') {
                primaryAxisManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
        return chart;
      };
      
      chart.secondDataRange = function(range){
        if (!arguments.length){
          return {
            min: secondaryAxisBottomBoundary,
            max: secondaryAxisTopBoundary
          };
        }
        if (range !== null) {
            secondaryAxisTopBoundary = range.max;
            secondaryAxisBottomBoundary = range.min;
            if (range.from === 'axis') {
                secondaryAxisManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
        return chart;
      };      
      
      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
      
      /**
     * get/set your event dispatch if you support event
     */
      chart.dispatch = function(_){
        if(!arguments.length){
          return eDispatch;
        }
        eDispatch = _;
        return this;
      };
      
      /**
      * get/set your color palette if you support color palette
      */
      chart.colorPalette = function(_){
        if(!arguments.length){
          return colorPalette;
        }
        colorPalette = _;
        return this;
      };        
        // chart.primaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis1ColorPalette;
            // }  
            // axis1ColorPalette = _;
            // return this;
        // };
// 
        // chart.secondaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis2ColorPalette;
            // }  
            // axis2ColorPalette = _;
            // return this;
        // };        

      /**
      * get/set your shape Palette if you support shape Palette
      */
      chart.shapePalette = function(_){
        if(!arguments.length){
          return shapePalette;
        }
        shapePalette = _;
        return this;
      };
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
//      var dataTransform = function(data1,data2){
//        var barGroups = [];
//      // the number of bar in each group
//      var barGroupNumber =  data1[0].length;
//      var barGroup = [];
//      for(var i=0; i<data1.length; i++){
//        var temp = d3.max(data1[i], function(m){return m.val;});
//        var temp2 = d3.min(data1[i], function(m){return m.val;});
//        if(primaryAxisTopBoundary <temp){
//          primaryAxisTopBoundary = temp;
//        }
//        if(primaryAxisBottomBoundary > temp2){
//            primaryAxisBottomBoundary = temp2;
//        }
//          barGroup.push(data1[i]);
//        }
//      if(data2 != undefined){
//      
//        for(i=0; i<data2.length; i++){
//          var temp = d3.max(data2[i], function(m){return m.val;});
//          var temp2 = d3.min(data2[i], function(m){return m.val;});
//          if(secondaryAxisTopBoundary < temp){
//            secondaryAxisTopBoundary = temp;
//          }
//          if(secondaryAxisBottomBoundary > temp2){
//              secondaryAxisBottomBoundary = temp2;
//          }
//          barGroup.push(data2[i]);
//        }
//      }
//       
//      for(var j=0; j < barGroupNumber; j++){
//        var ds = [];
//        for(i=0; i< barGroup.length; i++){
//          ds.push(barGroup[i][j]);
//        }
//        barGroups.push(ds);
//      }
//     
//        return barGroups;
//      };
      
      var dataTransform = function(valueAxis1,valueAxis2, colorIndexArray){
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        var barGroups = [];
      // the number of bar in each group
        var barGroupNumber = 0;
        
        if (valueAxis1[0] && valueAxis1[0].length) {
            barGroupNumber =  valueAxis1[0].length;
        } else if (valueAxis2[0] && valueAxis2[0].length){
            barGroupNumber =  valueAxis2[0].length;
        }
      var barGroup = [];
      var temp = 0, temp2 = 0;
      var i = 0, j = 0;
      for(i=0; i < valueAxis1.length; i++){
        if(hasMNDonCategoryAxis){
          for(j = 0;  j< valueAxis1[i].length; j++){
            if(colorIndexArray[j] === 0){
              temp = valueAxis1[i][j].val;
              valueAxis1[i][j].valueAxis = 0;
              
              if(primaryAxisTopBoundary <temp){
                primaryAxisTopBoundary = temp;
              }
              if(primaryAxisBottomBoundary > temp){
                primaryAxisBottomBoundary = temp;
              }
              indexforSecondaryAxis++;
            }else{
              temp2 = valueAxis1[i][j].val;
              valueAxis1[i][j].valueAxis = 1;
              
              if(secondaryAxisTopBoundary < temp2){
                secondaryAxisTopBoundary = temp2;
              }
              if(secondaryAxisBottomBoundary > temp2){
                  secondaryAxisBottomBoundary = temp2;
              }
            }
          }
        }else{
          temp = d3.max(valueAxis1[i], function(m){return m.val;});
          temp2 = d3.min(valueAxis1[i], function(m){return m.val;});
          
          if(primaryAxisTopBoundary <temp){
            primaryAxisTopBoundary = temp;
          }
          if(primaryAxisBottomBoundary > temp2){
            primaryAxisBottomBoundary = temp2;
          }
        }
        barGroup.push(valueAxis1[i]);
          
        }
      if(valueAxis2 !== undefined){
        for(i=0; i<valueAxis2.length; i++){
          temp = d3.max(valueAxis2[i], function(m){return m.val;});
          temp2 = d3.min(valueAxis2[i], function(m){return m.val;});
          
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp;
          }
          if(secondaryAxisBottomBoundary > temp2){
              secondaryAxisBottomBoundary = temp2;
          }
          barGroup.push(valueAxis2[i]);
        }
      }
      
      for(j=0; j < barGroupNumber; j++){
        var ds = [];
        for(i=0; i< barGroup.length; i++){
          if(!hasMNDonCategoryAxis){
            if( i < valueAxis1.length){
              barGroup[i][j].valueAxis = 0;
            }else{
              barGroup[i][j].valueAxis = 1;
            }
          }
          if(NumberUtils.isNoValue(barGroup[i][j].val)){
            barGroup[i][j].val = ' ';
          }
          ds.push(barGroup[i][j]);
        }
        if(MNDInnerOnColor){
          var dSet = [], flag1=0, flag2=0;
          var n=0;
          for(var m=0; m < valueAxis1.length; m++){
            dSet.push(ds[m]);
            flag1++;
            if(flag1 === measureOnAxis1 && valueAxis2 !== undefined){
              flag2 = 0;
              for(; n<valueAxis2.length; n++){
                if(flag2 >= measureOnAxis2){
                  flag1 = 0;
                  break;
                }
                dSet.push(ds[valueAxis1.length+n]);
                flag2++;
              }
            }
          }
          barGroups.push(dSet);
        }else{
          barGroups.push(ds);
        }
      }
     
        return barGroups;
      };      
      
    properties = manifest.props(null);
      return chart;
  };
  return bar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.bar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.bar',
    'name' : 'bar',
    base : "sap.viz.modules.xy.bar.base",
    'properties' : {
      'fillMode' : {
        'name' : 'fillMode',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'image' : {
            'name' : 'image',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set enabled/disabled image fill.'
          },
          'imagePalette' : {
            'name' : 'imagePalette',
            'supportedValueType' : 'StringArray',
            'supportedValues' : [ 'image1.png', 'image2.png', 'image3.png', 'image4.png' ],
            'defaultValue' : [ 'http://www.sap.com/global/ui/images/global/sap-logo.png', 
                               'http://www.sap.com/global/ui/images/global/sap-logo.png', 
                               'http://www.sap.com/global/ui/images/global/sap-logo.png',
                               'http://www.sap.com/global/ui/images/global/sap-logo.png',
            ],
            'description' : 'images to fill the bar',
          } 
        },
        'isExported' : true,
        'description' : 'Settings for tooltip related properties.'
      }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_bar',
    name : 'IDS_MULTIBARCHART',
    base : 'riv/base/multiple/xy',
    modules : {
      legend : {
        data : {
          aa : [ 3 ]
        }
      },
      tooltip : {
        configure : {
          properties : {
            chartType : 'bar',
            orientation : 'left'
          }
        }
      },
      main : {
        controllers : {
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              propertyCategory : 'interaction',
        properties : {
                      supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
              }
            }
          }
        },
        configure : {
          properties : {
            'mergeDataRange' : ['primary']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              background : {
                configure : {
                  properties : {
                    direction : 'horizontal'
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    orientation : 'horizontal',
                    outsidePosition : 'right'
                  }
                }
              },
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis of an XY chart.',
                  propertyCategory : 'xAxis',
                  properties : {
                    title : {
                      visible : false
                    },
                    type : 'value',
                    position : 'bottom'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  aa : [ 1 ]
                },
                configure : {
                  'description':'Settings for the category axis of an XY chart.',
                  propertyCategory : 'yAxis',
                  properties : {
                    type : 'category',
                    position : 'left',
                    gridline : {
                      visible : false
                    }
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    },
                    gridline : {
              isExported : false
              },
              label : {
                    isExported : false
                    },
                    axisline : {
                    isExported : false
                   }
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.bar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
      secondaryValues: null,
      axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, { 
    targetModule : 'main.plot.xAxis',
    target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
    }
      ],
      events : [ {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main',
            type : 'initialized.interaction'
          }, {
              targetModule : 'tooltip',
              listener : 'showTooltip',
              sourceModule : 'main',
              type : 'showTooltip'
          }, {
              targetModule : 'tooltip',
              listener : 'hideTooltip',
              sourceModule : 'main',
              type : 'hideTooltip'
          }, {
            targetModule : 'main.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'legend',
            type : 'highlightedByLegend'
          }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
            }, {
              targetModule : 'main.plot.dataLabel',
              listener : 'showLabel',
              sourceModule : 'main.plot.plot',
              type : 'initialized.datalabel'
            }, {
              targetModule : 'main.plot.dataLabel',
              listener : 'removeLabel',
              sourceModule : 'main.plot.plot',
              type : 'startToInit.datalabel'
            }]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.verticalbar',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, tooltipDataHandler, ColorSeries, Scaler, Repository, NumberUtils, Objects, langManager, boundUtil) {
  var vBar = function(manifest, ctx) {
    var tooltipDataHandlerObj;
    var data1, 
        data2, 
        data, 
        seriesData = [], 
        primaryAxisTopBoundary = 0, 
        primaryAxisBottomBoundary = 0,
        primaryAxisManualRange = false,
        secondaryAxisManualRange = false,
        secondaryAxisTopBoundary = 0,
        secondaryAxisBottomBoundary = 0,
        sWrapper = null;
    
    var width = undefined, 
        height = undefined,
        id = Math.floor(Math.random() * 10000),
        x = 0, 
        y = 0,
        isDualAxis = false,
        colorPalette = [],
        axis1ColorPalette,
        axis2ColorPalette,
        MNDInnerOnColor = false,
        measureOnAxis1 = 0,
        measureOnAxis2 = 0,
        shapePalette = ['squareWithRadius'],
        properties,
        eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
      
    var effectManager = ctx.effectManager;
    
    var valueScales = [],
        xScale = d3.scale.ordinal(),
        yScale = d3.scale.linear(),
        yScale2 = d3.scale.linear();


    var decorativeShape, 
        eventLayerShape, 
        lastSelected = [], 
        tooltipVisible = true,
        lastHovered = null;

      
    var indexforSecondaryAxis = 0,
        barNumber,
        barGroupNumber,
        barWidth,
        yPositions = [];
        
    var enableDataLoadingAnimation = true,
        enableDataUpdatingAnimation = true,
        enableRoundCorner = false,
        clipEdge = true,
        totalIntervalTime = 1000,
        afterAttachToDOM = false,
        isOnlyInitAnimation = false;
    
    var defsEnter, 
        roundCornerDefs,
        suffix = Repository.newId();
    var drawingEffect = 'normal';
    
    var sizeChange = false, dataStructureChange = false, dataValueChange = false;
    
    chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
        // find the closet dimension
        var i = -1;
        while (i < seriesData.length) {
          if (Math.abs(xOnModule - xScale.rangeBand()*i - 0.5 * xScale.rangeBand() ) <= 0.5 * xScale.rangeBand()) {
            break;
          }
          i++;
        }

        if (i > (seriesData.length - 1)|| i < 0) {
          decorativeShape.attr('visibility', 'hidden');
          return;
        }
      
        decorativeShape.attr('x',xScale.rangeBand() * i + barWidth/4)
                       .attr('visibility', 'visible');
      
        if(lastHovered !== i){
          if (tooltipVisible) {
            lastHovered = i;
            //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element
            var transform = sWrapper[0][0].getTransformToElement(sWrapper[0][0].ownerSVGElement);
            var xoffset = transform.e;
            
            var tData = tooltipDataHandlerObj.generateTooltipData(data, seriesData, i, colorPalette, shapePalette);
            tData.point = {
              x: xScale.rangeBand()*i + 0.5 * xScale.rangeBand() + xoffset,
              y: d3.event.layerY
            };
            tData.plotArea = {
              x : transform.e,
              y : transform.f,
              width : width,
              height : height
            };
            eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
          }
        }
      };
    
      chart.parent = function(){
        return sWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          sWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
        }else{
          sWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      

      chart.blurOut = function(){
        decorativeShape.attr('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
          eDispatch.hideTooltip();
      }
      };
      
      var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        enableDataLoadingAnimation =  properties.animation.dataLoading; 
        enableDataUpdatingAnimation =  properties.animation.dataUpdating; 
        tooltipVisible = properties.tooltip.enabled;
        drawingEffect = properties.drawingEffect;
      
        if(isDualAxis && !hasMNDonCategoryAxis){
          axis1ColorPalette = properties.primaryValuesColorPalette;   
          axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
          axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }
        var colorIndexes = 0;
        if(!hasMNDonCategoryAxis){
          indexforSecondaryAxis = data1.length;
          colorIndexes = seriesData[0].length;   
        }else{
          colorIndexes = seriesData.length * seriesData[0].length;
        }
        colorPalette = [];
        if(MNDInnerOnColor){
          var flag = 0, flag2 = 0, j = 0;
          for(var i=0 ; i < indexforSecondaryAxis; i++){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
            flag++;
            if(flag == measureOnAxis1){
              flag2 = 0;
              for(; j <=(colorIndexes-indexforSecondaryAxis); j++){
                if(flag2 >= measureOnAxis2){
                  flag = 0;
                  break;
                }
                colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
                flag2++;
              }
            }
          }
        }else{
          for(var i=0 ; i < colorIndexes; i++){
            if(i < indexforSecondaryAxis){
              colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
            }else if(isDualAxis && !hasMNDonCategoryAxis){
              colorPalette.push(axis2ColorPalette[(i-indexforSecondaryAxis) % axis2ColorPalette.length]);  
            }
          }  
        }
      };
      
      /**
       * Create chart
       */

      function chart(selection){
        
        boundUtil.drawBound(selection, width, height);

        tooltipDataHandlerObj = tooltipDataHandler();
        
        // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
        if(valueScales.length == 0) return;
        
        eDispatch.startToInit();
        
        selection.each(function(){
              barNumber = seriesData[0].length;
              barGroupNumber =  seriesData.length;
              barWidth = 8 * (xScale.rangeBand()) / (9*barNumber +7 );
              
              var svg = sWrapper = d3.select(this);

              if(decorativeShape == null){
                  decorativeShape = svg.append('rect').attr('width', xScale.rangeBand() - barWidth/2).attr('height',height).attr('visibility', 'hidden')
                    .attr('fill', 'rgba(133,133,133, 0.2)');
                }else{
                  decorativeShape.attr('width', xScale.rangeBand() - barWidth/2).attr('height',height).attr('visibility', 'hidden');
                }
    
              //vertical bar
              if(defsEnter == null){
                defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
              }else{
                defsEnter.attr('width', width).attr('height', height);
              }    
              
              if(roundCornerDefs == null){      
                roundCornerDefs = svg.append('defs');
              }else{
                if( dataStructureChange || sizeChange || dataValueChange || !enableRoundCorner){
                  roundCornerDefs.remove();
                  roundCornerDefs = svg.append('defs')
                }
              }
            
              var r = Math.log(barWidth)/Math.log(2);
              if( r < 0 ){
                enableRoundCorner = false;
              }
              var valueScale;
              var datashapesgroup = svg.selectAll('g.datashapesgroup');
              if(!TypeUtils.isExist(datashapesgroup[0][0])){
                datashapesgroup = svg.append('g').attr('class', 'datashapesgroup');
              }
              
              var barGroup = datashapesgroup.selectAll('g.bar').data(seriesData), lastBarGroupIndex = seriesData.length -1, lastBarIndex = seriesData[0].length - 1;    
                  barGroup.enter().append('g');
                  barGroup.attr('class','bar').each( function (perBarGroup, i) {
                      var xArray=[], yArray=[];
                      var barShape = d3.select(this).selectAll('g.datashape').data(perBarGroup);
                      barShape.enter().append('g').attr('class','datashape').append('rect').attr('class', 'datapoint');

                      barShape.exit().remove();
                      // [21-Nov-2012 Nick] Keep the original x-position for each g.datashape, it is used when data value changes.
                      if(afterAttachToDOM){
                        barShape.each(function(){
                          yArray.push(this.getTransformToElement(this.parentNode).f);
                        });
                      }
                      barShape.attr('transform', function(perRectData,m){
                          var y;
                          valueScale = valueScales[perRectData.valueAxis];
                          if(perRectData.val >= 0){
                            y = valueScale(perRectData.val);
                          }else{
                           y = valueScale(0) ;
                          }
                          var x = xScale(i) + barWidth * m;
                          x = x + barWidth/8 *(m) + barWidth/2;
                          xArray.push(x);
                          return 'translate('+x+','+y+')';
                      });
                      var bar = barShape.select('rect.datapoint');
                        bar.attr('fill', function(d,i){ 
                                  d.fillColor = colorPalette[i % colorPalette.length]; 
                                  var parameter = {
                                      drawingEffect:drawingEffect,
                                      fillColor : d.fillColor,
                                      direction : 'horizontal'
                                  };
                                  return effectManager.register(parameter);
                            })
                            .attr('shape-rendering','crispEdges').attr('fill-opacity', 1);
                      
                      if(enableDataLoadingAnimation && !isOnlyInitAnimation ){
                      // [05 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                      // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                      if(dataStructureChange){
                        bar.attr('width', barWidth).attr('height', 0)
                           .attr('x', function (perRectData, m) {
                             var x = xScale(i) - xArray[m] + barWidth * m;
                             x = x + barWidth/8 *(m) + barWidth/2;
                             return x;
                           })
                          .attr('y', function(perRectData){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0 && perRectData.val > 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              return height;
                            }else{
                              return 0;
                            }
                          });
 
                        
                        if(enableRoundCorner){
                          bar.attr('clip-path', function(perRectData, m){
                            var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;
                            roundCornerDefs.append('clipPath').attr('id', id)
                                .append('rect').attr('rx', r).attr('ry', r)
                                .attr('x', 0).attr('width', barWidth)
                                .attr('y', h)
                                .transition().delay(function(d,m){return (m + barNumber * i) * interval})
                                .attr('height', function(){
                                  valueScale = valueScales[perRectData.valueAxis];
                                  // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                  // the space is reserved
                                  if(perRectData.val !== ' ' && perRectData.val != 0){
                                    var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                    // [10 - Sep - 2012 Nick] if the height of one bar is less than 1px, use 1px.
                                    return (height + r); 
                                  }else{
                                    return 0;
                                  }
                                })
                                .attr('y', function(){
                                  if(perRectData.val > 0){
                                    return  0;
                                  }else{
                                    return 0 - r;
                                  }
                                });
                            return 'url(#' + id + ')'; });
                        }
                        
                        var interval = totalIntervalTime / (barNumber * barGroupNumber);
                        bar.transition().delay(function(d,m){return (m + barNumber * i) * interval})
                          .attr('height', function(perRectData,m){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              return height;
                            }else{
                              return 0;
                            }
                          })
                          .attr('y', 0).attr('x',0)
                          .each('end', function(perRectData, m){
                            if(m === lastBarIndex && i === lastBarGroupIndex){
                              completeAnimation();
                            }
                          });
                      }else if(sizeChange){
                        if(enableRoundCorner){
                          bar.attr('clip-path', function(perRectData, m){
                            var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                            roundCornerDefs.append('clipPath').attr('id', id).append('rect').attr('rx', r).attr('ry', r)
                                  .attr('width', w).attr('x', x).attr('height', h)
                                  .attr('y', function(){
                                      if(perRectData.val > 0){
                                        return 0;
                                      }else{
                                        return 0 - r;
                                      }
                                  })
                                  .transition().duration(totalIntervalTime).attr('width',barWidth)
                                  .attr('height', function(){
                                    valueScale = valueScales[perRectData.valueAxis];
                                    // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                    // the space is reserved
                                    if(perRectData.val !== ' ' && perRectData.val != 0){
                                      var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                      // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                      return  (height + r); 
                                    }else{
                                      return 0;
                                    }
                                  })
                            return 'url(#' + id + ')'; });
                        }
                        //bar.transition().delay(function(d,m){return (m + barNumber * i) * interval}).attr('width',  function(d, m){
                        bar.transition().duration(totalIntervalTime).attr('width', barWidth)
                           .attr('height', function(perRectData){
                              valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                              if(perRectData.val !== ' ' && perRectData.val != 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              return  height; 
                            }else{
                              return 0;
                            }
                           })
                           .attr('y', 0).attr('x', 0)
                           .each('end', function(d, m){
                             if(m === lastBarIndex && i === lastBarGroupIndex){
                               completeAnimation();
                             }
                           });
                      }else if(dataValueChange){
                        var barYP = [];
                        bar.attr('y',function(d,k){
                          var pos = yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                          barYP.push(pos);
                          return pos;
                        })
                        if(enableRoundCorner){
                          bar.attr('clip-path', function(perRectData, m){
                            var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;  
                            roundCornerDefs.append('clipPath').attr('id', id)
                                .append('rect').attr('rx', r).attr('ry', r)
                                  .attr('x', x).attr('width', barWidth)
                                  .attr('height', function(){
                                    valueScale = valueScales[perRectData.valueAxis];
                                    var newHeight = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                    if(parseFloat(h) > newHeight){
                                      return h;
                                    }else{
                                      return newHeight;
                                    }
                                  }) 
                                  .attr('y', function(){
                                    return barYP[m];
                                  })
                                  .transition().duration(totalIntervalTime)
                                  .attr('height', function(){
                                      valueScale = valueScales[perRectData.valueAxis];
                                    // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                    // the space is reserved
                                      if(perRectData.val !== ' ' && perRectData.val != 0){
                                      var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                      // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                      return (height + r); 
                                    }else{
                                      return 0;
                                    }
                                  }).attr('y', function () {
                                      valueScale = valueScales[perRectData.valueAxis];
                                    if(perRectData.val >= 0){
                                      return 0;
                                    }else{
                                      return 0 - r;
                                    }
                                  });
                            return 'url(#' + id + ')'; });
                        }
                        
                        //To seperate dataValueChange, as in size change, we calculate more than data value change.
                        //in value change, only change the width, in size, there are height width, y
                        bar.transition().duration(totalIntervalTime)
                          .attr('height', function(perRectData,m){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                              perRectData.height = height;
                              return height; 
                            }else{
                              return 0;
                            }
                          })
                          .attr('y', 0).attr('x',0)
                          .each('end', function(d, m){
                            if(m === lastBarIndex && i === lastBarGroupIndex){
                              completeAnimation();
                            }
                          });
                      }
                      else if(enableRoundCorner){
                        bar.attr('clip-path', function(perRectData, m){
                          var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                        roundCornerDefs.append('clipPath').attr('id', id)
                          .append('rect').attr('rx', r).attr('ry', r)
                          .attr('width', barWidth)
                          .attr('height', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                              return  (height + r); 
                            }else{
                              return 0;
                            }
                          })
                          .attr('y', function () {
                               valueScale = valueScales[perRectData.valueAxis];
                               if(perRectData.val >= 0){
                                 return 0;
                               }else{
                                 return 0 - r;
                               }
                          })
                          .attr('x', 0);
                        return 'url(#' + id + ')'; });
                        }  
                    }
                      // [05-Sep-2012 Nick] When animation is disabled, the chart is drawed here.
                      else{
                      bar.attr('width', barWidth)
                         .attr('height', function(perRectData){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                          // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0){
                            var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                            // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                            perRectData.height = height;
                            return height; 
                          }else{
                            return 0;
                          }
                         })
                         .attr('y', 0).attr('x', 0);
                      
                      if(enableRoundCorner){
                          bar.attr('clip-path', function(perRectData, m){
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                          roundCornerDefs.append('clipPath').attr('id', id)
                            .append('rect').attr('rx', r).attr('ry', r)
                            .attr('width', barWidth)
                            .attr('height', function(){
                              valueScale = valueScales[perRectData.valueAxis];
                              // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                              // the space is reserved
                              if(perRectData.val !== ' ' && perRectData.val != 0){
                                var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                return  (height + r); 
                              }else{
                                return 0;
                              }
                            })
                            .attr('y', function () {
                                 valueScale = valueScales[perRectData.valueAxis];
                                 if(perRectData.val >= 0){
                                   return 0;
                                 }else{
                                   return 0 - r;
                                 }
                            })
                            .attr('x', 0);
                          return 'url(#' + id + ')'; });
                        }
                      }
                     // bar.exit().remove();
                });

                barGroup.exit().remove();
                sizeChange = false, dataValueChange = false, dataStructureChange = false;
            
        });
        if(!enableDataLoadingAnimation)
          completeAnimation();
        
        return chart;
      }
      

      function completeAnimation(){
          eDispatch.initialized();
          afterAttachToDOM = true;
      }
      
      chart.afterUIComponentAppear = function(){
        eDispatch.initialized(); 
      };
      
      
    function changeYPosition(d,m){
      var i = d3.interpolate(height,  (m >= indexforSecondaryAxis) ? yScale2(d.val) : yScale(d.val));
        return function(t){ 
          return   i(t);
        }
    };
    
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange =  (width === value)&&!sizeChange ? false:true;
          width = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange ? false:true;
        height = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)){
          makeScales();
        }
         return chart;        
      };

      /**
      * set/get data, for some modules like Title, it doesn't need data
      */
    chart.data = function(value){
      if (!arguments.length){
          return data;
      }
        data = value;
        
        var obj = MNDHandler(data);

        data1 = obj["MG1"];
        data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
 
        if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
        }else{
          hasMNDonCategoryAxis = false;
          if(TypeUtils.isExist(data2)){
                isDualAxis = true;
            }else{
                isDualAxis = false;
            }
        }
        
        var _seriesData = dataTransform(data1,data2, obj.color);
        //judge what changed in dataset
        if(seriesData.length !== _seriesData.length || _seriesData[0].length !== seriesData[0].length){
          dataStructureChange = true;
        }else {
          dataValueChange = true;
        }
        seriesData = _seriesData;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      
      parseOptions();
       return chart;        
    };


      /**
      * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
          return properties;
         }
            Objects.extend(true, properties, props);  
            parseOptions();

         return chart;        
      };
     
      /**
       * TODO: add desc
       */
      var makeScales = function(){
      var domain = [];
      for (var i=0; i < seriesData.length; i++){
           domain.push(i);
        }
      
      valueScales = [];
        //when all data is 0 or null, we make yscale.domain from 0 to 1
        xScale.domain(domain).rangeBands([0, width]);
        if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
          yScale.domain([0, 1]).range([height, 0]);

        }else{
          yScale.domain([primaryAxisBottomBoundary, primaryAxisTopBoundary]).range([height, 0]);

        }

        if(TypeUtils.isExist(data2) || isDualAxis){
        //when data of second axis is all 0 or null, we make the xScale2 same with xScale .

          if(secondaryAxisTopBoundary === 0 && secondaryAxisBottomBoundary === 0){
            yScale2.domain(yScale.domain()).range(yScale.range());
          }else{
            yScale2.domain([secondaryAxisBottomBoundary, secondaryAxisTopBoundary]).range([height, 0])
            //when data of first axis is all 0 or null, we make the xScale same with xScale2 .
            if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
              yScale.domain(yScale2.domain()).range(yScale2.range());
            }
          }
          if (!secondaryAxisManualRange && !primaryAxisManualRange)
          {
              Scaler.perfectDual(yScale, yScale2);
          }
          else if(!secondaryAxisManualRange && primaryAxisManualRange)
          {
              Scaler.perfect(yScale2);
          }
          else if (secondaryAxisManualRange && !primaryAxisManualRange)
          {
              Scaler.perfect(yScale);
          }
        }else{
          if (!primaryAxisManualRange) {
            Scaler.perfect(yScale);
          }
          yScale2.range([0, 0]);
        }
            valueScales.push(yScale);
            valueScales.push(yScale2);
      };
      
      /**
       * TODO: please fill your comments here, or jsdoc will complain.
       */
      chart.categoryScale = function(scale){
        if (!arguments.length){
          return xScale;
         }
        xScale = scale;
         return chart;
      };
     
      chart.primaryScale = function(scale){
        if (!arguments.length){
          return yScale;
         }
        yScale = scale;
        valueScales[0] = yScale;
         return chart;
      };
      
      chart.secondScale = function(scale){
        if (!arguments.length){
          return yScale2;
         }
        yScale2 = scale;
        valueScales[1] = yScale2;
         return chart;
      };

      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(!hasMNDonCategoryAxis){
          return colorPalette[seriesData[0].length - 1];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };          
      
      chart.primaryDataRange = function(range){
        if (!arguments.length){
          return {
            min: primaryAxisBottomBoundary,
            max: primaryAxisTopBoundary
          };
        }
        if (range !== null) {
            primaryAxisTopBoundary = range.max;
            primaryAxisBottomBoundary = range.min;
            if (range.from === 'axis') {
                primaryAxisManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
        return chart;
      };
      
      chart.secondDataRange = function(range){
        if (!arguments.length){
          return {
            min: secondaryAxisBottomBoundary,
            max: secondaryAxisTopBoundary
          };
        }
        if (range !== null) {
            secondaryAxisTopBoundary = range.max;
            secondaryAxisBottomBoundary = range.min;
            if (range.from === 'axis') {
                secondaryAxisManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
        return chart;
      };    

      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
      
      chart.x = function(_){
        if(!arguments.length){
          return x;
        }
        x= _;
        return this;
      };
      
      chart.y = function(_){
        if(!arguments.length)
          return y;
        y = _;
        return this;
      };

      chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };
      
    chart.dataLabel = function(_){};
    
    chart.eventTarget = function (evt) {
      if (evt.type == 'mousemove') {
        return chart.hoverOnPoint;
      } else if (evt.type == 'mouseout') {
        return blurOut;
      }
    };
      
      /**
      * get/set your color palette if you support color palette
      */
      chart.colorPalette = function(_){
        if(!arguments.length){
          return colorPalette;
        }
        colorPalette = _;
        return this;
      };

                
        // chart.primaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis1ColorPalette;
            // }  
            // axis1ColorPalette = _;
            // return this;
        // };
// 
        // chart.secondaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis2ColorPalette;
            // }  
            // axis2ColorPalette = _;
            // return this;
        // };        

      /**
      * get/set your shape Palette if you support shape Palette
      */
      chart.shapePalette = function(_){
        if(!arguments.length){
          return shapePalette;
        }
        shapePalette = _;
        return this;
      };
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
//      var dataTransform = function(data1,data2){
//        var stackedBarGroup = [];
//      // the number of bar in each group
//      var barGroupNumber =  data1[0].length;
//      var transferredDataSet = [];
//      for(var i=0; i<data1.length; i++){
//                var temp = d3.max(data1[i], function(m){return m.val;});
//                var temp2 = d3.min(data1[i], function(m){return m.val;});
//                if(primaryAxisTopBoundary <temp){
//                    primaryAxisTopBoundary = temp;
//                }
//                if(primaryAxisBottomBoundary > temp2){
//                    primaryAxisBottomBoundary = temp2;
//                }
//          transferredDataSet.push(data1[i]);
//        }
//      if(data2 != undefined){
//        for(i=0; i<data2.length; i++){
//                    var temp = d3.max(data2[i], function(m){return m.val;});
//                    var temp2 = d3.min(data2[i], function(m){return m.val;});
//                    if(secondaryAxisTopBoundary < temp){
//                        secondaryAxisTopBoundary = temp;
//                    }
//                    if(secondaryAxisBottomBoundary > temp2){
//                        secondaryAxisBottomBoundary = temp2;
//                    }
//          transferredDataSet.push(data2[i]);
//        }
//      }
//       
//      for(var j=0; j < barGroupNumber; j++){
//        var ds = [];
//        for(i=0; i< transferredDataSet.length; i++){
//          ds.push(transferredDataSet[i][j]);
//        }
//        stackedBarGroup.push(ds);
//      }
//     
//        return stackedBarGroup;
//      };
      
      var dataTransform = function(valueAxis1,valueAxis2, colorIndexArray){
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        var barGroups = [];
      // the number of bar in each group
      var barGroupNumber = 0;
      
      if (valueAxis1[0] && valueAxis1[0].length) {
            barGroupNumber = valueAxis1[0].length;
      } else if (valueAxis2[0] && valueAxis2[0].length) {
            barGroupNumber = valueAxis2[0].length;
      }
      var barGroup = [];
      var temp = temp2 = 0;
      for(var i=0; i < valueAxis1.length; i++){
        if(hasMNDonCategoryAxis){
          for(var j = 0;  j< valueAxis1[i].length; j++){
            if(colorIndexArray[j] == 0){
              temp = valueAxis1[i][j].val;
              valueAxis1[i][j].valueAxis = 0;
              
              if(primaryAxisTopBoundary <temp){
                primaryAxisTopBoundary = temp;
              }
              if(primaryAxisBottomBoundary > temp){
                primaryAxisBottomBoundary = temp;
              }
              indexforSecondaryAxis++;
            }else{
              temp2 = valueAxis1[i][j].val;
              
              valueAxis1[i][j].valueAxis = 1;
              if(secondaryAxisTopBoundary < temp2){
                secondaryAxisTopBoundary = temp2;
              }
              if(secondaryAxisBottomBoundary > temp2){
                  secondaryAxisBottomBoundary = temp2;
              }
            }
          }
        }else{
          temp = d3.max(valueAxis1[i], function(m){return m.val;});
          temp2 = d3.min(valueAxis1[i], function(m){return m.val;});
          
          if(primaryAxisTopBoundary <temp){
            primaryAxisTopBoundary = temp;
          }
          if(primaryAxisBottomBoundary > temp2){
            primaryAxisBottomBoundary = temp2;
          }
        }
        barGroup.push(valueAxis1[i]);
          
        }
      if(valueAxis2 != undefined){
      
        for(i=0; i<valueAxis2.length; i++){
          var temp = d3.max(valueAxis2[i], function(m){return m.val;});
          var temp2 = d3.min(valueAxis2[i], function(m){return m.val;});
          
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp;
          }
          if(secondaryAxisBottomBoundary > temp2){
              secondaryAxisBottomBoundary = temp2;
          }
          barGroup.push(valueAxis2[i]);
        }
      }
      
      
       
      for(var j=0; j < barGroupNumber; j++){
        var ds = [];
        for(i=0; i< barGroup.length; i++){
          if(!hasMNDonCategoryAxis){
            if( i < valueAxis1.length){
              barGroup[i][j].valueAxis = 0;
            }else{
              barGroup[i][j].valueAxis = 1;
            }
          }
          if(NumberUtils.isNoValue(barGroup[i][j].val)){
            barGroup[i][j].val = ' ';
          }
          ds.push(barGroup[i][j]);
        }
        if(MNDInnerOnColor){
          var dSet = [], flag1=0, flag2=0;
          var n=0;
          for(var m=0; m < valueAxis1.length; m++){
            dSet.push(ds[m]);
            flag1++;
            if(flag1 == measureOnAxis1 && valueAxis2 != undefined){
              flag2 = 0;
              for(; n<valueAxis2.length; n++){
                if(flag2 >= measureOnAxis2){
                  flag1 = 0;
                  break;
                }
                dSet.push(ds[valueAxis1.length+n]);
                flag2++;
              }
            }
          }
          barGroups.push(dSet);
        }else{
          barGroups.push(ds);
        }
      }
        return barGroups;
      };
    
      properties = manifest.props(null);
      return chart;
  };
  return vBar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.verticalbar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.verticalbar',
    'name' : 'vertical bar',
    base : "sap.viz.modules.xy.bar.base",
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_column',
    name : 'IDS_MULTIVERTICALBARCHART',
    base : 'viz/multi_bar',
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'verticalbar',
            orientation : 'left'
          }
        }
      },
      main : {
        modules: {
          plot : {
            modules : {
              background : {
                configure : {
                  properties : {
                    direction : 'vertical'
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    orientation : 'vertical',
                    outsidePosition : 'up'
                  }
                }
              },
              xAxis : {
                data : {
                  aa : [ 1 ]
                },
                configure : {
                  'description':'Settings for the category axis of an XY chart.',
                  properties : {
                    type : 'category',
                    gridline : {
                      visible : false
                    }
                  },
                  propertiesOverride : {                   
                    gridline : {
              isExported : false
              },
              label : {
                    isExported : false
                    },
                    axisline : {
                    isExported : false
                   }
                  }
                }
              },
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                data : null,
                configure : {
                  'description':'Settings for the value axis of an XY chart.',
                  properties : {
                    type : 'value',
                    gridline : {
                      visible : true
                    }
                  },
                  propertiesOverride : {                   
                    gridline : {
              isExported : true
              },
              label : {
                    isExported : true
                    },
                    axisline : {
                    isExported : true
                   }
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.verticalbar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{  
        multiplier:{
        max:1
      },
        axisLabels:{
        max:1
      },
      secondaryValues: null
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, { targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var multiVBarChart = {
    id : 'viz/multi_dual_column',
    name : 'IDS_MULTIDUALVERTICALBARCHART',
    base : 'viz/multi_column',
    modules : {
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['primary', 'second']
          }
        },
        modules: {
          plot : {
            modules : {
                 plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
                yAxis:{
                      id : 'sap.viz.modules.axis',
                  configure:{
                    'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                  }
                },
              yAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                 propertyCategory : 'yAxis2',
                  properties : {
                    title : {
                      visible : false
                    },
                    type : 'value',
                    position : 'right'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues:
     {
       min: 1,
    max : Number.POSITIVE_INFINITY 
     },
    axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main',
        target : 'secondDataRange',
        sourceModule : 'main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'main.plot.yAxis2',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'secondScale'
      }, {
        targetModule : 'main.plot.yAxis2',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'main.plot.yAxis',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'main.plot.yAxis2',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      },
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.stackedverticalbar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
    var module = {
      'id' : 'sap.viz.modules.stackedverticalbar',
      'name' : 'stacked vertical bar',
      base : "sap.viz.modules.verticalbar",
      'properties' : {
        'mode' : {
          'name' : 'mode',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'comparison', 'percentage' ],
          'defaultValue' : 'comparison',
          'description' : 'Set dispaly mode of stacked vertical bar.',
            'isExported' : true
        }
      },
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_dual_stacked_column',
    name : 'IDS_MULTIDUALSTACKEDVERTICALBARCHART',
    base : 'viz/multi_dual_column',
    modules : {
      main : {
        modules: {
          plot : {
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedverticalbar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false
                  },
                  propertiesOverride : {
                    position : {
                      isExported : false
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualPercentageStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualStackedVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_100_dual_stacked_column',
    name : 'IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART',
    base : 'viz/multi_dual_stacked_column',
    modules : {
      main : {
        modules: {
          plot : {
            modules : {
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  properties : {
                    isPercentMode : true
                  }
                }
              },
              yAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  properties : {
                    isPercentMode : true
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.stackedverticalbar',
                configure : {
                  properties : {
                    'mode' : 'percentage'
                  }
                }
              },
              
              dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode : true,
                      type : 'value',
                      showZero : true
                    }
                  }
                }
            }
          }
        }
      },
      tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
        formatString: [["0.00%"],["0.00%"]]
            }
          }
      }
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var multiBarChart = {
    id : 'viz/multi_dual_bar',
    name : 'IDS_MULTIDUALBARCHART',
    base : 'viz/multi_bar',
    modules : {
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['primary', 'second']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
                 plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
              xAxis:{
                  id : 'sap.viz.modules.axis',
              configure:{
                'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
              }
            },
              xAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'xAxis2',
                  properties : {
                    title : {
                      visible : false
                    },
                    gridline : {
                      visible : false
                    },
                    type : 'value',
                    position : 'top'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              }
      }
          }
        }
      }
  },
    feeds:{
      multiplier:{
      max:1
    },
    secondaryValues:{
      min: 1,
      max : Number.POSITIVE_INFINITY 
    },
    axisLabels:{
      max:1
    }
  },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main',
        target : 'secondDataRange',
        sourceModule : 'main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      },   {
        targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },   {
        targetModule : 'main.plot.xAxis2',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'secondScale'
      },
   {
        targetModule : 'main.plot.xAxis2',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'main.plot.xAxis2',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.stackedbar',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TypeUtils, ObjectUtils, dispatch, MNDHandler,tooltipDataHandler, ColorSeries, Scaler, Repository, NumberUtils, Objects, langManager, boundUtil) {
  var bar = function(manifest, ctx) {
    var tooltipHandlerObj = null;
    var data, 
        data1 = [[]],
        data2 = [[]],
        seriesData = [], tooltipData = [], //in stacked chart the value in tooltip is the same with data in seriesData, but in percentage chart it use the absolute value of negative data.
        primaryAxisTopBoundary = 0,
        primaryAxisBottomBoundary = 0,
        primaryAxisManualRange = false,
        secondaryAxisManualRange = false,
        secondaryAxisTopBoundary = 0,
        secondaryAxisBottomBoundary = 0,
        gWrapper = null;
    
    var width, 
        height,
        id = Math.floor(Math.random() * 10000),
        x = 0, y = 0,
        isDualAxis = false,
        colorPalette = [],
        axis1ColorPalette,
        axis2ColorPalette,
        MNDInnerOnColor = false,
        measureOnAxis1 = 0,
        measureOnAxis2 = 0,
        shapePalette = ['squareWithRadius'],
        properties,
        eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
      
    var effectManager = ctx.effectManager;
    
    var yScale = d3.scale.ordinal(),
        xScale = d3.scale.linear(),
        xScale2 = d3.scale.linear();
      
    var decorativeShape = null,
        lastSelected = [],
        evtData = [],
        lastHovered = null,
        isLasso = false;
      
    var barNumber = 1,
        barGroupNumber,
        barNumberinGroup,
        barHeight,
        positiveIndexes = [], 
        negativeIndexes = [];
      
    var enableDataLoadingAnimation = true,
        enableDataUpdatingAnimation = true,
        enableRoundCorner = false,
        clipEdge = true,
        hasMNDonCategoryAxis = false,
        isOnlyInitAnimation = false,
        afterAttachToDOM = false,
        tooltipVisible,
        totalIntervalTime = 1000;
    
    var defsEnter = null, 
        roundCornerDefs = null,
        suffix = Repository.newId();
    
    var mode = 'comparison'; // bar display mode
    
    var drawingEffect = 'normal';
    
    var sizeChange = false, dataStructureChange = false, dataValueChange = false;
    
      
    var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        mode = properties.mode === 'percentage'? 'percentage': 'comparison';
        enableDataLoadingAnimation =  properties.animation.dataLoading; 
        enableDataUpdatingAnimation =  properties.animation.dataUpdating; 
        tooltipVisible = properties.tooltip.enabled;      
        if(isDualAxis && !hasMNDonCategoryAxis){
          axis1ColorPalette = properties.primaryValuesColorPalette;   
          axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
          axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }

        drawingEffect = properties.drawingEffect;
        
        var indexforSecondaryAxis = data1.length;
            colorPalette = [];
        var i,j;
        if(MNDInnerOnColor){
          var flag = 0, flag2 = 0;
          for(i=0; i < seriesData[0][0].length; i++){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
            flag++;
            if(flag === measureOnAxis1 && isDualAxis && TypeUtils.isExist(seriesData[0][1])){
              flag2 = 0;
              for(j=0; j <=seriesData[0][1].length; j++){
                if(flag2 >= measureOnAxis2){
                  flag = 0;
                  break;
                }
              colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
              flag2++;
            }
          }
        }
      }else{
          for(i=0 ; i < seriesData[0].length; i++){
            for(j=0; j < seriesData[0][0].length; j++){
               colorPalette.push(axis1ColorPalette[j % axis1ColorPalette.length]);
            }
            if(isDualAxis && TypeUtils.isExist(seriesData[0][1])){
              for(j=0; j < seriesData[0][1].length; j++){
                colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
              }
            }
          }
        }                    
      };
      
      function chart(selection){
        boundUtil.drawBound(selection, width, height);
        
        //deal with percentage mode
        if(mode === 'percentage'){
          turnToPercentage();
        }
        
        tooltipHandlerObj = tooltipDataHandler();
        
        // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
        if(!TypeUtils.isExist(xScale) && !TypeUtils.isExist(xScale2)) {
          return;
        }
        eDispatch.startToInit();
        
        selection.each(function(){
          
        barNumber = (TypeUtils.isExist(data2)) ? 2 : 1;
        barHeight = 8 * (yScale.rangeBand()) / (9*barNumber +7 );
        
        barNumberinGroup = seriesData[0][0].length + ((TypeUtils.isExist(seriesData[0][1])) ? seriesData[0][1].length : 0);
        var barHeightInitial = 8 * (yScale.rangeBand()) / (9*barNumberinGroup +7 );
          
        var svg = (gWrapper = d3.select(this));
        //append decorativeShape
          if(decorativeShape === null){
            decorativeShape = svg.append('rect').attr('width', width).attr('height',
            yScale.rangeBand() - barHeight/2).attr('visibility', 'hidden').attr(
                'fill', 'rgba(133,133,133, 0.2)');
          }else{
            decorativeShape.attr('width', width).attr('height', yScale.rangeBand() - barHeight/2).attr('visibility', 'hidden');
          }
          
          if(defsEnter === null){
          defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
        }else{
          defsEnter.attr('width', width).attr('height', height);
        }  
          
           if(roundCornerDefs === null){      
          roundCornerDefs = svg.append('defs').attr('id', 'round-corner-clip' + suffix);
        }else{
          if( dataStructureChange || sizeChange || dataValueChange  || !enableRoundCorner){
            roundCornerDefs.remove();
            roundCornerDefs = svg.append('defs').attr('id', 'round-corner-clip' + suffix);
          }
        }    
        
        var r = Math.log(barHeight)/Math.log(2);
        if( r < 0 ){
          enableRoundCorner = false;
        }
        var datashapesgroup = svg.selectAll('g.datashapesgroup');
        if(!TypeUtils.isExist(datashapesgroup[0][0])){
          datashapesgroup = svg.append('g').attr('class', 'datashapesgroup');
        }
        var barGroup;
            barGroup = datashapesgroup.selectAll('g.bar').data(seriesData);     
            barGroup.enter().append('g');
            barGroup.attr('class','bar').each( function (perGroupData,i) {
              var axisGroup = d3.select(this).selectAll('g.axisGroup').data(perGroupData);     
                axisGroup.enter().append('g');
                axisGroup.attr('class','axisGroup').each( function (perAxisData,j) {  
                  // This is for dual axis
                  var valueScale = (j === 0) ? xScale : xScale2;
                  var startPoint = (j === 0) ? barHeight /2 : (barHeight /2 + barHeight + barHeight/8);
                  var initStartPoint = (j === 0) ? yScale(i) : (yScale(i) + barHeight / 2 + barHeight) ;
                  var fillingColor =  (j === 0) ? axis1ColorPalette : axis2ColorPalette;
                  
                  // This is for pos/neg values.
                  var positiveX = 0, negativeX = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                  var yArray = [], xArray=[];
                  // wrap a datashape g for each rect
                  var barShape = d3.select(this).selectAll('g.datashape').data(perAxisData);
                      barShape.enter().append('g').attr('class','datashape').append('rect').attr('class', 'datapoint');
                      barShape.exit().remove();
                      
                      // [21-Nov-2012 Nick] Keep the original x-position for each g.datashape, it is used when data value changes.
                      if(afterAttachToDOM){
                        barShape.each(function(){
                          xArray.push(this.getTransformToElement(this.parentNode).e);
                        });
                      }
                      
                      // [20-Nov-2012 Nick] As g.datashape is considered as a 'shape' concept, all positioning behavior is applied to this element
                      barShape.attr('transform', function (perRectData, k) {
                        var y = yScale(i) + startPoint;
                        yArray.push(y);
                        
                        var x;
                        if(perRectData.val >= 0){
                          positiveX = valueScale(positiveStackedValue);
                          positiveStackedValue += perAxisData[k].val;
                                         x = positiveX;
                        }else{
                          negativeStackedValue += perAxisData[k].val;
                          x =  valueScale(negativeStackedValue);
                        }     
                          return 'translate('+x+','+y+')'
                      });
                      
                  var bar = barShape.select('rect.datapoint');
                      bar.attr('fill', function(d,colorIndex){  
                        d.fillColor = fillingColor[colorIndex % fillingColor.length];
                        var parameter = {
                          drawingEffect:drawingEffect,
                          fillColor : d.fillColor,
                          direction : 'vertical'
                        };
                        return effectManager.register(parameter);
                      }).attr('shape-rendering','crispEdges').attr('fill-opacity', 1);
                  
                  // [04 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                  // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                  if(enableDataLoadingAnimation && !isOnlyInitAnimation){
                  if(dataStructureChange){
                    bar.attr('height',barHeightInitial)
                       .attr('y', function (perRectData, m) {
                           var y = initStartPoint - yArray[m] + barHeightInitial * m;
                           y = y + barHeightInitial/8 *(m) + barHeightInitial /2;
                           return y;
                       }).attr('x', function(perRectData){
                         if(perRectData.val  > 0){
                           return 0;
                         }else{
                           return valueScale(0) - valueScale(perRectData.val);
                         }
                       }).attr('width', 0);

                    // [04 - Sep - 2012 Nick] Round corner enabled. Do the same transition as the bars do.
                    if(enableRoundCorner){
                      bar.attr('clip-path', function(perRectData, indexinGroup){
                        if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                            var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                            var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                      .append('rect').attr('class', 'roundCorner-clip')
                                      .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                      .attr('height',barHeightInitial).attr('width', 0)
                                      .attr('x', this.x.baseVal.value)
                                      .transition().duration(totalIntervalTime/2)
                                      .attr('x',function(){
                                        if(indexinGroup ===  negativeIndexes[j][i] ){
                                          return 0;
                                        }else{
                                          return 0 - r;
                                        }
                                      })
                                      .attr('width', function(){
                                         return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                      })
                                      .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                                      .attr('height',barHeight).attr('y', 0);
                          return 'url(#' + id + ')' ;
                        }
                         
                      });
                    }
                    negativeStackedValue = 0;
                    bar.transition().duration(totalIntervalTime/2)
                       .attr('width', function(perRectData){
                         return Math.abs(valueScale(perRectData.val) - valueScale(0));
                       })
                       .attr('x', 0);
                    
                    bar.transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                       .attr('height',barHeight)
                       .attr('y', 0)
                       .each('end', function(d, m){
                        //As in large data with animation, transition code will be washed away, we should reset the width of rect in the animation end.
                           this.setAttribute('width', Math.abs(valueScale(d.val) - valueScale(0)) );
                         // Fire out event to tell the animation is done.
                         if(m === seriesData[0][0].length - 1 && i === 0){
                           completeAnimation();
                         }
                       });
                  }
                  else if(sizeChange){
                    bar.attr('x',function(d,k){
                          return xArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
                       })
                       .attr('width', function(perRectData){
                         var newWidth = Math.abs(valueScale(perRectData.val) - valueScale(0));
                         if(parseFloat(this.width.baseVal.value) > newWidth){
                           return this.width.baseVal.value;
                         }else{
                           return newWidth;
                         }
                     });
                    var sizeTransition = bar.transition();
                    sizeTransition.duration(totalIntervalTime/2)
                       .attr('width', function(perRectData){
                         return Math.abs(valueScale(perRectData.val) - valueScale(0));
                       })
                       .attr('x',0)
                       .attr('height',barHeight)
                       .each('end', function(d, m){
                        this.setAttribute('width', Math.abs(valueScale(d.val) - valueScale(0)));
                         // Fire out event to tell the animation is done.
                         if(m === seriesData[0][0].length - 1 && i === 0){
                           completeAnimation();
                         }
                       });
                    
                      if(enableRoundCorner){
                        sizeTransition.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                            var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                            var x = parseFloat(this.x.baseVal.value) ;
                            var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                        .attr('height',this.height.baseVal.value).attr('width', this.width.baseVal.value + r)
                                        .attr('x', function(){
                                          return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                        })
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('x',function(){
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return 0;
                                          }else{
                                            return 0 - r;
                                          }
                                        })
                                        .attr('width', function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                        })
                                        .attr('height',barHeight).attr('y', 0);
                            return 'url(#' + id + ')' ;
                          }
                           
                        });
                      }
                  }
                  // [04 - Sep - 2012 Nick] Data has the same structure, but the value changed.
                  // TO BE TESTED ! WE DO NOT HAVE THIS WORK FLOW NOW.  
                  else if(dataValueChange){
                    bar.attr('x',function(d,k){
                        return xArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
                    });
                    var stateChange = bar.transition();
                      stateChange.duration(totalIntervalTime/2)
                        .attr('width', function(perRectData){
                          return Math.abs(valueScale(perRectData.val) - valueScale(0));
                        })
                        .attr('x', 0)
                        .each('end', function(d, m){
                          this.setAttribute('width', Math.abs(valueScale(d.val) - valueScale(0)));
                          // Fire out event to tell the animation is done.
                          if(m === seriesData[0][0].length - 1 && i === 0){
                            completeAnimation();
                          }
                        });
                        if(enableRoundCorner){
                          stateChange.attr('clip-path', function(perRectData, indexinGroup){
                            if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var x = parseFloat(this.x.baseVal.value) ;
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                        .attr('height',barHeight).attr('width', this.width.baseVal.value + r)
                                        .attr('x', function(){
                                          return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                        })
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('x',function(){
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return 0;
                                          }else{
                                            return 0 - r;
                                          }
                                        })
                                        .attr('width', function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                        });  
                              return 'url(#' + id + ')' ;
                            }
                          });
                      }
                  }
                  else if (enableRoundCorner){
                    bar.attr('clip-path', function(perRectData, indexinGroup){
                      if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                        var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                        var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                    .append('rect').attr('class', 'roundCorner-clip')
                                    .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                    .attr('height',barHeight).attr('width', function(){
                                                                  return  Math.abs(valueScale(perRectData.val) - valueScale(0) ) + r;
                                                              });
                        if(indexinGroup === negativeIndexes[j][i]){
                          roundCorner.attr('x',0);
                        }else{
                          roundCorner.attr('x',0 - r);  
                        }
            
                        return 'url(#' + id + ')' ;
                      }
                       
                    });
                  }

                //  bar.exit().remove();  
                }else{
                  bar.attr('y',0).attr('x', 0) 
                     .attr('width',function(perRectData,k){
                           var width = Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           return width;                   
                     })
                     .attr('height',barHeight);
                  
                  if(enableRoundCorner){
                    bar.attr('clip-path', function(perRectData, indexinGroup){
                      if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                        var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                        var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                    .append('rect').attr('class', 'roundCorner-clip')
                                    .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                    .attr('height',barHeight).attr('width', function(){
                                                                  return  Math.abs(valueScale(perRectData.val) - valueScale(0) ) + r;
                                                              });
                        if(indexinGroup === negativeIndexes[j][i]){
                          roundCorner.attr('x',0);
                        }else{
                          roundCorner.attr('x',0 - r);  
                        }
            
                        return 'url(#' + id + ')' ;
                      }
                       
                    });
                  }
                }
              });
              axisGroup.exit().remove();
          });
          barGroup.exit().remove();
          if(!enableDataUpdatingAnimation){
            isOnlyInitAnimation = true;
          }
         
        
        sizeChange = false, dataValueChange = false, dataStructureChange = false;
        });
        
        if(!enableDataLoadingAnimation){
          completeAnimation();
        }
        
        return chart;
      }
     
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(yOnModule - yScale.rangeBand()*i - 0.5 * yScale.rangeBand() ) <= 0.5 * yScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1) || i < 0) {
        decorativeShape.attr(
            'visibility', 'hidden');
        return;
      }

      decorativeShape.attr(
          'y',
          yScale.rangeBand() * i + barHeight/4).attr(
          'visibility', 'visible');

      if(i !== lastHovered){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode.parentNode.parentNode point to the main container
          var transform = gWrapper[0][0].getTransformToElement(gWrapper[0][0].ownerSVGElement);
          var yoffset = transform.f;
          var sumAxis1 = 1, sumAxis2 = 1 , m = 0;
          var tData = tooltipHandlerObj.generateTooltipData(data, tooltipData, barGroupNumber-1-i, colorPalette, shapePalette);
          
          tData.point = {
              x: d3.event.layerX,
              y: yScale.rangeBand()*i + 0.5 * yScale.rangeBand() + yoffset
          };
          tData.plotArea = {
            x : transform.e,
            y : transform.f,
            width : width,
            height : height
          };
          tData.valueAxis0Count = seriesData[0][0].length;
          tData.valueAxis1Count = TypeUtils.isExist(seriesData[0][1]) ? seriesData[0][1].length:0;
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
        }
      }
      };
      
      chart.blurOut = function(){
        decorativeShape.attr('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {      
        eDispatch.hideTooltip();
      }
      };
      
      chart.parent = function(){
        return gWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
        }else{
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      
        function turnToPercentage(){
          for(var i=0, len = seriesData.length; i < len; i++){
            for(var j=0 , rowSeriesData = seriesData[i], rowTooltipData = tooltipData[i]; j < rowSeriesData.length; j++){
              var sum = 0, avaCount = 0, k;
              for(k=0; k < rowSeriesData[j].length; k++){
                sum += Math.abs(rowSeriesData[j][k].val);
                if(!rowSeriesData[j][k].isNaN) {
                  avaCount++;
                }
              }
              if(sum === 0){

                for(k=0; k < rowSeriesData[j].length; k++){
                        rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                        rowSeriesData[j][k].val = rowSeriesData[j][k].isNaN? 0:1/avaCount ;
                        if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                          rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : 1/avaCount;
                        }
                }
              }else{
                for(k=0; k < rowSeriesData[j].length; k++){
                    if(rowSeriesData[j][k].val < 0){
                      rowSeriesData[j][k].isNegative = true;
                    }
                    rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                    rowSeriesData[j][k].val = Math.abs(rowSeriesData[j][k].val/sum);
                    if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                      rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : rowTooltipData[j][k].val/sum;
                    }
                }
              }
              
            }
          }
      }
      
      function completeAnimation(){
            eDispatch.initialized();
            afterAttachToDOM = true;
      }
      
      chart.afterUIComponentAppear = function(){
        eDispatch.initialized(); 
      };
      
      
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange = (width === value)&&!sizeChange? false:true;
          width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange? false:true;
        height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
         return chart;        
      };
      /**
       * set/get data, for some modules like Title, it doesn't need data
       */
      chart.data = function(value){
        if (!arguments.length){
          return data;
        }
        data = value;
        var obj = MNDHandler(data);
                 
        var _data1 = obj["MG1"];
        var _data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
        tooltipData = [];
        var i;
        
        if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
          var tempData1 = [], tempData2 = [];
          var tempStackedData1 = [], tempStackedData2 = [];
          for(i=0; i<_data1.length; i++){
            tempData1 = [];
            tempData2 = [];
            for(var j=0; j<_data1[i].length; j++){
              if(obj.color[j] === 0){
                tempData1.push(_data1[i][j]);
                tempData2.push({
                  val:null,
                  hasMNDonCategoryAxis : true
                });
              }else{
                tempData1.push({
                  val:null,
                  hasMNDonCategoryAxis : true
                });
                tempData2.push(_data1[i][j]);
              }
            }
            tempStackedData1.push(tempData1);
            tempStackedData2.push(tempData2);
          }
          _data1 = tempStackedData1;
          _data2 = tempStackedData2;
          
      }else{
            hasMNDonCategoryAxis = false;
            if(TypeUtils.isExist(_data2)){
              if(! dataStructureChange && 
                  (data2.length !== _data2.length || data2[0].length !== _data2[0].length)){
                  dataStructureChange = true;
               }
              isDualAxis = true;
            }else{
              isDualAxis = false;
            }
     }
     if(data1.length !== _data1.length || data1[0].length !== _data1[0].length){
       dataStructureChange = true;
     }

      var _seriesData = dataHandler(_data1, _data2, obj.color);
      
        //judge what changed in dataset
        if(!dataStructureChange){
          dataValueChange = true;
        }
        seriesData = _seriesData;
        data1 = _data1;
        data2 = _data2;
        
        if(hasMNDonCategoryAxis){
          for(i=0; i< seriesData.length; i++){
            var temp = seriesData[i];
            if(temp[0][0].hasMNDonCategoryAxis){
              tooltipData.push(temp[1]);
            }else{
              tooltipData.push(temp[0]);
            }
          }
        }else{
          tooltipData = ObjectUtils.extend(true, {}, seriesData); 
        }
        
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      
      parseOptions();
      
      return chart;        
    };


    /**
     * set/get properties
    */
    chart.properties = function(props){
      if (!arguments.length){
          return properties;
       }
      Objects.extend(true, properties, props);
            parseOptions();
        
        return chart;        
    };
       

    var makeScales = function(){
      var domain = [];
      for (var i=0; i < seriesData.length; i++){
          domain.push(i);
        }
        yScale.domain(domain).rangeBands([height, 0]);
        if(mode === 'percentage'){
          xScale.domain([0,1]).range([0, width]);
          xScale2.domain([0,1]).range([0, width]);
        }else{
          //when all data is 0 or null ,we make the domain from 0 to 1
          if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0 ){
            xScale.domain([0,1]).range([0, width]);
          }else{
            xScale.domain([primaryAxisBottomBoundary,primaryAxisTopBoundary]).range([0, width]);            
          }
         
          
          if( TypeUtils.isExist(data2) || isDualAxis ){
          //when data of second axis is all 0 or null, we make the xScale2 same with xScale .

            if(secondaryAxisTopBoundary === 0 && secondaryAxisBottomBoundary === 0){
              xScale2.domain(xScale.domain()).range(xScale.range());
            }else{
              xScale2.domain([secondaryAxisBottomBoundary, secondaryAxisTopBoundary]).range([0, width])
              //when data of first axis is all 0 or null, we make the xScale same with xScale2 .
              if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
                xScale.domain(xScale2.domain()).range(xScale2.range());
              }
            }

          }else{
            if (!primaryAxisManualRange) {
              Scaler.perfect(xScale);
            }
          }
        }
        if (!primaryAxisManualRange && !secondaryAxisManualRange)
        {
            Scaler.perfectDual(xScale, xScale2);
        }
        else if(!primaryAxisManualRange && secondaryAxisManualRange)
        {
            Scaler.perfect(xScale);
        }
        else if(primaryAxisManualRange && !secondaryAxisManualRange)
        {
            Scaler.perfect(xScale2);
        }
        if(!TypeUtils.isExist(data2)){
            xScale2.range([0, 0]);
        }
    };


    chart.colorPalette = function(Palette){
        if (!arguments.length){
          return colorPalette;
       }
        colorPalette = Palette;
       return chart;        
    };

    chart.categoryScale = function(scale){
        if (!arguments.length){
          return yScale;
       }
        yScale = scale;
       return chart;
    };
    
    chart.primaryDataRange = function(range){
      if (!arguments.length){
        var maxt, mint;
        if(mode === 'percentage'){
          maxt = 1;
          mint = 0;
        }else{
          mint = primaryAxisBottomBoundary < 0 ? primaryAxisBottomBoundary : 0;
          maxt = primaryAxisTopBoundary;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      if (range !== null) {
          primaryAxisTopBoundary = range.max;
          primaryAxisBottomBoundary = range.min;
          if (range.from === 'axis') {
            primaryAxisManualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            makeScales();
          }
      }
      return chart;
    };
      
    chart.secondDataRange = function(range){
      if (!arguments.length){
        var maxt, mint;
        if(mode === 'percentage'){
          maxt = 1;
          mint = 0;
        }else{
          mint = secondaryAxisBottomBoundary< 0 ? secondaryAxisBottomBoundary : 0 ;
          maxt = secondaryAxisTopBoundary;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      if (range !== null) {
          secondaryAxisTopBoundary = range.max;
          secondaryAxisBottomBoundary = range.min;
          if (range.from === 'axis') {
            secondaryAxisManualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            makeScales();
          }
      }
      return chart;
    }; 
       
    chart.primaryScale = function(scale){
        if (!arguments.length){
          return xScale;
       }
        xScale = scale;
       return chart;
    };     
    
    chart.secondScale = function(scale){
            if (!arguments.length){
                return xScale2;
            }
            xScale2 = scale;
            return chart;
        };    

      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
          //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(TypeUtils.isExist(seriesData[0][1]) && !hasMNDonCategoryAxis){
          return axis2ColorPalette[seriesData[0][1].length-1];
        }else{
          //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };          
        
      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
     
      chart.x = function(_){
        if(!arguments.length){
          return x;
        }
        x= _;
        return this;
      };
      
      chart.y = function(_){
        if(!arguments.length){
          return y;
        }
        y = _;
        return this;
      };
      
      chart.dispatch = function(_){
        if(!arguments.length){
          return eDispatch;
        }
        eDispatch = _;
        return this;
      };
      
      chart.dataLabel = function(_){};
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
//      var dataTransform = function(data1, data2){
//        var stackedBarGroup = [];
//      // the number of bar in each group
//      var barGroupNumber =  data1[0].length;;
//      var transferredDataSet = data1;
//      var temp, temp2;
//      for(var j=0; j < barGroupNumber; j++){
//        var ds = [];
//        temp = 0, temp2 = 0
//        for(i=0; i< transferredDataSet.length; i++){
//          ds.push(transferredDataSet[i][j]);
//          if(transferredDataSet[i][j].val >= 0){
//            temp += transferredDataSet[i][j].val;
//          }else{
//            temp2 += transferredDataSet[i][j].val;
//          }
//        }
//        if(primaryAxisTopBoundary < temp){
//          primaryAxisTopBoundary = temp
//        }
//        if(primaryAxisBottomBoundary > temp2){
//          primaryAxisBottomBoundary = temp2
//        }
//        stackedBarGroup.push(ds);
//      }
//      if(TypeUtils.isExist(data2)){
//          barGroupNumber =  data2[0].length;;
//                transferredDataSet = data2;
//                for(var j=0; j < barGroupNumber; j++){
//                    temp = 0
//                    for(i=0; i< transferredDataSet.length; i++){
//                        stackedBarGroup[j].push(transferredDataSet[i][j]);
//                        temp += transferredDataSet[i][j].val;
//                    }
//                    if(secondaryAxisBoundary < temp){
//                        secondaryAxisBoundary = temp
//                    }
//                }
//            }
//      
//        return stackedBarGroup;
//      };
      
      var dataHandler = function(valueAxis1Data, valueAxis2Data, colorIndexArray){
        
        var positiveIndex = -1, negativeIndex = -1;
        positiveIndexes = [[],[]], negativeIndexes = [[],[]];
      
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        
        var stackedBarGroupsData = [];
        // the number of bar in each group
        barGroupNumber =  valueAxis1Data[0].length;
        var temp, temp2;
        for(var j=0; j < barGroupNumber; j++){
          var tempDataSetAxis1 = [], tempDataSetAxis2 = [];
          var oneGroupDataSet = [];
          temp = 0, temp2 = 0;
          positiveIndex = -1, negativeIndex = -1;
          for(var i=0; i< valueAxis1Data.length; i++){
            if(NumberUtils.isNoValue(valueAxis1Data[i][j].val)){
              //Jimmy/1/9/2013, what happens if we use null as the number value
              //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
              //and http://bclary.com/2004/11/07/#a-11.8.5
              //checked in chrome/IE9/firefox/javafx, it works fine
              //the change is to ensure we display 'No Value' in other places related to this data point
              valueAxis1Data[i][j].val = null;
              valueAxis1Data[i][j].isNaN = true;
            }else{
              
              if(valueAxis1Data[i][j].val >= 0){
                temp += valueAxis1Data[i][j].val;
                positiveIndex = i;
              }else{
                temp2 += valueAxis1Data[i][j].val;
                negativeIndex = i;
              }
            }
          tempDataSetAxis1.push(valueAxis1Data[i][j]);
        }
        positiveIndexes[0].push(positiveIndex);
        negativeIndexes[0].push(negativeIndex);
        
        if(primaryAxisTopBoundary < temp){
          primaryAxisTopBoundary = temp;
        }
        if(primaryAxisBottomBoundary > temp2){
          primaryAxisBottomBoundary = temp2;
        }
        oneGroupDataSet.push(tempDataSetAxis1);
        
        
        if(TypeUtils.isExist(valueAxis2Data)){
          temp = 0, temp2 = 0;
          positiveIndex = -1, negativeIndex = -1;
          for(i=0; i< valueAxis2Data.length; i++){
            positiveIndex = 0, negativeIndex = -1;
            if(NumberUtils.isNoValue(valueAxis2Data[i][j].val)){
              //Jimmy/1/9/2013, what happens if we use null as the number value
              //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
              //and http://bclary.com/2004/11/07/#a-11.8.5
              //checked in chrome/IE9/firefox/javafx, it works fine
              //the change is to ensure we display 'No Value' in other places related to this data point
              valueAxis2Data[i][j].val = null;
              valueAxis2Data[i][j].isNaN = true;
            }else{
              
              if(valueAxis2Data[i][j].val >= 0){
                temp += valueAxis2Data[i][j].val;
                positiveIndex = i;
              }else{
                temp2 += valueAxis2Data[i][j].val;
                negativeIndex = i;
              }
            }
            tempDataSetAxis2.push(valueAxis2Data[i][j]);
          }
          positiveIndexes[1].push(positiveIndex);
          negativeIndexes[1].push(negativeIndex);
          
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp;
          }
          if(secondaryAxisBottomBoundary > temp2){
            secondaryAxisBottomBoundary = temp2;
          }
          oneGroupDataSet.push(tempDataSetAxis2);
        }
        stackedBarGroupsData.push(oneGroupDataSet);
       }
        
        return stackedBarGroupsData;
      };
    
      properties = manifest.props(null);
      return chart;
  };
  return bar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.stackedbar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
    var module = {
      'id' : 'sap.viz.modules.stackedbar',
      'name' : 'stacked bar',
      base : "sap.viz.modules.bar",
      'properties' : {
        'mode' : {
          'name' : 'mode',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'comparison', 'percentage' ],
          'defaultValue' : 'comparison',
          'description' : 'Set dispaly mode of stacked bar.',
          'isExported' : true
        }
      },
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_dual_stacked_bar',
    name : 'IDS_MULTIDUALSTACKEDBARCHART',
    base : 'viz/multi_dual_bar',
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedbar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false
                  },
                  propertiesOverride : {
                    position : {
                      isExported : false
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualPercentageStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualStackedBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_dual_stacked_bar',
    name : 'IDS_MULTIDUALPERCENTAGESTACKEDBARCHART',
    base : 'viz/multi_dual_stacked_bar',
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  properties : {
                    isPercentMode : true
                  }
                }
              },
              xAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  properties : {
                    isPercentMode : true
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.stackedbar',
                configure : {
                  properties : {
                    'mode' : 'percentage'
                  }
                }
              },
              
              dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode : true,
                      type : 'value',
                      showZero : true
                    }
                  }
                }
            }
          }
        }
      },
      
      tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
        formatString: [["0.00%"],["0.00%"]]
            }
          }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_stacked_column',
    name : 'IDS_MULTISTACKEDVERTICALBARCHART',
    base : 'viz/multi_column',
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedverticalbar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false
                  },
                  propertiesOverride : {
                    position : {
                      isExported : false
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds:{  
      multiplier:{
      max:1
    },
      axisLabels:{
      max:1
    },
    secondaryValues: null
  },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      },{
    targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPercentageStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiStackedVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_stacked_column',
    name : 'IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART',
    base : 'viz/multi_stacked_column',
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues: null,
      axisLabels:{
        max:1
      }
    },
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  properties : {
                    isPercentMode : true
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.stackedverticalbar',
                configure : {
                  properties : {
                    'mode' : 'percentage'
                  }
                }
              },
              dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode : true,
                      showZero : true
                    }
                  }
                }
            }
          }
        }
      },
      
      tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
        formatString: [["0.00%"],["0.00%"]]
            }
          }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_stacked_bar',
    name : 'IDS_MULTISTACKEDBARCHART',
    base : 'viz/multi_bar',
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedbar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false
                  },
                  propertiesOverride : {
                    position : {
                      isExported : false
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds:{  
        multiplier:{
        max:1
      },
        axisLabels:{
        max:1
      },
      secondaryValues:null
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      },{ 
      targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPercentageStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiStackedBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_stacked_bar',
    name : 'IDS_MULTIPERCENTAGESTACKEDBARCHART',
    base : 'viz/multi_stacked_bar',
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues: null,
      axisLabels:{
        max:1
      }
    },
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  properties : {
                    isPercentMode : true
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.stackedbar',
                configure : {
                  properties : {
                    'mode' : 'percentage'
                  }
                }
              },
              dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode : true,
                      type : 'value',
                      showZero : true
                    }
                  }
              }
            }
          }
        }
      },
      tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
        formatString: [["0.00%"],["0.00%"]]
            }
          }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Radar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup( Manifest, constants ) {
  var colors = {
    id : "regionColor",
    name : "Region Color",
    type : constants.Type.Dimension,
    min : 0,
    max : 2,
    aaIndex : 2,
    acceptMND : 2
  },
  
  shapes = {
    id : "regionShape",
    name : "Region Shape",
    type : constants.Type.Dimension,
    min : 0,
    max : 2,
    aaIndex : 3,
    acceptMND : 0
  },
  
  axes = {
    id : "radarAxes",
    name : "Radar Axes",
    type : constants.Type.Dimension,
    min : 1,
    max : 1,
    aaIndex : 1,
    acceptMND : 1
  },

  values = {
    id : "radarAxesValues",
    name : "Radar Axes Values",
    type : constants.Type.Measure,
    min : 1,
    max : constants.Constraints.INF,
    mgIndex : 1
  };

  var feeds = {
    id : "radar",
    feeds : [ colors, shapes, axes, values ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.util.ShapeSeriesGenerator',
  version : '4.0.0'},
[

],
function Setup(){
  var ShapeSeries = {
    sapShapes : function(){
      return d3.scale.ordinal().range(['circle', 'diamond', 'triangle-up', 'triangle-down', 'triangle-left', 'triangle-right', 'cross', 'intersection']);
    }
  };
  return ShapeSeries;
});sap.riv.module(
{
  qname : 'sap.viz.modules.radar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ShapeSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup( callouts, types, texts, evtHub, axis, colorRange, shapeRange, scaler, global, 
  painter, langManager, tooltipDataHandler, Objects, BoundUtil) {
  return function ( conf, ctx ) {
    var width = 0, height = 0, data = {}, properties = {}, angles,
        rescale, styles = {}, radar, valueaxis, yscale = d3.scale.linear(), 
        defaults, brush = {}, colorPalette = [], shapePalette = [], textRuler,
        dispatch, container = null, ranges, selections = {}, selectionMode = 'multiple', 
        arrange, effects = ctx.effectManager;
    
    dispatch = evtHub("selectData", "deselectData", 
      "showTooltip", "hideTooltip", "initialized", 'startToInit');
    
    radar = {
      clazz : "spiderweb",
      node : null,
      color : colorRange.sap32(),
      shape : shapeRange.sapShapes(),
      radiusLength : 0,
      radius : d3.scale.linear(),
      anchor : { x : 0, y : 0 },
      radians : [],
      series : [],
      categories : [],
      caption : { 
        node : null,
        name : "category-axis-title",
        width : 0,
        height : 0
      },
      labels : {},
      locked : false,
    };
    
    valueaxis = {
      clazz : "valueaxis",
      anchor : { x : 0, y : 0 },
      ref : axis(global.get("sap.viz.modules.axis"), ctx),
      node : null,
      width : 0,
      height : 0
    };
    
//    properties = {
//      drawingEffect : "normal",
//      polarGrid : { visible : true, color : "#d8d8d8" },
//      polarAxis : { title : { visible : false, text : "Categories" } },
//      valueAxis : { visible : true, title : { visible : false, text : "Value" }, label : { formatString : null} },
//      line : { width : 2 },
//      surface : { fill : { visible : true, transparency : 0.3 } },
//      colorPalette : [],
//      shapePalette : [],
//      marker : { size : 6 },
//      tooltip : { enabled : true },
//      multichart : false
//    };
    properties = conf.props(null);
    
    css = {
     // background : "viz-plot-background",
      axisTitle : "viz-axis-title"
    },
    
    styles = {
      spacing : { hgap : 5, vgap : 5 },
     // background : { css : { key : "viz-plot-background", def : null } },
      alignment : { horizontal : "center" },
      polaraxis : { 
        clazz : "polar_axis", 
        color : "#6c6c6c", 
        weight : "1px",
        labels : { css : { key : "viz-polar-axis-label", def : null } },
        title : { css: { key : "viz-polar-axis-title", def : null } }
      },
      polargrid : { clazz : "polar_grid", color : "#d8d8d8", weight : "1px" },
      line : { clazz : "dataline" },
      valueaxis : { clazz : "value_axis", title : { css : { key : "viz-axis-title", def : null } }},
      marker : { clazz : "datapoint", css : { key : "viz-radar-marker", def : null },
                 stroke : "transparent" },
      labels : { color : "#333333", fontSize : "14px", fontWeight : "normal", fontFamily : "Arial" },
      tooltip : { radialOffset : 1 * 10  } // 1em
    };
    
    ranges = {
      dataline : {
        weight : [ 1, 7 ]
      },
      marker : {
        size : [ 4, 32 ]
      }
    };
    
    defaults = {
      options : $.extend( true, {}, properties ),
      styles : $.extend( true, {}, styles ),
      wording : {
        dash : " - ",
        dot : ".",
        slash : " / ",
        ellipsis : "...",
        series : "s",
        data : "d",
        measureIndex : " mi",
        and : " & "
      }
    };
    
    // only deal with domain values
    rescale = function () {
      var series = radar.series, min = arguments[0], max = arguments[1];
      // Measure values are always two-dimensional.
      radar.max = typeof max !== "undefined" ? max :
                  d3.max( d3.merge( d3.merge(series) ), function (_) { return _.val; } );
      radar.min = typeof min !== "undefined" ? min : 
                  d3.min( d3.merge( d3.merge(series) ), function (_) { return _.val; } );
      
      if ( radar.min === radar.max ) {
        if ( radar.min === 0 ) radar.max = 100;
        if ( radar.min < 0 ) radar.max = 0;
        if ( radar.min > 0 ) radar.min = 0;
      }
      
      if ( !radar.min || radar.min === "NaN" ) {
        radar.min = 0;
      }
      if ( !radar.max || radar.max === "NaN" ) {
        radar.max = 0;
      }
    };

    textRuler = function ( text, style ) {
      return texts.fastMeasure(text, style["font-size"] || style.fontSize,
        style["font-weight"] || style.fontWeight, style["font-family"] || style.fontFamily);
    };
    
    /* Layout algorithm. Arguments are preferred widths */
    arrange = function () {
      var sizes = arguments[0],
          axisWidth = sizes.valueaxis, lblW = sizes.lblW, lblH = sizes.lblH,
          caption = sizes.caption,
          pole = {}, w, r, adjust, bbox,
          hgap = styles.spacing.hgap, vgap = styles.spacing.vgap,
          counter = -1, mem = [];
      
      (function layout() {
        counter++;
        if ( lblH - 1/3 * height > 0 ) lblH = 0;
        if ( caption.height - 1/3 * height > 0 ) caption.height = 0;
        if ( caption.width - 2/3 * width > 0 ) caption.width = 0;  
        
        if ( width - height >= 0 ) {
          r = ( height - 2 * (lblH + 2 * vgap) - 
            (caption.height !== 0 ? caption.height + 2 * vgap : 0) ) / 2;
          w = 2 * r + 2 * (lblW + 2 * hgap) + axisWidth;
          if ( w > width ) {
            adjust = w - width;
            r = ( height - adjust - 2 * (lblH + 2 * vgap) - 
              (caption.height !== 0 ? caption.height + 2 * vgap : 0) ) / 2;
          }
        } else {
          r = ( width - 2 * (lblW + 2 * hgap) - axisWidth ) / 2;
        }
    
        mem[counter] = r;
        if ( typeof mem[counter - 2] !== 'undefined' && mem[counter - 2] <= 0 ) { return 0; } // prevent infinite loops   
        
        if ( lblW > r || r <= 0 ) {
          lblW = 0, lblH = 0; 
          caption.width = 0, caption.height = 0; 
          r = layout();
          
          if ( axisWidth > r) {
            axisWidth = 0;
            r = layout();
            if ( width >= height ) {
              if ( r < height / 2 ) r = height / 2, vgap = 0;
            } else {
              if ( r < width / 2 ) r = width / 2, hgap = 0;
            }
          }
        }
        return r;
      })();
      
      bbox = { // bounding box
        width : axisWidth + 2 * r + 4 * hgap + 2 * lblW,
        height : 2 * ( lblH + r ) + 4 * vgap + 
          (caption.height !== 0 ? caption.height + 2 * vgap : 0)
      };
      
      radar.radiusLength = r;
      valueaxis.width = axisWidth;
      valueaxis.anchor.x = 0;
      valueaxis.anchor.y = lblH + 2 * vgap;
      radar.caption.width = caption.width;
      radar.caption.height = caption.height;
      pole.x = axisWidth + lblW + r + hgap * 2;
      pole.y = lblH + r + vgap * 2;
      caption.x = pole.x;
      caption.y = pole.y + r + lblH + 2 * vgap + caption.height / 2;
      
      var xoffset = 0, yoffset = 0;
      if ( axisWidth ) {
        valueaxis.ref.gridlineLength(pole.x - axisWidth);
        if ( width > height ) {
          xoffset = width / 2 - bbox.width / 2;
          valueaxis.anchor.x += xoffset;
          pole.x += xoffset;
          caption.x += xoffset;
        }
      } else {
        if ( width > height ) {
          xoffset = width / 2 - pole.x;
          pole.x += xoffset;
          caption.x += xoffset;
        } 
      }
      
      //radar.caption.node.attr("transform", "translate(" + caption.x + "," + caption.y + ")");
      radar.caption.node.attr("x", caption.x);
      radar.caption.node.attr("y", caption.y);
      valueaxis.node.attr("transform", "translate(" + 
        valueaxis.anchor.x + "," + valueaxis.anchor.y + ")");
      radar.node.attr("transform", "translate(" + pole.x + "," + pole.y + ")");
      radar.pole = pole;
      radar.labels.width = lblW;
      radar.labels.height = lblH;
    };
    
    /*
     * Creates scale function/object for angular computation.
     * 
     * @param nulls - indexes of empty elements
     * @param N - numbers of non-empty elements
     * @param cardinal - numbers of all elements
     */
    angles = function ( nulls, N, cardinal ) {
      var domain = [], intervals = [], i;
      if ( !nulls.length ) {
        return d3.scale.linear()
          .domain([ 0, cardinal ])
          .range([ 0, 2 * Math.PI ]);
      }
      //if ( nulls.length > N ) callouts.error("Invalid argument.");
      for ( i = 0; i < cardinal; i++ ) {
        domain.push(i);
        intervals.push(i / cardinal * 2 * Math.PI);
      }
      for ( i = nulls.length - 1; i >= 0; i-- ) {
        intervals.splice(nulls[i].order, 1);
      }
      
      return d3.scale.ordinal()
            .domain(domain)
            .range(intervals);
    };
    
    function chart ( selection ) {
      BoundUtil.drawBound(selection, width, height);
      dispatch.startToInit();
      selection.each(function ( datum ) {
        var parent = d3.select(this), prefix = defaults.wording;
        valueaxis.node = null;
        radar.node = null;
        radar.radiusLength = 0;
        container = parent;
        
        parent.select(prefix.dot.concat(valueaxis.clazz)).remove();
        parent.select(prefix.dot.concat(radar.clazz)).remove();
        parent.select( prefix.dot + radar.caption.name ).remove();
        
        valueaxis.node = parent.append("g").attr("class", valueaxis.clazz);
        radar.node = parent.append("g").attr("class", radar.clazz + ' datashapesgroup');
        radar.caption.node = parent.append("text").attr("class", radar.caption.name);
        
        styles.valueaxis.title.css.def = ctx.styleManager.query(styles.valueaxis.title.css.key);
        styles.polaraxis.labels.css.def = ctx.styleManager.query(styles.polaraxis.labels.css.key);
        
        var cardinal, lblW, lblH, r, i, j, pole = {},
            labels = radar.categories, series = radar.series,
            hgap = styles.spacing.hgap, vgap = styles.spacing.vgap, 
            radians = radar.radians;
        
        var ls = []; // Labels array
        for ( i = 0; i < labels.length; i++ ) {
          ls.push( textRuler(labels[i], styles.polaraxis.labels.css.def) );
        }
        lblW = d3.max( ls, function (_) { return _.width; } );
        lblH = d3.max( ls, function (_) { return _.height; } );

        yscale.domain([radar.min, radar.max])
              .range([200, 0]); // fake radius length
        scaler.perfect(yscale);
        
        valueaxis.ref.scale(yscale).properties({
          label : {
        	visible : true,
        	formatString : properties.valueAxis.label.formatString        	  
          },
          title : {
            visible : properties.valueAxis.title.visible,
            text : properties.valueAxis.title.text
          },
          type : "value",
          position : "left",
          gridline : {
            visible : true,
            showFirstLine : true,
            showLastLine : true,
            type : "dotted"
          }
        });
        
        valueaxis.width = properties.valueAxis.visible ? valueaxis.ref.getPreferredSize().width : 0;
        if ( valueaxis.width > 0.5 * width ) valueaxis.width = 0;
        
        arrange({ 
          valueaxis : valueaxis.width, 
          lblW : lblW,
          lblH : lblH, 
          caption : {
            width : textRuler( properties.polarAxis.title.visible ? 
              properties.polarAxis.title.text : 0, styles.polaraxis.labels.css.def ).width,
            height : textRuler( properties.polarAxis.title.visible ? 
              properties.polarAxis.title.text : 0, styles.polaraxis.labels.css.def).height,
          }});
        
        if ( properties.polarAxis.title.visible && radar.caption.width 
             && radar.caption.height ) {
          radar.caption.node
            .text(properties.polarAxis.title.text)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle")
            .style("font-family", styles.valueaxis.title.css.def["font-family"])
            .style("font-size", styles.valueaxis.title.css.def["font-size"])
            .style("font-weight", styles.valueaxis.title.css.def["font-weight"])
            .style("fill", styles.valueaxis.title.css.def["fill"]);
        }
        
        yscale.range([ radar.radiusLength, 0 ]); // Re-calculate scale
        scaler.perfect(yscale);
        
        valueaxis.ref.scale(yscale);
        if ( properties.valueAxis.visible && valueaxis.width ) {
          valueaxis.node.call(valueaxis.ref);
        }
        
        var line = radar.node.append("g").attr("class", "polaraxes-group")
                  .selectAll(styles.polaraxis.clazz).data(labels);
        // Create nodes upon new data injected
        line.enter()
          .append("g")
          .attr("transform", function (d , i) {
            var rotation = i / labels.length * 360 - 90;
            if ( rotation > -180 && rotation < 180 ) {
              radians.push({ axisIdx : i,
                radian : -1 * rotation * Math.PI / 180 });
            } else { // rotation > 180 and rotation < 270
              radians.push({ axisIdx : i,
                radian : (360 - rotation) * Math.PI / 180 });
            }
            return "rotate("+ rotation +") translate("+ radar.radiusLength +")";
          });
        line.append("svg:line")
          .attr("x2", -1 * radar.radiusLength)
          .style("stroke", effects.register({
            drawingEffect: "normal",
            fillColor: styles.polaraxis.color
          }))
          .style("stroke-width", styles.polaraxis.weight)
          .style("fill", "transparent");
        
        radians.sort( function (a, b) { return a.radian - b.radian; } );
        
        var angle; // Polar angle
        
        if ( radar.labels.width && radar.labels.height ) {
          // Plot category labels
          line.append("g").attr("class", "categoryLabel")
            .append("text")
            .text(function (d, i) { return d; })
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle")
            .attr("transform", function (d, i) {
              angle = i / labels.length * 360 - 90;
              if ( angle % 90 === 0 ) {
                if ( angle === -90 || angle === 270 ) {
                  return "rotate(90) translate(0," + (-1 * ( 
                    textRuler(d, styles.polaraxis.labels.css.def).height / 2 + vgap ) ) +")";
                } else if ( angle === 0 ) {
                  return "translate("+ ( textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap ) +")";
                } else if ( angle === 180 ) {
                  return "rotate(180) translate(" + ( -1 * ( 
                    textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap ) ) +")";
                } else {
                  return "rotate(-90) translate(0," + ( 
                    textRuler(d, styles.polaraxis.labels.css.def).height / 2 + vgap ) +")";
                }
              }
              if ( (angle > -90 && angle < 0) || (angle > 0 && angle < 90) ) {
                return "rotate("+ (-1 * angle) +") translate(" + 
                  ( textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap ) +",0)";
              }
              return "rotate("+ (-1 * angle) +") translate(" +
                ( -1 * (textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap) ) +",0)";

            })
            .style("font-family", styles.polaraxis.labels.css.def["font-family"])
            .style("font-size", styles.polaraxis.labels.css.def["font-size"])
            .style("fill", effects.register({
              drawingEffect: "normal",
              fillColor: styles.polaraxis.labels.css.def["fill"]
            }));        
        }
        
        if ( !radar.min && !radar.max ) {
          dispatch.initialized();
          return;
        }
        
        // Reset value scales to desired orders
        yscale.domain([ radar.max, radar.min ]);
        scaler.perfect(yscale);
        
        cardinal  = radar.categories.length;
        
        // Default polar angle scale
        angle = angles([], cardinal, cardinal);
        
        // Path generator of line data on the radar plate
        var polarLine = d3.svg.line.radial()
          .interpolate("linear")
          .radius(yscale)
          .angle(function (d, i) { return angle(i); });

        var tickValues = yscale.ticks( yscale.tickNum ), polarTicks = [], circle = [];
        for ( i = 0; i < tickValues.length; i++ ) {
          circle = [];
          for ( j = 0; j < labels.length; j++ ) {
            circle.push(tickValues[i]);
          }
          polarTicks.push(circle);
        }

        if ( properties.polarGrid.visible ) {
          radar.node.append("g").attr("class", "polargrid-group")
            .selectAll( "." + styles.polargrid.clazz )
            .data( polarTicks )
          .enter()
            .append("path")
            .attr("class", styles.polargrid.childClazz)
            .attr("d", function (d) { return polarLine(d) + "Z"; })
            .style("fill", "none")
            .style("stroke", effects.register({
              drawingEffect : "normal",
              fillColor : styles.polargrid.color}))
            .style("stroke-width", styles.polargrid.weight);
        }
        
        // Plot actual data
        radar.node.append("g")
          .attr("class", "dataline-group")
          .selectAll( "." + styles.line.clazz )
          .data(series)
        .enter()
          .append("path")
          .attr("class", function (d, i) {
            return prefix.series.concat(i + " ").concat(styles.line.clazz);
           })
          .attr("d", function (d, i) { // Each d is a data series
            if ( !d.length ) return;
            var numbers = [];
            angle = angles([], cardinal, cardinal);
            for ( var n = 0; n < d.length; n++ ) numbers.push(d[n].val);
            if ( numbers.length !== radar.categories.length ) {
              angle = angles(chart.vacants[i], numbers.length, cardinal);
            }
            return polarLine(numbers) + "Z"; 
          })
          .style("fill", function (d, i) {
            if ( !d.length ) return; 
            if ( properties.surface.fill.visible ) {
              return effects.register({
                drawingEffect: "normal",
                fillColor: d[0].color
              });
            }
          })
          .style("fill-opacity", function (d, i) {
            if ( properties.surface.fill.visible ) return properties.surface.fill.transparency;
            return 0;
          })
          .style("stroke", function (d, i) { 
            if ( !d.length ) return;
            return effects.register({
              drawingEffect: "normal",
              fillColor: d[0].color}); 
          })
          .style("stroke-width", properties.line.width > ranges.dataline.weight[1] || 
             properties.line.width < ranges.dataline.weight[0] ? 
             defaults.options.line.width : properties.line.width
          );
        
        // draw markers
        var markerContainer = radar.node.append("g")
          .attr("class", "marker-container")
          .selectAll("." + styles.marker.clazz)
          .data(series).enter().append("g");

        markerContainer.attr("class", "marker-group").each(function ( datum, index ) { 
          // for each series
          var nulls = chart.vacants[index], radians = [];
          $.each(radar.categories, function ( i, d ) { 
            radians.push(i / cardinal * 2 * Math.PI - 0.5 * Math.PI);
          });
          for ( var i = nulls.length - 1; i >= 0; i-- ) {
            radians.splice(nulls[i].order, 1);
          }
          
          d3.select(this).append("g")
            .attr("class", "marker-series")
            .selectAll("." + styles.marker.clazz)
            .data(datum)
            .enter()
            .append('g').attr('class','datashape')
            .attr("transform", function (d, i) {
              var x = yscale(d.val) * Math.cos(radians[i]);
                  y = yscale(d.val) * Math.sin(radians[i]);
              return "translate("+ x + ", " + y + ") rotate(0)";
            })
            .append("path")
            .attr("class", function (d, i) {
              return (
                prefix.series + index + " " +       // series index 
                prefix.data + d.order + " " +       // data index 
                styles.marker.clazz +               // class
                prefix.measureIndex + d.ctx.path.mi // measure index
              );
            })
            .attr("d", function (d, i) {
              return painter.createMarkerData({
                type : d.shape,
                rx : styles.marker.size / 2,
                ry : styles.marker.size / 2,
                borderWidth : 2
              });
            })
            .style("fill", function (d) {
              var parameters = {
                drawingEffect : properties.drawingEffect,
                graphType : d.shape,
                fillColor : d.color,
                direction : 'vertical',
              };
              return effects.register(parameters);
            });
          });
        
        // create place holder elements for empty values
        var phantomMarker = radar.node.append("g")
          .attr("class", "phantom-marker-group")
          .selectAll(".phantom-marker-series").data(chart.vacants)
          .enter().append("g");
          
        phantomMarker
          .attr("class", "phantom-marker-series")
          .each(function ( datum, index ) {
            d3.select(this)
              .selectAll(".phantom-marker")
              .data(datum)
            .enter()
              .append("path")
              .attr("class", function (d, i) {
                return (
                  prefix.series + index + " " +       // series index 
                  prefix.data + d.order + " " +       // data index 
                  prefix.measureIndex + d.ctx.path.mi // measure index
                );
              })
              .style("fill", "none");
          });
        
        dispatch.initialized();
      });
    }
    
    chart.dataLabel = function(_){}
    
    chart.data = function (_) {
      if ( !arguments.length ) return data;
      data = _, radar.series = [], radar.categories = [],
      radar.radians = [],
      shapePalette = [], colorPalette = [], chart.vacants = [];
      
      // Data processing is effective upon the
      // completion of various customizations.
      if ( !chart.caliberated ) return chart;
      
      // Analysis Axis 1 and one Measure Group 
      // are required to be fed to radar chart.
      var aa1 = data.getAnalysisAxisDataByIdx(0).values,
          mg = data.getMeasureValuesGroupDataByIdx(0).values,
          aa2 = data.getAnalysisAxisDataByIdx(1),
          aa3 = data.getAnalysisAxisDataByIdx(2),
          series = [], depth, cardinal, layer, hierarchy = [],
          feedings = {
            aa2 : { fed : aa2 !== null && aa2.values.length ? true : false, axesFed : false, hasMND : false },
            aa3 : { fed : aa3 !== null && aa3.values.length ? true : false, axesFed : false, hasMND : false }
          }, i, j, x;
      
      radar.mndized = aa1[0].type && aa1[0].type.toLowerCase() === "mnd" ? true : false;
      
      // Extracts dimension labels
      for ( i = 0; i < aa1.length; i++ ) {
        layer = [];
        for ( j = 0; j < aa1[i].rows.length; j++ ) {
          layer.push(aa1[i].rows[j].val);
        }
        hierarchy.push(layer);
      }
      
      depth = hierarchy.length, cardinal = hierarchy[0].length;
      if ( depth === 1 ) {
        for ( i = 0; i < cardinal; i++ ) { 
          radar.categories.push(hierarchy[0][i] === '' || hierarchy[0][i] === null ?
            langManager.get('IDS_ISNOVALUE') : hierarchy[0][i]);
        }
      } else { // splice layered dimension labels
        var column = [];
        for ( i = 0; i < cardinal; i++ ) {
          for ( j = 0; j < depth; j++ ) column.push(hierarchy[j][i]);
          radar.categories.push(column.join(defaults.wording.slash));
          column = [];
        }
      }

      cardinal = mg[0].rows[0].length;

      // deal with two-dimensional data
      if ( radar.mndized ) {
        /*
         * In case of AA1 is MNDized, each of the 
         * analysis axis has the chance of getting 
         * fed by one, two or not any axes at all.
         */
        if ( !feedings.aa2.fed && !feedings.aa3.fed ) {
          colorPalette.push(radar.color(0));
          shapePalette.push(radar.shape(0));
        }
        
        // AA2's always bound to rows in cross-table.
        if ( feedings.aa2.fed ) {
          for ( i = 0; i < aa2.values[0].rows.length; i++ ) {
            colorPalette.push(radar.color(i));
          }
          if ( !feedings.aa3.fed ) shapePalette.push(radar.shape(0));
        }
        
        // AA3's usually bound to columns in cross-table.
        if ( feedings.aa3.fed ) {
          for ( i = 0; i < aa3.values[0].rows.length; i++ ) {
            shapePalette.push(radar.shape(i));
          }
          if ( !feedings.aa2.fed ) colorPalette.push(radar.color(0));
        }
        
        for ( i = 0; i < mg.length; i++ ) {
          for ( j = 0; j < mg[i].rows.length; j++ ) {
            for ( x = 0; x < cardinal; x++ ) {
              mg[i].rows[j][x].color = colorPalette[x] || radar.color(0);
              if ( feedings.aa2.fed ) {
                mg[i].rows[j][x].shape = shapePalette[j] || radar.shape(0);
              } else {
                mg[i].rows[j][x].shape = shapePalette[x] || radar.shape(0);
              }
            }
          }
        }
        
        // Transform measure group into series.
        var entry, temp = [], item = [];
        for ( i = 0; i < mg[0].rows.length; i++ ) {
          entry = [];
          for ( j = 0; j < mg.length; j++ ) {
            entry.push(mg[j].rows[i]);
          }
          temp.push(entry);
        }

        for ( i = 0; i < temp.length; i++ ) {
          // process each same row of cross tables
          for ( x = 0; x < cardinal; x++ ) {
            // loops against columns
            for ( j = 0; j < temp[i].length; j++, nulls = [] ) {
              item.push(temp[i][j][x]);
            }
            series.push(item);
            item = [];
          }
        }
        
        $.each(series, function ( index, item ) {
          var values = item, nulls = [];
          for ( var i = 0; i < values.length; i++ ) {
            values[i].order = i; // actual data index
            if ( values[i].val === null ) nulls.push(values[i]);
          }
          for ( i = values.length - 1; i >= 0; i-- ) {
            if ( values[i].val === null ) values.splice(i, 1);
          }
          chart.vacants.push(nulls);
        });
        
        if ( properties.polarAxis.title.text === "Categories" ) { // not customized
          properties.polarAxis.title.text = langManager.get('IDS_DEFAULTMND');
        }
      } else {
        if ( feedings.aa2.fed ) {
          for ( i = 0; i < aa2.values.length; i++ ) {
            if ( aa2.values[i].type && 
                 aa2.values[i].type.toLowerCase() === "mnd" ) {
              feedings.aa2.hasMND = true;
            }
          }
          if ( feedings.aa2.hasMND ) {
            if ( aa2.values.length >= 2 ) feedings.aa2.axesFed = true;
            else feedings.aa2.axesFed = false;
          } else {
            feedings.aa2.axesFed = true;
          }
        }
        
        if ( feedings.aa3.fed ) {
          for ( i = 0; i < aa3.values.length; i++ ) {
            if ( aa3.values[i].type && 
                 aa3.values[i].type.toLowerCase() === "mnd" ) {
              feedings.aa3.hasMND = true;
            }
          }
          if ( feedings.aa3.hasMND ) {
            if ( aa3.values.length >= 2 ) feedings.aa3.axesFed = true;
            else feedings.aa3.axesFed = false;
          } else {
            feedings.aa3.axesFed = true;
          }
        }
  
        // Extract series values from measure groups
        var colorCursor = 0, shapeCursor = 0, x,
            aa2mndized = feedings.aa2.hasMND && !feedings.aa2.axesFed,
            aa3mndized = feedings.aa3.hasMND && !feedings.aa3.axesFed,
            nulls = [];
            
        for ( i = 0; i < mg.length; i++ ) {
          if ( aa2mndized ) colorPalette.push(radar.color(i));
          if ( aa3mndized ) shapePalette.push(radar.shape(i));
          
          for ( j = 0; j < mg[i].rows.length; j++, nulls = []) {
            // filter out null values
            for ( x = 0; x < mg[i].rows[j].length; x++ ) {
              if ( mg[i].rows[j][x].val === null ) {
                nulls.push(mg[i].rows[j][x]);
              }
              mg[i].rows[j][x].order = x;
            }
            series.push(mg[i].rows[j]);
            chart.vacants.push(nulls);
            
            if ( feedings.aa2.fed ) {
              if ( aa2mndized ) {
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = radar.color(i);
                }
              } else if ( feedings.aa2.hasMND && feedings.aa2.axesFed ) {
                colorCursor++;
                colorPalette.push(radar.color(colorCursor));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = radar.color(colorCursor);
                }
              } else {
                colorPalette.push(radar.color(j));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = radar.color(j);
                }
              }
            } else {
              // Default value in case aa2 is fed nothing
              colorPalette.push(radar.color(0));
              for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                mg[i].rows[j][x].color = radar.color(0);
              }
            }
            if ( feedings.aa3.fed ) {
              if ( aa3mndized ) {
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].shape = radar.shape(i);
                }
              } else if ( feedings.aa3.hasMND && feedings.aa3.axesFed ) {
                shapeCursor++;
                shapePalette.push(radar.shape(shapeCursor));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].shape = radar.shape(shapeCursor);
                }
              } else {
                if ( feedings.aa2.fed ) {
                  if ( feedings.aa2.hasMND ) {
                    shapePalette.push(radar.shape(j));
                    for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                      mg[i].rows[j][x].shape = radar.shape(j);
                    }
                  } else {
                    for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                      shapePalette.push(radar.shape(x));
                      mg[i].rows[j][x].shape = radar.shape(x);
                    }
                  }
                }

              }
            } else {
              shapePalette.push(radar.shape(0));
              for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                mg[i].rows[j][x].shape = radar.shape(0);
              }
            }
          }
        }
        for ( i = 0; i < series.length; i++ ) {
          for ( j = series[i].length - 1; j >= 0; j-- ) {
            for ( var n = 0; n < chart.vacants[i].length; n++ ) {
              if ( chart.vacants[i][n].order === j ) series[i].splice(j, 1);
            }
          }
        }
        if ( properties.polarAxis.title.text === "Categories" ) { // not customized
          properties.polarAxis.title.text = combine_dimension_titles(aa1);
        }
      }
      if ( properties.valueAxis.title.text === "Value" ) {
        var measures = [];
        for ( i = 0; i < mg.length; i++ ) {
          measures.push(mg[i].col === '' || mg[i].col === null ? langManager.get('IDS_ISNOVALUE') : mg[i].col);
        }
        properties.valueAxis.title.text = measures.join(defaults.wording.and);
      }
      
      radar.series = series;
      radar.feedings = feedings;
      if ( !radar.locked ) rescale();
      
      return chart;
    };
    
    function combine_dimension_titles ( axes ) {
      var str = '';
      for ( var i = 0; i < axes.length; i++ ) {
        str = str.concat(axes[i].col.val === null ? langManager.get('IDS_ISNOVALUE') : axes[i].col.val + 
          defaults.wording.slash);
      }
      return str.lastIndexOf(defaults.wording.slash) > 0 ? 
             str.substr(0, str.lastIndexOf(defaults.wording.slash)) : str;
    }
    
    chart.primaryDataRange = function (_) {
      if ( !arguments.length ) return { 
        min : radar.min, max : radar.max 
      };
      radar.min = _.min;
      radar.max = _.max;
      rescale(_.min, _.max);
      radar.locked = true;
      return chart;
    };
    
    chart.colorPalette = function (_) {
      if ( !arguments.length ) return colorPalette;
      colorPalette = _;
      return chart;
    };
    
    chart.shapes = function (_) {
      if ( !arguments.length ) return shapePalette;
      shapePalette = _;
      return chart;
    };
    
    chart.dispatch = function (_) {
      if ( !arguments.length ) return dispatch;
      dispatch = _;
      return chart;
    };
    
    chart.properties = function (_) {
      if ( !arguments.length ) return properties;
      Objects.extend(true, properties, _);
      if ( properties.colorPalette.length ) radar.color.range(properties.colorPalette);
      if ( properties.shapePalette.length ) radar.shape.range(properties.shapePalette);
      styles.marker.size = properties.marker.size;
      if ( styles.marker.size > ranges.marker.size[1] ||  styles.marker.size < ranges.marker.size[0]) styles.marker.size =  6;
      styles.polargrid.color = properties.polarGrid.color;
      chart.caliberated = true;
      chart.data(data);
      return chart;
    };
    
    chart.afterUIComponentAppear = function(){
      dispatch.initialized(); 
    };
    
    chart.width = function (_) {
      if ( !arguments.length ) return width;
      var changed = width === _ ? false : true;
      width = _;
      if ( types.isEmptyObject(data) && height ) chart.data(data);
      if ( changed && !radar.locked  ) rescale();
      return chart;
    };
    
    chart.height = function (_) {
      if ( !arguments.length ) return height;
      var changed = height === _ ? false : true;
      height = _;
      if ( types.isEmptyObject(data) && width ) chart.data(data);
      if ( changed && !radar.locked ) rescale();
      return chart;
    };
    
    chart.size = function (_) {
      if ( !arguments.length ) return {
        width : width, height : height
      };
      width = _;
      height = _;
      if ( types.isEmptyObject(data) && width && height ) chart.data(data);
      if ( width && height && radar.series.length ) rescale();
      return chart;
    };
    
    chart.parent = function (_) {
      if ( !arguments.length ) return container;
      container = _;
      return chart;
    };
    
    chart.hoverOnPoint = function ( cursor ) {
      var pole = radar.pole, theta, r,
          prefix = defaults.wording,
          radians = radar.radians,
          point = {
            x : cursor.x - pole.x,
            y : pole.y - cursor.y
          };
      r = Math.sqrt( Math.pow(point.x, 2) + Math.pow(point.y, 2) );
      
      // out of radius range
      if ( r > radar.radiusLength ) {
        if ( typeof chart.last !== "undefined" && 
            (types.isEmptyObject(selections)) ) {
          brush.straight(prefix.dot + prefix.data + chart.last, true);
        }
        // hide tool tip
        if ( properties.tooltip.enabled ) radar.prompt();
        return;
      }
      
      // range is (-PI, PI]
      theta = Math.atan2( point.y, point.x );
      
      // search for the target interval that the angle locates in
      var bisect = d3.bisector(function (d) { return d.radian; }).right,
          intv = bisect(radians, theta), mid, left, right, target;          
      
      if ( intv === 0 ) {
        left = radians.length - 1, right = 0;
        if ( radians[left].radian === Math.PI ) {
          mid = -1 * (Math.PI + Math.abs(radians[right].radian)) / 2;
          target = theta > mid ? target = radians[right].axisIdx : 
                   target = radians[left].axisIdx;
        } else {
          target = radians[0].axisIdx;
        }
      } else if ( intv === radians.length ) {
        target = radians[radians.length - 1].axisIdx;
      } else {
        left = intv - 1, right = intv;
        mid = (radians[left].radian + radians[right].radian) / 2;
        target = theta > mid ? target = radians[right].axisIdx : 
                 target = radians[left].axisIdx;
      }
      
      if ( typeof chart.last !== "undefined" && chart.last !== target ) {
        brush.straight(prefix.dot + prefix.data + chart.last, true);
      }
      
      brush.focus(prefix.dot + prefix.data + target, true);
      
      if ( !types.isEmptyObject(selections) ) {
        brush.dim(prefix.dot + prefix.data + target, true);
        for ( var key in selections ) {
          for ( var i = 0; i < selections[key].length; i++ )
            brush.highlight(selections[key]);
        }
      }
      
      // prompt tool tip if allowed
      if ( properties.tooltip.enabled ) radar.prompt(target);
      
      // Memorize the last processed axis index
      chart.last = target;
    };
    
    chart.clear = function () {
      if ( !arguments[0] ) {
        brush.straight().bright();
        selections = {};
      } else {
        brush.dim();
      }
    };
    
    chart.highlight = function ( objects ) {
      if ( !radar.min && !radar.max ) return;
      
      var target = objects instanceof Array ? objects : [ objects ], query = /[sS][0-9]+/, key;
      
      selectionMode = typeof arguments[1] === 'boolean' ? 'multiple' : ( 
        typeof arguments[1] === 'string' ? arguments[1].toLowerCase() :
        typeof arguments[2] === 'string' ? arguments[2].toLowerCase() : 'multiple');
          
      brush.highlight(target);
      
      for ( var i = 0, exists = false; i < target.length; i++, exists = false ) {
        key = target[i].className.baseVal.match(query)[0];
        if ( selections[key] ) {
          for ( var j = 0; j < selections[key].length; j++ ) {
            if ( selections[key][j] === target[i] ) exists = true;
          }
          if ( !exists ) selections[key].push(target[i]);
        } else {
          selections[key] = [];
          selections[key].push(target[i]);
        }
      }

      if ( selectionMode === 'single' ) return;

      var cardinal, seriesOrder;
      for ( var n in selections ) {
        if ( selections.hasOwnProperty(n) ) {
          seriesOrder = n.substr(1);
          cardinal = radar.series[seriesOrder].length;
          highlight(n, selections[n], cardinal);
        }
      }
    };
    
    function highlight( series, datapoints, cardinal ) {
      if ( datapoints.length === cardinal ) {
        brush.highlight2(defaults.wording.dot + series, true);
      } else {
        brush.highlight(datapoints);
      }
    }
    
    chart.unhighlight = function ( object ) {
      var target = object instanceof Array ? object : [object];
      brush.straight(target).dim(target);
     
      if ( selectionMode === 'single' ) { 
        selections = []; return; 
      }
      
      $.each(target, function ( index, item ) {
        var series = item.className.baseVal.match(/[sS][0-9]+/)[0];
      
        for ( var key in selections ) {
          for ( var i = 0; i < selections[key].length; i++ ) {
            if ( selections[key][i] === object ) {
              selections[key].splice(i, 1); break;
            }
          }
        }
        brush.straight2(defaults.wording.dot + series)
             .dim(defaults.wording.dot + series);
      });
    };
    
    chart.blurOut = function () {
      dispatch.hideTooltip();
    };
    
    radar.prompt = function () {
      if ( typeof arguments[0] === "undefined" ) { dispatch.hideTooltip(); return; }
      
      var volume, item = {}, elements, target = arguments[0], 
          prefix = defaults.wording, anchor = {}, angle = 0,
          r = radar.radiusLength - styles.tooltip.radialOffset, 
          translation = container[0][0].getTransformToElement(container[0][0].ownerSVGElement),
          i;
      
      for ( i = 0; i < radar.radians.length; i++ ) {
        if ( radar.radians[i].axisIdx === target ) {
          angle = radar.radians[i].radian; break;
        }
      }
      
      anchor.x = r * Math.cos(angle);
      anchor.y = r * Math.sin(angle);
      orient = angle <= 0.5 * Math.PI && angle > -0.5 * Math.PI ? "left" : "right";
      
      volume = {
        body : [],
        plotArea : {
          x : translation.e,
          y : translation.f,
          width : width,
          height : height
        },
        point : { // where tool tip arrow points to
          x : anchor.x + radar.pole.x + translation.e,
          y : anchor.y < 0 ? 
              Math.abs(anchor.y) + radar.pole.y + translation.f : 
              radar.pole.y - anchor.y + translation.f, 
          orientation : orient,
          angle : angle,
          range : {
            x : angle === 0.5 * Math.PI || angle === -0.5 * Math.PI ? 0 : 
                Math.abs(anchor.x),
            y : angle === 0 || angle === Math.PI || angle === -1 * Math.PI ? 0 : 
                Math.abs(anchor.y)
          }
        },
        footer : []
      };

      var aa1 = data.getAnalysisAxisDataByIdx(0).values,
          aa2 = radar.feedings.aa2.fed ? data.getAnalysisAxisDataByIdx(1).values : null,
          aa3 = radar.feedings.aa3.fed ? data.getAnalysisAxisDataByIdx(2).values : null,
          mg = data.getMeasureValuesGroupDataByIdx(0).values;
      
      elements = radar.node.selectAll("." + prefix.data + target);
      var col, row, cardinal, index, i, j, temp;
      
      if ( radar.mndized ) {
        item = { 
          name : radar.categories[target] === '' || radar.categories[target] === null ? 
                 langManager.get('IDS_ISNOVALUE') : radar.categories[target], 
          val : []
        };
        
        // normal case
        elements.each(function (d) {
          var entry = {};
          entry.color = d.color;
          entry.shape = d.shape;
          entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
          
          if ( !radar.feedings.aa2.fed && !radar.feedings.aa3.fed ) {
            entry.label = null;
          }
          
          if ( radar.feedings.aa2.fed ) {
            index = properties.multichart ? d.ctx.path.dii_a2 : d.ctx.path.dii_a1;
            for ( i = 0, temp = []; i < aa2.length; i++ ) {
              temp.push(aa2[i].rows[index]);
            }
            col = temp;
            if ( !radar.feedings.aa3.fed ) entry.label = col;
          }
          
          if ( radar.feedings.aa3.fed ) {
            index = radar.feedings.aa2.fed ? d.ctx.path.dii_a2 : d.ctx.path.dii_a1;
            for ( i = 0, temp = []; i < aa3.length; i++ ) {
              temp.push(aa3[i].rows[index]);
            }
            if ( radar.feedings.aa2.fed ) {
              row = temp;
              entry.label = [];
              entry.label = entry.label.concat(col);
	            entry.label = entry.label.concat(row);
            } else {
              col = temp;
              entry.label = col;
            }
          }
          
          item.val.push(entry);
        });
        
        volume.body.push(item);
      } else {
        if ( !radar.feedings.aa2.axesFed && !radar.feedings.aa3.axesFed ) {
          elements.each(function (d) {
            var entry = {}, item = { name : mg[d.ctx.path.mi].col, val : [] };
            entry.color = d.color;
            entry.shape = d.shape;
            entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
            entry.label = null;
            
            item.val.push(entry);
            volume.body.push(item);
          });
        } else {
          for ( var x = 0; x < mg.length; x++ ) {
            item = { name : mg[x].col === null ? langManager.get('IDS_ISNOVALUE') : mg[x].col, val : [] };
            
            elements.each(function (d) {
              var entry = {};
              entry.color = d.color;
              entry.shape = d.shape;
              entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
              
              var clazz = d3.select(this)[0][0].className.baseVal
                .match(/\smi[0-9]+/);
              if ( clazz !== null ) clazz = clazz[0];
              else return;
              
              temp = [];
              if ( clazz === (prefix.measureIndex + x) ) {
                var aa = aa2 !== null ? aa2 : aa3;
                for ( i = 0; i < aa.length; i++ ) {
                  if ( d.ctx.path.dii_a2 > aa[i].rows.length - 1 ) {
                    d.ctx.path.dii_a2 = aa[i].rows.length - 1;
                  }
                  temp.push(aa[i].rows[d.ctx.path.dii_a2]);
                }
                entry.label = temp;
              } else return;
              item.val.push(entry);
            });
            volume.body.push(item);
          }
        }
        
        var dimension = {};
        for ( i = 0; i < aa1.length; i++ ) {
          dimension = {};
          dimension.label = aa1[i].col;
          dimension.value = aa1[i].rows[target];
          volume.footer.push(dimension);
        }
      }
      dispatch.showTooltip(tooltipDataHandler.formatTooltipData(volume));
    };
    
    brush.params = { // UX defined
      stroke : {
        invisible : "transparent",
        natural : "#ffffff",
        heavy : "#333333"
      },
      
      weight : {
        natural : properties.line.width,
        heavy : "2px"
      },
      
      opacity : {
        natural : 1,
        low : 0.2
      }
    };
    
    /*
     * Functions of the effects library are
     * state-less. Each of the function accepts
     * one of the two types of arguments: 
     * DOM nodes in array, or
     * CSS class with an optional boolean field
     * in determining whether all elements with
     * the given CSS class will be selected.
     */
    brush.dim = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) { // select everything
        radar.node.selectAll(prefix.dot + styles.line.clazz)
          .attr("opacity", brush.params.opacity.low);
        radar.node.selectAll(prefix.dot + styles.marker.clazz)
          .attr("opacity", brush.params.opacity.low);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .attr("opacity", brush.params.opacity.low);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .attr("opacity", brush.params.opacity.low);
      } else {
        radar.node.select(arguments[0])
          .attr("opacity", brush.params.opacity.low);
      }
      return brush;
    };
    
    brush.bright = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) {
        radar.node.selectAll(prefix.dot + styles.line.clazz)
          .attr("opacity", brush.params.opacity.natural);
        radar.node.selectAll(prefix.dot + styles.marker.clazz)
          .attr("opacity", brush.params.opacity.natural);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .attr("opacity", brush.params.opacity.natural);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .attr("opacity", brush.params.opacity.natural);
      } else {
        radar.node.select(arguments[0])
          .attr("opacity", brush.params.opacity.natural);
      }
      return brush;
    };
    
    // remove all decorations
    brush.straight = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) {
        radar.node.selectAll(prefix.dot + styles.marker.clazz)
          .style("stroke", brush.params.stroke.invisible);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .style("stroke", brush.params.stroke.invisible);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .style("stroke", brush.params.stroke.invisible);
      } else {
        radar.node.select(arguments[0])
          .style("stroke", brush.params.stroke.invisible);
      }
      return brush;
    };
    
    // Just recover stroke-width
    brush.straight2 = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) {
        radar.node.selectAll(prefix.dot + styles.marker.clazz)
          .style("stroke-width", brush.params.weight.natural);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .style("stroke-width", brush.params.weight.natural);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .style("stroke-width", brush.params.weight.natural);
      } else {
        radar.node.select(arguments[0])
          .style("stroke-width", brush.params.weight.natural);
      }
      return brush;
    };
    
    // Change stroke color and stroke-width
    brush.highlight = function () {
      if ( !arguments.length ) return;
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .style("stroke", brush.params.stroke.heavy)
            .style("stroke-width", brush.params.weight.heavy)
            .attr("opacity", brush.params.opacity.natural);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .style("stroke", brush.params.stroke.heavy)
          .style("stroke-width", brush.params.weight.heavy)
          .attr("opacity", brush.params.opacity.natural);
      } else {
        radar.node.select(arguments[0])
          .style("stroke", brush.params.stroke.heavy)
          .style("stroke-width", brush.params.weight.heavy)
          .attr("opacity", brush.params.opacity.natural);
      }
      return brush;
    };
    
    // Just thicken stroke-width
    brush.highlight2 = function () {
      if ( !arguments.length ) return;
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .style("stroke-width", brush.params.weight.heavy)
            .attr("opacity", brush.params.opacity.natural);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .style("stroke-width", brush.params.weight.heavy)
          .attr("opacity", brush.params.opacity.natural);
      } else {
        radar.node.select(arguments[0])
          .style("stroke-width", brush.params.weight.heavy)
          .attr("opacity", brush.params.opacity.natural);
      }
      return brush;
    };
    
    brush.focus = function () {
      if ( !arguments.length ) return;
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .style("stroke", brush.params.stroke.natural)
            .style("stroke-width", brush.params.weight.natural);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .style("stroke", brush.params.stroke.natural)
          .style("stroke-width", brush.params.weight.natural);
      } else {
        radar.node.select(arguments[0])
          .style("stroke", brush.params.stroke.natural)
          .style("stroke-width", brush.params.weight.natural);
      }
      return brush;
    };
    
    
    return chart;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Radar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.radar',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.Radar',
  version : '4.0.0'
}
],
function Setup( Manifest, Constants, fn ) {
  var module = {
    id : "sap.viz.modules.radar",
    type : Constants.Module.Type.Chart,
    name : "radar",
    description : "Radar module properties",
    properties : {
      drawingEffect : {
        name : 'drawingEffect',
        supportedValueType : 'List',
        supportedValues : [ 'normal', 'glossy' ],
        defaultValue : 'normal',
        description : 'Set drawing effect of radar.',
        isExported : true
      },
      polarGrid : {
        name : "polarGrid",
        supportedValueType : "Object",
        supportedValues : {
          visible : {
            name : "visible",
            supportedValueType : "Boolean",
            defaultValue : true,
            description : "Set polar gridline visibility switch."
          },
          color : {
            name : "color",
            supportedValueType : "String",
            defaultValue : "#d8d8d8",
            description : "Set polar gridline color."
          }
        },
        description : "Settings for Polar gridline customizations."
      },
      valueAxis : {
        name : "valueAxis",
        supportedValueType : "Object",
        supportedValues : {
          visible : {
            name : "visible",
            supportedValueType : "Boolean",
            defaultValue : true,
            description : "Set value axis visibility switch."
          },
          title : {
            name : "title",
            supportedValueType : "Object",
            supportedValues : {
              visible : {
                name : "visible",
                supportedValueType : "Boolean",
                defaultValue : false,
                description : "Set value axis title visibility switch."
              },
              text : {
                name : "text",
                supportedValueType : "String",
                defaultValue : "Value",
                description : "Set value axis title text."
              },
            },
            description : "Settings for value axis title."
          },
          label : {
        	name : "label",
        	supportedValueType : "Object",
        	supportedValues : {         	  
        	  formatString : {
                name : 'formatString',
        		supportedValueType : 'String',
        		defaultValue : null,
        		description : 'Set format string of value axis. If number format and format string are both set, number format will be ignored. '
        	  }
            },
              description : "Settings for axis label."
          }
        },
        description : "Settings for value axis at side bar."
      },
      polarAxis : {
        name : "polarAxis",
        supportedValueType : "Object",
        supportedValues : {
          title : {
            name : "title",
            description: "Settings for polar axis title.",
            supportedValueType : "Object",
            supportedValues : {
              visible : {
                name : "visible",
                supportedValueType : "Boolean",
                defaultValue : false,
                description : "Set category axis visibility switch."
              },
              text : {
                name : "text",
                supportedValueType : "String",
                defaultValue : "Categories",
                description : "Set category axis text."
              }
            }
          }
        },
        description : "Settings for polar axes customizations."
      },
      colorPalette : {
        name : "colorPalette",
        defaultValue : Constants.SAPColor,
        description : "Set marker color customizations."
      },
      shapePalette : {
        name : "shapePalette",
        supportedValueType : "StringArray",
        defaultValue : [ "circle", "diamond", "triangle-up", "triangle-down", 
                  "triangle-left", "triangle-right", "cross", "intersection" ],
        supportedValues : [ "circle", "diamond", "triangle-up", "triangle-down", 
                  "triangle-left", "triangle-right", "cross", "intersection" ],
        description : 'Set marker shape customizations.'
      },
      line : {
        name : "line",
        description : "Settings for line customizations.",
        supportedValueType : "Object",
        supportedValues : {
          width : {
            name : 'width',
            supportedValueType : 'PositiveInt',
            defaultValue : 2,
            description : "Line weight settings. Range is [1, 7]"
          }
        }
      },
      surface : {
        name : "surface",
        supportedValueType : "Object",
        supportedValues : {
          fill : {
            name : 'fill',
            supportedValueType : 'Object',
            supportedValues : {
              visible : {
                name : 'visible',
                supportedValueType : 'Boolean',
                defaultValue : true,
                description : 'Set enable/disable fill effect for polar area.'
              },
              transparency : {
                name : 'transparency',
                supportedValueType : 'Double',
                defaultValue : 0.3,
                //min : '0',
                //max : '1',
                description : 'Set alpha value for polar area fill color.'
              },
            }
          }
        },
        description : "Settings for Surface customizations."
      },
      marker : {
        name : "marker",
        //description : "Settings for data point marker customizations.",
        supportedValueType : "Object",
        supportedValues : {
          size : {
            name : "size",
            supportedValueType : "PositiveInt",
            defaultValue : 6,
            min : 4,
            max : 32,
            description : "Set marker size customization."
          }
        },
        description : "Settings for marker/data point graphics."
      },
      tooltip : {
        name : "tooltip",
        supportedValueType : "Object",
        supportedValues : {
          enabled : {
            name : "enabled",
            supportedValueType : "Boolean",
            supportedValues : [ true, false ],
            defaultValue : true,
            description : "Set tooltip enablement."
          }
        },
        'isExported' : false,
        description : "Settings for tooltip customization."
      },
    },
    events : {
      'initialized': Constants.Module.Event.Initialized.desc,
      selectData : Constants.Module.Event.SelectData.desc,
      deselectData : Constants.Module.Event.DeSelectData.desc,
      showTooltip : Constants.Module.Event.TooltipShow.desc,
      hideTooltip : Constants.Module.Event.TooltipHide.desc
    },
    feeds : {
      id : "radar"
    },
    css : {    
      ".viz-axis-title" : {
        description : "Font style for polar axis title.",
        value : {
          fill : "#333333",
          "font-family" : "'Open Sans', Arial, Helvetica, sans-serif",
          "font-size" : "14px",
          "font-weight" : "bold"
        }
      },
      '.viz-axis-label' : {
        'description' : 'Define style for the axis label.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      },     
      ".viz-polar-axis-label" : {
        description : "Font styles for polar axis labels.",
        value : {
          "font-family" : "'Open Sans', Arial, Helvetica, sans-serif",
          "fill" : "#333333",
          "font-size" : "11px",
          "font-weight" : "bold"
        }
      }
    },
    configure : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiRadarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Radar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiRadarChart = {
    id : 'viz/multi_radar',
    name : 'IDS_MULTIRADARCHART',
    base : 'riv/base/multiple/xy',
    modules : {
      legend : {
        data : {
          aa : [ 3]
        }
      },
      tooltip : {
        id : "sap.viz.modules.tooltip",
        configure : {
          properties : {
            chartType : "radar",
            orientation : "left"
          }
        }
      },
      main : {
        controllers : {
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              propertyCategory : 'interaction',
              properties : {
                      supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
              }
            }
          }
        },
        configure : {
          properties : {
            'mergeDataRange' : ['primary']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    orientation : 'vertical',
                    position : 'outside',
                    automaticInOutside : false,
                    outsidePosition : 'up'
                  },
                  propertiesOverride : {
                    position : {
                      isExported : false
                    }                    
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.radar',
                configure : {
                  description: 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : "plotArea",
                  properties : {
                    multichart : true
                  }
                }
              },
              background : {
                configure : {
                  propertyCategory : 'background',
                  properties : {
                    visible : false
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      multiplier : {
        acceptMND : 0,
        max : 2
      },
      
      regionShape : {
        max : 0
      }
      
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : "legend",
        target : "colorPalette",
        sourceModule : "main.plot.plot",
        source : "colorPalette"
      }, 
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapes'
      }
      ], 
      events : [ 
      {
        targetModule : 'main.interaction',
        listener : 'registerEvent',
        sourceModule : 'main',
        type : 'initialized.interaction'
      }, {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main',
        type : 'hideTooltip'
      }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
      }, {
        targetModule : 'main.plot.dataLabel',
        listener : 'showLabel',
        sourceModule : 'main.plot.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'main.plot.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'main.plot.plot',
        type : 'startToInit.datalabel'
      }]
    }
  };

  Manifest.register(multiRadarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.controller.rotate',
  version : '4.0.0'},
[

],
function Setup() {
  
  return function(manifest){
    
    var m = null, g = null, props =  manifest.props(null), xAngle = 0, yAngle = 0, mousedown = false;
    var rotate = function(){
      
      return rotate;
    };
    

    rotate.registerEvent = function() {
      g.on('mousedown.rotate', start).on('mousemove.rotate', move).on(
          'mouseup.rotate', end);
      
      $(g.node()).mouseleave(end);
      
      var angle = m.rotate();
      xAngle = angle.xAngle;
      yAngle = angle.yAngle;
      
    };

    function start() {
      oldX = d3.event.layerX;
      oldY = d3.event.layerY;
      mousedown = true;
    };

    function move() {
     if(mousedown == true){
       var x = d3.event.layerX;
       var y = d3.event.layerY;
       
       yAngle += (oldX - x) /2;
       if(yAngle > 180){
         yAngle -= 360;
       }else if(yAngle < -180){
         yAngle += 360;
       }
       
       xAngle += (y - oldY)/2;
       if(xAngle > 90){
         xAngle = 90;
       } else if(xAngle < -90){
         xAngle = -90;
       }
       
       oldX = x;
       oldY = y;
       
       m.rotate({
         xAngle: xAngle,
         yAngle: yAngle
         });
     }
    }

    function end() {
      mousedown = false;
    }
    
    rotate.module = function(_){
      if(!arguments.length){
        return m;
      }
      m = _; g = m.parent();
      return rotate;
    };
    
    rotate.properties = function(_){
      if(!arguments.length){
        return props;
      }
      props = _;
      return rotate;
    };
    
    return rotate;
    
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.controller.Rotate',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.controller.rotate',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.controller.rotate',
    'name' : 'selection',
    'base' : "sap.viz.modules.controller.base",
    'description': 'Settings for the interactions of the chart.',
    'properties' : {},
    'fn' : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.Vector3D',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.threeD.Vector',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.0'
}
],
function Setup(Vector, Point) {
  function Vector3D() {
    Vector.apply(this, arguments);
  }

  Vector3D.prototype = Object.create(Vector.prototype);

  Vector3D.prototype.transform = function(m) {
    var p1 = new Point(0, 0, 0).transform(m);
    var p2 = new Point(this.value(0), this.value(1), this.value(2))
        .transform(m);
    this.value(0, p2.x - p1.x);
    this.value(1, p2.y - p1.y);
    this.value(2, p2.z - p1.z);
    return this;
  };

  return Vector3D;
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.cube',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.threeD.Vector4D',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.Vector3D',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.0'
}
],
function Setup(Vector4D, Vector3D, matrix, Point3D) {
  return function() {
    var width, height, depth, transformMatrix, color;
    function cube(parent) {
      var wrapper = parent.selectAll("g.cube").data(function(d, i) {
        var wv = d3.functor(width).apply(this, arguments);
        var hv = d3.functor(height).apply(this, arguments);
        var dv = d3.functor(depth).apply(this, arguments);
        var m = d3.functor(transformMatrix).apply(this, arguments);
        var c = d3.functor(color).apply(this, arguments);

        return [ {
          wv : wv,
          hv : hv,
          dv : dv,
          m : m,
          data : d,
          c : c
        } ];
      });
      wrapper.exit().remove();
      wrapper.enter().append("g").attr("class", "cube datapoint normal");

      var initBoundingBox = function(w, h, d){
        return [
                [0,0,0],
                [0,h,0],
                [0,h,d],
                [0,0,d],
                [w,0,0],
                [w,h,0],
                [w,h,d],
                [w,0,d]
                ];
      };
      
      var rects = wrapper.selectAll("rect[class|=\"cube-surface\"]").data(
          function(d) {
            var wv = d.wv;
            var hv = d.hv;
            var dv = d.dv;

            var c = d.c;
            var hsl = d3.rgb(c).hsl();
            var light = hsl.l;
            var lightC = d3.hsl(hsl.h, hsl.s, light * 1.06).rgb().toString();
            var darkC = d3.hsl(hsl.h, hsl.s, light * 0.94).rgb().toString();

            var rectDatas = new Array({
              m : matrix().rotateX(90).translate(0, hv, 0).transform(d.m),
              type : "bottom"
            }, {
              m : matrix().rotateY(180).translate(0, 0, dv).transform(d.m),
              type : "back"
            }, {
              m : matrix().rotateY(90).transform(d.m),
              type : "left"
            }, {
              type : "front",
              m : d.m
            }, {
              m : matrix().rotateY(-90).translate(wv, 0, 0).transform(d.m),
              type : "right"
            }, {
              m : matrix().rotateX(-90).transform(d.m),
              type : "top"
            });

            rectDatas.forEach(function(o) {
              o.normal = new Vector3D(0, 0, -1).transform(o.m);
            });

            rectDatas = rectDatas.filter(function(o) {
              return o.normal.value(2) < 0;
            });

            rectDatas.forEach(function(o) {
              switch (o.type) {
              case "bottom":
                o.x = 0;
                o.y = 0;
                o.w = wv;
                o.h = dv;
                break;
              case "back":
                o.x = -wv;
                o.y = 0;
                o.w = wv;
                o.h = hv;
                break;
              case "left":
                o.x = -dv;
                o.y = 0;
                o.w = dv;
                o.h = hv;
                break;
              case "front":
                o.x = 0;
                o.y = 0;
                o.w = wv;
                o.h = hv;
                break;
              case "right":
                o.x = 0;
                o.y = 0;
                o.w = dv;
                o.h = hv;
                break;
              case "top":
                o.x = 0;
                o.y = -dv;
                o.w = wv;
                o.h = dv;
                break;
              }

              var normalX = o.normal.value(0);
              o.fill = normalX === 0 ? lightC : (normalX < 0 ? c : darkC);
            });

            return rectDatas;
          });

      rects.exit().remove();

      rects.enter().append("rect").attr("class", function(d) {
        return "cube-surface-" + d.type;
      });

      rects.attr("x", function(d) {
        return d.x;
      }).attr("y", function(d) {
        return d.y;
      }).attr("width", function(d) {
        return d.w;
      }).attr("height", function(d) {
        return d.h;
      }).attr("transform", function(d) {
        if (d.m) {
          return d.m.projection();
        }
      }).attr("fill", function(d) {
        return d.fill;
      });

      wrapper.each(function(d) {
        var flbpz = 0;
        if (d.m) {
          var ctMz = d.m.row(2);
          flbpz = new Vector4D(0, d.hv, 0, 1).dotProduct(ctMz);
        }
        d3.select(this.parentNode).datum().flbpz = flbpz;
        
        var points = initBoundingBox(d.wv, d.hv, d.dv), npoints = [];
        points.forEach(function(p){
          npoints.push(new Point3D(p[0], p[1], p[2]).transform(d.m));
        });
        
        npoints.sort(function(a, b) {
          return (b.x - a.x);
         });
         
         npoints.splice(2);
         
         npoints.sort(function(a,b){
           return (a.y - b.y);
         });
       
         d.rtp = npoints[0];
      });

      parent.sort(function(a, b) {
        return d3.descending(a.flbpz, b.flbpz);
      });
    }

    cube.width = function() {
      if (arguments.length === 0) {
        return width;
      }

      width = arguments[0];
      return cube;
    };

    cube.height = function() {
      if (arguments.length === 0) {
        return height;
      }

      height = arguments[0];
      return cube;
    };

    cube.depth = function() {
      if (arguments.length === 0) {
        return depth;
      }

      depth = arguments[0];
      return cube;
    };

    cube.matrix = function() {
      if (arguments.length === 0) {
        return transformMatrix;
      }

      transformMatrix = arguments[0];
      return cube;
    };

    cube.color = function() {
      if (arguments.length === 0) {
        return color;
      }

      color = arguments[0];
      return cube;
    };

    return cube;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.bar3d',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.cube',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
}
],
function Setup(MNDHandler, Scaler, Objects, cube, matrix, langManager, ObjectUtils, dispatch, TypeUtils, tooltip, tooltipDataHandler) {

  var barPaddingRatio = 0.5;

  return function(manifest) {
    var width = 0, height = 0, data, properties = manifest.props(null), m = matrix();
    var datas, d = dispatch('initialized', 'showTooltip', 'hideTooltip', 'valueScaleChange', 'primaryCategoryScaleChange', 'secondaryCategoryScaleChange');
    var parent = null;
    var lastHovered = null;
    
    var secondaryCategoryData = {
        'sap.viz.modules.column3d.dimension':{
          key: 'sap.viz.modules.column3d.dimension',
          values : [{
            col: {val:''},
            rows: []
          }]
        }
    };
    
    var primaryCategoryData = {
        'sap.viz.modules.column3d.dimension':{
          key: 'sap.viz.modules.column3d.dimension',
          values : [{
            col: {val:''},
            rows: []
          }]
        }
    };
    
    var primaryCategoryScale = d3.scale.ordinal(), secondaryCategoryScale = d3.scale
        .ordinal(), valueScale = d3.scale.linear();

    var cubeBuilder = cube();

    var colorPalette = d3.scale.ordinal();

    function chart(selection) {

      parent = selection;
      
      var styles = selection.selectAll("style").data(
          [ ".normal rect{stroke:#FFF; opacity:1} .selected rect{stroke:#000; opacity:1} .deselected rect{stroke:#FFF; opacity:0.4}" ]);
      styles.exit().remove();
      styles.enter().append("style");
      styles.text(String);

      colorPalette.range(properties.colorPalette);

      var primaryCategoryRangeBand = primaryCategoryScale.rangeBand();
      var secondaryCategoryRangeBand = secondaryCategoryScale.rangeBand();

      var vertical = isVertical();

      var barCategorySize = primaryCategoryRangeBand /
          (1 + 2 * barPaddingRatio);
      var barDepth = barCategorySize;
      var barCategoryPadding = barCategorySize * barPaddingRatio;
      var barValueSize = vertical ? function(d) {
        return height - valueScale(d.data.val);
      } : function(d) {
        return valueScale(d.data.val);
      };

      cubeBuilder.width(vertical ? barCategorySize : barValueSize).height(
          vertical ? barValueSize : barCategorySize).depth(barDepth).matrix(
          function(d) {
            var primaryCategoryOffset = d.aa1 * primaryCategoryRangeBand +
                barCategoryPadding;

            var x = vertical ? primaryCategoryOffset : 0;
            var y = vertical ? valueScale(d.data.val) : height -
                primaryCategoryOffset;
            var z = d.aa2 * secondaryCategoryRangeBand + barCategoryPadding;
            return matrix().translate(x, y, z).transform(m);
          }).color(function(d) {
        return colorPalette(d.aa2);
      });

      var mainShapesGroup = selection.select('g.mainshapesgroup');
      if(!TypeUtils.isExist(mainShapesGroup[0][0])){
        mainShapesGroup = selection.append('g').attr('class', 'mainshapesgroup');
      }
      
      var dataShapes = mainShapesGroup.selectAll("g.datashape").data(datas);
      
      dataShapes.exit().remove();
      dataShapes.enter().append("g").attr("class", "datashape");

      cubeBuilder(dataShapes);

      d.initialized();
     
    }
    chart.afterUIComponentAppear = function(){
      d.initialized(); 
    };
    
    chart.width = function(value) {
      if (!arguments.length) {
        return width;
      }

      width = value;

      if (isVertical()) {
        updatePrimaryCategoryScaleRange();
        updateSecondaryCategoryScaleRange();
      } else {
        updateValueScaleRange();
      }

      return chart;
    };

    chart.height = function(value) {
      if (!arguments.length) {
        return height;
      }

      height = value;

      if (isVertical()) {
        updateValueScaleRange();
      } else {
        updatePrimaryCategoryScaleRange();
        updateSecondaryCategoryScaleRange();
      }

      return chart;
    };

    chart.primaryCategoryScale = function(scale) {
      if (!arguments.length) {
        return primaryCategoryScale;
      }
      primaryCategoryScale = scale;
      return chart;
    };

    chart.secondaryCategoryScale = function(scale) {
      if (!arguments.length) {
        return secondaryCategoryScale;
      }
      secondaryCategoryScale = scale;
      return chart;
    };

    chart.valueScale = function(scale) {
      if (!arguments.length) {
        return valueScale;
      }
      valueScale = scale;
      return chart;
    };

    chart.data = function(value) {
      if (!arguments.length) {
        return data;
      }
      data = value;

      var mndData = MNDHandler(data);
      
      generateSecondCategoryData(mndData, data);
      
      var parsedData = mndData.MG1;

      var i;

      var primaryCategoryLength = parsedData[0].length;
      var primaryCategoryDomain = new Array(primaryCategoryLength);
      for (i = 0; i < primaryCategoryLength; i++) {
        primaryCategoryDomain[i] = i;
      }
      primaryCategoryScale.domain(primaryCategoryDomain);

      var secondaryCategoryLength = parsedData.length;
      var secondaryCategoryDomain = new Array(secondaryCategoryLength);
      for (i = 0; i < secondaryCategoryLength; i++) {
        secondaryCategoryDomain[i] = i;
      }
      secondaryCategoryScale.domain(secondaryCategoryDomain);

      updateSecondaryCategoryScaleRange();

      datas = [];
      for ( var i = 0, len1 = parsedData.length; i < len1; i++) {
        var groupData = parsedData[i];
        for ( var j = 0, len2 = groupData.length; j < len2; j++) {
          datas.push({
            data : groupData[j],
            aa2 : i,
            aa1 : j
          });
        }
      }

      var extent = d3.extent(datas, function(o) {
        return o.data.val;
      });
      var min = extent[0], max = extent[1];
      var bottom = min >= 0 ? 0 : min;
      var top = max <= 0 ? 0 : max;
      if (bottom === 0 && top === 0) {
        top = 100;
      }

      valueScale.domain([ bottom, top ]);
      Scaler.perfect(valueScale);
      return chart;
    };

    /**
     * set/get properties
     */
    chart.properties = function(props) {
      if (!arguments.length) {
        return properties;
      }
      Objects.extend(true, properties, props);

      updatePrimaryCategoryScaleRange();
      updateSecondaryCategoryScaleRange();
      updateValueScaleRange();

      return chart;
    };

    chart.colorPalette = function(_) {
      if (!arguments.length) {
        return properties.colorPalette;
      }
      properties.colorPalette = _;
      return this;
    };

    chart.matrix = function(_) {
      if (!arguments.length) {
        return m;
      }
      m = _;
      return this;
    };

    chart.secondaryCategoryData = function(_){
      if(!arguments.length){
        return secondaryCategoryData;
      }
      secondaryCategoryData = _;
      return this;
    };

    chart.primaryCategoryData = function(_){
      if(!arguments.length) {
        return primaryCategoryData;
      }
      primaryCategoryData = _;
      return chart;
    };
    
    chart.dispatch = function(_){
      if(!arguments.length){
        return d;
      }
      d = _;
      return chart;
    };
    
    chart.parent = function(){
      if( !arguments.length ){
        return parent;
      }
      parent = _;
      return chart;
    };
    
    chart.highlight = function(_){
      if (_ instanceof Array) {
        for ( var i = 0; i < _.length; i++) {
          // _[i].setAttribute('opacity', 1);
          var classname = _[i].getAttribute('class');
          classname = classname.replace('normal', 'selected');
          classname = classname.replace('deselected', 'selected');
          _[i].setAttribute('class', classname);
        }
      } else {
        // _.setAttribute('opacity', 1);
        var classname = _.getAttribute('class');
        classname = classname.replace('normal', 'selected');
        classname = classname.replace('deselected', 'selected');
        _.setAttribute('class', classname);
      }
    };
    
    chart.unhighlight = function(_){
      if (_ instanceof Array) {
        for ( var i = 0; i < _.length; i++) {
          // _[i].setAttribute('opacity', 0.4);
          var classname = _[i].getAttribute('class');
          classname = classname.replace('selected', 'deselected');
          classname = classname.replace('nomral', 'deselected');
          _[i].setAttribute('class', classname);
        }
      } else {
        var classname = _.getAttribute('class');
        classname = classname.replace('selected', 'deselected');
        classname = classname.replace('nomral', 'deselected');
        _.setAttribute('class', classname);
      }
    };
    
    chart.clear = function(gray){
      if (gray == null) {
        parent.selectAll('.datapoint').each(function(d) {
          var classname = this.getAttribute('class');
          if (classname.indexOf('deselected') != -1) {
            classname = classname.replace('deselected', 'normal');
          } else {
            classname = classname.replace('selected', 'normal');
          }
          this.setAttribute('class', classname);
        });
      } else {
        parent.selectAll('.datapoint').each(function(d) {
          var classname = this.getAttribute('class');
          classname = classname.replace('selected', 'deselected');
          classname = classname.replace('normal', 'deselected');
          this.setAttribute('class', classname);
        });
      }
    };
    
    chart.mouseover = function(node) {
      if (lastHovered === node) {
        return;
      }

      var tooltipData = {
        body : [],
        footer : []
      };

      var nd = node.__data__.data, body = tooltipData.body, footer = tooltipData.footer;
      var path = nd.data.ctx.path;

      body.push({
        name : data.getMeasureValuesGroupDataByIdx(0).values[path.mi].col,
        val : [ {
          value : nd.data.val,
          color : node.__data__.c,
          shape : 'squareWithRadius'
        } ]
      });

      var a0data = data.getAnalysisAxisDataByIdx(0), aa1 = path.dii_a1;
      if (a0data) {
        for ( var i = 0, len = a0data.values.length; i < len; i++) {
          footer.push({
            'label' : a0data.values[i].col.val,
            'value' : a0data.values[i].rows[aa1].val,
          });
        }
      }

      var a1data = data.getAnalysisAxisDataByIdx(1), aa2 = path.dii_a2;
      if (a1data) {
        for ( var i = 0, len = a1data.values.length; i < len; i++) {
          if (a1data.values[i].type === 'MND') {
            continue;
          }
          footer.push({
            'label' : a1data.values[i].col.val,
            'value' : a1data.values[i].rows[aa2].val,
          });
        }
      }
      var transform = parent.node().getTransformToElement(
          parent.node().ownerSVGElement);

      var rtp = node.__data__.rtp;
      tooltipData.point = {
        x : rtp.x + transform.e,
        y : rtp.y + transform.f
      };

      tooltipData.plotArea = {
        x : transform.e,
        y : transform.f,
        width : width,
        height : height
      };

      lastHovered = node;
      d.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));

    };

    chart.mouseout = function(target) {
      lastHovered = null;
      d.hideTooltip();
    };
    
    function isVertical() {
      return properties.direction === "vertical";
    }

    function updatePrimaryCategoryScaleRange() {
      primaryCategoryScale.rangeBands(isVertical() ? [ 0, width ]
          : [ height, 0 ]);
      d.primaryCategoryScaleChange(primaryCategoryScale,isVertical() ? [ 0, width ]
      : [ height, 0 ]);
    }

    function updateSecondaryCategoryScaleRange() {
      secondaryCategoryScale.rangeBands([
          0,
          primaryCategoryScale.rangeBand() *
              secondaryCategoryScale.domain().length ]);
      d.secondaryCategoryScaleChange(secondaryCategoryScale, [0, primaryCategoryScale.rangeBand() * 
          secondaryCategoryScale.domain().length ]);
    }

    function updateValueScaleRange() {
      valueScale.range(isVertical() ? [ height, 0 ] : [ 0, width ]);
      d.valueScaleChange(valueScale,  isVertical() ? [ height, 0 ] : [ 0, width ]);
    }
    
    var handleNull = function(_){
      var defaultString = langManager.get('IDS_ISNOVALUE');
      if (_ === null || _ === undefined){
        return defaultString;
      }
      else{ 
        return _;
      }
    };
    
    var handleNullInArray = function(array){
      for (var i = 0; i < array.length; ++i){
        array[i].val = handleNull(array[i].val);
      }
      return array;
    };
    
    var _setPathByaa = function(path){
      var pathObj = {};
      switch(path.aa){
        case 0:
          pathObj.dii_a1 = path.dii;
          break;
        case 1:
          pathObj.dii_a2 = path.dii;
          break;
        case 2:
          pathObj.dii_a3 = path.dii;
          break;
      }
      return pathObj;
    };
    
    var _parseColorLegendFeeds = function(colorFeeds, shapeFeeds){
      var title, labels = [], colorFeedLength, shapeFeedLength;
      var colorData = _parseLegendFeed(title, colorFeeds, colorFeedLength);
      colorFeedLength = colorData.feedsLength;
      var shapeData = _parseLegendFeed(title, shapeFeeds, shapeFeedLength);
      shapeFeedLength = shapeData.feedsLength;
      
      secondaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].rows = shapeData.labels;
      primaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].rows = colorData.labels

    };
    
    var getCartesian = function(arrays, symbol) {
      var result = arrays[0];
      var fff = function(arr) {
        var ar = result;
        result = [];
        for(var i = 0; i < ar.length; i++) {
          for(var j = 0; j < arr.length; j++) {
            var t1 = (ar[i].val === undefined) ? ar[i].val : ar[i].val, t2 = (arr[j].val === undefined) ? arr[j].val : arr[j].val;
            var ctx = {
              path : {}
            };
            ObjectUtils.extend(ctx.path, ar[i].ctx.path, arr[j].ctx.path);
            result.push({
              'val': t1 + symbol + t2, 
              'ctx': ctx
            });
          }
        }
      };
      for(var i = 1; i < arrays.length; i++) {
        fff(arrays[i]);
      }

      return result;
    };
    
    var _parseLegendFeed = function(title, feeds, feedsLength){
      var labels = [], rows = [], dimensionTag = ' / ', measureTag = ' - ';
      var MNDIndex, hasOnlyMND = false, i, j, len;
      //Handle colors feeds
      if(feeds && feeds.length > 0){
        for(i = 0, len = feeds.length; i < len; i++) {
          if(feeds[i].type !== 'MND') {
            if(title === undefined) {
              title = handleNull(feeds[i].col.val);
            } else {
              title = title + dimensionTag + handleNull(feeds[i].col.val);
            }
            
            rows = feeds[i].rows;
            for(j = 0; j < rows.length; j++) {
              if(labels[j] === undefined) {
                labels[j] = {};
                labels[j].val = handleNull(rows[j].val);
                labels[j].ctx = {
                  path : _setPathByaa(rows[j].ctx.path)
                };
              } else {
                labels[j].val = labels[j].val + dimensionTag + handleNull(rows[j].val);
              }
            }
          } else {
            MNDIndex = i;
          }
        }
        feedsLength = labels.length;
      }
      
      //Handle Colors with MND
      if(MNDIndex !== undefined) {
        //Save color feed with MND status.
        if(labels.length > 0){
          if(feeds[MNDIndex].rows.length > 1){
            if(MNDIndex === 0) {
              title = langManager.get('IDS_DEFAULTMND') + measureTag + title; 
              //MND is the first feed type. Legend label should be 'MND - A/B/C'
              labels = getCartesian([handleNullInArray(feeds[MNDIndex].rows), labels], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } else if(MNDIndex === feeds.length - 1) {
              title = title + measureTag + langManager.get('IDS_DEFAULTMND');
              //MND is the last feed type. Legend label should be 'A/B/C - MND'
              labels = getCartesian([labels, handleNullInArray(feeds[MNDIndex].rows)], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } 
          }
        }else{
          title = langManager.get('IDS_DEFAULTMND');
          rows = feeds[MNDIndex].rows;
          for(j = 0; j < rows.length; j++) {
            rows[j].val = handleNull(rows[j].val);
            labels.push(rows[j]);
          }
          feedsLength = rows.length;
          if(rows.length === 1){
            hasOnlyMND = true;
          }
        }
      }
      
      return {
        'title' : title,
        'labels' : labels,
        'feedsLength' : feedsLength,
        'MNDInfo' : {
          'MNDIndex' : MNDIndex,
          'hasOnlyMND': hasOnlyMND //Only has MND, no cartesian
        }
      };
    };

    function generateSecondCategoryData(){
      var colorFeeds = null, shapeFeeds = null;;
      var aa = data.getAnalysisAxisDataByIdx(0);
      if(aa){ 
        colorFeeds = aa.values;
      }
     
      aa = data.getAnalysisAxisDataByIdx(1);
      if(aa){
        shapeFeeds = aa.values;
      }
     
      _parseColorLegendFeeds(colorFeeds, shapeFeeds);
    };
    
    return chart;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xyz.Bar3D',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.bar3d',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.0'
}
],
function Setup(Manifest, fn, Constants) {
  var module = {
    'id' : 'sap.viz.modules.bar3d',
    'name' : '3d bar',
    'type' : Constants.Module.Type.Chart,
    fn : fn,
    'properties' : {
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.SAPColor,
        'description' : 'Set color palette.'
      },
      'direction' : {
        'name' : "direction",
        'supportedValueType' : 'List',
        'supportedValues' : [ 'vertical', 'horizontal' ],
        'defaultValue' : "vertical",
        'description' : 'Set direction.',
        'isExported' : false
      }
    },
    'feeds' : {
      id : "xy",
      configure : {
        secondaryValues : null
      }
    }
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.xyzlayout',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.0'
}
],
function Setup(TypeUtils, matrix, Point) {
  /*
   * Function set that represents a light-weight layout manager
   * who calculates optimal component layout data, rather than
   * operating on components directly.
   */
  var initBoundingBox = function(width, height, depth) {
    var bounds = [ {
      x : 0,
      y : 0,
      z : 0
    }, {
      x : 0,
      y : 0,
      z : depth
    }, {
      x : width,
      y : 0,
      z : 0
    }, {
      x : width,
      y : 0,
      z : depth
    }, {
      x : 0,
      y : height,
      z : 0
    }, {
      x : 0,
      y : height,
      z : depth
    }, {
      x : width,
      y : height,
      z : 0
    }, {
      x : width,
      y : height,
      z : depth
    } ];

    return bounds.map(function(bound) {
      return new Point(bound.x, bound.y, bound.z);
    });
  };

  var computeTransformBB = function(bounds, m) {
    var point = bounds[0];
    point.transform(m);

    var minx = point.x, miny = point.y, maxx = point.x, maxy = point.y;

    for ( var i = 1, len = bounds.length; i < len; i++) {
      point = bounds[i];
      point.transform(m);

      minx = Math.min(minx, point.x);
      miny = Math.min(miny, point.y);
      maxx = Math.max(maxx, point.x);
      maxy = Math.max(maxy, point.y);
    }

    return {
      x : minx,
      y : miny,
      z : maxx,
      w : maxy
    };

  };

  var computerMargin = function(prefs, m_xaxis, m_yaxis, m_zaxis) {
    return {
      top : 0,
      left : prefs.west.size.width,
      bottom : prefs.south.size.height > prefs.east.size.height ? prefs.south.size.height
          : prefs.east.size.height,
      right : prefs.east.size.height
    };
  };

  var prepareScale = function(width, height, bb, margin) {
    var bbSizeX = bb.z - bb.x;
    var bbSizeY = bb.w - bb.y;

    var sizeV = height - margin.bottom - margin.top;
    var sizeH = width - margin.left - margin.right;

    var ratioX = sizeH / bbSizeX;
    var ratioY = sizeV / bbSizeY;
    var minRatio = Math.min(ratioX, ratioY);

    return {
      x : minRatio,
      y : ratioY,
      z : minRatio
    };

  };

  var computeScale = function(width, height, depth, m, m_xaxis, m_yaxis,
      m_zaxis, prefs) {
    var bounds = initBoundingBox(width, height, depth);
    var bb = computeTransformBB(bounds, m);
    var savedBB = {
      x : bb.x,
      y : bb.y,
      x : bb.z,
      w : bb.w
    };
    var margin = computerMargin(prefs, m_xaxis, m_yaxis, m_zaxis);
    var scale = prepareScale(width, height, bb, margin);
    return scale;
  };

  var xyzlayout = function(spec) {

    var defaults = {
      resize : true,
      type : 'grid',
      padding : [ 0, 0, 0, 0 ],
      hgap : 0,
      vgap : 0
    };

    var hgap = spec.hgap || defaults.hgap, vgap = spec.vgap || defaults.vgap, padding = spec.padding
        || defaults.padding, bias = spec.bias || 'none';

    var m_xaxis = spec.m_xaxis, m_yaxis = spec.m_yaxis, m_zaxis = spec.m_zaxis, m_plot = spec.m_plot, m_background = spec.m_background;
    var twidth = spec.size.width, theight = spec.size.height;
    var xAngle = spec.xAngle, yAngle = spec.yAngle;

    var layoutSolution = {}, options = spec.prefs;

    var defaults = {
      resize : true,
      type : 'grid',
      padding : [ 0, 0, 0, 0 ],
      hgap : 0,
      vgap : 0
    };

    var hgap = spec.hgap || defaults.hgap, vgap = spec.vgap || defaults.vgap, padding = spec.padding
        || defaults.padding, bias = spec.bias || 'none';

    var m_xaxis = spec.m_xaxis, m_yaxis = spec.m_yaxis, m_zaxis = spec.m_zaxis, m_plot = spec.m_plot, m_background = spec.m_background;
    var twidth = spec.size.width, theight = spec.size.height;
    var xAngle = spec.xAngle, yAngle = spec.yAngle;

    var layoutSolution = {}, options = spec.prefs;

    if (!spec.finalLayout) {
      node = layoutSolution.center = {};
      node.bounds = {
        x : 0,
        y : 0,
        width : twidth,
        height : theight
      };

      return layoutSolution;
    }

    var w_y = options.west.size.width, h_y = options.west.size.height, w_x = options.south.size.width, h_x = options.south.size.height, w_z = options.east.size.width, h_z = options.east.size.height;

    var m = matrix();//.transform(matrix().rotateY(yAngle).rotateX(xAngle));
    m.transform(matrix().rotateY(yAngle).rotateX(xAngle));

    //var m_scale = computeScale(twidth, theight, w_z, m, m_xaxis, m_yaxis, m_zaxis, options);
    var bounds = initBoundingBox(twidth, theight, w_z);
    var bb = computeTransformBB(bounds, m);
    //var savedBB  =  { x: bb.x, y: bb.y, x: bb.z, w: bb.w};
    var margin = computerMargin(options, m_xaxis, m_yaxis, m_zaxis);
    var m_scale = prepareScale(twidth, theight, bb, margin);

    layoutSolution.scale = m_scale;

    h_y = theight - h_x;

    m.scale(m_scale.x, m_scale.y, m_scale.z);
    m_xaxis.scale(m_scale.x, m_scale.y, m_scale.z);
    m_yaxis.scale(m_scale.x, m_scale.y, m_scale.z);
    m_zaxis.scale(m_scale.x, m_scale.y, m_scale.z);
    m_plot.scale(m_scale.x, m_scale.y, m_scale.z);

    bounds = initBoundingBox(twidth, theight, w_z);
    var newbb = computeTransformBB(bounds, m);
    var scaledHeight = newbb.w - newbb.y;
    var scaledWidth = newbb.z - newbb.x;

    var minx = (twidth - scaledWidth) / 2;
    var miny = (theight - scaledHeight) / 2
        + Math.abs(new Point(0, 0, w_z).transform(m).y);//m.transformPoint({x:0,y:0,z:w_z}).y);

    //west
    var node = layoutSolution.west = {};
    var westpoint = new Point(0, 0, 0).transform(m);// m.transformPoint({x:0, y:0, z:0});
    var westpoint2 = new Point(0, h_y, 0).transform(m);
    var westlength = Math.sqrt(Math.pow(westpoint2.y - westpoint.y, 2)
        + Math.pow(westpoint2.x - westpoint.x, 2));
    node.bounds = {
      x : westpoint.x - w_y,
      y : westpoint.y - 7.5,
      width : w_z,
      height : westlength
    };
    m_yaxis.rotateY(-90).translate(westpoint.x, westpoint.y, 0).transform(
        matrix().rotateY(yAngle).rotateX(xAngle));

    //south
    node = layoutSolution.south = {};

    var mm = matrix().rotateY(yAngle).rotateX(xAngle);
    var spoint = new Point(0, h_y, 0).transform(m);
    var southpoint = new Point(0, h_y, 0).transform(mm);// m_yaxis.transformPoint({x: w_y, y:h_y - options.west.endPadding, z:0});

    var southpoint2 = new Point(w_x, h_y, 0).transform(mm);
    var southlength = Math.sqrt(Math.pow(southpoint2.y - southpoint.y, 2)
        + Math.pow(southpoint2.x - southpoint.x, 2));
    node.bounds = {
      x : spoint.x,
      y : spoint.y,
      width : southlength * m_scale.x,
      height : h_x
    };
    node.angle = Math.atan(mm.value(1, 0) / mm.value(0, 0)) * 180 / Math.PI;
    node.labelAngle = Math.atan(mm.value(1, 2) / mm.value(0, 2)) * 180 / Math.PI;
    node.tickAngle = Math.atan(mm.value(1, 2) / mm.value(0, 2)) * 180 / Math.PI;
    
    m_xaxis.rotateX(-90).transform(matrix().rotateY(yAngle).rotateX(xAngle))
        .translate(southpoint.x, southpoint.y, 0);

    //center
    node = layoutSolution.center = {};
    var centerpoint = new Point(0, 0, 0).transform(m);// m_yaxis.transformPoint({x: w_y, y: 0, z:0});
    node.bounds = {
      x : centerpoint.x,
      y : centerpoint.y,
      width : w_x,
      height : h_y - options.west.endPadding
    };
    m_plot.transform(matrix().rotateY(yAngle).rotateX(xAngle)).translate(
        centerpoint.x, centerpoint.y, 0);

    //east
    node = layoutSolution.east = {};
    var epoint = new Point(w_x, h_y - options.west.endPadding, 0).transform(m);

    var eastpoint = new Point(w_x, 0, 0).transform(mm); //m_xaxis.transformPoint({x: w_x, y:0, z: 0});
    var eastpoint2 = new Point(w_x, 0, w_z).transform(mm);
    var eastlength = Math.sqrt(Math.pow(eastpoint2.y - eastpoint.y, 2)
        + Math.pow(eastpoint2.x - eastpoint.x, 2));

    node.bounds = {
      x : epoint.x,
      y : epoint.y,
      width : eastlength * m_scale.z,
      height : h_z
    };
    node.angle = Math.atan(mm.value(1, 2) / mm.value(0, 2)) * 180 / Math.PI;
    node.labelAngle = Math.atan(mm.value(1, 0) / mm.value(0, 0)) * 180 / Math.PI;
    node.tickAngle = Math.atan(mm.value(1, 0) / mm.value(0, 0)) * 180 / Math.PI;
    
    m_zaxis.rotateY(-90).rotateZ(-90).transform(
        matrix().rotateY(yAngle).rotateX(xAngle)).translate(eastpoint.x,
        eastpoint.y, 0);

    node = layoutSolution.background = {};
    var backgroundpoint = new Point(w_y + w_z, 0, 0).transform(m_yaxis); // m_yaxis.transformPoint({x: w_y + w_z, y :0, z: 0});
    node.bounds = {
      x : backgroundpoint.x,
      y : backgroundpoint.y,
      width : w_x,
      height : h_y - options.west.endPadding
    };
    m_background.scale(layoutSolution.scale.x, layoutSolution.scale.y,
        layoutSolution.scale.z).transform(
        matrix().rotateY(yAngle).rotateX(xAngle)).translate(backgroundpoint.x,
        backgroundpoint.y, 0);

    return layoutSolution;
  };

  return xyzlayout;
});sap.riv.module(
{
  qname : 'sap.viz.modules.xyzcontainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.xyzlayout',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.SingleChartDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.threeD.Vector3D',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TypeUtils, Objects, Functions, xyzlayout, Manifest,
    SingleChartDataHandler, dispatch, matrix, Point3D, Vector3D, boundUtil) {

  // xyzcontainer
  var retfn = function(manifest, ctx) {

    function load(moduleId) {
      return Manifest.module.get(moduleId).execute(ctx);
    }
    var width = 0, height = 0, properties = {}, data = {}, config = {}, modules = {}, selections = {}, spaceWithoutPlot, parent = null; // a d3
    // selection

    var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), initializedModules = 0;
    ;
    var innerProperties = manifest.props(null);
    var xAngle = 20, yAngle = 50;

    var count = 0;
    var yAxisScale = d3.scale.linear(); // can be linear or ordinal scale
    var xAxisScale =  d3.scale.ordinal(); // can be linear or ordinal scale
    var zAxisScale =  d3.scale.ordinal();
    // /////////////////////can be moved to base container/////////////////////
    var resolveProperties = function(nodeConfig, isContainer) {
      var props = {}, // Empty properties basket
      propsCat, // Property category node
      usrProps, // User set properties
      sysProps; // Predefined properties in configure node
      if (isContainer) {
        // Jimmy/8/15/2012 pay attention to the property structure, for
        // container we will pass
        // all properties instead of properties under propsCat only.
        if (nodeConfig) {
          propsCat = nodeConfig.propertyCategory;
          usrProps = properties;
          sysProps = {};
          sysProps[propsCat] = nodeConfig.properties;
          Objects.extend(true, props, sysProps, usrProps);
        } else {
          props = properties;
        }
      } else {
        if (nodeConfig) {
          propsCat = nodeConfig.propertyCategory;
          usrProps = properties[propsCat];
          sysProps = nodeConfig.properties;
          // User properties will override predefined properties
          Objects.extend(true, props, sysProps, usrProps);
        }
      }
      return props;
    };

    var updateProperties = function(id, isContainer) {
      var moduleManifest = config.modules; // Module configurations
      var props, nodeConfig, propsCat;
      if (moduleManifest[id] && modules[id]) {
        nodeConfig = moduleManifest[id].configure;
        if (isContainer) {
          props = properties;
        } else {
          if (nodeConfig) {
            propsCat = nodeConfig.propertyCategory;
            props = Objects.extend(true, {}, properties[propsCat]);
          } else {
            props = {};
          }
        }
        modules[id].properties(props);
      }
    };
    // /////////////////////can be moved to base container/////////////////////

    function initialize() {
      if (TypeUtils.isEmptyObject(config))
        Functions.error('Container configuration missing');

      initializedModules = 0;

      initAxis('xAxis');
      initAxis('yAxis');
      initAxis('zAxis');
      initAxis('background');

      var plotConfig = config.modules.plot;
      if (!plotConfig)
        return;
      var plot = modules.plot = load(plotConfig.id);
      var dataHandler = new SingleChartDataHandler(data);
      plot.data(dataHandler.getDataAdapter());

      var props;
      if (plotConfig.configure) {
        props = resolveProperties(plotConfig.configure);
        plot.properties(props);
      }

      if (plot.dispatch) {
        var dis = plot.dispatch();
        if (dis.initialized) {
          initializedModules++;
          dis.on('initialized.xycontainer', initialized);
        }
        ;
        if (dis.showTooltip)
          dis.on('showTooltip.xycontainer', showTooltip);
        if (dis.hideTooltip)
          dis.on('hideTooltip.xycontainer', hideTooltip);
      }

      var dataLabelConfig = config.modules.dataLabel;
      if (TypeUtils.isExist(dataLabelConfig)
          && TypeUtils.isExist(plot.dataLabel)) {
        var dataLabel = modules.dataLabel = load(dataLabelConfig.id);
        plot.dataLabel(dataLabel);
        dataLabel.plot(plot);
        if (dataLabelConfig.configure) {
          props = resolveProperties(dataLabelConfig.configure);
          dataLabel.properties(props);
        }
      }

      if (modules.xAxis && !selections.xAxis)
        selections.xAxis = parent.append('g').attr('class', 'xAxis');
      if (modules.yAxis && !selections.yAxis)
        selections.yAxis = parent.append('g').attr('class', 'yAxis');
      if (modules.zAxis && !selections.zAxis)
        selections.zAxis = parent.append('g').attr('class', 'zAxis');
      if (modules.plot && !selections.plot)
        selections.plot = parent.append('g').attr('class', 'plot');
      if (modules.background && !selections.background)
        selections.background = parent.insert('g', ':first-child').attr(
            'class', 'background');
    }

    function updateAxisData(id) {
      if (modules[id]) {
        var axisConfig = config.modules[id];
        var axisDataConfig = axisConfig.data;
        if (axisDataConfig) {
          modules[id].data(data.createDataAdapterForModule(axisDataConfig));
        }
      }
    }
    ;

    function initAxis(id) {
      if (!config.modules[id])
        return;

      var axisConfig = config.modules[id], axis = modules[id] = load(axisConfig.id);

      updateAxisData(id);

      var props = resolveProperties(axisConfig.configure);
      axis.properties(props);

      if (axis.dispatch && axis.dispatch()['initialized']) {
        initializedModules++;
        axis.dispatch().on('initialized.xycontainer', initialized);
      }
    }

    var initBoundingBox = function(width, height, depth) {
      var bounds = [ {
        x : 0,
        y : 0,
        z : 0
      }, {
        x : 0,
        y : 0,
        z : depth
      }, {
        x : width,
        y : 0,
        z : 0
      }, {
        x : width,
        y : 0,
        z : depth
      }, {
        x : 0,
        y : height,
        z : 0
      }, {
        x : 0,
        y : height,
        z : depth
      }, {
        x : width,
        y : height,
        z : 0
      }, {
        x : width,
        y : height,
        z : depth
      } ];

      return bounds.map(function(bound) {
        return new Point3D(bound.x, bound.y, bound.z);
      });
    };

    var computeTransformBB = function(bounds, m) {
      var point = bounds[0];
      point.transform(m);

      var minx = point.x, miny = point.y, maxx = point.x, maxy = point.y;

      for ( var i = 1, len = bounds.length; i < len; i++) {
        point = bounds[i];
        point.transform(m);

        minx = Math.min(minx, point.x);
        miny = Math.min(miny, point.y);
        maxx = Math.max(maxx, point.x);
        maxy = Math.max(maxy, point.y);
      }

      return {
        x : minx,
        y : miny,
        z : maxx,
        w : maxy
      };

    };

    function radian(deg) {
      return deg * Math.PI / 180;
    }

    var computeMargin = function(params, info3d, omatrix, cwidth, cheight,
        cdepth, southPrefSize, westPrefSize, eastPrefSize) {

      var sangle = layoutAxis('south', params, 'xAxis', xAxisScale, omatrix, 0,
          0, cwidth, cheight, cdepth, info3d.x0, info3d.x1, info3d.y0,
          info3d.z0, info3d.z1)
      var asangle = Math.abs(radian(sangle));

      var wangle = layoutAxis('west', params, 'yAxis', yAxisScale, omatrix, 0,
          0, cwidth, cheight, cdepth, info3d.x0, info3d.x1, info3d.y0,
          info3d.z0, info3d.z1)
      var awangle = Math.abs(radian(wangle));

      var zangle = layoutAxis('none', params, 'zAxis', zAxisScale, omatrix, 0,
          0, cwidth, cheight, cdepth, info3d.x0, info3d.x1, info3d.y0,
          info3d.z0, info3d.z1)
      var azangle = Math.abs(radian(zangle));

      var left = 0, top = 0, right = 0, bottom = 0;

      left = westPrefSize.width * Math.cos(awangle);

      if (zangle <= 1 && sangle > 0
          && !(zangle == 1 && sangle == 91 && xAngle > 0)) {
        left = (left > southPrefSize.height * Math.cos(asangle)) ? left
            : southPrefSize.height * Math.cos(asangle);
        right = eastPrefSize.height * Math.cos(azangle);

        bottom = (southPrefSize.height * Math.sin(asangle) > eastPrefSize.height
            * Math.sin(azangle)) ? southPrefSize.height * Math.sin(asangle)
            : eastPrefSize.height * Math.sin(azangle)

      } else {
        left = (left > eastPrefSize.height * Math.cos(azangle)) ? left
            : eastPrefSize.height * Math.cos(azangle);
        right = southPrefSize.height * Math.cos(asangle);

        bottom = (southPrefSize.height * Math.sin(asangle) > eastPrefSize.height
            * Math.sin(azangle)) ? southPrefSize.height * Math.sin(asangle)
            : eastPrefSize.height * Math.sin(azangle)
      }
      return {
        top : 0,
        left : left,
        bottom : bottom,
        right : right
      };
    };

    var prepareScale = function(sizeH, sizeV, bb, margin, param) {
      var bbSizeX = bb.z - bb.x;
      var bbSizeY = bb.w - bb.y;

      var ratioX = sizeH / bbSizeX;
      var ratioY = sizeV / bbSizeY;
      var minRatio = Math.min(ratioX, ratioY);

      return {
        x : minRatio,
        y : ratioY,
        z : minRatio
      };

    };

    var computeScale = function(width, height, depth, m) {
      var bounds = initBoundingBox(width, height, depth);
      var bb = computeTransformBB(bounds, m);
      var savedBB = {
        x : bb.x,
        y : bb.y,
        x : bb.z,
        w : bb.w
      };
      var margin = computeMargin();
      var scale = prepareScale(width, height, bb, margin);
      return scale;
    };

    var generateRendererParam = function(m) {
      var camera_ = new Vector3D(0, 0, 1);

      var isRenderRT = false, // left
      isRenderTP = false, // top
      isRenderFT = false; // front

      var origin = new Point3D(0, 0, 0);
      var pointX = new Point3D(1, 0, 0);
      var pointY = new Point3D(0, -1, 0);
      var pointZ = new Point3D(0, 0, 1);

      origin.transform(m);
      pointX.transform(m);
      pointY.transform(m);
      pointZ.transform(m);

      var renderingOrderX = new Vector3D(pointX.x - origin.x, pointX.y
          - origin.y, pointX.z - origin.z), renderingOrderY = new Vector3D(
          pointY.x - origin.x, pointY.y - origin.y, pointY.z - origin.z), renderingOrderZ = new Vector3D(
          pointZ.x - origin.x, pointZ.y - origin.y, pointZ.z - origin.z)

      if (camera_.dotProduct(renderingOrderX) < 0) {
        isRenderRT = true;
      }

      if (camera_.dotProduct(renderingOrderY) < 0) {
        isRenderTP = true;
      }

      if (camera_.dotProduct(renderingOrderZ) > 0) {
        isRenderFT = true;
      }

      return {
        isRenderRT : isRenderRT,
        isRenderTP : isRenderTP,
        isRenderFT : isRenderFT,
        renderingOrderX : renderingOrderX,
        renderingOrderY : renderingOrderY,
        renderingOrderz : renderingOrderZ
      };
    };

    function layoutAxis3D(params_, x_, y_, width_, height_, yDepth_) {
      var x0, x1, y0, y1, z0, z1;
      y0 = y_ + height_;

      if (params_.isRenderFT) {
        x0 = x_;
        if (params_.isRenderTP)
          z0 = 0;
        else
          z0 = yDepth_;
      } else {
        x0 = x_ + width_;
        if (params_.isRenderTP)
          z0 = yDepth_;
        else
          z0 = 0;
      }
      if (params_.isRenderRT) {
        z1 = 0;
        if (params_.isRenderTP)
          x1 = x_ + width_;
        else
          x1 = x_;
      } else {
        z1 = yDepth_;
        if (params_.isRenderTP)
          x1 = x_;
        else
          x1 = x_ + width_;
      }

      return {
        x0 : x0,
        x1 : x1,
        y0 : y0,
        z0 : z0,
        z1 : z1
      };
    }
    ;

    function layoutAxis(type, params, axis, scale, m, x_, y_, width_, height_,
        yDepth_, x0, x1, y0, z0, z1) {
      var origin, point, tick, vector;
      var length, angle, labelAngle, tickAngle, gap;

      switch (type) {
        case 'south':
          origin = new Point3D(x_, y0, z0);
          gap = (0 == z0) ? -yDepth_ : yDepth_;
          tick = new Point3D(x_, y0, z0 + gap);
          point = new Point3D(x_ + width_, y0, z0);
          break;
        case 'north':
          origin = new Point3D(x_, height_ - y0, yDepth_ - z0);
          gap = (0 == z0) ? -yDepth_ : yDepth_;
          tick = new Point3D(x_, y0, yDepth_ - z0 + gap);
          point = new Point3D(x_ + width_, height_ - y0, yDepth_ - z0);
          break;
        case 'west':
          origin = new Point3D(x0, y_, z1);
          tick = new Point3D(x0 - width_, y_, z1);
          point = new Point3D(x0, y_ - height_, z1);
          break;
        case 'east':
          origin = new Point3D(width_ - x0, y_ + height_, yDepth_ - z1);
          tick = new Point3D(width_, y_ + height_, yDepth_ - z1);
          point = new Point3D(width_ - x0, y_, yDepth_ - z1);
          break;
        default:
          origin = new Point3D(x1, y0, 0);
          gap = (x_ == x1) ? -width_ : width_;
          tick = new Point3D(x1 + gap, y0, 0);
          point = new Point3D(x1, y0, yDepth_);
          break;
      }

      origin.transform(m);
      tick.transform(m);
      point.transform(m);

      if (type == 'west') {
        labelAngle = 0;
        tickAngle = 0;
      } else {
        vector = new Vector3D(tick.x - origin.x, tick.y - origin.y, point.z
            - origin.z);
        labelAngle = Math.atan2(vector.values[0], vector.values[1]) * 180
            / Math.PI + 90;
        if (labelAngle > 90)
          labelAngle -= 180;
        else if (labelAngle < -90)
          labelAngle += 180;
        labelAngle = computeAngle3D(labelAngle);
        tickAngle = Math.atan2(vector.values[1], vector.values[0]) * 180
            / Math.PI;
      }

      modules[axis].labelAngle(labelAngle).tickAngle(tickAngle);

      vector = new Vector3D(point.x - origin.x, point.y - origin.y, point.z
          - origin.z);
      selections[axis].attr('transform', 'translate(' + origin.x + ' '
          + origin.y + ')');
      angle = Math.atan2(vector.values[1], vector.values[0]) * 180 / Math.PI
          + 90;

      // a special setting, if the angle
      if (type === 'none' && angle == 0) {
        angle = -1;
      }
      modules[axis].angle(angle);

      modules[axis].labelAlign('start');

      length = (point.x - origin.x) * (point.x - origin.x)
          + (point.y - origin.y) * (point.y - origin.y);

      if (length < 0.01)
        length = 0;

      if (type == 'west') {
        modules[axis].height(Math.sqrt(length));
      } else {
        modules[axis].width(Math.sqrt(length));
      }

      if (scale.rangeBands) {
        scale.rangeBands([ 0, Math.sqrt(length) ]);
      } else {
        scale.range([ Math.sqrt(length), 0 ]);
      }

      return labelAngle;
    }
    ;

    function computeAngle3D(angleParam) {

      var angle = angleParam % 360;
      if (-271 < angle && angle < -270)
        return -271;
      else if (-270 <= angle && angle < -269)
        return -269;
      if (-181 < angle && angle < -180)
        return -181;
      else if (-180 <= angle && angle < -179)
        return -179;
      else if (-91 < angle && angle < -90)
        return -91;
      else if (-90 <= angle && angle < -89)
        return -89;
      else if (-1 < angle && angle < 0)
        return -1;
      else if (0 <= angle && angle < 1)
        return 1;
      else if (89 < angle && angle < 90)
        return 89;
      else if (90 <= angle && angle < 91)
        return 91;
      else if (179 < angle && angle < 180)
        return 179;
      else if (180 <= angle && angle < 181)
        return 181;
      else if (269 < angle && angle < 270)
        return 269;
      else if (270 <= angle && angle < 271)
        return 271;
      else if (359 < angle && angle < 360)
        return 359;
      return Math.round(angleParam);
    }

    function relayout(firstLayout) {
      count++;
      if (TypeUtils.isEmptyObject(modules) || !width || !height)
        return;

      width = width < 0 ? 0 : width;
      height = height < 0 ? 0 : height;

      if (count % 4 != 0) {
        modules.plot.width(width).height(height);
      } else {

        var southPrefSize = modules.xAxis.getPreferredSize();
        var westPrefSize = modules.yAxis.getPreferredSize();
        var eastPrefSize = modules.zAxis.getPreferredSize();

        var cwidth = southPrefSize.width, cheight = westPrefSize.height, cdepth = eastPrefSize.width;
        var omatrix = matrix().rotateY(yAngle).rotateX(xAngle);

        var params = generateRendererParam(omatrix);
        var info3d = layoutAxis3D(params, 0, 0, cwidth, cheight, cdepth);

        var bounds = initBoundingBox(cwidth, cheight, cdepth);
        var bb = computeTransformBB(bounds, omatrix);
        var savedBB = {
          x : bb.x,
          y : bb.y,
          x : bb.z,
          w : bb.w
        };

        var margin = computeMargin(params, info3d, omatrix, cwidth, cheight,
            cdepth, southPrefSize, westPrefSize, eastPrefSize);
        var sizeV = height - margin.bottom - margin.top;
        var sizeH = width - margin.left - margin.right;
        var scale = prepareScale(sizeH, sizeV, bb, margin);
        var scaleMatrix = omatrix.unit().scale(scale.x, scale.y, scale.z)
            .clone();
        omatrix.rotateY(yAngle).rotateX(xAngle);

        var offsetX = 0, offsetY = 0;
        var exit = 0;
        while (exit < 10) {

          bounds = initBoundingBox(cwidth, cheight, cdepth);
          bb = computeTransformBB(bounds, omatrix);

          offsetX = 0 - bb.x + margin.left + (sizeH - bb.z + bb.x) / 2;
          offsetY = 0 - bb.y + margin.top + (sizeV - bb.w + bb.y) / 2;

          if (offsetX > 0 && offsetY > 0) {
            break;
          }

          scale = prepareScale(sizeH, sizeV, bb, margin);

          omatrix = scaleMatrix.clone();
          omatrix.scale(scale.x, scale.y, scale.z);
          scaleMatrix = omatrix.clone();

          omatrix.rotateY(yAngle).rotateX(xAngle);
          exit++;
        }

        modules.plot.matrix(omatrix);

        layoutAxis('south', params, 'xAxis', xAxisScale, omatrix, 0, 0, cwidth,
            cheight, cdepth, info3d.x0, info3d.x1, info3d.y0, info3d.z0,
            info3d.z1)

        layoutAxis('west', params, 'yAxis', yAxisScale, omatrix, 0, 0, cwidth,
            cheight, cdepth, info3d.x0, info3d.x1, info3d.y0, info3d.z0,
            info3d.z1)

        layoutAxis('none', params, 'zAxis', zAxisScale, omatrix, 0, 0, cwidth,
            cheight, cdepth, info3d.x0, info3d.x1, info3d.y0, info3d.z0,
            info3d.z1)

        var node = selections.yAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.yAxis.attr('transform', 'translate('
            + (transform.e - westPrefSize.width) + ',' + transform.f + ')');

        bounds = initBoundingBox(cwidth, cheight, cdepth);
        bb = computeTransformBB(bounds, omatrix);

        node = selections.yAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.yAxis.attr('transform', 'translate('
            + (transform.e + offsetX) + ',' + (transform.f + offsetY) + ')');

        node = selections.xAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.xAxis.attr('transform', 'translate('
            + (transform.e + offsetX) + ',' + (transform.f + offsetY) + ')');

        node = selections.zAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.zAxis.attr('transform', 'translate('
            + (transform.e + offsetX) + ',' + (transform.f + offsetY) + ')');

        node = selections.plot.node();
        selections.plot.attr('transform', 'translate(' + (offsetX) + ','
            + (offsetY) + ')');

      }

    }

    function container(selection) {
      selection.each(function(data) {
        parent = selection;
        boundUtil.drawBound(selection, width, height);
        if (TypeUtils.isEmptyObject(modules))
          initialize();
        render();
      });
      return container;
    }

    container.width = function(_, firstLayout) {
      if (!arguments.length)
        return width;
      width = _;
      // Jimmy,8/20/2012, as a container, you don't know whether your
      // sub elements need relayout even if the container size remains
      // the same. so here we just give a chance to sub elements to relayout
      relayout(firstLayout);
      return container;
    };

    container.height = function(_, firstLayout) {
      if (!arguments.length)
        return height;
      height = _;
      // see @width
      relayout(firstLayout);
      return container;
    };

    container.size = function(_) {
      if (!arguments.length)
        return {
          'width' : width,
          'height' : height
        };
      height = _.height;
      width = _.width;
      // see @width
      relayout();
      return container;
    };

    container.data = function(_) {
      if (!arguments.length)
        return data;
      data = _;
      if (!TypeUtils.isEmptyObject(modules)) {
        // plot exists, we need update its data
        var dataHandler = new SingleChartDataHandler(data);
        modules.plot.data(dataHandler.getDataAdapter());
        updateAxisData('xAxis');
        updateAxisData('yAxis');
        updateAxisData('zAxis');
      }

      return container;
    };

    container.properties = function(_) {
      if (!arguments.length)
        return innerProperties;
      properties = _;
      if (!TypeUtils.isEmptyObject(modules)) {
        updateProperties('xAxis');
        updateProperties('yAxis');
        updateProperties('zAxis');
        updateProperties('plot');
        updateProperties('datalabel');
        updateProperties('background');
      }
      Objects.extend(true, innerProperties, _.xyzcontainer);
      xAngle = innerProperties && innerProperties.xAngle ? innerProperties.xAngle
          : xAngle;
      yAngle = innerProperties && innerProperties.yAngle ? innerProperties.yAngle
          : yAngle;
      return container;
    };

    container.config = function(_) {
      if (!arguments.length)
        return config;
      config = _;
      return container;
    };

    container.modules = function(_) {
      if (!arguments.length) {
        if (TypeUtils.isEmptyObject(modules)) {
          initialize();
        }
        return modules;
      }
      modules = _;
      return container;
    };

    container.parent = function(_) {
      if (!arguments.length)
        return parent;
      parent = _;
      return container;
    };

    container.rotate = function(_){
      if(!arguments.length){
        return {
          xAngle: xAngle,
          yAngle: yAngle
        };
      }
      
      count = 2;
      xAngle = _.xAngle;
      yAngle = _.yAngle;
      relayout();
      relayout();
      render();
      
      return container;
    };
    
    container.dispatch = function(_) {
      if (!arguments.length)
        return eDispatch;
      eDispatch = _;
      return container;
    };

    container.infoForSizeLegend = function() {
      return {
        space : spaceWithoutPlot,
        number : 1,
        plotHeight : modules.plot.height()
      };
    };

    container.yAxis = function(_) {
      if (!arguments.length) {
        return yAxisScale;
      }
      yAxisScale = _.copy();
      return container;
    };

    container.xAxis = function(_) {
      if (!arguments.length) {
        return xAxisScale;
      }
      xAxisScale = _.copy();
      return container;
    };

    container.zAxis = function(_) {
      if (!arguments.length) {
        return zAxisScale;
      }
      zAxisScale = _.copy();
      return container;
    };

    container.xAxisScaleChange = function(_, range){
      if(  xAxisScale.rangeBands ){
        xAxisScale.rangeBands(range);
      }else {
        xAxisScale.range(range);
      }
    };
    
    container.zAxisScaleChange = function(_, range){
        zAxisScale.rangeBands(range);
    };
    
    container.yAxisScaleChange = function(_, range){
      if(  yAxisScale.rangeBands ){
        yAxisScale.rangeBands(range);
      }else {
        yAxisScale.range(range);
      }
    };
    
    
    function render() {
      for ( var sel in selections) {
        if (selections.hasOwnProperty(sel)) {
          selections[sel].datum(modules[sel].data()).call(modules[sel]);
        }
      }
      if (TypeUtils.isExist(modules.dataLabel)) {
        modules.dataLabel();
      }
    }

    var initializedCount = 0;
    function initialized() {
      if (initializedModules == ++initializedCount) {
        initializedCount = 0;
        eDispatch.initialized();
      }
    }
    ;

    function showTooltip(evt) {
      eDispatch.showTooltip(evt);
    }
    ;

    function hideTooltip(evt) {
      eDispatch.hideTooltip(evt);
    }
    ;

    return container;
  };
  return retfn;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.XYZContainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.xyzcontainer',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.xyzcontainer',
    'type' : Constants.Module.Type.Container,
    'name' : 'single container',
    'properties' : {
			'xAngle': {
    				 name : 'xAngle',
    				 supportedValueType: 'Number',
    				 defaultValue: 20
			},
			'yAngle': {
				 name: 'yAngle',
				 supportedValueType: 'Number',
				 defaultValue : 50
			}
    },
    'css' : null,
    'configure' : null,
    'events' : {
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xyz.Base3DChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYZContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xyz.Bar3D',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Rotate',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  return function(direction) {
    var isVertical = direction === "vertical";

    var categoryAxis, valueAxis;
    if (isVertical) {
      categoryAxis = "xAxis";
      valueAxis = "yAxis";
    } else {
      categoryAxis = "yAxis";
      valueAxis = "xAxis";
    }

    var chart = {
      id : 'viz/3d_' + (isVertical ? 'column' : 'bar'),
      name : 'IDS_3D_' + (isVertical ? 'COLUMN' : 'BAR'),
      modules : {
        title : {
          id : 'sap.viz.modules.title',
          configure : {
            propertyCategory : 'title'
          }
        },
        legend : {
          id : 'sap.viz.modules.legend',
          data : {
            aa : [ 2 ]
          },
          configure : {
            propertyCategory : 'legend'
          }
        },
        tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
              orientation : 'left'
            }
          }
        },
        main : {
          id : 'sap.viz.modules.xyzcontainer',
          controllers : {
            'interaction' : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                propertyCategory : 'interaction',
                properties : {
                  //supportedEventNames: ['mouseup', 'mousemove', 'touchstart'],
                  selectability: {
                    mode: 'multiple',
                    selectWithCtrlKey: true
                  },
                  preserveSelectionWhenDragging: true
                }
              }
            },
            
            'rotate': {
              id : 'sap.viz.modules.controller.rotate',
              configure : {
                propertyCategory: 'rotate'
              }
            }
          },
          modules : {
            plot : {
              id : 'sap.viz.modules.bar3d',
              configure : {
                'description' : 'Settings regarding the chart area and plot area as well as general chart options.',
                propertyCategory : 'plotArea',
                properties : {
                  direction : direction
                }
              }
            },
            zAxis : {
              id : 'sap.viz.modules.axis',
              configure : {
                'description' : 'Settings for the category axis of an XYZ chart.',
                propertyCategory : 'zAxis',
                properties : {
                  type : 'category',
                  position : 'bottom',
                  forceVerticalFont : true,
                  gridline : {
                    visible : false
                  },
                  shapeRendering : false,
                  isIndependentMode : true
                }
              }
            },

            background : {
              id : 'sap.viz.modules.background',
              configure : {
                propertyCategory : 'background',
                properties : {
                  direction : direction
                }
              }
            }
          },
       configure : {
                    propertyCategory : 'xyzcontainer',
                    properties : {
                      xAngle:20,
                      yAngle:50
                    }
           }
        }
      },
      dependencies : {
        attributes : [{
          targetModule : 'main',
          target : categoryAxis ,
          sourceModule : 'main.plot',
          source : 'primaryCategoryScale'
        }, {
          targetModule : 'main',
          target : valueAxis,
          sourceModule : 'main.plot',
          source : 'valueScale'
        },{
          targetModule : 'main.' + valueAxis,
          target : 'scale',
          sourceModule : 'main',
          source : valueAxis
        }, {
          targetModule : 'main.' + categoryAxis,
          target : 'scale',
          sourceModule : 'main',
          source : categoryAxis
        },{
          targetModule : 'main',
          target : 'zAxis',
          sourceModule : 'main.plot',
          source : 'secondaryCategoryScale'
        }, {
          targetModule : 'main.zAxis',
          target : 'scale',
          sourceModule : 'main',
          source : 'zAxis'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
          targetModule : 'main.zAxis',
          target : 'independentData',
          sourceModule : 'main.plot',
          source : 'secondaryCategoryData'
      },{
        targetModule : 'main.'+categoryAxis,
        target : 'independentData',
        sourceModule : 'main.plot',
        source : 'primaryCategoryData'
      } ],
        events : [ {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'main.rotate',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.rotate'
        }, {
          targetModule : 'main',
          listener : isVertical? 'xAxisScaleChange': 'yAxisScaleChange',
          sourceModule : 'main.plot',
          type : 'primaryCategoryScaleChange.xyzcontainer'
        },{
          targetModule : 'main',
          listener : isVertical? 'yAxisScaleChange': 'xAxisScaleChange',
          sourceModule : 'main.plot',
          type : 'valueScaleChange.xyzcontainer'
        },{
          targetModule : 'main',
          listener : 'zAxisScaleChange',
          sourceModule : 'main.plot',
          type : 'secondaryCategoryScaleChange.xyzcontainer'
        },{
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip.tooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip.tooltip'
        }]
      }
    };

    var modules = chart.modules.main.modules;

    modules[categoryAxis] = {
      id : 'sap.viz.modules.axis',
      data : {
        aa : [ 1 ]
      },
      configure : {
        'description' : 'Settings for the value axis of an XYZ chart.',
        propertyCategory : categoryAxis,
        properties : {
          type : 'category',
          isIndependentMode : true,
          position : isVertical ? 'bottom' : 'left',
          forceVerticalFont : (isVertical ? true : undefined),
          gridline : {
            visible : false,
            showFirstLine: (isVertical ? false : true),
            showLastLine: (isVertical ? false : true)
          },
          shapeRendering : false
        },
        propertiesOverride : {
          gridline : {
            isExported : false
          },
          label : {
            isExported : false
          },
          axisline : {
            isExported : false
          }
        }
      }
    };

    modules[valueAxis] = {
      id : 'sap.viz.modules.axis',
      configure : {
        'description' : 'Settings for the category axis of an XYZ chart.',
        propertyCategory : valueAxis,
        properties : {
          type : 'value',
          position : (isVertical ? 'left' : 'bottom'),
          forceVerticalFont : (isVertical ? undefined : true),
          shapeRendering : false,
          gridline : {
              showFirstLine: (isVertical ? true : false),
              showLastLine: (isVertical ? true : false)
          }
        }
      }
    };

    Manifest.register(chart);
  };
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xyz.Bar3DChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.xyz.Base3DChart',
  version : '4.0.0'
}
],
function Setup(fn) {
  fn("horizontal");
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xyz.Column3DChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.xyz.Base3DChart',
  version : '4.0.0'
}
],
function Setup(fn) {
  fn("vertical");
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'riv/basehorizontalchart',
      name : 'IDS_BASEHORIZONTALCHART',
     'abstract' : true,
      modules : {
        title : {
          id : 'sap.viz.modules.title',
          configure : {
              propertyCategory : 'title'
          }
        },
        legend : {
          id : 'sap.viz.modules.legend',
          data : {
              aa : [ 2 ]
          },
          configure : {
              propertyCategory : 'legend'
          }
        },
        tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
              chartType : 'bar',
              orientation : 'left'
            }
          }
        },
        /**
             * 'sizeLegend' : {}
             */
        main : {
          id : 'sap.viz.modules.xycontainer',
          modules : {
            dataLabel : {
              id : 'sap.viz.modules.datalabel',
              configure : {
                propertyCategory : 'dataLabel',
                properties : {
                  paintingMode : 'rectCoordinate',
                  visible : false,
                  orientation : 'horizontal',
                  position : 'inside',
                  automaticInOutside : true,
                  showZero : true,
                  isStackMode : false,
                  isPercentMode : false,
                  outsideVisible : true,
                  outsidePosition : 'right'
                }
              }
            },
            xAxis : {
              id : 'sap.viz.modules.axis',
              configure : {
              'description': 'Settings for the value axis of an XY chart.',
                propertyCategory : 'xAxis',
                properties : {
                  type : 'value',
                  position : 'bottom'
                }
              }
            },

            yAxis : {
              id : 'sap.viz.modules.axis',
              data : {
                  aa : [ 1 ]
              },
              configure : {
              'description': 'Settings for the category axis of an XY chart.',
                propertyCategory : 'yAxis',
                properties : {
                  type : 'category',
                  position : 'left',
                  gridline : {
                    visible : false
                  }
                },
                propertiesOverride : {
                  gridline : {
                    isExported : false
                  },
                  label : {
                  isExported : false
                  },
                  axisline : {
                  isExported : false
                  }
                }
              }
            },
      
      background : {
        id: 'sap.viz.modules.background',
        configure : {
          propertyCategory : 'background',
          properties : {
            direction : 'horizontal'
          }
        }
      }
          }
        }
      },
      
      dependencies : {
        attributes : [ {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        } ],
        events : [ {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        } ]
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalAreaChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/horizontal_area',
    name : 'IDS_HORIZONTALAREACHART',
    base: 'riv/basehorizontalchart',
    
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'horizontalline',
            orientation : 'left'
          }
        }
      },
      main : {
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction',
                    properties : {
                      supportedEventNames: ['mouseup', 'mousemove']
                    }
                  }
                }
              },
        'modules' : {
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                position : 'outside',
                automaticInOutside : false,
                outsidePosition  : 'left',
                showZero : false
              },
              propertiesOverride:{
                position : {
                  isExported : false
                }
              }
            }
          },
          plot : {
            id : 'sap.viz.modules.area',
            configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea',
              propertiesOverride: {
                bStacked :true             
              },
              properties : {
                 orientation:'horizontal'
              }
            }
          }
        }
      }
     
    },
    feeds:{
      secondaryValues:null
    },
    dependencies : {
      attributes : [ {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'main.plot',
        target : 'primaryDataRange',
        sourceModule : 'main.xAxis',
        source : 'range'
      }, {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'primaryScale'
      }, {
      targetModule : 'main.xAxis',
      target : 'title',
      sourceModule : 'main.plot',
      source : 'primaryAxisTitle'
    }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      }, {
        targetModule : 'main.interaction',
        listener : 'registerEvent',
        sourceModule : 'main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
      }, {
        targetModule : 'main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'main.plot',
        type : 'startToInit.datalabel'
      } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageHorizontalAreaChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalAreaChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_horizontal_area',
    name : 'IDS_PERCENTAGEHORIZONTALAREACHART',
    base: 'viz/horizontal_area',
    
    modules : {  
      main : {    
        'modules' : {
          plot : {
            
            configure : {
              properties: {
                mode : "percentage"
              }
            }
          },
          xAxis : {
            id : 'sap.viz.modules.axis',
            configure : {
            'description': 'Settings for the value axis of an XY chart.',
              propertyCategory : 'xAxis',
              properties : {
                isPercentMode : true
              }
            }
          },
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                isPercentMode: true
              }
            }
          }
        }
      },
      tooltip : {
        id : 'sap.viz.modules.tooltip',
        configure : {
          propertyCategory : 'tooltip',
          properties : {
            chartType : 'horizontalline',
            orientation : 'left',
            formatString: [["0.00%"],["0.00%"]]
          }
        }
    }
     
    }   
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.DataLabel',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'riv/baseverticalchart',
      name : 'IDS_BASEVERTICALCHART',
      'abstract' : true,
      modules : {
        title : {
          id : 'sap.viz.modules.title',
          configure : {
              propertyCategory : 'title'
          }
        },
        legend : {
          id : 'sap.viz.modules.legend',
          data : {
              aa : [ 2 ]
          },
          configure : {
              propertyCategory : 'legend'
          }
        },
        tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
              chartType : 'verticalbar',
              orientation : 'left'
            }
          }
        },
        main : {
          id : 'sap.viz.modules.xycontainer',
          modules : {
            dataLabel : {
              id : 'sap.viz.modules.datalabel',
              configure : {
                propertyCategory : 'dataLabel',
                properties : {
                  paintingMode : 'rectCoordinate',
                  visible : false,
                  orientation : 'vertical',
                  position : 'inside',
                  automaticInOutside : true,
                  showZero : true,
                  isStackMode : false,
                  isPercentMode : false,
                  outsideVisible : true,
                  outsidePosition : 'up'
                }
              }
            },
            yAxis : {
              id : 'sap.viz.modules.axis',
              configure : {
              'description': 'Settings for the value axis of an XY chart.',
               propertyCategory : 'yAxis',
                properties : {
                  type : 'value',
                  position : 'left'
                }
              }
            },

            xAxis : {
              id : 'sap.viz.modules.axis',
              data : {
                  aa : [ 1 ]
              },
              configure : {
              'description': 'Settings for the category axis of an XY chart.',
                propertyCategory : 'xAxis',
                properties : {
                  type : 'category',
                  position : 'bottom',
                  gridline : {
                    visible : false
                  }
                },
                propertiesOverride : {
                  gridline : {
                      isExported : false
                    },
                    label : {
                    isExported : false
                    },
                    axisline : {
                    isExported : false
                   }
                }
                    
              }
            },
      
      background : {
        id: 'sap.viz.modules.background',
        configure : {
          propertyCategory : 'background',
          properties : {
            direction : 'vertical'
          }
        }
      }
          }
        }
      },
      dependencies : {
        attributes : [ {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        } ],
         events : [ {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        } ]
      }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.AreaChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/area',
    name : 'IDS_AREACHART',
    base: 'riv/baseverticalchart',
    
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'line',
            orientation : 'left'
          }
        }
      },
      main : {
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction',
                    properties : {
                      supportedEventNames: ['mouseup', 'mousemove']
                    }
                  }
                }
              },
        'modules' : {
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                position : 'outside',
                automaticInOutside : false,
                outsidePosition : 'down',
                showZero : false
              },
              propertiesOverride:{
                position : {
                  isExported : false
                }
              }
            }
          },
          plot : {
            id : 'sap.viz.modules.area',
            configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea',
              propertiesOverride: {
                bStacked :true
              }
            }
          }
        }
      }
     
    },
    feeds:{
      secondaryValues: null
    },
    dependencies : {
      attributes : [ {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'main.plot',
        target : 'primaryDataRange',
        sourceModule : 'main.yAxis',
        source : 'range'
      }, {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'primaryScale'
      }, {
      targetModule : 'main.yAxis',
      target : 'title',
      sourceModule : 'main.plot',
      source : 'primaryAxisTitle'
    }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      }, {
        targetModule : 'main.interaction',
        listener : 'registerEvent',
        sourceModule : 'main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
      }, {
        targetModule : 'main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'main.plot',
        type : 'startToInit.datalabel'
      }]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageAreaChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.AreaChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_area',
    name : 'IDS_PERCENTAGEAREACHART',
    base: 'viz/area',
    
    modules : {
      main : {    
        'modules' : {
          plot : {
            
            configure : {
              properties: {
                mode : "percentage"
              }
            }
          },
          yAxis : {
            id : 'sap.viz.modules.axis',
            configure : {
            'description': 'Settings for the value axis of an XY chart.',
              propertyCategory : 'yAxis',
              properties : {
                isPercentMode : true
              }
            }
          },
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                isPercentMode: true
              }
            }
          }
        }
      },
      tooltip : {
        id : 'sap.viz.modules.tooltip',
        configure : {
          propertyCategory : 'tooltip',
          properties : {
            chartType : 'line',
            orientation : 'left',
            formatString: [["0.00%"],["0.00%"]]
          }
        }
    }
     
    }   
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.mekko',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TypeUtils, ObjectUtils, dispatch, MNDHandler,tooltipDataHandler, ColorSeries, Scaler, Repository, NumberUtils, Objects , langManager, BoundUtil) {
 var mekko = function(manifest, ctx) {
      var data,
          data1 = [[]],
          data2 = [[]],
          seriesData , tooltipData = [], //in stacked chart the value in tooltip is the same with data in seriesData, but in percentage chart it use the absolute value of negative data.
          primaryAxisTopBoundary = 0,
          primaryAxisBottomBoundary = 0,
          secondaryAxisTopBoundary = 0,
          secondaryAxisBottomBoundary = 0,
          gWrapper = null;
      
      var defaultString = langManager.get('IDS_ISNOVALUE');
      
      var width, 
          height,
          x = 0, y = 0,
          colorPalette = [],
          axis1ColorPalette,
          shapePalette = ['squareWithRadius'],
          properties = manifest.props(null),
          eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
                
      var effectManager = ctx.effectManager;
      
      var categoryScale = d3.scale.ordinal(),
          valueScale = d3.scale.linear();
      categoryScale.noEqual = true;
      
      var decorativeShape = null,
          lastHovered = null;
        
      var barNumber = 1,
          barGroupNumber,
          barNumberinGroup,
          barHeight,
          positiveIndexes = [], 
          negativeIndexes = [];
        
      var enableDataLoadingAnimation = true,
          enableDataUpdatingAnimation = true,
          enableRoundCorner = false,
          clipEdge = true,
          hasMNDonCategoryAxis = false,
          isOnlyInitAnimation = false,
          tooltipVisible = true,
          totalIntervalTime = 1000;
      
      var defsEnter = null, 
          roundCornerDefs = null,
          suffix = Repository.newId();
      
      var mode = 'comparison'; // bar display mode
      
      var drawingEffect = 'normal';
      
      var sizeChange = false, dataStructureChange = false, dataValueChange = false,modeChange = false;
    
      var dimensionData = {
          'sap.viz.modules.mekko.dimension':{
            key: 'sap.viz.modules.mekko.dimension',
            values : [{
              col: {val:''},
              rows: []
            }]
          }
      };
      
      var rangeBounds = [], rangeSumForScale = [],rangeSumForValue = [];

      var isHorizontal = true, afterAttachToDOM = false;
      
      var parseOptions = function(){
          if(mode === properties.mode){
            mode = properties.mode === 'percentage'? 'percentage': 'comparison';
            modeChange = false;
          }
          else{
            mode = properties.mode === 'percentage'? 'percentage': 'comparison';
            modeChange = true;
          }
          isHorizontal = properties.orientation === 'horizontal'? true: false;
          enableRoundCorner = properties.isRoundCorner;
          enableDataLoadingAnimation =  properties.animation.dataLoading; 
          enableDataUpdatingAnimation =  properties.animation.dataUpdating; 
          tooltipVisible = properties.tooltip.enabled;      
    
          axis1ColorPalette = properties.colorPalette;
          
          drawingEffect = properties.drawingEffect;
          
          colorPalette = [];
          var i,j;
      
          for(i=0 ; i < seriesData[0].length; i++){
              for(j=0; j < seriesData[0][0].length; j++){
               colorPalette.push(axis1ColorPalette[j % axis1ColorPalette.length]);
              }
            }           
        };
        
        function chart(selection){
            BoundUtil.drawBound(selection, width, height);
            //deal with percentage mode
            if(mode === 'percentage'){
              turnToPercentage();
              

            }
            if(mode ==='comparison'){
              turnToComparison();
              
            }
            //if there is no scale, do not need to draw anything.
            if(!TypeUtils.isExist(valueScale)) {
              return;
            }
            eDispatch.startToInit();
            selection.each(function(){
              
            barNumber = (TypeUtils.isExist(data2)) ? 2 : 1;
            barHeight = 8 * (categoryScale.rangeBand()) / (9*barNumber +7 );
            
            barNumberinGroup = seriesData[0][0].length + ((TypeUtils.isExist(seriesData[0][1])) ? seriesData[0][1].length : 0);
          
          var barGroupNumber = seriesData.length;
            var svg = (gWrapper = d3.select(this));
            //append decorativeShape
              if(decorativeShape === null){
                if(isHorizontal){
                  decorativeShape = svg.append('rect').attr('width', width).attr('height',
                  categoryScale.rangeBand() - barHeight/2).attr('visibility', 'hidden').attr(
                      'fill', 'rgba(133,133,133, 0.2)');
                }
                else{
                  decorativeShape = svg.append('rect').attr('width', categoryScale.rangeBand() - barHeight/2).attr('height',
                  height).attr('visibility', 'hidden').attr(
                      'fill', 'rgba(133,133,133, 0.2)');  
                }
              }else{
                if(isHorizontal){
                  decorativeShape.attr('width', width).attr('height', categoryScale.rangeBand() - barHeight/2).attr('visibility', 'hidden');
                }
                else{
                  decorativeShape.attr('width', categoryScale.rangeBand() - barHeight/2).attr('height', height).attr('visibility', 'hidden');
                
                }
              }
              
              if(defsEnter === null){
              defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
            }else{
              defsEnter.attr('width', width).attr('height', height);
            }  
              
            if(roundCornerDefs === null){      
              roundCornerDefs = svg.append('defs').attr('id', 'round-corner-clip' + suffix);
            }else{
              if( dataStructureChange || sizeChange || dataValueChange ){
                roundCornerDefs.remove();
                roundCornerDefs = svg.append('defs').attr('id', 'round-corner-clip' + suffix);
              }
            }    
            
            
            var datashapesgroup = svg.selectAll('g.datashapesgroup');
            if(!TypeUtils.isExist(datashapesgroup[0][0])){
              datashapesgroup = svg.append('g').attr('class', 'datashapesgroup');
            }
            
            var barGroup;
            if(enableDataLoadingAnimation && !isOnlyInitAnimation){
                barGroup = datashapesgroup.selectAll('g.bar').data(seriesData);       
                barGroup.enter().append('g');
                barGroup.attr('class','bar').each( function (perGroupData,i) {
            var barHeightInitial = isHorizontal? 8 * (rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i]) / (9*barNumberinGroup +7 ):8 * (rangeBounds[i+1]- rangeBounds[i]) / (9*barNumberinGroup +7 );
            
            //2012-12-31 for roundcorner by yuanhao.
            var barFinalHeight = isHorizontal? rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] : rangeBounds[i+1]- rangeBounds[i];
            if( barFinalHeight > 1){
              barFinalHeight = barFinalHeight - 1;
            }
            var r = Math.log(barFinalHeight)/Math.log(2);
            if( r < 0 ){
              enableRoundCorner = false;
            } 
            var axisGroup = d3.select(this).selectAll('g.axisGroup').data(perGroupData);     
                    axisGroup.enter().append('g');
                    axisGroup.attr('class','axisGroup').each( function (perAxisData,j) {  
                      // This is for dual axis
                      
                      var fillingColor = axis1ColorPalette ;
                      var startPoint = barHeight /2;
                      var initStartPoint = categoryScale(i);

                      // This is for pos/neg values.
                      var positiveX = 0, negativeX = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                      var yArray = [],xArray = [];
                      // wrap a datashape g for each rect
                      var barShape = d3.select(this).selectAll('g.datashape').data(perAxisData);
                          barShape.enter().append('g').attr('class','datashape')

                          barShape.each(function(d){
                            var bar = d3.select(this).selectAll('rect').data([d]);
                            bar.enter().append('rect');
                            bar.exit().remove();
                          });
                          barShape.exit().remove();

                          if(afterAttachToDOM){
                            barShape.each(function(){
                              if(TypeUtils.isExist(this.getTransformToElement(this.parentNode))){
                                xArray.push(this.getTransformToElement(this.parentNode).e);
                                yArray.push(this.getTransformToElement(this.parentNode).f);
                              }else{
                                xArray.push(0);
                                yArray.push(0);
                              }

                            });
                          }
                          //transform for datashape
                          barShape.attr('transform', function (perRectData, k){
                            if(isHorizontal){
                              var y = height - rangeBounds[barGroupNumber - i - 1] ;
                              
                              var x;
                              if(perRectData.val >= 0){
                                
                                positiveX = valueScale(positiveStackedValue);
                                positiveStackedValue += perRectData.val;
                                x = positiveX;
                               }else{
                                negativeStackedValue += perRectData.val;
                                negativeX = valueScale(negativeStackedValue);
                               
                                x = negativeX;
                               }
                            }
                            //for vertical valueScale has been reversed.
                            else{
                              var x = rangeBounds[i];

                              var y ;
                              if(perRectData.val >= 0){
                                positiveStackedValue += perRectData.val;
                                positiveY = valueScale(positiveStackedValue);
                                
                                y = positiveY;
                               }else{
                                
                                negativeY = valueScale(negativeStackedValue);
                                negativeStackedValue += perRectData.val;
                                y = negativeY;
                               }
                            }
                             return 'translate('+x+','+y+')';
                          });

                      var bar = d3.select(this).selectAll('rect');
                        
                        bar.attr('fill', function(d,colorIndex){  
                          d.fillColor = fillingColor[colorIndex % fillingColor.length];
                          var parameter = {
                              drawingEffect:drawingEffect,
                              fillColor : d.fillColor,
                              direction : isHorizontal?'vertical': 'horizontal'
                          };
                          return effectManager.register(parameter);
                        }).attr('class', 'datapoint').attr('fill-opacity', 1);
                      
                      //If data structure change or data value change, we should do animation from beginning.
                      if(dataStructureChange){
                        if(isHorizontal){
                          bar.attr('height', barHeightInitial).attr('y', function (perRectData, m) {
                              return  barHeightInitial*m;
                             })
                             .attr('x', 0)
                             .attr('width', 0);
                           
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            bar.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var roudCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                                                .append('rect').attr('class', 'roundCorner-clip')
                                                                .attr('rx', r).attr('ry', r).attr('y', this.y.baseVal.value)
                                                                .attr('height', barHeightInitial).attr('width', 0)
                                                                .attr('x', this.x.baseVal.value)
                                                                .transition().duration(totalIntervalTime/2)
                                                                .attr('x',function(){
                                                                  if(indexinGroup === negativeIndexes[j][i] ){
                                                                    return 0;
                                                                  }else{
                                                                    return 0 -r;
                                                                  }
                                                                })
                                                                .attr('width',function(){
                                                                  return Math.abs(valueScale(perRectData.val) -  valueScale(0)) + r;
                                                                })
                                                                .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                                                                .attr('height', barFinalHeight).attr('y', 0);
                                return 'url(#' + id + ')';
                              }
                            });
                          }

                           negativeStackedValue = 0;
                           bar.transition().duration(totalIntervalTime/2).attr('width', function(perRectData, m){
                            return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                          }).attr('x', 0)
                            .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2).attr('height',function(perRectData , m){
                              var h = rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                              if(h > 1){
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] - 1;
                              }else{
                                return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                              }})
                            .attr('y', 0)
                            .attr('width', function(perRectData, m){
                              return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                            })
                            .each('end', function(perRectData, m){
                              if(i === 0 && m === barNumberinGroup - 1){
                                initialized();
                              }
                            });
                        }
                        else{
                          bar.attr('width', barHeightInitial).attr('x', function (perRectData, m) {
                              return  barHeightInitial*m;
                             })
                             .attr('y', function(perRectData, m){
                              return Math.abs(valueScale(perRectData.val) - valueScale(0));
                             })
                             .attr('height', 0);
                           
                           //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            bar.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var roudCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                                                .append('rect').attr('class', 'roundCorner-clip')
                                                                .attr('rx', r).attr('ry', r).attr('y', this.y.baseVal.value)
                                                                .attr('width', barHeightInitial).attr('height', 0)
                                                                .attr('x', this.x.baseVal.value)
                                                                .transition().duration(totalIntervalTime/2)
                                                                .attr('y',function(){
                                                                  if(indexinGroup === negativeIndexes[j][i] ){
                                                                    return 0 -r;
                                                                  }else{
                                                                    return 0;
                                                                  }
                                                                })
                                                                .attr('height',function(){
                                                                  return Math.abs(valueScale(perRectData.val) -  valueScale(0)) + r;
                                                                })
                                                                .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                                                                .attr('width', barFinalHeight).attr('x', 0);
                                return 'url(#' + id + ')';
                              }
                            });
                          }

                           negativeStackedValue = 0;
                           bar.transition().duration(totalIntervalTime/2).attr('height', function(perRectData, m){
                            return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                          }).attr('y', 0)
                            .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2).attr('width',function(perRectData , m){
                              var w = rangeBounds[i + 1]- rangeBounds[i];
                              if(w > 1){
                              return rangeBounds[i + 1]- rangeBounds[i] - 1;
                              }else{
                                return rangeBounds[i + 1]- rangeBounds[i];
                              }})
                            .attr('x', 0)
                            .attr('height', function(perRectData, m){
                              return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                            })
                            .each('end', function(perRectData, m){
                              if(i === 0 && m === barNumberinGroup - 1){
                                initialized();
                              }
                            });
                        }
                      }
                      //if datavalue change , we need put the x,y,width ,height to last postion
                      else if( dataValueChange){
                        bar.attr('x',function(d,k){
                          return xArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
                        })
                        .attr('y',function(d,k){
                          return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                        });
                        var barTransition = bar.transition();
                        if(isHorizontal){
                          barTransition.duration(totalIntervalTime/2)
                          .attr('width', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                           .attr('x', 0)
                          .attr('height',function(perRectData , m){
                            var h = rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            if(h > 1){
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] - 1;
                            }else{
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            }
                          })
                          .attr('y', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            barTransition.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var x = parseFloat(this.x.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                          .append('rect').attr('class', 'roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('height',this.height.baseVal.value).attr('width', this.width.baseVal.value + r)
                                          .attr('x', function(){
                                            return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                          })
                                          .attr('y',this.y.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('x',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0;
                                            }else{
                                              return 0 - r;
                                            }
                                          })
                                          .attr('width', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('height',barFinalHeight).attr('y',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });
                          }
                        }
                        else{
                          barTransition.duration(totalIntervalTime/2)
                          .attr('height', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                           .attr('y', 0)
                          .attr('width',function(perRectData , m){
                            var w = rangeBounds[i + 1]- rangeBounds[i];
                            if(w > 1){
                              return rangeBounds[i + 1]- rangeBounds[i] - 1;
                            }else{
                              return rangeBounds[i + 1]- rangeBounds[i];
                            }
                          })
                          .attr('x', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            barTransition.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var y = parseFloat(this.y.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                          .append('rect').attr('class', 'roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('width',this.width.baseVal.value).attr('height', this.height.baseVal.value + r)
                                          .attr('y', function(){
                                            return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                          })
                                          .attr('x',this.x.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('y',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0 - r;
                                            }else{
                                              return 0 ;
                                            }
                                          })
                                          .attr('height', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('width',barFinalHeight).attr('x',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });
                          }
                        }
                      }
                      //if plot container size change, we should update x, y, width, height of bar rects.
                      //The behavour of value change is not same as bar's, in mekko, it also has to change
                      //x, y, width, height of bar rects.
                      else if(sizeChange){
                        if(isHorizontal){
                          bar.attr('x',function(d,k){
                            return xArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
                          })
                          .attr('width', function(perRectData){
                           var newWidth = Math.abs(valueScale(perRectData.val) - valueScale(0));
                           if(parseFloat(this.width.baseVal.value) > newWidth){
                             return this.width.baseVal.value;
                           }else{
                             return newWidth;
                           }
                          });
                          var barTransition = bar.transition();
                          barTransition.duration(totalIntervalTime/2)
                          .attr('width', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                          .attr('x', 0)
                          .attr('height',function(perRectData , m){
                            var h = rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            if(h > 1){
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] - 1;
                            }else{
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            }
                          })
                          .attr('y', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            barTransition.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var x = parseFloat(this.x.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                          .append('rect').attr('class', 'roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('height',this.height.baseVal.value).attr('width', this.width.baseVal.value + r)
                                          .attr('x', function(){
                                            return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                          })
                                          .attr('y',this.y.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('x',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0;
                                            }else{
                                              return 0 - r;
                                            }
                                          })
                                          .attr('width', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('height',barFinalHeight).attr('y',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });
                          }
                        }
                        else{
                          bar.attr('y',function(d,k){
                            return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                          })
                          .attr('height', function(perRectData){
                           var newHeight = Math.abs(valueScale(perRectData.val) - valueScale(0));
                           if(parseFloat(this.height.baseVal.value) > newHeight){
                             return this.height.baseVal.value;
                           }else{
                             return newHeight;
                           }
                          });
                          var barTransition = bar.transition();
                          barTransition.duration(totalIntervalTime/2)
                          .attr('height', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                          .attr('y', 0)
                          .attr('width',function(perRectData , m){
                            var w = rangeBounds[i + 1]- rangeBounds[i];
                            if(w > 1){
                              return rangeBounds[i + 1]- rangeBounds[i] - 1;
                            }else{
                              return rangeBounds[i + 1]- rangeBounds[i];
                            }
                          })
                          .attr('x', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            barTransition.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var y = parseFloat(this.y.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                          .append('rect').attr('class', 'roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('width',this.width.baseVal.value).attr('height', this.height.baseVal.value + r)
                                          .attr('y', function(){
                                            return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                          })
                                          .attr('x',this.x.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('y',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0 - r;
                                            }else{
                                              return 0 ;
                                            }
                                          })
                                          .attr('height', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('width',barFinalHeight).attr('x',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });
                          }
                        }
                      }
                      //if modeChange we just adjust the x of bar to last postion
                      else if(modeChange){
                        if(isHorizontal){
                          bar.attr('x',function(d,k){
                          return xArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
                          });
                          var barTransition = bar.transition();
                          barTransition.duration(totalIntervalTime/2)
                          .attr('width', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                           .attr('x', 0)
                          .attr('height',function(perRectData , m){
                            var h = rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            if(h > 1){
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] - 1;
                            }else{
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            }
                          })
                          .attr('y', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            barTransition.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var x = parseFloat(this.x.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                          .append('rect').attr('class', 'roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('height',this.height.baseVal.value).attr('width', this.width.baseVal.value + r)
                                          .attr('x', function(){
                                            return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                          })
                                          .attr('y',this.y.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('x',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0;
                                            }else{
                                              return 0 - r;
                                            }
                                          })
                                          .attr('width', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('height',barFinalHeight).attr('y',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });
                          }
                        }
                        else{
                          bar.attr('y',function(d,k){
                          return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                          });
                          var barTransition = bar.transition();
                          barTransition.duration(totalIntervalTime/2)
                          .attr('height', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                           .attr('y', 0)
                          .attr('width',function(perRectData , m){
                            var w = rangeBounds[i + 1]- rangeBounds[i];
                            if(w > 1){
                              return rangeBounds[i + 1]- rangeBounds[i] - 1;
                            }else{
                              return rangeBounds[i + 1]- rangeBounds[i];
                            }
                          })
                          .attr('x', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            barTransition.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var y = parseFloat(this.y.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                          .append('rect').attr('class', 'roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('width',this.width.baseVal.value).attr('height', this.height.baseVal.value + r)
                                          .attr('y', function(){
                                            return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                          })
                                          .attr('x',this.x.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('y',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0 - r;
                                            }else{
                                              return 0 ;
                                            }
                                          })
                                          .attr('height', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('width',barFinalHeight).attr('x',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });
                          }
                        }
                      }
                      
                      //bar.exit().remove();  //Nick                
                    });
                  axisGroup.exit().remove();
                });
                barGroup.exit().remove();
                if(!enableDataUpdatingAnimation){
                  isOnlyInitAnimation = true;
                }
              }else{
                barGroup = svg.selectAll('g.bar').data(seriesData);     
                barGroup.enter().append('g');
                barGroup.attr('class','bar').each( function (perGroupData,i) {
                var barFinalHeight = isHorizontal? rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] : rangeBounds[i+1]- rangeBounds[i];
                if( barFinalHeight > 1){
                  barFinalHeight = barFinalHeight - 1;
                }
                var r = Math.log(barFinalHeight)/Math.log(2);
                if( r < 0 ){
                  enableRoundCorner = false;
                } 
                var axisGroup = d3.select(this).selectAll('g.axisGroup').data(perGroupData);     
                  axisGroup.enter().append('g');
                  axisGroup.attr('class','axisGroup').each( function (perAxisData,j) {
                    
                    
                    var fillingColor =  axis1ColorPalette;
                    var positiveX = 0, negativeX = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                    var positiveIndex = 0, negativeIndex = -1;
                    var yArray = [] ,xArray = [];
                    
                    // wrap a datashape g for each rect
                    var barShape = d3.select(this).selectAll('g.datashape').data(perAxisData);
                        barShape.enter().append('g').attr('class','datashape')
                        barShape.each(function(d){
                          var bar = d3.select(this).selectAll('rect').data([d]);
                          bar.enter().append('rect');
                          bar.exit().remove();
                        });
                        barShape.exit().remove();

                        
                        //transform for datashape
                        barShape.attr('transform', function (perRectData, k){
                            if(isHorizontal){
                              var y = height - rangeBounds[barGroupNumber - i - 1] ;
                              
                              var x;
                              if(perRectData.val >= 0){
                                
                                positiveX = valueScale(positiveStackedValue);
                                positiveStackedValue += perRectData.val;
                                x = positiveX;
                               }else{
                                negativeStackedValue += perRectData.val;
                                negativeX = valueScale(negativeStackedValue);
                               
                                x = negativeX;
                               }
                            }
                            //for vertical valueScale has been reversed.
                            else{
                              var x = rangeBounds[i];

                              var y ;
                              if(perRectData.val >= 0){
                                positiveStackedValue += perRectData.val;
                                positiveY = valueScale(positiveStackedValue);
                                
                                y = positiveY;
                               }else{
                                
                                negativeY = valueScale(negativeStackedValue);
                                negativeStackedValue += perRectData.val;
                                y = negativeY;
                               }
                            }
                             return 'translate('+x+','+y+')';
                          });
                        var bar = d3.select(this).selectAll('rect');
                    
                        if(isHorizontal){
                          bar.attr('width', function(perRectData, m){
                           return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                          .attr('x', 0)
                          .attr('height',function(perRectData , m){
                            var h = rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            if(h > 1){
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] - 1;
                            }else{
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            }})
                          .attr('y', 0)
                          .attr('fill', function(d,colorIndex){  
                            d.fillColor = fillingColor[colorIndex % fillingColor.length];
                            var parameter = {
                              drawingEffect:drawingEffect,
                              fillColor : d.fillColor,
                              direction : 'vertical'
                            };
                          return effectManager.register(parameter);
                           })
                           .attr('class', 'datapoint').attr('fill-opacity', 1);
                            //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            bar.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var roudCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                                                .append('rect').attr('class', 'roundCorner-clip')
                                                                .attr('rx', r).attr('ry', r)
                                                                .attr('x',function(){
                                                                  if(indexinGroup === negativeIndexes[j][i] ){
                                                                    return 0;
                                                                  }else{
                                                                    return 0 -r;
                                                                  }
                                                                })
                                                                .attr('width',function(){
                                                                  return Math.abs(valueScale(perRectData.val) -  valueScale(0)) + r;
                                                                })
                                                                .attr('height', barFinalHeight).attr('y', 0);
                                return 'url(#' + id + ')';
                              }
                            });
                          }

                         }
                         else{
                          bar.attr('height', function(perRectData, m){
                           return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                          .attr('x', 0)
                          .attr('width',function(perRectData , m){
                            var w = rangeBounds[i + 1]- rangeBounds[i];
                            if(w > 1){
                              return rangeBounds[i + 1]- rangeBounds[i] - 1;
                            }else{
                              return rangeBounds[i + 1]- rangeBounds[i];
                            }
                          })
                          .attr('y', 0)
                          .attr('fill', function(d,colorIndex){  
                            d.fillColor = fillingColor[colorIndex % fillingColor.length];
                            var parameter = {
                              drawingEffect:drawingEffect,
                              fillColor : d.fillColor,
                              direction : 'horizontal'
                            };
                          return effectManager.register(parameter);
                           })
                           .attr('class', 'datapoint').attr('fill-opacity', 1);
                            //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            bar.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var roudCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                                                .append('rect').attr('class', 'roundCorner-clip')
                                                                .attr('rx', r).attr('ry', r)
                                                                .attr('y',function(){
                                                                  if(indexinGroup === negativeIndexes[j][i] ){
                                                                    return 0 - r;
                                                                  }else{
                                                                    return 0 ;
                                                                  }
                                                                })
                                                                .attr('height',function(){
                                                                  return Math.abs(valueScale(perRectData.val) -  valueScale(0)) + r;
                                                                })
                                                                .attr('width', barFinalHeight).attr('x', 0);
                                return 'url(#' + id + ')';
                              }
                            });
                          }
                         }
                      });
                    axisGroup.exit().remove();
                  });        
                barGroup.exit().remove();
            }
            
            sizeChange = false, dataValueChange = false, dataStructureChange = false;
            });
            
            if(!enableDataLoadingAnimation || !enableDataUpdatingAnimation){
              initialized();
            }
            
            return chart;
          }
        
        chart.hoverOnPoint = function(point){
          var xOnModule = point.x, yOnModule = point.y;
          // find the closet dimension
          var i = 0, len = rangeBounds.length -1, currentBound = 0;
          if(isHorizontal){
            while (i < len ) {
              if (yOnModule >= (height - rangeBounds[i]) && yOnModule < (height - rangeBounds[i+1])) {
                currentBound = rangeBounds[i] - rangeBounds[i+1];
                break;
              };
              i++;
            }
          }else{
            while (i < len ) {
              if (xOnModule >= (rangeBounds[i]) && xOnModule < (rangeBounds[i+1])) {
                currentBound = rangeBounds[i+1] - rangeBounds[i];
                break;
              };
              i++;
            }
          }
          if (i > (seriesData.length - 1) || i < 0) {
            decorativeShape.attr(
                'visibility', 'hidden');
            return;
          }
          
          if(isHorizontal){
            decorativeShape.attr(
              'y', height - rangeBounds[i]).attr(
              'visibility', 'visible').attr('height', currentBound);
          }else{
            decorativeShape.attr(
              'x', rangeBounds[i]).attr(
              'visibility', 'visible').attr('width', currentBound);
          }
          if(i !== lastHovered){
            if (tooltipVisible) {
              lastHovered = i;
              //this.parentNode.parentNode.parentNode point to the main container
              var transform = gWrapper[0][0].getTransformToElement(gWrapper[0][0].ownerSVGElement);
              var yoffset = transform.f;
              var xoffset = transform.e;
              var tData = isHorizontal? generateTooltipData(barGroupNumber - i -1): generateTooltipData(i);
              
              tData.point = {
                  x: isHorizontal? d3.event.layerX : rangeBounds[i] + currentBound/2 + xoffset,
                  y: isHorizontal? height - rangeBounds[i] + currentBound/2 + yoffset: d3.event.layerY
              };
              tData.plotArea = {
                x : transform.e,
                y : transform.f,
                width : width,
                height : height
              };
              tData.valueAxis0Count = seriesData[0][0].length;
              tData.valueAxis1Count = TypeUtils.isExist(seriesData[0][1]) ? seriesData[0][1].length:0;
              eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
            }
          }
        };
        
        var generateTooltipData = function(aai1){
        var tData = {
          'body' : [],
          'footer' : []
        };
        var a0data = data.getAnalysisAxisDataByIdx(0).values;

        var g0data = data.getMeasureValuesGroupDataByIdx(0).values;
        var g1data = data.getMeasureValuesGroupDataByIdx(1).values;
        // have two analysis
        if( TypeUtils.isExist(data.getAnalysisAxisDataByIdx(1)) ){
          var a1data = data.getAnalysisAxisDataByIdx(1).values;
        }
        //make up body data
        var elemcount = tooltipData[0][0].length;
        
        for(var i = 0, ilen = g0data.length; i < ilen; i++){
          var tbody = {}, rows = [];
          tbody.name = g0data[i].col;
          tbody.val = rows;
          for(var j = 0; j < elemcount; j++){
            var label = '';
            if(TypeUtils.isExist(a1data)){
              for(var t = 0, tlen = a1data.length;  t < tlen; t++){
                if(t === 0){
                  label += a1data[t].rows[j].val;
                }else{
                  label += ' / ' + a1data[t].rows[j].val;
                }
                
              }
            }
            rows.push({
              value: tooltipData[aai1][0][j].isNaN ? defaultString : tooltipData[aai1][0][j].val,  
              label: label,
              shape: 'squareWithRadius',
              color: colorPalette[j]
            });
          }
          
          tData.body.push(tbody);
        }


      //make up body data
        //from d1data
        var tbody = {}, rows = [];
        tbody.name = g1data[0].col;
        tbody.val = rows;
        rows.push({
          value:TypeUtils.isExist( rangeSum[aai1] ) ? rangeSum[aai1] : defaultString,
          valueAxis: 1
        });
        tData.body.push(tbody);
      
      //from a0data
      for(var i =0, len = a0data.length; i < len; i++){
        var footer = {};
        footer.label = a0data[i].col.val;
        footer.value = a0data[i].rows[aai1].val;
        
        tData.footer.push(footer);
      }
        
      return tData;
      };
        


        chart.blurOut = function(){
          decorativeShape.attr('visibility', 'hidden');
          lastHovered = null;
          if (tooltipVisible) {      
            eDispatch.hideTooltip();
          }
        };
        
        chart.parent = function(){
          return gWrapper;
        };
        
        chart.highlight = function(elems){
          if(elems instanceof Array){
            for(var i = 0, len = elems.length; i < len; i++){
              elems[i].setAttribute('fill-opacity', 1);
            }
          }else{
            elems.setAttribute('fill-opacity', 1);
          }
        };
        
        chart.unhighlight = function(elems){
          if(elems instanceof Array){
            for(var i = 0, len = elems.length; i < len; i++){
              elems[i].setAttribute('fill-opacity', 0.2);
            }
          }else{
            elems.setAttribute('fill-opacity', 0.2);
          }
        };
        
        chart.clear = function(gray){
          if( gray == null){
            gWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
          }else{
            gWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
          }
        };
        
          function turnToPercentage(){
            for(var i=0, len = seriesData.length; i < len; i++){
              for(var j=0 , rowSeriesData = seriesData[i], rowTooltipData = tooltipData[i]; j < rowSeriesData.length; j++){
                var sum = 0, avaCount = 0, k;
                for(k=0; k < rowSeriesData[j].length; k++){
                  sum += Math.abs(rowSeriesData[j][k].val);
                  if(!rowSeriesData[j][k].isNaN) {
                    avaCount++;
                  }
                }
                if(sum === 0){

                  for(k=0; k < rowSeriesData[j].length; k++){
                          rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                          rowSeriesData[j][k].val = rowSeriesData[j][k].isNaN? 0:1/avaCount ;
                          if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                            rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : 1/avaCount;
                          }
                  }
                }else{
                  for(k=0; k < rowSeriesData[j].length; k++){
                        if(rowSeriesData[j][k].val < 0){
                          rowSeriesData[j][k].isNegative = true;
                        }
                        rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                        rowSeriesData[j][k].val = Math.abs(rowSeriesData[j][k].val/sum);
                        if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                          rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : rowTooltipData[j][k].val/sum;
                        }
                  }
                }
                
              }
            }
        }
        function turnToComparison(){
          var obj = ObjectUtils.extend(true, {}, MNDHandler(data));
                   
          var _data1 = obj["MG1"];
          var _data2 = obj["MG2"];
          measureOnAxis1 = obj.MG1Number;
          tooltipData = [];
          
          var _seriesData = dataHandler(_data1, null, obj.color);
           
          
          seriesData = _seriesData;
          data1 = _data1;
          data2 = _data2;
          
          tooltipData = ObjectUtils.extend(true, {}, seriesData); 
        }

        function initialized(){
            eDispatch.initialized();
            afterAttachToDOM = true;

        }
        
        chart.afterUIComponentAppear = function(){
          eDispatch.initialized(); 
        };
        
        
        
        /**
        * set/get width
        */
        chart.width = function(value){
            if (!arguments.length){
              return width;
            }
            sizeChange = (width === value)&&!sizeChange? false:true;
            width = value;
        
            makeScales();
          
            return chart;
        };

        /**
        * set/get height
        */
        chart.height = function(value){
          if (!arguments.length){
            return height;
           }
          sizeChange = (height === value)&&!sizeChange? false:true;
          height = value;
        
            makeScales();
          
           return chart;        
        };
        /**
         * set/get data, for some modules like Title, it doesn't need data
         */
        chart.data = function(value){
          if (!arguments.length){
            return data;
          }

          data = value;
          var obj = ObjectUtils.extend(true, {}, MNDHandler(data));
                   
          var _data1 = obj["MG1"];
          var _data2 = obj["MG2"];
          measureOnAxis1 = obj.MG1Number;
          tooltipData = [];
          
          var _seriesData = dataHandler(_data1, null, obj.color);
          
          if(data1.length !== _data1.length || data1[0].length !== _data1[0].length){
              dataStructureChange = true;
          }else{
            dataValueChange = true;
          }
          
          seriesData = _seriesData;
          data1 = _data1;
          data2 = _data2;
          
      tooltipData = ObjectUtils.extend(true, {}, seriesData); 
          
          
        
      makeScales();
          
        
        parseOptions();
        
        return chart;        
      };


      /**
       * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
            return properties;
         }
         
          Objects.extend(true, properties, props);
          parseOptions();
          
          makeScales();
          
          return chart;        
      };
         
      //adjust domain and rangebouds, for all no_value or zero value
      var adjustScale = function( rangeBounds){
        for(var i = 0; i< rangeBounds.length ;i++){
          if(!NumberUtils.isNoValue(rangeBounds[i]) && rangeBounds[i] != 0 )
            return;
        }

        for(var i = 1; i< rangeBounds.length ;i++){
            rangeBounds[i] = i*(isHorizontal? height / (rangeBounds.length -1) : width /(rangeBounds.length -1));
        }
      }
      var makeScales = function(){
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
            var domain = [], total = 0, tempsum = 0;
            rangeBounds = [], rangeSum = [],  rangeBounds[0] = 0;
            var rows = dimensionData['sap.viz.modules.mekko.dimension'].values[0].rows = [];
            dimensionData['sap.viz.modules.mekko.dimension'].values[0].col.val = data.getMeasureValuesGroupDataByIdx(1).values[0].col;
            for (var i=0, len = data2.length; i < len; i++){
              for(var j = 0; j< data2[i].length; j++){
                
                if(TypeUtils.isExist(rangeSum[j])){
                  rangeSum[j] += data2[i][j].val;
                }
                else{
                  rangeSum[j] = data2[i][j].val;
                }
              }
            }
            for (var i = 0 ,len = rangeSum.length; i < len; i++){
              domain.push(i);
              total += rangeSum[i] > 0? rangeSum[i] : (0 - rangeSum[i]);
            }  
            for(var j =0, len = rangeSum.length; tempsum += Math.abs(rangeSum[j]), j<len; j++){
              tempsum = parseFloat(tempsum.toFixed(8));
              rangeBounds[j+1] = total==0? null : Math.abs(isHorizontal? tempsum/total*height : tempsum/total*width);
              rows.push({
                val : TypeUtils.isExist( rangeSum[j] ) ? rangeSum[j] : defaultString
              });
            }
            //adjust domain and rangebouds, for all no_value or zero value
            adjustScale(rangeBounds);
            //if is horizontal we need to reverse the categoryScale, otherwise we need to reverse the valueScale
            if(isHorizontal){
              
              categoryScale.domain(domain).range(rangeBounds.reverse());
              if(mode === 'percentage'){                
                valueScale.domain([0,1]).range([0, width]).nice();
                Scaler.perfect(valueScale);
              }else{
                //when all data is 0 or null, we make domain (0,1)
                if( primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
                  valueScale.domain([0,1]).range([0, width]).nice();
                }else{
                  valueScale.domain([primaryAxisBottomBoundary,primaryAxisTopBoundary]).range([0, width]).nice();
                }
                Scaler.perfect(valueScale);
              }
            }else{
              categoryScale.domain(domain).range(rangeBounds);
              if(mode === 'percentage'){
                valueScale.domain([1,0]).range([0, height]).nice();
                Scaler.perfect(valueScale);
              }else{
                if( primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
                  valueScale.domain([1, 0]).range([0, height]).nice();                 
                }else{
                  valueScale.domain([primaryAxisTopBoundary, primaryAxisBottomBoundary]).range([0, height]).nice();
                }
                Scaler.perfect(valueScale);
              }
            }
          }
        
        };

      chart.colorPalette = function(Palette){
          if (!arguments.length){
            return colorPalette;
         }
          colorPalette = Palette;
         return chart;        
      };

      chart.categoryScale = function(scale){
          if (!arguments.length){
            return categoryScale;
         }
          categoryScale = scale;
         return chart;
      };
      
      chart.dimensionData = function(_){
        if(!arguments.length){
          return dimensionData;
        }
        dimensionData = _;
        return chart;
      };
      
      chart.secondCategoryScale = function(){
        if(!arguments.length){
          return categoryScale;
        }
        categoryScale = _;
        return chart;
      };
      
      chart.primaryDataRange = function(range){
        if (!arguments.length){
          var maxt, mint;
          if(mode === 'percentage'){
            maxt = 1;
            mint = 0;
          }else{
            mint = primaryAxisBottomBoundary < 0 ? primaryAxisBottomBoundary : 0;
            maxt = primaryAxisTopBoundary;
          }
          return {
            min: mint,
            max: maxt
          };
        }
        primaryAxisTopBoundary = range.max;
        primaryAxisBottomBoundary = range.min;
        
        makeScales();
        
        return chart;
      };
        
      chart.secondDataRange = function(range){
        if (!arguments.length){
          var maxt, mint;
          if(mode === 'percentage'){
            maxt = 1;
            mint = 0;
          }else{
            mint = secondaryAxisBottomBoundary< 0 ? secondaryAxisBottomBoundary : 0 ;
            maxt = secondaryAxisTopBoundary;
          }
          return {
            min: mint,
            max: maxt
          };
        }
        secondaryAxisTopBoundary = range.max;
        secondaryAxisBottomBoundary = range.min;
        
        makeScales();
        
        return chart;
      }; 
         
      chart.primaryScale = function(scale){
          if (!arguments.length){
            return valueScale;
         }
          valueScale = scale;
         return chart;
      };       

        chart.primaryAxisColor = function(){
            //as in mekko, it does not has MND feed, so always return undefined.
            return undefined;
        };        
          
        /**
        * get preferred size
        * @return {
            'width': NUMBER,
            'height' : NUMBER
          }
        */
        chart.getPreferredSize = function(){
          
        };
       
        chart.x = function(_){
          if(!arguments.length){
            return x;
          }
          x= _;
          return this;
        };
        
        chart.y = function(_){
          if(!arguments.length){
            return y;
          }
          y = _;
          return this;
        };
        
        chart.dispatch = function(_){
          if(!arguments.length){
            return eDispatch;
          }
          eDispatch = _;
          return this;
        };
        
        chart.dataLabel = function(_){};
        
        chart.primaryAxisTitle = function(_){
          if(!arguments.length){
            var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
            if(titles){
              for(var i=0, len =titles.values.length; i< len;i++ ){
                  if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                  {
                      title.push(titles.values[i].col);
                  }
                  else
                  {
                      title.push(langManager.get('IDS_ISNOVALUE'));
                  }
              }
            }
            return title.join('/');
          }
          return this;
        };
        
        chart.secondAxisTitle = function(_){
          if(!arguments.length){
            var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
            if(titles){
              for(var i=0, len =titles.values.length; i< len;i++ ){
                  if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                  {
                      title.push(titles.values[i].col);
                  }
                  else
                  {
                      title.push(langManager.get('IDS_ISNOVALUE'));
                  }
              }
            }
            return title.join('/');
          }
          return this;
        };
        
        var dataHandler = function(valueAxis1Data, valueAxis2Data, colorIndexArray){
          
          var positiveIndex = -1, negativeIndex = -1;
          positiveIndexes = [[],[]], negativeIndexes = [[],[]];
        
          primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
          secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
          
          var stackedBarGroupsData = [];
          // the number of bar in each group
          barGroupNumber =  valueAxis1Data[0].length;

          var temp, temp2;
          for(var j=0; j < barGroupNumber; j++){
            var tempDataSetAxis1 = [], tempDataSetAxis2 = [];
            var oneGroupDataSet = [];
            temp = 0, temp2 = 0;
            positiveIndex = -1, negativeIndex = -1;
            for(var i=0; i< valueAxis1Data.length; i++){
              if(NumberUtils.isNoValue(valueAxis1Data[i][j].val)){
                valueAxis1Data[i][j].val = 0;
                valueAxis1Data[i][j].isNaN = true;
              }else{

                if(valueAxis1Data[i][j].val >= 0){
                  temp += valueAxis1Data[i][j].val;
                  positiveIndex = i;
                }else{
                  temp2 += valueAxis1Data[i][j].val;
                  negativeIndex = i;
                }
              }
            tempDataSetAxis1.push(valueAxis1Data[i][j]);
          }
          positiveIndexes[0].push(positiveIndex);
          negativeIndexes[0].push(negativeIndex);
          
          if(primaryAxisTopBoundary < temp){
            primaryAxisTopBoundary = temp;
          }
          if(primaryAxisBottomBoundary > temp2){
            primaryAxisBottomBoundary = temp2;
          }
          oneGroupDataSet.push(tempDataSetAxis1);
          
          
          if(TypeUtils.isExist(valueAxis2Data)){
            temp = 0, temp2 = 0;
            positiveIndex = -1, negativeIndex = -1;
            for(i=0; i< valueAxis2Data.length; i++){
              positiveIndex = 0, negativeIndex = -1;
              if(NumberUtils.isNoValue(valueAxis2Data[i][j].val)){
                valueAxis2Data[i][j].val = 0;
                valueAxis2Data[i][j].isNaN = true;
              }else{

                if(valueAxis2Data[i][j].val >= 0){
                  temp += valueAxis2Data[i][j].val;
                  positiveIndex = i;
                }else{
                  temp2 += valueAxis2Data[i][j].val;
                  negativeIndex = i;
                }
              }
              tempDataSetAxis2.push(valueAxis2Data[i][j]);
            }
            positiveIndexes[1].push(positiveIndex);
            negativeIndexes[1].push(negativeIndex);
            
            if(secondaryAxisTopBoundary < temp){
              secondaryAxisTopBoundary = temp;
            }
            if(secondaryAxisBottomBoundary > temp2){
              secondaryAxisBottomBoundary = temp2;
            }
            oneGroupDataSet.push(tempDataSetAxis2);
          }
          stackedBarGroupsData.push(oneGroupDataSet);
        }
          
          return stackedBarGroupsData;
        };
      
        properties = manifest.props(null);
        return chart;
    };
    return mekko;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Mekko',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.mekko',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
	/**
	 * Mekko chart's feed defination is similar with bar chart. It accept a dimension axis and two measure value axis like dual bar chart.
	 */
  var module = {
    'id' : 'sap.viz.modules.mekko',
    'name' : 'mekko',
    base : "sap.viz.modules.xy.bar.base",
    'properties' : {
    	'mode' : {
            'name' : 'mode',
            'supportedValueType' : 'List',
            'supportedValues' : [ 'comparison', 'percentage' ],
            'defaultValue' : 'comparison',
            'description' : 'Set dispaly mode of mekko chart.'
          },
          'orientation' : {
            'name' : 'orientation',
            'supportedValueType' : 'List',
            'supportedValues' : [ 'vertical', 'horizontal' ],
            'defaultValue' : 'horizontal',
            'description' : 'vertical or horizontal mekko chart.'
          },
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/bar',
      name : 'IDS_BARCHART',
      base : 'riv/basehorizontalchart',
      modules : {
          main : {
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction',
                    properties : {
                      supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                    }
                  }
                }
              },
              modules : {
                plot : {
                    id : 'sap.viz.modules.bar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              }
          }
      },
      feeds:{
        secondaryValues:  null
      },
     dependencies : {
        attributes : [ {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.xAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ],
        events : [ {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        }, 
        {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        },{
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
        }, {
          targetModule : 'legend',
          listener : 'deselectLegend',
          sourceModule : 'main.interaction',
          type : 'deselectLegend'
        }, {
          targetModule : 'main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'main.plot',
          type : 'startToInit.datalabel'
        }]
      }      
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalMekkoChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Mekko',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/horizontal_mekko',
    name : 'IDS_HORIZONTALMEKKOCHART',
    base : 'viz/bar',
      modules : {
          main : {
              modules : {
        dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      isStackMode : true,
                      showZero : false
                    },
                    propertiesOverride:{
                      position : {
                        isExported : false
                      }
                    }
                  }
                },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                        
                        mode: {
                          isExported: false
                        },
                        orientation: {
                          isExported: false
                        }
                     }
                  }
                },
                xAxis:{
                      id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                    }
                },
                yAxis : {
                   id : 'sap.viz.modules.axis',
                   configure : {
                     properties:{
                       type : 'category',
                             position : 'left',
                             label:{
                               hideStrategy : 'greedy'
                             }
                     }
                   }
                },
                yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'yAxis2',
                        properties : {
                          isIndependentMode : true,
                            type : 'category',
                            position : 'right',
                            gridline : {
                                visible : false
                            },                          
                            label:{
                              hideStrategy : 'greedy'
                            }
                  
                        },
                        propertiesOverride:{
                          gridline: {
                              isExported: false
                            },
                            axisline: {
                              isExported: false
                            },
                            label:{
                              numberFormat:{
                                isExported: false
                              }
                            }
                         }
                    }
                }
         
              }
          },
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : {
                chartType : 'mekko',
                orientation : 'left'
              }
            }
        }
      },
    feeds:{
    secondaryValues: {
      min : 1,
      max : 1
    },
    primaryValues : {
       min : 1,
         max : 1
    },
    regionColor :{
      min: 0,
      max: 1,
      acceptMND: -1
    },
    axisLabels :{
      min: 1,
      max: 1,
      acceptMND: -1
    }
    },
      dependencies : {
        attributes : [ {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.yAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondCategoryScale'
        }, {
          targetModule : 'main.xAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'main.xAxis',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'primaryAxisTitle'
    }, {
      targetModule : 'main.yAxis2',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'secondAxisTitle'
    },{
        targetModule : 'main.yAxis2',
        target : 'independentData',
        sourceModule : 'main.plot',
        source : 'dimensionData'
    }, {
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageHorizontalMekkoChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalMekkoChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_horizontal_mekko',
    name : 'IDS_PERCENTAGEHORIZONTALMEKKOCHART',
    base : 'viz/horizontal_mekko',
      modules : {
      
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'mekko',
                  formatString: [["0.00%"],[""]]
                }
              }
          },
          main : {
              modules : {
                dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        isPercentMode: true
                      }
                    }
                  },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                    properties : {
                        mode: 'percentage'
                      },
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                        
                        mode: {
                          isExported: false
                        },
                        orientation: {
                            isExported: false
                          }
                     }
                  }
                },
                xAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        isPercentMode : true
                      }
                    }
                  }
              }
            }
          }
      };


  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/column',
      name : 'IDS_VERTICALBARCHART',
      base : 'riv/baseverticalchart',
      modules : {
          main : {
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction',
          properties : {}
                  }
                }
              },      
              modules : {
                plot : {
                    id : 'sap.viz.modules.verticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              }
          }
      },
      feeds:{
        secondaryValues:  null
      },
      dependencies : {
        attributes : [ {
          targetModule : 'main.plot',
          target : 'primaryDataRange',
          sourceModule : 'main.yAxis',
          source : 'range'
        }, {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.yAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'main.yAxis',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'primaryAxisTitle'
    },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
        } ],
         events : [ {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
      }, {
            targetModule : 'legend',
          listener : 'deselectLegend',
          sourceModule : 'main.interaction',
          type : 'deselectLegend'
      }, {
        targetModule : 'main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'main.plot',
        type : 'startToInit.datalabel'
      }]
      }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.MekkoChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Mekko',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/mekko',
    name : 'IDS_MEKKOCHART',
    base : 'viz/column',
      modules : {
          main : {
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      isStackMode : true,
                      showZero : false
                    },
                    propertiesOverride:{
                      position : {
                        isExported : false
                      }
                    }
                  }
                },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                    properties : {
                        orientation: 'vertical'
                      },
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                        
                        mode: {
                          isExported: false
                        },
                        orientation: {
                          isExported: false
                        }
                     }
                  }
                },
                yAxis:{
                      id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                      properties:{
                        position : 'left'
                      }
                    }
                },
                xAxis : {
                   id : 'sap.viz.modules.axis',
                   configure : {
                     properties:{
                       type : 'category',
                             position : 'bottom',
                             label:{
                               hideStrategy : 'greedy'
                             }
                     }
                   }
                },
                xAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'xAxis2',
                        properties : {
                          isIndependentMode : true,
                            type : 'category',
                            position : 'top',
                            gridline : {
                                visible : false
                            },                          
                            label:{
                              hideStrategy : 'greedy'
                            }
                  
                        },
                        propertiesOverride:{
                          gridline: {
                              isExported: false
                            },
                            axisline: {
                              isExported: false
                            },
                            label:{
                              numberFormat:{
                                isExported: false
                              }
                            }
                         }
                    }
                }
         
              }
          },
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'mekko',
                  orientation : 'bottom'
                }
              }
          }
          
      
      },
    feeds:{
    secondaryValues: {
      min : 1,
      max : 1
    },
    primaryValues : {
       min : 1,
         max : 1
    },
    regionColor :{
      min: 0,
      max: 1,
      acceptMND: -1
    },
    axisLabels :{
      min: 1,
      max: 1,
      acceptMND: -1
    }
    },
      dependencies : {
        attributes : [ {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.xAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondCategoryScale'
        }, {
          targetModule : 'main.yAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'main.yAxis',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'primaryAxisTitle'
    }, {
      targetModule : 'main.xAxis2',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'secondAxisTitle'
    },{
        targetModule : 'main.xAxis2',
        target : 'independentData',
        sourceModule : 'main.plot',
        source : 'dimensionData'
    }, {
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageMekkoChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.MekkoChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_mekko',
    name : 'IDS_PERCENTAGEMEKKOCHART',
    base : 'viz/mekko',
      modules : {
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  formatString: [["0.00%"],[""]]
                }
              }
          },
          main : {
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode: true
                    }
                  }
                },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                    properties : {
                        mode: 'percentage'
                      },
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                       
                        mode: {
                          isExported: false
                        },
                        orientation: {
                            isExported: false
                          }
                     }
                  }
                },
                yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        isPercentMode : true
                      }
                    }
                  }
              }
            }
          }
      };


  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.HorizontalBoxplot',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.horizontalboxplot',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.horizontalboxplot',
    'name' : 'horizontal boxplot',
    base : "sap.viz.modules.xy.base",
    'properties' : { 
          'primaryValuesColorPalette' : null,
          'secondaryValuesColorPalette' : null,
          'tooltip' : {
            'name' : 'tooltip',
            'supportedValueType' : 'Object',
            'supportedValues' : {
              'enabled' : {
                'name' : 'enabled',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set enabled/disabled tooltip.'
              }
            },
            'isExported' : false,
            'description' : 'Settings for tooltip related properties.'
          }
    },
    'feeds' : {
      configure : {
          secondaryValues:null,
          axisLabels:{
          acceptMND: -1,
          min : 1,
          max : 1
        }
    }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalBoxplotChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalBoxplot',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/horizontal_boxplot',
      name : 'IDS_HORIZONTALBOXPLOTCHART',
      base : 'riv/basehorizontalchart',
      modules : {
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'horizontalboxplot',
                  orientation : 'left'
                }
              }
          },
          main : {
              modules : {
                dataLabel:null,
                yAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                },
                plot : {
                    id : 'sap.viz.modules.horizontalboxplot',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              },
          controllers : {
              'interaction' : {
                    id : 'sap.viz.modules.controller.interaction',
                    configure : {
                          propertyCategory : 'interaction'
                    }
                }
        }
          }
      },

     dependencies : {
       attributes : [ {
         targetModule : 'main.yAxis',
         target : 'scale',
         sourceModule : 'main.plot',
         source : 'categoryScale'
          },{
            targetModule : 'main.xAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'primaryScale'
          },{
         targetModule : 'main.xAxis',
         target : 'title',
         sourceModule : 'main.plot',
         source : 'primaryAxisTitle'
          },{
              targetModule : 'main.yAxis',
              target : 'independentData',
              sourceModule : 'main.plot',
              source : 'dimensionData'
          },{
            targetModule : 'legend',
            target : 'colorPalette',
            sourceModule : 'main.plot',
            source : 'colorPalette'
          }, {
            targetModule : 'legend',
            target : 'setSelectionMode',
            sourceModule : 'main.interaction',
            source : 'getSelectionMode'
          } ],
           events : [ {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main.plot',
            type : 'initialized'
          }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
          }, {
          targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
        }
          ]
        }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.verticalboxplot',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, Scaler, NumberUtils, langManager,tooltipDataHandler, Objects, boundUtil) {
  var boxplot = function(manifest, ctx) {

    var sWrapper = null, 
      dimensionGroup = [], 
      dimensionDomain = [], 
      seriesData = [], 
      legendData = [], 
      regionData = [], 
      dimensionData = [], 
      boxplotData = [],
      colorPalette = [],
      boxColorPalette = [],
      _data = null; 
    var  dimensions = {
        'sap.viz.modules.verticalboxplot.dimension' : {
                'key' : 'sap.viz.modules.verticalboxplot.dimension',
                'values' : null
        }
      };

    var width = undefined, 
      height = undefined, 
      xScale = d3.scale.ordinal(), 
      yScale = d3.scale.linear(), 
      xDimensionScale = d3.scale.ordinal(),
      decorativeShape,
      boxWidth,
      lastHovered = null,
      tooltipVisible = true,
      scaleMinMax = {
          min: 0,
          max: 0
      },
      effectManager = ctx.effectManager,
      drawingEffect = 'normal',
      defaultString = langManager.get('IDS_ISNOVALUE');
    
        var _properties = {},
          eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    
    var outLierLayout = {
      width : '1',
      color : '#000000'
    };

    var quartileLayout = {
      width: '0',
      midLineColor: '#000000'
    };
    
    var lowOutLiersObj = [], highOutLiersObj = [], whiskersObj = [], lowWhiskerObj = [], highWhiskerObj = [], quartilesObj = [], outLiersObj = [];
    
    var makeScales = function() {
      var domain = [];
      for ( var i = 0; i < seriesData.length; i++) {
        domain.push(i);
      }
      //when all data is 0 or null ,we should make yScale.domain from 0 to 1
      xScale.domain(domain).rangeBands([0, width]);
      xDimensionScale.domain(dimensionDomain).rangeBands([0, width]);   
      if(!scaleMinMax || (scaleMinMax.min === 0 && scaleMinMax.max === 0)){
        yScale.domain([ 0, 1 ]).range([ height, 0 ]).nice();

      } else{
        yScale.domain([ scaleMinMax.min, scaleMinMax.max ]).range([ height, 0 ]).nice();

      }
      Scaler.perfect(yScale);

    };
    
    chart.dimensionData = function(_)
    {
      if (!arguments.length){
        return dimensions;
      }
      dimensions = _;
      return chart;    
    };
    
    function locateBoundary(data) {
      
      if (TypeUtils.isExist(data)) {
        length = data.length;
        var firstLoop = false;
        for (var i = 0; i < length; i++) {
          
          if (data[i].length > 0) {
            if (!firstLoop) {
              scaleMinMax = findMinMax(data[i]);
              firstLoop = true;
            } else {
              var tmp = findMinMax(data[i]);
              if (tmp) {
                if (tmp.min < scaleMinMax.min) {
                  scaleMinMax.min = tmp.min;
                }
                if (tmp.max > scaleMinMax.max) {
                  scaleMinMax.max = tmp.max;
                }
              }
              
            }
          }
        }
      }
      
    }
    
    function findMinMax(range) {
      var minMax = {min:0, max:0};
      if (TypeUtils.isExist(range)) {
        range.sort( function(aObj, bObj) { return aObj.val - bObj.val; });
        
        minMax = {min: range[0].val, max: range[range.length - 1].val};
      }
      return minMax;
    }

    function clearBoxData() {
      lowOutLiersObj = [];
      highOutLiersObj = [];
      whiskersObj = [];
      lowWhiskerObj = [];
      highWhiskerObj = [];
      quartilesObj = [];
      outLiersObj = [];
    }
    
    function clearGlobalData() {
      dimensionGroup = []; 
      dimensionDomain = []; 
      seriesData = []; 
      legendData = []; 
      regionData = []; 
      dimensionData = []; 
      boxplotData = []; 
    }

    function even(n) {
      return (n & 1) == 0;
    }

    function median(distribution, start, end) {
      var n = end - start + 1;
      if (n <= 0)
        return -1;

      var ret;
      var ctxValue = distribution[start + Math.floor((n + 1) / 2) - 1].ctx;

      if (even(n)) {
        ret = (distribution[start + Math.floor((n + 1) / 2) - 1].val + distribution[start
            + Math.floor((n + 1) / 2)].val) / 2;
      } else {
        ret = distribution[start + Math.floor((n + 1) / 2) - 1].val;
      }
      return {
        'ctx' : ctxValue,
        'val' : ret
      };
    }

    function setDistribution(distribution) {

      if (distribution && distribution.length > 0) {
        var n = distribution.length,
          box = {
            'Maximum:': null,
            '3rd Quartile:': null,
            'Median:': null,
            '1st Quartile:': null,
            'Minimum:': null  
          };
        
            midLine = median(distribution,  0,  n - 1);
            box['Median:'] = midLine;
            
          // Q1 is the median of the first half of the set; we add the median to
            // it if the whole set length is even
            var bak = distribution[Math.floor(n / 2)];
            distribution[Math.floor(n / 2)] = midLine;
            var boxBottom = median(distribution, 0, Math.floor(n / 2));
            distribution[Math.floor(n / 2)] = bak;
            
            // Q3 is the median of the second half of the set; we add the median to
            // it if the whole set length is even
            bak = distribution[Math.floor((n - 1) / 2)];
            distribution[Math.floor((n - 1) / 2)] = midLine;
            var boxTop  = median(distribution, Math.floor((n - 1) / 2), n - 1);
            distribution[Math.floor((n - 1) / 2)] = bak;
            box['3rd Quartile:'] = boxTop;
            box['1st Quartile:'] = boxBottom;
            
        // inter-quartile range
        var iqr = boxTop.val - boxBottom.val;
        // lower adjacent limit
        var lal = boxBottom.val - 1.5 * iqr;
        // upper adjacent limit
        var ual = boxTop.val + 1.5 * iqr;

        // search for the lowest non outlier
        var i = 0;
        while (distribution[i].val < lal)
          i++;
        lowWhisker = distribution[i];
        box['Minimum:'] = lowWhisker;

        if (lowWhisker) {
          if (boxBottom) {
            if (boxBottom.val != lowWhisker.val) {
              lowWhiskerObj.push({
                'pair' : [boxBottom, lowWhisker],
                'ctx' : [boxBottom.ctx, lowWhisker.ctx],
                'val' : [boxBottom.val, lowWhisker.val]
              });
            }
          }
        }

        // low outliers are all the values lower than lowest non outlier
        for ( var k = 0; k < i; k++)
          outLiersObj.push(distribution[k]);

        // search for the largest non outlier
        var j = n - 1;
        while (distribution[j].val > ual)
          j--;
        highWhisker = distribution[j];
        box['Maximum:'] = highWhisker;

        for ( var k = 0; k < n - j - 1; k++)
          outLiersObj.push(distribution[j + 1 + k]);

        if (outLiersObj.length > 0)
          box['outLiers(s)'] = outLiersObj.length;
        // if (lowWhiskerObj.length == 1) {
        // whiskersObj.push(lowWhiskerObj[0]);
        // }

        // if (highWhiskerObj.length == 1) {
        // whiskersObj.push(highWhiskerObj[0]);
        // }

        if (highWhisker) {
          if (boxTop) {
            if (boxTop.val != highWhisker.val) {
              highWhiskerObj.push({
                'pair' : [highWhisker, boxTop],
                'ctx' : [highWhisker.ctx, boxTop.ctx],
                'val' : [highWhisker.val, boxTop.val]
              });
            }
          }
        }

        if (boxBottom && boxTop && midLine) {
          if (boxBottom.val == boxTop.val) {
            quartilesObj.push({
              'pair' : [boxBottom, boxBottom],
              'midLine': null,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val]
            });
          } else if (midLine.val == boxTop.val || midLine.val == boxBottom.val) {
            quartilesObj.push({
              'pair' : [boxTop, boxBottom],
              'midLine': null,
              'ctx' : [boxTop.ctx, boxBottom.ctx],
              'val' : [boxTop.val, boxBottom.val]
            });
          } else {
            quartilesObj.push({
              'pair' : [boxTop, midLine],
              'midLine': midLine,
              'ctx' : [boxTop.ctx],
              'val' : [boxTop.val]
            });
            quartilesObj.push({
              'pair' : [midLine, boxBottom],
              'midLine': midLine,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val]
            });
          }
        }
        
        boxplotData.push(box);
      }
    }
      
    function chart(selection) { 
      
      selection.each(function() {
        
        boundUtil.drawBound(selection, width, height);
          
        boxNumber = 1, boxGroupNumber = seriesData.length, boxWidth = 8 * (xScale.rangeBand()) / (9 * boxNumber + 7);
  
          var svg = sWrapper = d3.select(this);
          svg.selectAll('g.box').remove();
          
          if(decorativeShape == null){
            decorativeShape = svg.append('rect').attr('width', xScale.rangeBand() - boxWidth/2).attr('height', height).style('visibility', 'hidden').attr('fill', 'rgba(133,133,133, 0.2)');
          }else{
            decorativeShape.attr('width', xScale.rangeBand() - boxWidth/2).attr('height',height).style('visibility', 'hidden');
          }
          
          var boxGroup = svg.selectAll('g.box').data(seriesData);

          boxGroup.enter().append('g');
        boxGroup.attr('class', 'box').each( function(boxData, outerIndex) {
              
            if (boxData.length == 0) {
              boxplotData.push({});
              return;
            }
            
            boxData = boxData.sort(function(aObj, bObj) { return aObj.val - bObj.val; });
    
                var arrLength = boxData.length, min = boxData[0], max = boxData[arrLength - 1];
    
                setDistribution(boxData);
    
                var outLiersSelector = d3.select(this).selectAll('circle.outliers').data(outLiersObj);
                outLiersSelector.enter().append('circle');
                outLiersSelector.attr('cx', function(outLier) {
                  var x = xScale(outerIndex) + boxWidth;
                  return x;
                })
                .attr('cy', function(outLier, num) {
                  var y = yScale(outLier.val);
                  return y;
                })
                .attr('r', '2')
                //.attr('shape-rendering', 'crispEdges')
                .attr('stroke', effectManager.register(
                                                    {
                                                  drawingEffect : 'normal',
                                                  fillColor : outLierLayout.color
                                                }
                                                      )
             )
                .attr('stroke-width', outLierLayout.width)
                .attr('fill', 'none')
                .attr('class', 'datapoint outliers');
                
                outLiersSelector.exit().remove();

                var quartileSelector = d3.select(this).selectAll('rect.quartile').data(quartilesObj);
                quartileSelector.enter().append('rect');
                quartileSelector.attr('x', function(quartile) {
                  var x = xScale(outerIndex) + boxWidth / 2;
                  return x;
                })
                .attr('y', function(quartile, num) {
                  var y = yScale(quartile.pair[0].val);
                  return y;
  
                })
                .attr('width', boxWidth)
                .attr('height', function(quartile, num) {
                  var height = 0;
                  var pairDiff = quartile.pair[1].val - quartile.pair[0].val;
                  if (pairDiff == 0) {
                    height = 1;
                  } else {
                    height = yScale(quartile.pair[1].val) - yScale(quartile.pair[0].val);
                  }
  
                  return height;
                })
                .attr('shape-rendering', 'crispEdges')
                .attr( 'fill', function(d){
                  var parameter = {
                      drawingEffect : drawingEffect,
                      fillColor : boxColorPalette[outerIndex % boxColorPalette.length],
                      direction : 'horizontal'
                    };
            return effectManager.register(parameter);   
                })
                .attr('stroke-width', quartileLayout.width)
                //.attr('stroke', '#000000')
                .attr('class', 'datapoint quartile');
                
                if (quartilesObj.length == 2) {
                  var midLineXStart = xScale(outerIndex) + boxWidth / 2;
                  var midLineXEnd = midLineXStart + boxWidth;
                  var midLineYStart = midLineYEnd = yScale(quartilesObj[0].midLine.val);
                  var lineSelector = d3.select(this);
                    lineSelector.append('line')
                    .attr('x1', midLineXStart)
                    .attr('y1', midLineYStart)
                    .attr('x2', midLineXEnd)
                    .attr('y2', midLineYEnd)
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'midline');
                }
                
                quartileSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.rectlowwhisker').data(lowWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector.attr('x', function(whisker) {
                  var x = xScale(outerIndex) + boxWidth / 2;
                  horizontalLineXStart = x;
                  horizontalLineXEnd = x + boxWidth;
                  verticalLineXStart = verticalLineXEnd = x + boxWidth / 2;
                  return x;
                  })
                  .attr('y', function(whisker) {
                    var tmpPair = whisker.pair;
                    var y = yScale(tmpPair[0].val);
                    verticalLineYStart = y;
                    horizontalLineYStart = horizontalLineYEnd = yScale(tmpPair[1].val);
                    return y;
                  })
                  .attr('width', boxWidth)
                  .attr('height', function(whisker) {
                    var height = yScale(whisker.pair[1].val) - yScale(whisker.pair[0].val);
                    verticalLineYEnd = yScale(whisker.pair[1].val);
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', verticalLineXStart)
                    .attr('y1', verticalLineYStart)
                    .attr('x2', verticalLineXEnd)
                    .attr('y2', verticalLineYEnd)
                    .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'lineverticallowwhisker');
                    
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', horizontalLineXStart)
                    .attr('y1', horizontalLineYStart)
                    .attr('x2', horizontalLineXEnd)
                    .attr('y2', horizontalLineYEnd)
                    .attr('stroke', function(d){
                          var parameter = {
                         drawingEffect : 'normal',
                         fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                        };
                                   return effectManager.register(parameter);  
                                }
                         )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'linehorizontallowwhisker');
                    return height;
                    })
                  .attr('shape-rendering', 'crispEdges')
                  .attr('fill-opacity', '0')
                  .attr('stroke-width', '0')
                  .attr('class', 'datapoint rectlowwhisker');
                
                whiskerSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.recthighwhisker').data(highWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector
                    .attr('x', function(whisker) {
                      var x = xScale(outerIndex) + boxWidth / 2;
                      horizontalLineXStart = x;
                      horizontalLineXEnd = x + boxWidth;
                      verticalLineXStart = verticalLineXEnd = x + boxWidth / 2;
                      return x;
                      })
                    .attr('y', function(whisker, num) {
                      var tmpPair = whisker.pair;
                      var y = yScale(tmpPair[0].val);
                      verticalLineYStart = y;
                      horizontalLineYStart = horizontalLineYEnd = yScale(tmpPair[0].val);
                      return y;
                      })
                    .attr('width', boxWidth)
                    .attr('height', function(whiskersObj, num) {
                      var height = yScale(whiskersObj.pair[1].val) - yScale(whiskersObj.pair[0].val);
                      verticalLineYEnd = verticalLineYStart + height;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'lineverticalhighwhisker');
  
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', horizontalLineXStart)
                      .attr('y1', horizontalLineYStart)
                      .attr('x2', horizontalLineXEnd)
                      .attr('y2', horizontalLineYEnd)
                      .attr('stroke', function(d){
                            var parameter = {
                         drawingEffect : 'normal',
                         fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                        };
                                   return effectManager.register(parameter);  
                                }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'linehorizontalhighwhisker');
                       
                      return height;
                      })
                    .attr('shape-rendering', 'crispEdges')
                    .attr('fill-opacity', '0')
                    .attr('stroke-width', '0')
                    .attr('class', 'datapoint recthighwhisker');
                
                whiskerSelector.exit().remove();
                
                clearBoxData();
          eDispatch.initialized();
          
          });  
          boxGroup.exit().remove();
      });
    return chart;
    };
  
    chart.width = function(value) {
      if (!arguments.length) {
        return width;
      }
      
      width = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };
      
    chart.height = function(value) {
      if (!arguments.length) {
        return height;
      }

      height = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    }; 
    
    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };

    function getTooltipData(index) {
      
      var tooltipData =  {
          'body': [],
          'footer': []
        },
        internalIndex = 0;
      
      if (regionData) {

        var body = {
          'name': null,
          'val': []
        };
        
        internalIndex = index % regionData.length;
        body.name = regionData[internalIndex].name;
  
        if (regionData[internalIndex].label != null && regionData[internalIndex].shape != null && boxColorPalette[internalIndex] != null) {
          var item = {
              'shape': null,
              'color': null,
              'label': null,
              'value': null
            };
          
          item.shape = regionData[internalIndex].shape;
          item.color = boxColorPalette[internalIndex];
          item.label = regionData[internalIndex].label;
          body.val.push(item);
        }
        
        if (boxplotData) {
          
          if (boxplotData[index]) {

            for (var i in boxplotData[index]) {
              var item = {
                  'shape': null,
                  'color': null,
                  'label': null,
                  'value': null
                };
              item.label = i;
              if (boxplotData[index][i]) {
                if (i == 'outLiers(s)') {
                  item.value = boxplotData[index][i];
                } else {
                  item.value = boxplotData[index][i].val;
                }
              }
              body.val.push(item);
            }
          }
        }
        
        tooltipData.body.push(body);
      }
      
      if (dimensionData) {
        internalIndex = Math.floor(index / regionData.length);
        for (var i = 0; i < dimensionData.length; i++) {
          
          if (dimensionData[i].rows.length > 0) {
            var footer = {
                'label': null,
                'value': null
              };
            footer.label = dimensionData[i].col;
            footer.value = dimensionData[i].rows[internalIndex];
            
            tooltipData.footer.push(footer);
          }
        }
      }
    
      return tooltipData;
    }
    
    function generateTooltipData() {
      
      if (dimensions) {
        for (var i in dimensions) {
          dimensionData = dimensions[i].values;
        }
      }
      
      if (legendData) {
        var legendList = legendData.values;
        if (legendList.length > 1) {
          if (legendList[0].type == 'MND') {
            //mnd scan
            for (var mndIndex = 0; mndIndex < legendList[0].rows.length; mndIndex++) {

              //vertical scan
              for (var m = 0; m < legendList[1].rows.length; m++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.name = legendList[0].rows[mndIndex];
                var label = [];
                
                //horizontal scan
                for (var n = 1; n < legendList.length; n++) {
                  label.push(legendList[n].rows[m]);
                }
                legendObj.label = label;
                regionData.push(legendObj);
              }    

            }
          } else if (legendList[legendList.length - 1].type == 'MND') {

            for (var m = 0; m < legendList[0].rows.length; m++) {

              var label = [];
              for (var n = 0; n < legendList.length - 1; n++) {
                label.push(legendList[n].rows[m]);              
              }
              

              for (var mndIndex = 0; mndIndex < legendList[legendList.length - 1].rows.length; mndIndex++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.label = label;
                legendObj.name = legendList[legendList.length - 1].rows[mndIndex];
                regionData.push(legendObj);
              }
            }
          } 
        } else {
          for (var m = 0; m < legendList[0].rows.length; m++) {
            var legendObj = {
                'name': null,
                'shape': null,
                'color': null,
                'label': null
              };
            legendObj.name = legendList[0].rows[m];
            regionData.push(legendObj);
          }
        }
      }
      
      for (var k = 0; k < regionData.length; k++) {
        //regionData[k].color = boxColorPalette[k % boxColorPalette.length];
        regionData[k].shape = 'squareWithRadius';
      }
    }

    function setElementAttribute(element, attribute, value) {
      if (element) {
        var className = element.getAttribute('class');
        if(className.indexOf('recthighwhisker') == -1 && className.indexOf('rectlowwhisker') == -1
           && className.indexOf('linehorizontalhighwhisker') == -1 && className.indexOf('lineverticalhighwhisker') == -1
           && className.indexOf('linehorizontallowwhisker') == -1 && className.indexOf('lineverticallowwhisker') == -1) {
          element.setAttribute(attribute, value);
        }else if (className.indexOf('recthighwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('linehorizontalhighwhisker') != -1 || nodeClassName.indexOf('lineverticalhighwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }
        } else if(className.indexOf('rectlowwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('linehorizontallowwhisker') != -1 || nodeClassName.indexOf('lineverticallowwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }        
        }      
      }
    }
    
      chart.parent = function(){
        return sWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, elemsLen = elems.length; i < elemsLen; i++) {
          var item = elems[i];
          setElementAttribute(item, 'opacity', 1);
          }
        }else{
        setElementAttribute(elems, 'opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
          var item = elems[i];
          setElementAttribute(item, 'opacity', 0.2);
          }
        }else{
        setElementAttribute(elems, 'opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          sWrapper.selectAll('.datapoint').attr('opacity', 1);
          sWrapper.selectAll('.lineverticallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.lineverticalhighwhisker').attr('opacity', 1);
          sWrapper.selectAll('.linehorizontallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.linehorizontalhighwhisker').attr('opacity', 1);
        }else{
          sWrapper.selectAll('.datapoint').attr('opacity', 0.2);
          sWrapper.selectAll('.lineverticallowwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.lineverticalhighwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.linehorizontallowwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.linehorizontalhighwhisker').attr('opacity', 0.2);
        }
        
        sWrapper.selectAll('.recthighwhisker').attr('opacity', 0);
        sWrapper.selectAll('.rectlowwhisker').attr('opacity', 0);
      };
  
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(xOnModule - xScale.rangeBand()*i - 0.5 * xScale.rangeBand() ) <= 0.5 * xScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1)
          || i < 0) {
        decorativeShape.style(
            'visibility', 'hidden');
        return;
      }
      
      decorativeShape.attr(
          'x',
          xScale.rangeBand() * i + boxWidth/4).style(
          'visibility', 'visible');
      
      if(lastHovered !== i){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element.
          var transform = sWrapper[0][0].getTransformToElement(sWrapper[0][0].ownerSVGElement);
          var xoffset = transform.e;

          var tooltipData = getTooltipData(i);
          
          tooltipData.point = {
              x: xScale.rangeBand()*i + 0.5 * xScale.rangeBand() + xoffset,
              y: d3.event.layerY
              };
          tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : width,
                        height : height
                    };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
      }
      
      };
  
      chart.blurOut = function(){
        decorativeShape.style('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
          eDispatch.hideTooltip();
      }
      };
      
      function makeSubGroup(row, start, end, groups, parentGroupIndex) {
      if (row && start <= end && end < row.length) {
        var subStart = subEnd = pos = start;
        while (pos <= end) {
          while (((pos+1) <= end) && (row[pos + 1].val == row[pos].val)) {
            subEnd++;
            pos++;
          }
            
          groups.push({
            'val': row[subStart],
            'parentGroupIndex': parentGroupIndex,
            'start': subStart,
            'end': subEnd
          });
          pos++;
          subStart = subEnd = pos;
        }          
      }
    }

    
    function generateGroup(row) {
      var curGroups = [];
      if (row) {
        var mapLen = dimensionGroup.length;
        var preGroups = mapLen > 0?dimensionGroup[mapLen - 1].val : null;
        if (preGroups) {
          for (var i = 0, len = preGroups.length; i < len; i++) {
            var preGroup = preGroups[i];
            var start = preGroup.start;
            var end = preGroup.end;
            makeSubGroup(row, start, end, curGroups, i );
          }
        } else {
          makeSubGroup(row, 0, row.length - 1, curGroups, null);
        }
      }
      return curGroups;
    }

    function dataTransform(originalData) {
      if (originalData) {
        var originalDimension = originalData.getAnalysisAxisDataByIdx(0);
        legendData = originalData.getAnalysisAxisDataByIdx(1);
        if (originalDimension) {
          var len = originalDimension.values.length;
          if (len == 1) {
            dimensionGroup.push({'col': originalDimension.values[0].col.val, 'val': []});
          } else {
            for (var i = 0; i < len - 1; i++) {
              var row = originalDimension.values[i].rows;
              dimensionGroup.push({'col': originalDimension.values[i].col.val, 'val': generateGroup(row)});
            }
          }
        }
      }
    }
    
    function caculateLeavesNum(start, end) {
      
      var len = dimensionGroup.length, num = 0, index = 0, leavesGroups = dimensionGroup[len - 1].val;
      while (leavesGroups[index].start != start) {
        index++;
      }      
      while (leavesGroups[index].end != end) {
        num++;
        index++;
      }
      num++;
      return num;
    }

    function generateDimensions() {
      if (dimensionGroup) {
        var len = dimensionGroup.length, groups = null;
        
        groups = dimensionGroup[len - 1].val;
        if (groups.length == 0) {
          dimensionDomain.push(0);
          dimensionDomain.push(1);
        } else {
          for (var i = 0, lenScale = groups.length; i < lenScale; i++) {
            dimensionDomain.push(i);
          }
        }
        
        if (groups.length == 0) {
          dimensions['sap.viz.modules.verticalboxplot.dimension'].values = [{'col': {'val': dimensionGroup[len - 1].col}, 'rows': []}];
        } else {
          
          var scaleValues = [];
          for (var j = 0; j < len; j++) {
            var obj = {
              'col': {'val': ''},
              'rows': []
            };
            obj.col.val = dimensionGroup[j].col;
            var rowGroups = dimensionGroup[j].val;
            for (var k = 0,  lenRowGroups =  rowGroups.length; k < lenRowGroups; k++) {
              var start = rowGroups[k].start, end = rowGroups[k].end, num = caculateLeavesNum(start, end);
              for (var m = 0; m < num; m++) {
                obj.rows.push({
                  'val': handleNull(rowGroups[k].val.val),
                  'info' : rowGroups[k].val.info
                });
              }
            }
            
            scaleValues.push(obj);
          }
              
          dimensions['sap.viz.modules.verticalboxplot.dimension'].values = scaleValues;
        }        
      }      
    }
    
    function createColorPalette(length) {
      boxColorPalette = [];
      if (colorPalette.length > 0) {
        for( var i = 0; i < length; ++i) {
          boxColorPalette.push(colorPalette[i % colorPalette.length]);
        }
      }
    }
    
      function parseOptions(){  
      tooltipVisible = _properties.tooltip.enabled;
        colorPalette = _properties.colorPalette;
        drawingEffect = _properties.drawingEffect;
      }
      
    chart.data = function(value) {
      if (!arguments.length) {
        return _data;
      }
      
      clearGlobalData();
      parseOptions();
      
      _data = value;
        var obj = MNDHandler(_data);
        dataTransform(_data);
        dataMG1 = obj["MG1"];
        
      var len = dataMG1.length;
      var groups = dimensionGroup[dimensionGroup.length - 1].val;
      if (groups.length != 0) {
        for (var i = 0, groupsLen = groups.length; i < groupsLen; i++) {
          var start = groups[i].start, end = groups[i].end;
          for (var j = 0; j < len; j++) {
            var row = [], left = start, right = end;
            for (;left <= right; left++) {
              if (!NumberUtils.isNoValue(dataMG1[j][left].val))
                row.push(dataMG1[j][left]);
            }
            seriesData.push(row);
          }
        }
      } else {
        for (var j = 0; j < len; j++) {
          var row = [];
          for (var m = 0; m < dataMG1[j].length; m++) {
            if (!NumberUtils.isNoValue(dataMG1[j][m].val)) {
              row.push(dataMG1[j][m]);
            } 
          }
          seriesData.push(row);
        }
      }
        
      locateBoundary(seriesData);
      generateDimensions();
      
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
        makeScales();
      }
      
      generateTooltipData();
            createColorPalette(regionData.length);
      
      return chart;
    };
    
    chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
    chart.properties = function(props){

        if (!arguments.length){
          return _properties;
         }
      
      Objects.extend(true, _properties, props);
            parseOptions();
            createColorPalette(regionData.length);
            
         return chart;        
      };
    
    chart.categoryScale = function(scale){
      if (!arguments.length){
        return xDimensionScale;
      }
      xDimensionScale = scale;
      return chart;
     };
     
     chart.primaryScale = function(scale){
       if (!arguments.length){
         return yScale;
       }
       yScale = scale;
       return chart;
     };
  
    chart.colorPalette = function(Palette){
      if (!arguments.length){
        return colorPalette;
      }
      colorPalette = Palette;
      return chart;
     };
  
     chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };
    _properties = manifest.props(null);
    return chart;
  };

  return boxplot;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.VerticalBoxplot',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.verticalboxplot',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.verticalboxplot',
    'name' : 'vertical boxplot',
    base : "sap.viz.modules.xy.base",
    'properties' : { 
          'primaryValuesColorPalette' : null,
          'secondaryValuesColorPalette' : null,
          'tooltip' : {
            'name' : 'tooltip',
            'supportedValueType' : 'Object',
            'supportedValues' : {
              'enabled' : {
                'name' : 'enabled',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set enabled/disabled tooltip.'
              }
            },
            'isExported' : false,
            'description' : 'Settings for tooltip related properties.'
          }
    },
    'feeds' : {
      configure : {
          secondaryValues:null,
          axisLabels:{
          acceptMND: -1,
          min : 1,
          max : 1
        }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.VerticalBoxplotChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBoxplot',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/boxplot',
      name : 'IDS_VERTICALBOXPLOTCHART',
      base : 'riv/baseverticalchart',
      modules : {
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'verticalboxplot',
                  orientation : 'left'
                }
              }
          },
          main : {
              modules : {
                dataLabel:null,
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                },
                plot : {
                    id : 'sap.viz.modules.verticalboxplot',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              },
              controllers : {
                'interaction' : {
                    id : 'sap.viz.modules.controller.interaction',
                    configure : {
                          propertyCategory : 'interaction'
                    }
                }
              }
          }
      },

     dependencies : {
       attributes : [ {
         targetModule : 'main.yAxis',
         target : 'scale',
         sourceModule : 'main.plot',
         source : 'primaryScale'
          },{
         targetModule : 'main.yAxis',
         target : 'title',
         sourceModule : 'main.plot',
         source : 'primaryAxisTitle'
          },{
            targetModule : 'main.xAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'categoryScale'
          },{
              targetModule : 'main.xAxis',
              target : 'independentData',
              sourceModule : 'main.plot',
              source : 'dimensionData'
          },{
            targetModule : 'legend',
            target : 'colorPalette',
            sourceModule : 'main.plot',
            source : 'colorPalette'
          },{
            targetModule : 'legend',
            target : 'setSelectionMode',
            sourceModule : 'main.interaction',
            source : 'getSelectionMode'
          } ],
           events : [ {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main.plot',
            type : 'initialized.interaction'
          }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
          }, {
            targetModule : 'legend',
          listener : 'deselectLegend',
          sourceModule : 'main.interaction',
          type : 'deselectLegend'
          }
          ]
        }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.combination',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(dispatch, Manifest, ColorSeries, MNDHandler, TypeUtils, ObjUtils, MultiAxesDataAdapter, TooltipDataHandler, Scaler, NumberUtils, Objects, langManager, BoundUtil) {
  var combination = function(manifest, ctx) {
    function module(selection) {
      BoundUtil.drawBound(selection, _width, _height);
      _tooltipDataHandler = TooltipDataHandler();
      selection.each(
        function(inputData) {
          if (inputData !== undefined) {
            prepareData(inputData);
          }
          _d3root = d3.select(this);
          
          redraw();
        }
      );//each
      return module;
    }

    module.afterUIComponentAppear = function(){
      _eDispatch.initialized(); 
    };
    
    
    /**
     * set/get width
     */
    module.width = function(_) {
      if (!arguments.length) {
        return _width;
      }
      _width =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    /**
     * set/get height
     */
    module.height = function(_) {
      if (!arguments.length) {
        return _height;
      }
      _height =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    /**
     * set/get size
     * 
     * @param {Object}
     *            {'width':Num, 'height':Num}
     */
    module.size = function(_) {
      if (!arguments.length) {
        return {
          width : _width,
          height: _height
        };
      }
      _width = _.width;
      _height = _.height;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };

    /**
     * set/get properties
     */
    module.properties = function(_) {
      if (!arguments.length) {
        return getProperty();
      }
      setProperty(Objects.extend(true, getProperty(), _));
      prepareData(_rawdata, true);
      return module;
    };
    
    module.dataLabel = function(_){};
    /**
     * set/get data
     */
    module.data = function(_) {
      if (!arguments.length) {
        return _rawdata;
      }
      prepareData(_);
      return module;
    };

    module.primaryAxisTitle = function(_){
        if(!arguments.length) {
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      module.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
     
      module.dispatch = function(_){
        if(!arguments.length) {
          return _eDispatch;
        }
        _eDispatch = _;
        return module;
      };

      module.primaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis1.scale;
        }
        _valueAxis1.scale = scale;
        return module;
      };
      
      module.secondaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis2.scale;
        }
        _valueAxis2.scale = scale;
        return module;
      };
      
      module.categoryScale = function(scale)
      {
        if(!arguments.length) {
          return _xScale;
        }
        _xScale = scale;
        return module;
      };

    module.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis1.scale.domain()[0],
          max: _valueAxis1.scale.domain()[1]
        };
      }
      
      if (range !== null) {
          _valueAxis1.topValue = range.max;
          _valueAxis1.bottomValue = range.min;
          if (range.from === 'axis') {
            _valueAxis1.manualRange = true;
          }
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
            calculateScale(_valueAxis1, _valueAxis1.scale);
          }
      }
      return module;
    };

    module.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis2.scale.domain()[0],
          max: _valueAxis2.scale.domain()[1]
        };
      }
      if (range !== null) {
          _valueAxis2.topValue = range.max;
          _valueAxis2.bottomValue = range.min;
          if (range.from === 'axis') {
            _valueAxis2.manualRange = true;
          }
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
            calculateScale(_valueAxis2, _valueAxis2.scale);
          }
      }
      return module;
    };

    module.primaryAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.primaryValuesColorPalette[0];
      } else {
        return null;
      }
    };
    
    module.secondAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.secondaryValuesColorPalette[0];
      } else {
        return null;
      }
    };

      module.colorPalette = function(Palette){
        if (!arguments.length){
          return _colorPalette;
         }
         return module;
      };

      module.shapePalette = function(Palette){
        if (!arguments.length){
          return _shapePalette;
         }
         return module;
      };

    module.parent = function () {
      return _d3root;
    };
    
    module.clear = function (gray) {
      for (var i in _module)
      {
        if (gray === undefined) {
          _module[i].module.clear();
        } else {
          _module[i].module.clear('grayall');
        }
      }
    };

    module.highlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      if (elementArray.length === 0) {
        return;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].highlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].highlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.highlight(_module[i].highlightArray);
        }
      }
    };

    module.unhighlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }    
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].unhighlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].unhighlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.unhighlight(_module[i].unhighlightArray);
        }
      }
    };
    
    module.hoverOnPoint = function( point ) {
      var i;
      if (_props.tooltip.enabled) {
        var point0= point.x, point1 = point.y;
  
        if(point0 < 0 || point0 > _width) {
          return;
        }
        var xIndex = getCategoryIndex(point0);
        if(_preMouseMoveXIndex === xIndex) {
          return;
        }
        _preMouseMoveXIndex = xIndex;

        var tData = _tooltipDataHandler.generateTooltipData(_rawdata, 
                                   _tooltipdata, 
                                   xIndex, 
                                   _colorPalette, 
                                   _shapePalette);
        var matrix = _d3root.node().getTransformToElement(_d3root.node().ownerSVGElement);                                   
        tData.point = {
            x: _xScale.rangeBand()*(xIndex + 0.5) + matrix.e,
            y: _height / 4 + matrix.f
        };
        _eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.hoverOnPoint(point);
        }
      }
      return true;
    };

    module.blurOut = function( ) {
      var i;
      if (_props.tooltip.enabled) {
        _eDispatch.hideTooltip();
        _preMouseMoveXIndex = -1;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.blurOut();
        }
      }      
      return true;
    };  

      var _xScale = d3.scale.ordinal(),
          _valueAxis1 = {
            scale: d3.scale.linear()
          },
          _valueAxis2 = {
            scale: d3.scale.linear()
          };

    
    //private field
    var _tooltipDataHandler;
    var _eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    //property
    var _width, _height;
    var _props = {
      priorityMap : {
        'bar' : 5,
        'line' : 0
      },
      defaultShape : 'line',
      MNDOnCategory : false,
      MNDInner : false
    };
    var _effectManager = ctx.effectManager;
    //data
    var _rawdata, _tooltipdata;
    var _d3root;
    var _colorPalette, _shapePalette;
    
    //module
    var _module;

    var _preMouseMoveXIndex = -1;

    var dummyDispatch = function (_) {
      this.mtype = _;
    };
    dummyDispatch.prototype.initialized = function() {
      _dummyDispatchHelper.initialized(this.mtype);
    };
    dummyDispatch.prototype.startToInit = function() {
      _eDispatch.startToInit();
    };
    var _dummyDispatchHelper = {
      initialized : function(mtype) {
        var i;
        if (_module[mtype]) {
          _module[mtype].isCompleteAnimation = true;
        }
        for (i in _module) {
          if (!_module[i].isCompleteAnimation) {
            return true;
          }
        }
        _eDispatch.initialized();
        return true;
      }
    };

    function init() {
      //TODO: should destroy useless module here(stop animation of useless module)
      _module = {};
    }
    function prepareData ( rawdata , isMandatory ) {
      var i, j, mtype, tm;
      if ((rawdata === null) || (rawdata === undefined) || (!isMandatory && (_rawdata === rawdata))) {
        return;
      }

      init();
      _rawdata = rawdata;

       var obj = MNDHandler(_rawdata );
      _props.MNDInner = obj.MNDInner;
      _valueAxis1.data = obj['MG1'];
      _valueAxis2.data = obj['MG2'];
      _tooltipdata = TooltipDataHandler.dataTransform(obj);

      if (obj.color) {
        var tempData = obj['MG1'];
        var data0 = [];
        var data1 = [];
        for (i=0; i<tempData.length; i++) {
          var temp0 = [];
          var temp1 = [];
          var temp = tempData[i];
          for (j=0; j<temp.length; j++) {
            if (obj.color[j] === 0) {
              temp0.push(temp[j]);
            } else if (obj.color[j] === 1) {
              temp1.push(temp[j]);
            }
          }
          data0.push(temp0);
          data1.push(temp1);
        }
        _valueAxis1.data = data0;
        _valueAxis2.data = data1;
      }
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      if (obj.hasMND && !obj.MNDOnColor) {
        mtype = _props.dataShape.primaryAxis[0];
        if (mtype === undefined) {
          mtype = _props.defaultShape;
        }
        if (_module[mtype] === undefined) {
          _module[mtype] = {};
        }
        _module[mtype].data = _rawdata;
        _props.MNDOnCategory = true;
      } else {
        _props.MNDOnCategory = false;
        var daa1 = _rawdata.getAnalysisAxisDataByIdx(0);
        var daa2 = _rawdata.getAnalysisAxisDataByIdx(1);
        var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
        var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
        for (i=0; i<dva1.values.length; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined) {
            mtype = _props.defaultShape;
          }
          if (_module[mtype] === undefined) {
            _module[mtype] = {m1Num:0, m2Num:0};
          }
          tm = _module[mtype];
          tm.m1Num ++;
          if (tm.data === undefined) {
            tm.data = new MultiAxesDataAdapter();
            tm.data.addAnalysisAxis(daa1);
            tm.data.addAnalysisAxis(daa2);
            tm.data.addMeasureValuesGroup({
              index: dva1.index,
              values: []
            });
            if (dva2) {
              tm.data.addMeasureValuesGroup({
                index: dva2.index,
                values: []
              });
            }
          }
          var tva1 = tm.data.getMeasureValuesGroupDataByIdx(0);
          tva1.values.push(dva1.values[i]);
        }
        
        if (dva2) {
          for (i=0; i<dva2.values.length; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined) {
              mtype = _props.defaultShape;
            }
            if (_module[mtype] === undefined) {
              _module[mtype] = {m1Num:0, m2Num:0};
            }
            tm = _module[mtype];
            tm.m2Num ++;
            if (tm.data === undefined) {
              tm.data = new MultiAxesDataAdapter();
              tm.data.addAnalysisAxis(daa1);
              tm.data.addAnalysisAxis(daa2);
              tm.data.addMeasureValuesGroup({
                index: dva1.index,
                values: []
              });
              if (dva2) {
                tm.data.addMeasureValuesGroup({
                  index: dva2.index,
                  values: []
                });
              }
            }
            var tva2 = tm.data.getMeasureValuesGroupDataByIdx(1);
            tva2.values.push(dva2.values[i]);
          }
        }
      }
      prepareColor();
    }
    
    function prepareColor() {
      var i, j, color, mtype, tm;
      if (_rawdata === undefined) { return; }
      
      var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
      var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
      var valueAxis1ColorPalette;
      var valueAxis2ColorPalette;

      if (dva2 && !_props.MNDOnCategory) {
        valueAxis1ColorPalette = _props.primaryValuesColorPalette;  
      }else{
        valueAxis1ColorPalette = _props.colorPalette;
      }
      
      valueAxis2ColorPalette = _props.secondaryValuesColorPalette;
      
      _colorPalette = [];
      _shapePalette = [];
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].colorPaletteY1 = [];
            _module[i].currentM1Index = -1;
            if (dva2) {
              _module[i].colorPaletteY2 = [];
              _module[i].currentM2Index = -1;
            }
        }
      }
      
      if (_props.MNDOnCategory) {
        mtype = _props.dataShape.primaryAxis[0];
        var rowslength = dva1.values[0].rows.length;
        for (j=0; j<rowslength; j++) {
          _module[mtype].colorPaletteY1.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
          _shapePalette.push(getShape(mtype));
          _colorPalette.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
        }
      } else {
        var measure1Num = dva1.values.length;
        var measure2Num = 0;
        if (dva2) {
          measure2Num = dva2.values.length;
        }
        var measureNum = measure1Num + measure2Num;
        var colorAxisDataNum = dva1.values[0].rows.length;
        for (i=0; i<measure1Num; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined) {
            mtype = _props.defaultShape;
          }
          tm = _module[mtype];
          tm.currentM1Index ++;
          for (j=0; j<colorAxisDataNum; j++) {
            if (_props.MNDInner) {
              color = valueAxis1ColorPalette[(i+j*measure1Num ) % valueAxis1ColorPalette.length];
              tm.colorPaletteY1[tm.currentM1Index+j*tm.m1Num] = color;
              _shapePalette[i+j*measureNum] = getShape(mtype);
              _colorPalette[i+j*measureNum] = color;
            } else {
              color = valueAxis1ColorPalette[(i*colorAxisDataNum+j) % valueAxis1ColorPalette.length];
              _module[mtype].colorPaletteY1.push(color);
              _shapePalette.push(getShape(mtype));
              _colorPalette.push(color);
            }
          }
        }

        if (dva2) {
          for (i=0; i<measure2Num; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined) {
              mtype = _props.defaultShape;
            }
            tm = _module[mtype];
            tm.currentM2Index ++;
            for (j=0; j<colorAxisDataNum; j++) {
              if (_props.MNDInner) {
                color = valueAxis2ColorPalette[(i+j*measure2Num ) % valueAxis2ColorPalette.length];
                tm.colorPaletteY2[tm.currentM2Index+j*tm.m2Num] = color;
                _shapePalette[measure1Num+i+j*measureNum] = getShape(mtype);
                _colorPalette[measure1Num+i+j*measureNum] = color;
              } else {
                color = valueAxis2ColorPalette[(i*colorAxisDataNum+j) % valueAxis2ColorPalette.length];
                _module[mtype].colorPaletteY2.push(color);
                _shapePalette.push(getShape(mtype));
                _colorPalette.push(color);
              }
            }
          }
        }
      } // _props.MNDOnCategory
    }
    function moduleSortHelp(a, b) {
      return (_props.priorityMap[b] - _props.priorityMap[a]);
    }
    function prepareModule() {
      var tempA = [],i;
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          tempA.push(i);
        }
      }
      tempA.sort(moduleSortHelp);

      _d3root.selectAll('.module').remove(); //TODO: should not always remove all
      var d3modules = _d3root.selectAll('.module').data(tempA);
      d3modules.enter().append('svg:g').attr('class', 'module');
      d3modules.exit().remove();
      
      d3modules.each(function(d) {
        _module[d].d3root = d3.select(this);
      });
      
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].module = getModule(i); //TODO: should not always new module instance
            var props = {
              colorPalette: _module[i].colorPaletteY1,
              primaryValuesColorPalette : _module[i].colorPaletteY1,
              tooltip : {enabled : false},
              animation : { 'dataLoading' : _props.animation.dataLoading },
              drawingEffect: _props.drawingEffect
            };
            if (_module[i].colorPaletteY2) {
              props.secondaryValuesColorPalette = _module[i].colorPaletteY2;
            }
            switch (i) {
            case 'line' :
              props.hoverline = { visible : false };
              ObjUtils.extend(props, _props.line);
              break;
            case 'bar' :
              props.animation.dataUpdating = _props.animation.dataLoading; 
              ObjUtils.extend(props, _props.bar);
              break;
            default :
              break;
            }

            _module[i].props = props;
            _module[i].module.dispatch(new dummyDispatch(i));
        }
      }
    }

    function redraw() {
      var i;
      prepareModule();

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            var m = _module[i];
            m.module.width(_width).height(_height).data(m.data)
                .properties(m.props).primaryScale(_valueAxis1.scale)
                .categoryScale(_xScale);
            var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
            if (dva2) {
              switch(i) {
              case 'bar' :
                m.module.secondScale(_valueAxis2.scale); break;
              case 'line' :
                m.module.secondaryScale(_valueAxis2.scale); break;
              default:
                break;
              }
            }
            m.d3root.call(m.module);
            m.dataPointElements = [];
            m.d3root.selectAll('.datapoint').each(function(){m.dataPointElements.push(this);});
        }
      }
    }

    function getCategoryIndex(val)
    {
      var index = val / _xScale.rangeBand();
      index = Math.floor(index);
      return index;
    }

      function computeScales() {
          var domain = [];
          var categoryNum = 0;
          if (_props.MNDOnCategory) {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum += _valueAxis1.data[0].length;
            }
            if (_valueAxis2.data && _valueAxis2.data.length > 0) {
              categoryNum += _valueAxis2.data[0].length;
            }        
          } else {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum = _valueAxis1.data[0].length;
            } else {
              categoryNum = _valueAxis2.data[0].length;  
            }
          }
          for (var i=0; i < categoryNum; i++) {
             domain.push(i);
          }      
          _xScale.domain(domain).rangeBands([0, _width]);

          calculateScale(_valueAxis1, _valueAxis1.scale);
          calculateScale(_valueAxis2, _valueAxis2.scale);

          if (_valueAxis1.data && _valueAxis1.data.length > 0 &&
              _valueAxis2.data && _valueAxis2.data.length > 0 ) {
          if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([_height, 0]); 
            _valueAxis2.scale.domain([0, 1]).range ([_height, 0]); 
          } else if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length !== 0){
            _valueAxis1.scale.domain(_valueAxis2.scale.domain()).range(_valueAxis2.scale.range());
          } else if(_valueAxis1.scale.domain().length !== 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain(_valueAxis1.scale.domain()).range(_valueAxis1.scale.range());
          }

          if (!_valueAxis1.manualRange && !_valueAxis2.manualRange) {
              Scaler.perfectDual(_valueAxis1.scale, _valueAxis2.scale);
          } else if (!_valueAxis1.manualRange) {
              Scaler.perfect(_valueAxis1.scale);
          } else if (!_valueAxis2.manualRange) {
              Scaler.perfect(_valueAxis2.scale);
          }
        } else if (_valueAxis1.data && _valueAxis1.data.length > 0 && !_valueAxis1.manualRange) {
          if(_valueAxis1.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([_height, 0]);
          }
          Scaler.perfect(_valueAxis1.scale);
        } else if (_valueAxis2.data && _valueAxis2.data.length > 0 && !_valueAxis2.manualRange) {
          if(_valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain([0, 1]).range ([_height, 0]);
          }
          Scaler.perfect(_valueAxis2.scale);
        }
      }

    function calculateScale(axisValue, scale) {
        if(axisValue.data && axisValue.data.length > 0) {
            if(axisValue.topValue === undefined) {
              var minMax = calculateMinMax(axisValue);
              if(!minMax||(minMax.min === 0 && minMax.max === 0)) {
                scale.domain([]).range ([]);             
              }else{
                scale.domain([minMax.min, minMax.max]).range ([_height, 0]);                
              }
            } else {
              scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([_height, 0]);
            }
        } else {
          scale.domain([0,0]).range(0,0);
        }
      }

    function getProperty() {
      var temp = {};
      temp.tooltip = {enabled:  _props.tooltip.enabled};
      temp.primaryValuesColorPalette = _props.primaryValuesColorPalette;
      temp.secondaryValuesColorPalette = _props.secondaryValuesColorPalette;
      temp.colorPalette = _props.colorPalette;
      temp.drawingEffect = _props.drawingEffect;
      temp.animation = { 'dataLoading' : _props.animation.dataLoading };
      temp.dataShape = {};
      ObjUtils.extend(true, temp.dataShape, _props.dataShape);
      temp.bar = {};
      ObjUtils.extend(true, temp.bar, _props.bar);
      temp.line = {};
      ObjUtils.extend(true, temp.line, _props.line);
  
      return temp;
    }

    function setProperty (props) {
      _props.tooltip = {enabled: props.tooltip.enabled};
      _props.primaryValuesColorPalette = props.primaryValuesColorPalette;
      _props.secondaryValuesColorPalette = props.secondaryValuesColorPalette;
      _props.drawingEffect = props.drawingEffect;
      _props.colorPalette = props.colorPalette;
      _props.animation = {dataLoading : props.animation.dataLoading};
      _props.dataShape = {};
      ObjUtils.extend(true, _props.dataShape, props.dataShape);
      _props.bar = {};
      ObjUtils.extend(true, _props.bar, props.bar);
      _props.line = {};
      ObjUtils.extend(true, _props.line, props.line);

      return _props;
    }
    function getModule(mtype) {
      var result;
      switch (mtype) {
      case 'bar':
        result = Manifest.module.get("sap.viz.modules.verticalbar"); break;
      case 'line':
        result = Manifest.module.get("sap.viz.modules.line"); break;
      default:
        break;
      }
      return result.fn(result, ctx);
    }
    
    function getShape(mtype) {
      var result;
      switch (mtype) {
      case 'line':
        result = _props.line.marker.shape;
        break;
      case 'bar':
        result = 'squareWithRadius'; break;
      default:
        break;
      }
      return result;
    }

    function isExist(ao, element) {
      for (var n=0; n<ao.length; n++) {
        if (ao[n] === element) {
          return true;
        }
      }
      return false;
    }

    function calculateMinMax(axisValue)
    {
      if(!axisValue.data || axisValue.data.length === 0) {
        return null;
      }
      var minMax = {
          min: null,
          max: null
      };
      minMax.max = d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      });
      minMax.min = d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      });
      if(NumberUtils.isNoValue(minMax.max )) { 
        return null;
       }
      if(minMax.min >= 0) {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / _height ;
      } else if(minMax.max <= 0) {
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ _height;
      } else {
        var temp = (minMax.max - minMax.min) * 5 / _height;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }
    setProperty(manifest.props(null));
    return module;
  };
  return combination;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.combination',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {

  var module = {
    base : "sap.viz.modules.xy.base",
    'id' : 'sap.viz.modules.combination',
    'name' : 'combination',
    'properties' : {
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enabled/disabled data loading animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.'
      },
      'dataShape' : {
          'name' : 'dataShape',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'primaryAxis' : {
              'name' : 'primaryAxis',
              'supportedValueType' : 'StringArray',
              'supportedValues' : [ 'bar', 'line' ],
              'defaultValue' : [ 'bar', 'line', 'line'],
              'description' : 'Set shape of measure index1 data.'
            },
            'secondAxis' : {
              'name' : 'secondAxis',
              'supportedValueType' : 'StringArray',
              'supportedValues' : [ 'line', 'line' ],
              'defaultValue' : [ 'line', 'line', 'line'],
              'description' : 'Set shape of measure index2 data.',
                'isExported': false
            }
          },
          'description' : 'Set shape of measure data.'
      },
      'bar' : {
          'name' : 'bar',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'isRoundCorner' : {
            'name' : 'isRoundCorner',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set enable/disable round corner of bar.'
          }
          },
          'description' : 'Settings for bar properties.'     
      }, //bar
      'line' : {
          'name' : 'line',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'width' : {
            'name' : 'width',
            'supportedValueType' : 'PositiveInt',
            'defaultValue' : 2,
            'description' : 'Set width of line, range[1,7]. When beyond the range, the line width is default size 2.'
            },
            'marker' : {
                'name' : 'marker',
                'description' : 'Set marker/data point graphics settings.',
                'supportedValueType' : 'Object',
                'supportedValues' : {
                    'visible' : {
                      'name' : 'visible',
                      'supportedValueType' : 'Boolean',
                      'defaultValue' : false,
                      'description' : 'Set to show marker or not.'
                    },
                    'shape' : {
                      'name' : 'shape',
                      'supportedValueType' : 'StringArray',
                      'supportedValues' : ['circle', 'diamond', 'triangle-up', 'triangle-down', 'triangle-left', 'triangle-right', 'cross', 'intersection'],
                      'defaultValue' : 'circle',
                      'description' : 'Set marker shapes for chart.'
                    },
                    'size' : {
                      'name' : 'size',
                      'supportedValueType' : 'PositiveInt',
                      'defaultValue' : "6",
                      'min' : '4',
                      'max' : '32',
                      'description' : 'Set marker size of data point, range[4,32]. When beyond the range, the marker size is default size 6.'
                    }
                }
            }
          },
          'description' : 'Settings for line properties.'
      } //line
    }, 
    fn : fn
  
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.horizontalcombination',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(dispatch, Manifest, ColorSeries, MNDHandler, TypeUtils, ObjUtils, MultiAxesDataAdapter, TooltipDataHandler, Scaler, NumberUtils, Objects, langManager, BoundUtil) {
  var combination = function(manifest, ctx) {
    function module(selection) {
      _tooltipDataHandler = TooltipDataHandler();
      BoundUtil.drawBound(selection, _width, _height);
      selection.each(
        function(inputData) {
          if (inputData !== undefined) {
            prepareData(inputData);
          }
          _d3root = d3.select(this);
          
          redraw();
        }
      );//each
      return module;
    }

    /**
     * set/get width
     */
    module.width = function(_) {
      if (!arguments.length) {
        return _width;
      }
      _width =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    /**
     * set/get height
     */
    module.height = function(_) {
      if (!arguments.length) {
        return _height;
      }
      _height =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    
    module.afterUIComponentAppear = function(){
      _eDispatch.initialized(); 
    };
    /**
     * set/get size
     * 
     * @param {Object}
     *            {'width':Num, 'height':Num}
     */
    module.size = function(_) {
      if (!arguments.length) {
        return {
          width : _width,
          height: _height
        };
      }
      _width = _.width;
      _height = _.height;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };

    /**
     * set/get properties
     */
    module.properties = function(_) {
      if (!arguments.length) {
        return getProperty();
      }
      setProperty(Objects.extend(true, getProperty(), _));
      prepareData(_rawdata, true);
      return module;
    };
    
    module.dataLabel = function(_){};
    /**
     * set/get data
     */
    module.data = function(_) {
      if (!arguments.length) {
        return _rawdata;
      }
      prepareData(_);
      return module;
    };

    module.primaryAxisTitle = function(_){
        if(!arguments.length) {
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      module.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
     
      module.dispatch = function(_){
        if(!arguments.length) {
          return _eDispatch;
        }
        _eDispatch = _;
        return module;
      };

      module.primaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis1.scale;
        }
        _valueAxis1.scale = scale;
        return module;
      };
      
      module.secondaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis2.scale;
        }
        _valueAxis2.scale = scale;
        return module;
      };
      
      module.categoryScale = function(scale)
      {
        if(!arguments.length) {
          return _xScale;
        }
        _xScale = scale;
        return module;
      };

    module.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis1.scale.domain()[0],
          max: _valueAxis1.scale.domain()[1]
        };
      }
      
      if (range !== null) {
          _valueAxis1.topValue = range.max;
          _valueAxis1.bottomValue = range.min;
          if (range.from === 'axis') {
            _valueAxis1.manualRange = true;
          }
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
            calculateScale(_valueAxis1, _valueAxis1.scale);
          }
      }
      return module;
    };

    module.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis2.scale.domain()[0],
          max: _valueAxis2.scale.domain()[1]
        };
      }
      if (range !== null) {
          _valueAxis2.topValue = range.max;
          _valueAxis2.bottomValue = range.min;
          if (range.from === 'axis') {
            _valueAxis2.manualRange = true;
          }
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
            calculateScale(_valueAxis2, _valueAxis2.scale);
          }
      }
      return module;
    };

    module.primaryAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.primaryValuesColorPalette[0];
      } else {
        return null;
      }
    };
    
    module.secondAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.secondaryValuesColorPalette[0];
      } else {
        return null;
      }
    };

      module.colorPalette = function(Palette){
        if (!arguments.length){
          return _colorPalette;
         }
         return module;
      };

      module.shapePalette = function(Palette){
        if (!arguments.length){
          return _shapePalette;
         }
         return module;
      };

    module.parent = function () {
      return _d3root;
    };
    
    module.clear = function (gray) {
      for (var i in _module)
      {
        if (gray === undefined) {
          _module[i].module.clear();
        } else {
          _module[i].module.clear('grayall');
        }
      }
    };

    module.highlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      if (elementArray.length === 0) {
        return;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].highlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].highlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.highlight(_module[i].highlightArray);
        }
      }
    };

    module.unhighlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }    
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].unhighlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].unhighlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.unhighlight(_module[i].unhighlightArray);
        }
      }
    };
    
    module.hoverOnPoint = function( point ) {
      var i;
      if (_props.tooltip.enabled) {
        var point0= point.x, point1 = point.y;
  
        if(point1 < 0 || point1 > _height) {
          return;
        }
        var xIndex = getCategoryIndex(point1);
        if(_preMouseMoveXIndex === xIndex) {
          return;
        }
        _preMouseMoveXIndex = xIndex;

        var tData = _tooltipDataHandler.generateTooltipData(_rawdata, 
                                   _tooltipdata, 
                                   xIndex, 
                                   _colorPalette, 
                                   _shapePalette);
        var matrix = _d3root.node().getTransformToElement(_d3root.node().ownerSVGElement);
        tData.point = {
            y: (_height - _xScale.rangeBand()*(xIndex + 0.5)) + matrix.f,
            x: _width*3/4 + matrix.e
        };
        _eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.hoverOnPoint(point);
        }
      }
      return true;
    };

    module.blurOut = function( ) {
      var i;
      if (_props.tooltip.enabled) {
        _eDispatch.hideTooltip();
        _preMouseMoveXIndex = -1;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.blurOut();
        }
      }      
      return true;
    };  

      var _xScale = d3.scale.ordinal(),
        _valueAxis1 = {
        scale: d3.scale.linear()
      },
      _valueAxis2 = {
        scale: d3.scale.linear()
      };

    
    //private field
    var _tooltipDataHandler;
    var _eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    //property
    var _width, _height;
    var _props = {
      priorityMap : {
        'bar' : 5,
        'line' : 0
      },
      defaultShape : 'line',
      MNDOnCategory : false,
      MNDInner : false
    };
    
    var _effectManager = ctx.effectManager;
    //data
    var _rawdata, _tooltipdata;
    var _d3root;
    var _colorPalette, _shapePalette;
    
    //module
    var _module;

    var _preMouseMoveXIndex = -1;

    var dummyDispatch = function (_) {
      this.mtype = _;
    };
    dummyDispatch.prototype.initialized = function() {
      _dummyDispatchHelper.initialized(this.mtype);
    };
    dummyDispatch.prototype.startToInit = function() {
      _eDispatch.startToInit();
    };

    var _dummyDispatchHelper = {
      initialized : function(mtype) {
        var i;
        if (_module[mtype]) {
          _module[mtype].isCompleteAnimation = true;
        }
        for (i in _module) {
          if (!_module[i].isCompleteAnimation) {
            return true;
          }
        }
        _eDispatch.initialized();
        return true;
      }
    };

    function init() {
      //TODO: should destroy useless module here(stop animation of useless module)
      _module = {};
    }
    function prepareData ( rawdata , isMandatory ) {
      var i, j, mtype, tm;
      if ((rawdata === null) || (rawdata === undefined) || (!isMandatory && (_rawdata === rawdata))) {
        return;
      }

      init();
      _rawdata = rawdata;

       var obj = MNDHandler(_rawdata );
      _props.MNDInner = obj.MNDInner;
      _valueAxis1.data = obj['MG1'];
      _valueAxis2.data = obj['MG2'];
      _tooltipdata = TooltipDataHandler.dataTransform(obj);

      if (obj.color) {
        var tempData = obj['MG1'];
        var data0 = [];
        var data1 = [];
        for (i=0; i<tempData.length; i++) {
          var temp0 = [];
          var temp1 = [];
          var temp = tempData[i];
          for (j=0; j<temp.length; j++) {
            if (obj.color[j] === 0) {
              temp0.push(temp[j]);
            } else if (obj.color[j] === 1) {
              temp1.push(temp[j]);
            }
          }
          data0.push(temp0);
          data1.push(temp1);
        }
        _valueAxis1.data = data0;
        _valueAxis2.data = data1;
      }
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      if (obj.hasMND && !obj.MNDOnColor) {
        mtype = _props.dataShape.primaryAxis[0];
        if (mtype === undefined) {
          mtype = _props.defaultShape;
        }
        if (_module[mtype] === undefined) {
          _module[mtype] = {};
        }
        _module[mtype].data = _rawdata;
        _props.MNDOnCategory = true;
      } else {
        _props.MNDOnCategory = false;
        var daa1 = _rawdata.getAnalysisAxisDataByIdx(0);
        var daa2 = _rawdata.getAnalysisAxisDataByIdx(1);
        var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
        var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
        for (i=0; i<dva1.values.length; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined) {
            mtype = _props.defaultShape;
          }
          if (_module[mtype] === undefined) {
            _module[mtype] = {m1Num:0, m2Num:0};
          }
          tm = _module[mtype];
          tm.m1Num ++;
          if (tm.data === undefined) {
            tm.data = new MultiAxesDataAdapter();
            tm.data.addAnalysisAxis(daa1);
            tm.data.addAnalysisAxis(daa2);
            tm.data.addMeasureValuesGroup({
              index: dva1.index,
              values: []
            });
            if (dva2) {
              tm.data.addMeasureValuesGroup({
                index: dva2.index,
                values: []
              });
            }
          }
          var tva1 = tm.data.getMeasureValuesGroupDataByIdx(0);
          tva1.values.push(dva1.values[i]);
        }
        
        if (dva2) {
          for (i=0; i<dva2.values.length; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined) {
              mtype = _props.defaultShape;
            }
            if (_module[mtype] === undefined) {
              _module[mtype] = {m1Num:0, m2Num:0};
            }
            tm = _module[mtype];
            tm.m2Num ++;
            if (tm.data === undefined) {
              tm.data = new MultiAxesDataAdapter();
              tm.data.addAnalysisAxis(daa1);
              tm.data.addAnalysisAxis(daa2);
              tm.data.addMeasureValuesGroup({
                index: dva1.index,
                values: []
              });
              if (dva2) {
                tm.data.addMeasureValuesGroup({
                  index: dva2.index,
                  values: []
                });
              }
            }
            var tva2 = tm.data.getMeasureValuesGroupDataByIdx(1);
            tva2.values.push(dva2.values[i]);
          }
        }
      }
      prepareColor();
    }
    
    function prepareColor() {
      var i, j, color, mtype, tm;
      if (_rawdata === undefined) { return; }
      
      var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
      var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
      var valueAxis1ColorPalette;
      var valueAxis2ColorPalette;

      if (dva2 && !_props.MNDOnCategory) {
        valueAxis1ColorPalette = _props.primaryValuesColorPalette;  
      }else{
        valueAxis1ColorPalette = _props.colorPalette;
      }
      
      valueAxis2ColorPalette = _props.secondaryValuesColorPalette;
      
      _colorPalette = [];
      _shapePalette = [];
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].colorPaletteY1 = [];
            _module[i].currentM1Index = -1;
            if (dva2) {
              _module[i].colorPaletteY2 = [];
              _module[i].currentM2Index = -1;
            }
        }
      }
      
      if (_props.MNDOnCategory) {
        mtype = _props.dataShape.primaryAxis[0];
        var rowslength = dva1.values[0].rows.length;
        for (j=0; j<rowslength; j++) {
          _module[mtype].colorPaletteY1.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
          _shapePalette.push(getShape(mtype));
          _colorPalette.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
        }
      } else {
        var measure1Num = dva1.values.length;
        var measure2Num = 0;
        if (dva2) {
          measure2Num = dva2.values.length;
        }
        var measureNum = measure1Num + measure2Num;
        var colorAxisDataNum = dva1.values[0].rows.length;
        for (i=0; i<measure1Num; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined) {
            mtype = _props.defaultShape;
          }
          tm = _module[mtype];
          tm.currentM1Index ++;
          for (j=0; j<colorAxisDataNum; j++) {
            if (_props.MNDInner) {
              color = valueAxis1ColorPalette[(i+j*measure1Num ) % valueAxis1ColorPalette.length];
              tm.colorPaletteY1[tm.currentM1Index+j*tm.m1Num] = color;
              _shapePalette[i+j*measureNum] = getShape(mtype);
              _colorPalette[i+j*measureNum] = color;
            } else {
              color = valueAxis1ColorPalette[(i*colorAxisDataNum+j) % valueAxis1ColorPalette.length];
              _module[mtype].colorPaletteY1.push(color);
              _shapePalette.push(getShape(mtype));
              _colorPalette.push(color);
            }
          }
        }

        if (dva2) {
          for (i=0; i<measure2Num; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined) {
              mtype = _props.defaultShape;
            }
            tm = _module[mtype];
            tm.currentM2Index ++;
            for (j=0; j<colorAxisDataNum; j++) {
              if (_props.MNDInner) {
                color = valueAxis2ColorPalette[(i+j*measure2Num ) % valueAxis2ColorPalette.length];
                tm.colorPaletteY2[tm.currentM2Index+j*tm.m2Num] = color;
                _shapePalette[measure1Num+i+j*measureNum] = getShape(mtype);
                _colorPalette[measure1Num+i+j*measureNum] = color;
              } else {
                color = valueAxis2ColorPalette[(i*colorAxisDataNum+j) % valueAxis2ColorPalette.length];
                _module[mtype].colorPaletteY2.push(color);
                _shapePalette.push(getShape(mtype));
                _colorPalette.push(color);
              }
            }
          }
        }
      } // _props.MNDOnCategory
    }
    function moduleSortHelp(a, b) {
      return (_props.priorityMap[b] - _props.priorityMap[a]);
    }
    function prepareModule() {
      var tempA = [],i;
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          tempA.push(i);
        }
      }
      tempA.sort(moduleSortHelp);
      
      _d3root.selectAll('.module').remove(); //TODO: should not always remove all
      var d3modules = _d3root.selectAll('.module').data(tempA);
      d3modules.enter().append('svg:g').attr('class', 'module');
      d3modules.exit().remove();
      
      d3modules.each(function(d) {
        _module[d].d3root = d3.select(this);
      });
      
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].module = getModule(i); //TODO: should not always new module instance
            var props = {
              colorPalette : _module[i].colorPaletteY1,
              primaryValuesColorPalette : _module[i].colorPaletteY1,
              tooltip : {enabled : false},
              animation : { 'dataLoading' : _props.animation.dataLoading },
              drawingEffect: _props.drawingEffect
            };
            if (_module[i].colorPaletteY2) {
              props.secondaryValuesColorPalette = _module[i].colorPaletteY2;
            }
            switch (i) {
            case 'line' :
              props.hoverline = { visible : false };
              ObjUtils.extend(props, _props.line);
              break;
            case 'bar' :
              props.animation.dataUpdating = _props.animation.dataLoading; 
              ObjUtils.extend(props, _props.bar);
              break;
            default :
              break;
            }
            _module[i].props = props;
            _module[i].module.dispatch(new dummyDispatch(i));
        }
      }
    }

    function redraw() {
      var i;
      prepareModule();

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            var m = _module[i];
            m.module.width(_width).height(_height).data(m.data)
                .properties(m.props).primaryScale(_valueAxis1.scale)
                .categoryScale(_xScale);
            var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
            if (dva2) {
              switch(i) {
              case 'bar' :
                m.module.secondScale(_valueAxis2.scale); break;
              case 'line' :
                m.module.secondaryScale(_valueAxis2.scale); break;
              default:
                break;
              }
            }
            m.d3root.call(m.module);
            m.dataPointElements = [];
            m.d3root.selectAll('.datapoint').each(function(){m.dataPointElements.push(this);});
        }
      }
    }

    function getCategoryIndex(val)
    {
      var categoryNum = _xScale.domain().length;
      var index = val / _xScale.rangeBand();
        index = Math.floor(index);
       
      return categoryNum - 1 - index;
    }

      function computeScales() {
          var domain = [];
          var categoryNum = 0;
          if (_props.MNDOnCategory) {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum += _valueAxis1.data[0].length;
            }
            if (_valueAxis2.data && _valueAxis2.data.length > 0) {
              categoryNum += _valueAxis2.data[0].length;
            }        
          } else {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum = _valueAxis1.data[0].length;
            } else {
              categoryNum = _valueAxis2.data[0].length;  
            }
          }
          for (var i=0; i < categoryNum; i++) {
             domain.push(i);
          }      
          _xScale.domain(domain).rangeBands([_height, 0]);

          calculateScale(_valueAxis1, _valueAxis1.scale);
          calculateScale(_valueAxis2, _valueAxis2.scale);

          if (_valueAxis1.data && _valueAxis1.data.length > 0 &&
              _valueAxis2.data && _valueAxis2.data.length > 0 ) {
          if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([0,_width]); 
            _valueAxis2.scale.domain([0, 1]).range ([0,_width]); 
          } else if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length !== 0){
            _valueAxis1.scale.domain(_valueAxis2.scale.domain()).range(_valueAxis2.scale.range());
          } else if(_valueAxis1.scale.domain().length !== 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain(_valueAxis1.scale.domain()).range(_valueAxis1.scale.range());
          }

          if (!_valueAxis1.manualRange && !_valueAxis2.manualRange) {
              Scaler.perfectDual(_valueAxis1.scale, _valueAxis2.scale);
          } else if (!_valueAxis1.manualRange) {
              Scaler.perfect(_valueAxis1.scale);
          } else if (!_valueAxis2.manualRange) {
              Scaler.perfect(_valueAxis2.scale);
          }
        } else if (_valueAxis1.data && _valueAxis1.data.length > 0 && !_valueAxis1.manualRange) {
          if(_valueAxis1.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([0,_width]);
          }
          Scaler.perfect(_valueAxis1.scale);
        } else if (_valueAxis2.data && _valueAxis2.data.length > 0 && !_valueAxis2.manualRange) {
          if(_valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain([0, 1]).range ([0,_width]);
          }
          Scaler.perfect(_valueAxis2.scale);
        }
      }

    function calculateScale(axisValue, scale) {
        if(axisValue.data && axisValue.data.length > 0) {
            if(axisValue.topValue === undefined) {
              var minMax = calculateMinMax(axisValue);
              if(!minMax || ( minMax.min === 0 && minMax.max === 0)) {
                scale.domain([]).range ([]); 
              } else {
                scale.domain([minMax.min, minMax.max]).range ([0, _width]);
              }
            } else {
              scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([0, _width]);
            }
        } else {
          scale.domain([0,0]).range(0,0);
        }
      }

    function getProperty() {
      var temp = {};
      temp.tooltip = {enabled: _props.tooltip.enabled};
      temp.primaryValuesColorPalette = _props.primaryValuesColorPalette;
      temp.secondaryValuesColorPalette = _props.secondaryValuesColorPalette;
      temp.colorPalette = _props.colorPalette;
      temp.drawingEffect = _props.drawingEffect;
      temp.animation = { 'dataLoading' : _props.animation.dataLoading };
      temp.dataShape = {};
      ObjUtils.extend(true, temp.dataShape, _props.dataShape);
      temp.bar = {};
      ObjUtils.extend(true, temp.bar, _props.bar);
      temp.line = {};
      ObjUtils.extend(true, temp.line, _props.line);
  
      return temp;
    }

    function setProperty (props) {
      _props.tooltip = {enabled: props.tooltip.enabled};
      _props.primaryValuesColorPalette = props.primaryValuesColorPalette;
      _props.secondaryValuesColorPalette = props.secondaryValuesColorPalette;
      _props.drawingEffect = props.drawingEffect;
      _props.colorPalette = props.colorPalette;
      _props.animation = {dataLoading : props.animation.dataLoading};
      _props.dataShape = {};
      ObjUtils.extend(true, _props.dataShape, props.dataShape);
      _props.bar = {};
      ObjUtils.extend(true, _props.bar, props.bar);
      _props.line = {};
      ObjUtils.extend(true, _props.line, props.line);

      return _props;
    }

    function getModule(mtype) {
      var result;
      switch (mtype) {
      case 'bar':
        result = Manifest.module.get("sap.viz.modules.bar"); break;
      case 'line':
        result = Manifest.module.get("sap.viz.modules.horizontalline"); break;
      default:
        break;
      }
      return result.fn(result, ctx);
    }
    
    function getShape(mtype) {
      var result;
      switch (mtype) {
      case 'line':
        result = _props.line.marker.shape;
        break;
      case 'bar':
        result = 'squareWithRadius'; break;
      default:
        break;
      }
      return result;
    }

    function isExist(ao, element) {
      for (var n=0; n<ao.length; n++) {
        if (ao[n] === element) {
          return true;
        }
      }
      return false;
    }

    function calculateMinMax(axisValue)
    {
      if(!axisValue.data || axisValue.data.length === 0) {
        return null;
      }
      var minMax = {
          min: null,
          max: null
      };
      minMax.max = d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      });
      minMax.min = d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      });
      if(NumberUtils.isNoValue(minMax.max )) {
        return null;
      }
      if(minMax.min >= 0) {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / _width;
      } else if(minMax.max <= 0) {
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ _width;
      } else {
        var temp = (minMax.max - minMax.min) * 5 / _width;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }
    setProperty(manifest.props(null));
    return module;
  };
  return combination;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.HorizontalCombination',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.horizontalcombination',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {

  var module = {
    base : "sap.viz.modules.combination",
    'id' : 'sap.viz.modules.horizontalcombination',
    'name' : 'horizontalcombination',
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.line',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(dispatch, MNDHandler, TypeUtils, Scaler, ColorSeries, BoundingBox, NumberUtils, langManager, DrawUtil, TooltipDataHandler, Manifest, Repository, Objects,UADetector,BoundUtil) 
{
  return function(manifest, ctx) 
  {
    var width, height;
    var data_ = null, props;
    //alistar zhu
    var randomSuffix = Repository.newId();
    //alex su
    var tooltipData = null;
    var _tooltipDataHandler;

    var bgColor = "#FFFFFF";
    var hoverColor = "#cccccc";
    var selectedColor = "#333333";
    var xScale = d3.scale.ordinal();
    var mouseMoveLine;
    var preHighLightIndex;
    var g;
    var svgMarkersGroup, svgLinesGroup, svgLightLinesGroup;
    var eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized','startToInit');
    var hasMND;
    var bMNDOnColor;
    var bMNDInner;
    var effectManager = ctx.effectManager;
    var valueAxis1Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };

    var valueAxis2Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };
    var colorPalette = [];
    var PREFIXAXIS1 = 'axis1';
    var PREFIXAXIS2 = 'axis2';

    var bAnimationComplete = false;
    var enableDataLoadingAnimation = true;

    var selectedMarkerNum = 0;

    // clip defs for enimation

    var clipRect;
    
    var OPACITY = 0.4;
    function line(selection) {
      BoundUtil.drawBound(selection, width, height);
      //selection.each(generate);
      
      //alex su
      _tooltipDataHandler = TooltipDataHandler();
      
      renderChart(selection);
      return line;
    }

  
    


    function calculateMinMax(axisValue)
    {
      var minMax = {
          min:null,
          max:null
      };
      if(!axisValue.data || axisValue.data.length === 0){
        return;}
      minMax.max = Number(d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      }));
      minMax.min = Number(d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      }));
      
      if(NumberUtils.isNoValue(minMax.max )) { 
          return null;
        }
      
      if(minMax.min >= 0)
      {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / height ;
      }
      else if(minMax.max <= 0){
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ height;
      }else{
        var temp = (minMax.max - minMax.min) * 5 / height;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }

    function createColorPalette()
    {
      colorPalette = [];
      var i = 0, j = 0;
      if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
        valueAxis1Data.colorPalette = props.primaryValuesColorPalette;
      }
      else {
        valueAxis1Data.colorPalette = props.colorPalette;
      }
      
      valueAxis2Data.colorPalette = props.secondaryValuesColorPalette;
      
      if (hasMND && bMNDOnColor && bMNDInner) {
        var dva1 = data_.getMeasureValuesGroupDataByIdx(0);
        var dva2 = data_.getMeasureValuesGroupDataByIdx(1);
        var mg1mNum=0, mg2mNum=0, mNum=0, colorAxisDataNum=0;
  
        if (dva1 && dva1.values.length>0) { 
          mg1mNum = dva1.values.length;
          colorAxisDataNum = dva1.values[0].rows.length;
        }
        if (dva2 && dva2.values.length>0) {
          mg2mNum = dva2.values.length;
          colorAxisDataNum = dva2.values[0].rows.length;
        }

        for (i=0; i<colorAxisDataNum; i++) {
          for (j=0; j<mg1mNum; j++) {
            colorPalette.push(valueAxis1Data.colorPalette[i*mg1mNum+j % valueAxis1Data.colorPalette.length]);
          }
          for (j=0; j<mg2mNum; j++){
            colorPalette.push(valueAxis2Data.colorPalette[i*mg2mNum+j % valueAxis2Data.colorPalette.length]);
          }
        }
      } else {
        for( i = 0; i < valueAxis1Data.data.length; ++i){
          colorPalette.push(valueAxis1Data.colorPalette[i % valueAxis1Data.colorPalette.length]);
        }
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0)
        {
          for( i = 0; i < valueAxis2Data.data.length; ++i){
            colorPalette.push(valueAxis2Data.colorPalette[i % valueAxis2Data.colorPalette.length]);}
        }
      }
    }

    function calculateScale(axisValue)
    {
      if(axisValue.data && axisValue.data.length > 0)
      { 
        if(axisValue.topValue === null || axisValue.topValue === undefined)
        {
          var minMax = calculateMinMax(axisValue);
          //when all data is 0 or null ,we make axisValue.scale.domain(0,1)
          if(!minMax || (minMax.min === 0 && minMax.max === 0)) {
            axisValue.scale.domain([]).range ([]);
          }
          else  {
            axisValue.scale.domain([minMax.min, minMax.max]).range ([height, 0]);
          }
        }
        else{
          axisValue.scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([height, 0]);
        }

      }
      else{
        axisValue.scale.domain([0,0]).range([0,0]);
      }
      return axisValue.scale;
    }

    function computeScales()
    {
      var domain = [];
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      for (var i=0; i < categoryNum; i++){
        domain.push(i);
      }
      xScale.domain(domain).rangeBands([0, width]);
      calculateScale(valueAxis1Data);
      calculateScale(valueAxis2Data);

      if (valueAxis1Data.data && valueAxis1Data.data.length > 0 &&
            valueAxis2Data.data && valueAxis2Data.data.length > 0 ) {
        if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([height, 0]); 
          valueAxis2Data.scale.domain([0, 1]).range ([height, 0]); 
        } else if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length !== 0){
          valueAxis1Data.scale.domain(valueAxis2Data.scale.domain()).range(valueAxis2Data.scale.range());
        } else if(valueAxis1Data.scale.domain().length !== 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain(valueAxis1Data.scale.domain()).range(valueAxis1Data.scale.range());
        }
        
        if (!valueAxis1Data.manualRange && !valueAxis2Data.manualRange) {
            Scaler.perfectDual(valueAxis1Data.scale, valueAxis2Data.scale);
        } else if (!valueAxis1Data.manualRange) {
            Scaler.perfect(valueAxis1Data.scale);
        } else if (!valueAxis2Data.manualRange) {
            Scaler.perfect(valueAxis2Data.scale);
        }
      } else if (valueAxis1Data.data && valueAxis1Data.data.length > 0 && !valueAxis1Data.manualRange) {
        if(valueAxis1Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([height, 0]);
        }
        Scaler.perfect(valueAxis1Data.scale);
      } else if (valueAxis2Data.data && valueAxis2Data.data.length > 0 && !valueAxis2Data.manualRange) {
        if(valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain([0, 1]).range ([height, 0]);
        }
        Scaler.perfect(valueAxis2Data.scale);
      }
    }

    function changeGroupMarker(groupIndex, visible, borderColor)
    {
      if(groupIndex === undefined || groupIndex === null){
        return;
      }
      var seriesIndex = 0;
      for(seriesIndex = 0; seriesIndex < valueAxis1Data.data.length; ++seriesIndex)
      {   
        if(!valueAxis1Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, borderColor, valueAxis1Data);
          if(!props.marker.visible)
          {
            if(selectedMarkerNum > 0){
              d3.select(valueAxis1Data.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", visible);
            }else{
              d3.select(valueAxis1Data.markers[seriesIndex][groupIndex]).attr("opacity", 1).attr("visibility", visible);
            }
          }
        }
      }  

      if(!valueAxis2Data.data) {return;}

      for(seriesIndex = 0; seriesIndex < valueAxis2Data.data.length; ++seriesIndex)
      {
        if(!valueAxis2Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, borderColor, valueAxis2Data);
          if(!props.marker.visible)
          {
            if(selectedMarkerNum > 0){
              d3.select(valueAxis2Data.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", visible);
            } else {
              d3.select(valueAxis2Data.markers[seriesIndex][groupIndex]).attr("opacity", 1).attr("visibility", visible);
            }
          }
        }
      }
    }

    function changeOneMarker(seriesIndex, xIndex, borderColor, valueAxis)
    {
      d3.select(valueAxis.markers[seriesIndex][xIndex]).attr("stroke",  borderColor);
    }

    function getCategoryIndex(val)
    {
      var index = val / xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      if(index > categoryNum - 1) {index = categoryNum - 1;}
      if(index < 0) { index = 0;}
      return index;
    }

    function processOneAxisSelect(valueAxis, marker) {
      var findFlag = false, yi, xi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } //for j
      }//for i

      if (!findFlag) {
        return false;
      }

      if (valueAxis.selectedMarkers[yi][xi]) {
        return true;
      }

      changeOneMarker(yi, xi, selectedColor, valueAxis);
      d3.select(valueAxis.markers[yi][xi]).attr("opacity", 1).attr("visibility", "visible");
      valueAxis.selectedMarkers[yi][xi] = true;
    
      if(xi > 0 && valueAxis.selectedMarkers[yi][xi - 1]){
        valueAxis.highLines[yi][xi - 1].attr("visibility", "visible");
      }
      if(xi < valueAxis.highLines[0].length && valueAxis.selectedMarkers[yi][xi + 1])
      {
        valueAxis.highLines[yi][xi].attr("visibility", "visible");
      }
      
      ++selectedMarkerNum;
    }

    function processOneAxisDeselect (valueAxis, marker) {
      var xi = preHighLightIndex;

      var findFlag = false, yi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } 
      }

      if (!findFlag) {
        return false;
      }

      if (!valueAxis.selectedMarkers[yi][xi]){
        return true;
      }

      if(xi === preHighLightIndex){
        changeOneMarker(yi, xi, bgColor, valueAxis);
      }
      else{
        changeOneMarker(yi, xi, props.style.marker.stroke, valueAxis);
      }
      
      d3.select(valueAxis.markers[yi][xi]).attr("opacity", OPACITY);
      if(!props.marker.visible && xi !== preHighLightIndex){
        d3.select(valueAxis.markers[yi][xi]).attr("visibility", "hidden");
      }
      valueAxis.selectedMarkers[yi][xi] = false;
    
      if(xi > 0 && valueAxis.selectedMarkers[yi][xi - 1])
      {
        valueAxis.highLines[yi][xi - 1].attr("visibility", "hidden");
      }
      if(xi < valueAxis.highLines[0].length && valueAxis.selectedMarkers[yi][xi + 1]){
        valueAxis.highLines[yi][xi].attr("visibility", "hidden");
      }
  
      --selectedMarkerNum;
    }

    

    function processNullValue(axisValue)
    {
      var result = {
          data:[],
          color:[]
      };
      var arr = [];
      var k;
      var obj;
      for(var i = 0; i < axisValue.length; ++i)
      {
        var preIndex = 0;
        for(var j = 0; j < axisValue[i].length; ++j)
        {
          if(NumberUtils.isNoValue(axisValue[i][j].val))
          {
            if(j > preIndex)
            {
              arr = [];
              for(k = preIndex; k < j; k++)
              {
                obj = axisValue[i][k];
                obj.x = k;  
                arr.push(obj);
              }
              result.data.push(arr);
              result.color.push(i);
            }
            preIndex = j + 1;
          }
        }
        
        if(preIndex < axisValue[i].length)
        {
          arr = [];
          for(k = preIndex; k <  axisValue[i].length; k++)
          {
            obj = axisValue[i][k];
            obj.x = k;
            arr.push(obj);
          }
          result.data.push(arr);
          result.color.push(i);
        }
      }
      return result;
    }
    
    function processOneAxis(axisValue, prefix)
    {
      if(!axisValue.data || axisValue.data.length === 0){
        return;
      }
      var axisGroup = svgLinesGroup.select("g." + prefix);
      if(axisGroup.empty())
      {
        axisGroup = svgLinesGroup.append("svg:g").attr("class", prefix);
      }
      axisValue.selectedMarkers = new Array(axisValue.data.length);
      axisValue.markers = [];
      var result = processNullValue(axisValue.data);
      
      var lines = axisGroup.selectAll("." + "lines").data(result.data);
      
      lines.enter().append("path").attr('class', "lines")
        .attr("stroke-width", props.width).attr("stroke-linejoin", "round");
      lines.exit().remove();
      lines.attr("stroke-width", props.width);//@Alex: add this line to update attributes. 
      var line = d3.svg.line().x(function(d,i) { return xScale(d.x) + xScale.rangeBand() / 2; }).
      y(function(d) {  return axisValue.scale(d.val); });
      
      
      lines.attr("transform", 
          function(d, i) {
            d3.select(this).attr("d", line(d))
            .attr("stroke",  function (){
                var para = { graphType:"line", 
                fillColor:axisValue.colorPalette[result.color[i] %  axisValue.colorPalette.length]};
                return effectManager.register(para);
                });
      });
      
      // draw highlight lines
      var lightLineGroup = svgLightLinesGroup.selectAll("g." + prefix);
      if(lightLineGroup.empty())
      {
        lightLineGroup = svgLightLinesGroup.append("svg:g").attr("class", prefix);
      }
      var groups = lightLineGroup.selectAll("g").data(axisValue.data);
      groups.enter().append("g");
      groups.exit().remove();
      axisValue.highLines = [];
      groups.attr("transform", function(d,i) {
        d3.select(this).selectAll(".lightLine").remove();
        axisValue.highLines.push([]);
        for(var j = 1 ; j < d.length; ++j)
        {
          if(NumberUtils.isNoValue(d[j].val) || NumberUtils.isNoValue(d[j-1].val) ){
            axisValue.highLines[i].push(null);
          }else{
            axisValue.highLines[i].push(d3.select(this).append("svg:line").attr("class", "lightLine").attr("x1",  xScale(j-1) + xScale.rangeBand() / 2).
              attr("y1",axisValue.scale(d[j-1].val)).attr("x2",xScale(j) + xScale.rangeBand() / 2).attr("y2", axisValue.scale(d[j].val))
              .attr("stroke-width", props.width).attr("stroke",  
                  axisValue.colorPalette[i %  axisValue.colorPalette.length]).attr("visibility", "hidden"));
          }
        }
      });
      
      // draw markers
      for(var seriesIndex = 0; seriesIndex < axisValue.data.length; ++seriesIndex)
      {
        axisValue.selectedMarkers[seriesIndex] = [];
        for(var dataIndex = 0; dataIndex < axisValue.data[0].length; ++dataIndex)
        {
          axisValue.selectedMarkers[seriesIndex][dataIndex] = false;
        }
      }
      var markerGroup = svgMarkersGroup.select("g." + prefix);
      if(markerGroup.empty()){
        markerGroup = svgMarkersGroup.append("svg:g").attr("class", prefix);
      }
      groups = markerGroup.selectAll("g.marker").data(axisValue.data);
      groups.enter().append("svg:g").attr("class", "marker");
      groups.exit().remove();
      
      var visible = "hidden";
      if(props && props.marker && props.marker.visible){
        visible  = "visible";
      }
      groups.attr("transform", function(d, i) {
        
        var seriesMarkers = d3.select(this).selectAll(".datashape").data(d);
        var datashape = seriesMarkers.enter().append('g').attr('class','datashape');
        DrawUtil.createElements(datashape,{shape: props.marker.shape, className: "datapoint"} );
        seriesMarkers.exit().remove();
        var markerArr = [];
        seriesMarkers.attr("transform",function(point, index)
        {   
          if(NumberUtils.isNoValue(point.val))
          { 
              d3.select(this).remove();
              markerArr.push(null);
              return;
          }
          markerArr.push(d3.select(this).selectAll('path').node());
        
          var parameter = {
              drawingEffect:props.drawingEffect,
              graphType: props.marker.shape,
              fillColor : axisValue.colorPalette[i % axisValue.colorPalette.length],
              direction : 'vertical',
              rx: props.marker.size / 2,
              ry: props.marker.size / 2,
              borderWidth: 2,
              borderColor: props.style.marker.stroke,
              node:d3.select(this).select('path'),
              visibility: visible
          };

          DrawUtil.drawGraph(parameter, effectManager);
          return  "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(point.val) + ")";  
        });

        axisValue.markers.push(markerArr); 
      });
    }

    function processOneAxisDeselectAll(valueAxis, xIndex)
    {
      if(selectedMarkerNum === 0 || !valueAxis.selectedMarkers || valueAxis.selectedMarkers.length === 0){
        return;
      }

      for(var seriesIndex = 0; seriesIndex < valueAxis.selectedMarkers.length; ++seriesIndex)
      {
        for(var groupIndex = 0; groupIndex < valueAxis.selectedMarkers[0].length; ++groupIndex)
        {
          if(!valueAxis.selectedMarkers[seriesIndex][groupIndex]) {continue;}
          
          if(groupIndex === xIndex)
          {
            changeOneMarker(seriesIndex, groupIndex, bgColor, valueAxis);
            if(!props.marker.visible){
              d3.select(valueAxis.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", "visible");
            }
          }
          else
          {
            changeOneMarker(seriesIndex, groupIndex, props.style.marker.stroke, valueAxis);
            if(!props.marker.visible){
              d3.select(valueAxis.markers[seriesIndex][groupIndex]).attr("visibility", "hidden");
            }
          }
        
          valueAxis.selectedMarkers[seriesIndex][groupIndex] = false;
        }
      }
    }

    function deselectedAllHandler()
    {
      var xpoint = (d3.event ? d3.event.clientX : 0) - g.node().getBoundingClientRect().left;
      var xIndex = getCategoryIndex(xpoint);

      processOneAxisDeselectAll(valueAxis1Data, xIndex);
      processOneAxisDeselectAll(valueAxis2Data, xIndex);
      selectedMarkerNum = 0;
    }

    
    function renderChart(selection)
    {  
      getCSSStyle();
      eDispatch.startToInit();
      if(!g){ g = selection.append("svg:g");}

      if(!mouseMoveLine) {mouseMoveLine = g.append("svg:line");}
      mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", height)
      .attr("stroke-width", 1).attr("stroke", hoverColor)
      .attr("visibility", "hidden").attr("stroke-linejoin", "round");


      if(!svgLinesGroup)
      {
        svgLinesGroup = g.append("svg:g").attr("class", "datalines");
        svgLightLinesGroup = g.append("svg:g").attr("class", "lightLines");
        svgMarkersGroup = g.append("svg:g").attr("class", "markers datashapesgroup");
      }
      selectedMarkerNum = 0;
      lightAll();
      

      if(!clipRect){
        clipRect = g.append("svg:defs").append("svg:clipPath").attr("id", "clip1_" + randomSuffix).append("rect");
      }
        
      clipRect
        .attr("x", 0).attr("y", 0).attr("height", height).attr("width", (enableDataLoadingAnimation ? 0 : width));

      svgMarkersGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLightLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      if(enableDataLoadingAnimation )
      {
        bAnimationComplete = true;
        var totalNumber = 0;
        var interval = width / 50;
        var func = setInterval(function(d){
          if(totalNumber >= width)
          {
            clearInterval(func);
            eDispatch.initialized();
          }
          else
          {
            totalNumber += interval;
            clipRect.attr("width", totalNumber);
          }
        },
        20);
      }else {
          eDispatch.initialized();
          clipRect.attr("width", width);
      }
        
      processOneAxis(valueAxis1Data, PREFIXAXIS1);
      processOneAxis(valueAxis2Data, PREFIXAXIS2);
    }

    function lightAll() {
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS1).selectAll(".lightLine").attr("visibility", "hidden");
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS2).selectAll(".lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", 1);
      if(UADetector.isIE()){
        svgLinesGroup.selectAll(".lines").attr("visibility", "visible");
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.marker").selectAll(".datapoint").attr("opacity", 1);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.marker").selectAll(".datapoint").attr("opacity", 1);
    }

    function grayAll() {
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS1).selectAll(".lightLine").attr("visibility", "hidden");
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS2).selectAll(".lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", OPACITY);
      if(UADetector.isIE())
      {
        svgLinesGroup.selectAll(".lines").attr("visibility", "visible");
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.marker").selectAll(".datapoint").attr("opacity", OPACITY);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.marker").selectAll(".datapoint").attr("opacity", OPACITY);
    }
    
    function getCSSStyle() {
      if (!props.style){
        props.style = {};
      } 
      var cssDef;
      cssDef = ctx.styleManager.query('viz-plot-background');
      if (cssDef) {
        if (cssDef['fill']) {
          bgColor = cssDef['fill'];
        }
      }
      if (!props.style.marker){
        props.style.marker = {};
      }
      props.style.marker.stroke = "transparent";
      cssDef = ctx.styleManager.query('viz-plot-hoverline');
      if(cssDef)
      {
        if (cssDef['stroke']){
          hoverColor = cssDef['stroke'];
        }
      }
    };
    
    line.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    
    line.width = function(value) {
      if (!arguments.length){
        return width;
      }
      width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return line;
    };

    line.height = function(value) {
      if (!arguments.length){
        return height;
      }
      height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return line;
    };
    

    /*;
     * get/set properties
     */
    line.properties = function(_) {
      if (!arguments.length){
        return props;
      }
        
      Objects.extend(true, props, _);
      if(props.marker.size < 4 || props.marker.size > 32) { props.marker.size = 6;}
      if(props.width < 1 || props.width > 7) { props.width = 2; }
      enableDataLoadingAnimation =  props.animation.dataLoading;
      
      getCSSStyle();

      createColorPalette();
      return line;
    };
    
     line.primaryAxisColor = function(){
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
          return effectManager.register({graphType:"line", fillColor: valueAxis1Data.colorPalette[0]});
        }else{
          return null;
        }
      };
        
      line.secondAxisColor = function(){
        return effectManager.register({graphType:"line", fillColor:  valueAxis2Data.colorPalette[0]});
      };     
        
    /**
     * get/set your event dispatch if you support event
     */
    line.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;}
      eDispatch = _;
      return line;
    };
    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    line.data = function(value){
      if (!arguments.length){
        return data_;
      }
      data_ = value;
      var obj = MNDHandler(data_);
      valueAxis1Data.data = obj["MG1"];
      valueAxis2Data.data = obj["MG2"];

      hasMND = obj["hasMND"];
      bMNDOnColor = obj["MNDOnColor"];
      bMNDInner = obj["MNDInner"];
      //alex su
      tooltipData = TooltipDataHandler.dataTransform(obj);
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      createColorPalette();
      return line;        
    };
    
    line.dataLabel = function(_){};
      
      line.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      line.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
     
    /**
     * get color palette
     */
    line.getColorPalette = function() {
      if(colorPalette.length === 0)
      {
        createColorPalette();
      }
      return colorPalette;
    };

    line.shapePalette = function(){
      if(!arguments.length){
        return [props.marker.shape];
      }
      return line;
    };

    line.primaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis1Data.scale;
      }
      valueAxis1Data.scale = scale;
      return line;
    };

    line.secondaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis2Data.scale;
      }
      valueAxis2Data.scale = scale;
      return line;
    };

    line.categoryScale = function(scale)
    {
      if(!arguments.length)
      {
        return xScale;
      }
      xScale = scale;
      return line;

    };

    line.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis1Data.scale.domain()[0],
          max: valueAxis1Data.scale.domain()[1]
        };
      }
      
      if (range !== null) {
          valueAxis1Data.topValue = range.max;
          valueAxis1Data.bottomValue = range.min;
          if (range.from === 'axis') {
            valueAxis1Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis1Data);
          }
      }
      return line;
    };

    line.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis2Data.scale.domain()[0],
          max: valueAxis2Data.scale.domain()[1]
        };
      }
      if (range !== null) {
          valueAxis2Data.topValue = range.max;
          valueAxis2Data.bottomValue = range.min;
          if (range.from === 'axis') {
            valueAxis2Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis2Data);
          }
      }
      return line;
    };
    line.parent = function() { 
      return g;
    };

    /**
     * get/set size
     */
    line.size = function(w, h) {
      if (arguments.length === 0){
        return {
          width : line.width(),
          height : line.height()
        };
      }
      line.width(w).height(h);
      return line;
    };
    
    line.clear = function (gray) {
      deselectedAllHandler();
      if (gray === null || gray === undefined){
        lightAll();
      } else {
        grayAll();
      }
    };

    line.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }

      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        if(!processOneAxisSelect(valueAxis1Data, marker )){
          processOneAxisSelect(valueAxis2Data, marker );}

      }
    };

    line.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];

        if(!processOneAxisDeselect(valueAxis1Data, marker)){
          processOneAxisDeselect(valueAxis2Data, marker);
        }
      }

    };
    
    line.hoverOnPoint = function(point)
    {  
      var point0 = point.x, point1 = point.y;
      if(point0 < 0 || point0 > width){
        return;
      }

      var xIndex = getCategoryIndex(point0);
      if(preHighLightIndex === xIndex) { return; }
      var xCoord = xScale(xIndex) + xScale.rangeBand() / 2;
      changeGroupMarker(preHighLightIndex, "hidden", props.style.marker.stroke);
      changeGroupMarker(xIndex, "visible", bgColor);  

      preHighLightIndex = xIndex;


      if (props.hoverline.visible) {
        mouseMoveLine.attr("x1", xCoord).attr("x2", xCoord);
        mouseMoveLine.attr("visibility", "visible");
      } else {
        mouseMoveLine.attr("visibility", "hidden");
      }

      if (props.tooltip.enabled) {
        var pt = {};
        var matrix = g.node().getTransformToElement(g.node().ownerSVGElement);
        pt.x = xScale(xIndex) + xScale.rangeBand() / 2 + matrix.e;
        pt.y = height / 4 + matrix.f;
        //var globalPoint = pt.matrixTransform(g.node().parentNode.parentNode.getScreenCTM().inverse());
        //var tData = generateTooltipData(xIndex);
        //alex su
        var tData = _tooltipDataHandler.generateTooltipData(data_, 
               tooltipData, 
               xIndex, 
               colorPalette, 
               [props.marker.shape]);
        tData.point = pt;
        tData.plotArea = {
          x : matrix.e,
          y : matrix.f,
          width : width,
          height : height
        };
        eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }

    };

    line.blurOut = function()
    {  
      mouseMoveLine.attr("visibility", "hidden");
      changeGroupMarker(preHighLightIndex, "hidden", props.style.marker.stroke);
      preHighLightIndex = null;
      if (props.tooltip.enabled) { 
        eDispatch.hideTooltip();
      }
    };
    
    props = manifest.props(null);
    return line;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.line',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.line',
    'name' : 'line',
     base : 'sap.viz.modules.xy.base',
    'properties' : {
    'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'width' : {
        'name' : 'width',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 2,
        'min' : '1',
        'max' : '7',
        'description' : 'Set width of line, range[1,7]. When beyond the range, the line width is default size 2.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            }
          },
          'description' : 'Settings for tooltip related properties.'
     },
      'hoverline' : {
          'name' : 'hoverline',
          'supportedValueType' : 'Object',
          'description' : 'Settings for hoverline properties.',
          'supportedValues' : {
            'visible' : {
              'name' : 'visible',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set to enabled/disabled hoverline or not.',
            },
          },
      },
      'marker' : {
        'name' : 'marker',
      'description': 'Settings for marker/data point graphics',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set show marker or not.'
          },
          'shape' : {
            'name' : 'shape',
            'supportedValueType' : 'List',
        'supportedValues' : ['circle', 'diamond', 'triangle-up', 'triangle-down', 'triangle-left', 'triangle-right', 'cross', 'intersection'],
            'defaultValue' : 'circle',
            'description' : 'Set marker shapes for chart.'
          },
          'size' : {
            'name' : 'size',
            'supportedValueType' : 'PositiveInt',
            'defaultValue' : "6",
            'min' : '4',
            'max' : '32',
            'description' : 'Set marker size of data point, range[4,32]. When beyond the range, the marker size is default size 6.'
          }
        }
      }
    },
    'css' : {     
      '.viz-plot-hoverline': {
          'description' : 'Define style for hoverline in line.',
          'value' : {
            'stroke' : '#cccccc'
          }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.horizontalline',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(dispatch, MNDHandler, TypeUtils, Scaler, ColorSeries, BoundingBox, NumberUtils, langManager, DrawUtil, TooltipDataHandler, Manifest, Repository, Objects,UADetector,BoundUtil) 
{
  return function(manifest, ctx) 
  {
    var width, height;
    var data_ = null, props;
    var randomSuffix = Repository.newId();
    //alex su
    var tooltipData = null;
    var _tooltipDataHandler;

    var bgColor = "#FFFFFF";
    var hoverColor = "gray";
    var selectedColor = "#333333";
    var xScale = d3.scale.ordinal();
    var mouseMoveLine;
    var preHighLightIndex;
    var g;
    var svgMarkersGroup, svgLinesGroup, svgLightLinesGroup;
    var eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    var hasMND;
    var bMNDOnColor;
    var bMNDInner;
    var effectManager = ctx.effectManager;
    var valueAxis1Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };

    var valueAxis2Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };
    var colorPalette = [];
    var PREFIXAXIS1 = 'axis1';
    var PREFIXAXIS2 = 'axis2';

    var bAnimationComplete = false;
    var enableDataLoadingAnimation = true;

    var selectedMarkerNum = 0;

    // clip defs for enimation

    var clipRect;    
    var OPACITY = 0.4;

    function horizontalline(selection) {
      BoundUtil.drawBound(selection, width, height);
      //selection.each(generate);
      
      //alex su
      _tooltipDataHandler = TooltipDataHandler();
      
      renderChart(selection);
      return horizontalline;
    }

   
    function calculateMinMax(axisValue)
    {
      var minMax = {
          min:null,
          max:null
      };
      if(!axisValue.data || axisValue.data.length === 0){
        return null;
      }
      minMax.max = Number(d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      }));
      minMax.min = Number(d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      }));
      if(NumberUtils.isNoValue(minMax.max )) {
        return null;
      }
      if(minMax.min >= 0)
      {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / width ;
      }
      else if(minMax.max <= 0){
        minMax.max = 0;
        minMax.min +=  minMax.min * 5 / width;
      }else{
        var temp = (minMax.max - minMax.min) * 5 / width;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }

    function createColorPalette()
    {
      colorPalette = [];
      var i = 0, j = 0;
      if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
        valueAxis1Data.colorPalette = props.primaryValuesColorPalette ;
      } else { 
        valueAxis1Data.colorPalette = props.colorPalette;
      }

      valueAxis2Data.colorPalette = props.secondaryValuesColorPalette;
      
      if (hasMND && bMNDOnColor && bMNDInner) {
        var dva1 = data_.getMeasureValuesGroupDataByIdx(0);
        var dva2 = data_.getMeasureValuesGroupDataByIdx(1);
        var mg1mNum=0, mg2mNum=0, mNum=0, colorAxisDataNum=0;
        if (dva1 && dva1.values.length>0) { 
          mg1mNum = dva1.values.length;
          colorAxisDataNum = dva1.values[0].rows.length;
        }
        if (dva2 && dva2.values.length>0) {
          mg2mNum = dva2.values.length;
          colorAxisDataNum = dva2.values[0].rows.length;
        }

        for (i=0; i<colorAxisDataNum; i++) {
          for (j=0; j<mg1mNum; j++) {
            colorPalette.push(valueAxis1Data.colorPalette[i*mg1mNum+j % valueAxis1Data.colorPalette.length]);
          }
          for (j=0; j<mg2mNum; j++){
            colorPalette.push(valueAxis2Data.colorPalette[i*mg2mNum+j % valueAxis2Data.colorPalette.length]);
          }
        }
      } else {
        for(i = 0; i < valueAxis1Data.data.length; ++i){
          colorPalette.push(valueAxis1Data.colorPalette[i % valueAxis1Data.colorPalette.length]);
        }
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0)
        {
          for(i = 0; i < valueAxis2Data.data.length; ++i){
            colorPalette.push(valueAxis2Data.colorPalette[i % valueAxis2Data.colorPalette.length]);
          }
        }
      }
    }

    function calculateScale(axisValue)
    {
      if(axisValue.data && axisValue.data.length > 0 )
      {
        if( axisValue.topValue === null || axisValue.topValue === undefined)
        {
          var minMax = calculateMinMax(axisValue);
          if(!minMax || (minMax.min === 0 && minMax.max === 0)){
            axisValue.scale.domain([]).range ([]);
          } else {
            axisValue.scale.domain([minMax.min, minMax.max]).range ([0, width]);
          }
        }
        else{
          axisValue.scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([0, width]);
        }
      }
      else{
        axisValue.scale.domain([0,0]).range([0,0]);
      }
      return axisValue.scale;
    }

    function computeScales()
    {
      var domain = [];
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      for (var i=0; i < categoryNum; i++){
        domain.push(i);
      }
      xScale.domain(domain).rangeBands([height, 0]);
      calculateScale(valueAxis1Data);
      calculateScale(valueAxis2Data);
      if (valueAxis1Data.data && valueAxis1Data.data.length > 0 &&
            valueAxis2Data.data && valueAxis2Data.data.length > 0 ) {
        
        if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([0, width]); 
          valueAxis2Data.scale.domain([0, 1]).range ([0, width]); 
        } else if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length !== 0){
          valueAxis1Data.scale.domain(valueAxis2Data.scale.domain()).range(valueAxis2Data.scale.range());
        } else if(valueAxis1Data.scale.domain().length !== 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain(valueAxis1Data.scale.domain()).range(valueAxis1Data.scale.range());
        }
        
        if (!valueAxis1Data.manualRange && !valueAxis2Data.manualRange) {
            Scaler.perfectDual(valueAxis1Data.scale, valueAxis2Data.scale);
        } else if (!valueAxis1Data.manualRange) {
            Scaler.perfect(valueAxis1Data.scale);
        } else if (!valueAxis2Data.manualRange) {
            Scaler.perfect(valueAxis2Data.scale);
        }
      } else if (valueAxis1Data.data && valueAxis1Data.data.length > 0 && !valueAxis1Data.manualRange) {
        if(valueAxis1Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([0, width]);
        }
        Scaler.perfect(valueAxis1Data.scale);
      } else if (valueAxis2Data.data && valueAxis2Data.data.length > 0 && !valueAxis2Data.manualRange) {
        if(valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain([0, 1]).range ([0, width]);
        }
        Scaler.perfect(valueAxis2Data.scale);
      }
    }

    function changeGroupMarker(groupIndex, visible, borderColor)
    {
      if(groupIndex === undefined || groupIndex === null){
        return;
      }
      var seriesIndex = 0;
      for(seriesIndex = 0; seriesIndex < valueAxis1Data.data.length; ++seriesIndex)
      {   
        if(!valueAxis1Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, borderColor, valueAxis1Data);
          if(!props.marker.visible)
          {
            if(selectedMarkerNum > 0){
              d3.select(valueAxis1Data.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", visible);
            }else{
              d3.select(valueAxis1Data.markers[seriesIndex][groupIndex]).attr("opacity", 1).attr("visibility", visible);
            }
          }
        }
      }  

      if(!valueAxis2Data.data) {return;}

      for(seriesIndex = 0; seriesIndex < valueAxis2Data.data.length; ++seriesIndex)
      {
        if(!valueAxis2Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, borderColor, valueAxis2Data);
          if(!props.marker.visible)
          {
            if(selectedMarkerNum > 0){
              d3.select(valueAxis2Data.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", visible);
            }else{
              d3.select(valueAxis2Data.markers[seriesIndex][groupIndex]).attr("opacity", 1).attr("visibility", visible);
            }
          }
        }
      }
    }



    function changeOneMarker(seriesIndex, xIndex, borderColor, valueAxis)
    {
      d3.select(valueAxis.markers[seriesIndex][xIndex]).attr("stroke",  borderColor);
    }

    function getCategoryIndex(val)
    {
      var index = val / xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }      
      if(index > categoryNum - 1) { index = categoryNum - 1;}
      if(index < 0){ index = 0;}
      return categoryNum - 1 - index;
    }

    function processOneAxisSelect(valueAxis, marker) {
      var findFlag = false, yi, xi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } //for j
      }//for i

      if (!findFlag) {
        return false;
      }

      if (valueAxis.selectedMarkers[yi][xi]) {
        return true;
      }

      changeOneMarker(yi, xi, selectedColor, valueAxis);
      d3.select(valueAxis.markers[yi][xi]).attr("opacity", 1).attr("visibility", "visible");
      valueAxis.selectedMarkers[yi][xi] = true;
    
      if(xi > 0 && valueAxis.selectedMarkers[yi][xi - 1]){
        valueAxis.highLines[yi][xi - 1].attr("visibility", "visible");
      }
      if(xi < valueAxis.highLines[0].length && valueAxis.selectedMarkers[yi][xi + 1]){
        valueAxis.highLines[yi][xi].attr("visibility", "visible");
      }
      
      ++selectedMarkerNum;
    }

    function processOneAxisDeselect (valueAxis, marker) {
      var xi = preHighLightIndex;

      var findFlag = false, yi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } 
      }

      if (!findFlag) {
        return false;
      }

      if (!valueAxis.selectedMarkers[yi][xi]){
        return true;
      }

      if(xi === preHighLightIndex){
        changeOneMarker(yi, xi, bgColor, valueAxis);
      }
      else{
        changeOneMarker(yi, xi, props.style.marker.stroke, valueAxis);
      }
      
      d3.select(valueAxis.markers[yi][xi]).attr("opacity", OPACITY );
      if(!props.marker.visible && xi !== preHighLightIndex){
        d3.select(valueAxis.markers[yi][xi]).attr("visibility", "hidden");
      }
      valueAxis.selectedMarkers[yi][xi] = false;
  
      if(xi > 0 && valueAxis.selectedMarkers[yi][xi - 1]){
        valueAxis.highLines[yi][xi - 1].attr("visibility", "hidden");
      }
      if(xi < valueAxis.highLines[0].length && valueAxis.selectedMarkers[yi][xi + 1]){
        valueAxis.highLines[yi][xi].attr("visibility", "hidden");
      }
  
      --selectedMarkerNum;
    }

    
    function processNullValue(axisValue)
    {
      var result = {
          data:[],
          color:[]
      };
      var arr = [], obj, k;

      for(var i = 0; i < axisValue.length; ++i)
      {
        var preIndex = 0;
        for(var j = 0; j < axisValue[i].length; ++j)
        {
          if(NumberUtils.isNoValue(axisValue[i][j].val))
          {
            if(j > preIndex)
            {
              arr = [];
              for(k = preIndex; k < j; k++)
              {
                obj = axisValue[i][k];
                obj.x = k;  
                arr.push(obj);
              }
              result.data.push(arr);
              result.color.push(i);
            }
            preIndex = j + 1;
          }
        }
        
        if(preIndex < axisValue[i].length)
        {
          arr = [];
          for(k = preIndex; k <  axisValue[i].length; k++)
          {
            obj = axisValue[i][k];
            obj.x = k;
            arr.push(obj);
          }
          result.data.push(arr);
          result.color.push(i);
        }
      }
      return result;
    }
    
    function processOneAxis(axisValue, prefix)
    {
      if(!axisValue.data || axisValue.data.length === 0){
        return;
      }
      var axisGroup = svgLinesGroup.select("g." + prefix);
      if(axisGroup.empty())
      {
        axisGroup = svgLinesGroup.append("svg:g").attr("class", prefix);
      }
      axisValue.selectedMarkers = new Array(axisValue.data.length);
      axisValue.markers = [];
      var result = processNullValue(axisValue.data);
      
      var lines = axisGroup.selectAll("." + "lines").data(result.data);
      
      lines.enter().append("path").attr('class', "lines")
        .attr("stroke-width", props.width).attr("stroke-linejoin", "round");
      lines.exit().remove();
      lines.attr("stroke-width", props.width);//@Alex: add this line to update attributes.       
      var line = d3.svg.line().y(function(d,i) { return xScale(d.x) + xScale.rangeBand() / 2; }).x(function(d) {  return axisValue.scale(d.val); });
      lines.attr("transform", 
          function(d, i) {
            d3.select(this).attr("d", line(d))
            .attr("stroke",  function (){
                var para = { graphType:"line", 
                fillColor:axisValue.colorPalette[result.color[i] %  axisValue.colorPalette.length]};
                return effectManager.register(para);
                });
      });
      
      // draw highlight lines
      var lightLineGroup = svgLightLinesGroup.selectAll("g." + prefix);
      if(lightLineGroup.empty())
      {
        lightLineGroup = svgLightLinesGroup.append("svg:g").attr("class", prefix);
      }
      var groups = lightLineGroup.selectAll("g").data(axisValue.data);
      groups.enter().append("g");
      groups.exit().remove();
      axisValue.highLines = [];
      groups.attr("transform", function(d,i){
         d3.select(this).selectAll(".lightLine").remove();
        axisValue.highLines.push([]);
        for(var j = 1 ; j < d.length; ++j)
        {
          if(NumberUtils.isNoValue(d[j].val) || NumberUtils.isNoValue(d[j-1].val) ){
            axisValue.highLines[i].push(null); 
          } else {
            axisValue.highLines[i].push(d3.select(this).append("svg:line").attr("class", "lightLine").attr("x1", axisValue.scale(d[j-1].val)).
              attr("y1", xScale(j-1) + xScale.rangeBand() / 2).attr("x2",axisValue.scale(d[j].val)).attr("y2", xScale(j) + xScale.rangeBand() / 2)
              .attr("stroke-width", props.width).attr("stroke",  
                  axisValue.colorPalette[i %  axisValue.colorPalette.length]).attr("visibility", "hidden"));    
          }
        }
        
      });
      
      // draw markers
      for(var seriesIndex = 0; seriesIndex < axisValue.data.length; ++seriesIndex)
      {
        axisValue.selectedMarkers[seriesIndex] = [];
        for(var dataIndex = 0; dataIndex < axisValue.data[0].length; ++dataIndex)
        {
          axisValue.selectedMarkers[seriesIndex][dataIndex] = false;
        }
      }
      var markerGroup = svgMarkersGroup.select("g." + prefix);
      if(markerGroup.empty()){
        markerGroup = svgMarkersGroup.append("svg:g").attr("class", prefix);
      }
      groups = markerGroup.selectAll("g.marker").data(axisValue.data);
      groups.enter().append("svg:g").attr("class", "marker");
      groups.exit().remove();
      
      var visible = "hidden";
      if(props && props.marker && props.marker.visible){
        visible  = "visible";
      }
      groups.attr("transform", function(d, i) {
        
        var seriesMarkers = d3.select(this).selectAll(".datashape").data(d);
        var datashape = seriesMarkers.enter().append('g').attr('class','datashape');
        
        DrawUtil.createElements(datashape,{shape: props.marker.shape, className: "datapoint"} );
        seriesMarkers.exit().remove();
        var markerArr = [];
        seriesMarkers.attr("transform",function(point, index)
        {   
          if(NumberUtils.isNoValue(point.val))
          { 
              d3.select(this).remove();
              markerArr.push(null);
              return;
          }
          markerArr.push(d3.select(this).selectAll('path').node());
          
          var parameter = {
              drawingEffect: props.drawingEffect,
              graphType: props.marker.shape,
              fillColor: axisValue.colorPalette[i % axisValue.colorPalette.length],
              direction :'vertical',
              rx: props.marker.size / 2,
              ry: props.marker.size / 2,
              borderWidth: 2,
              borderColor: props.style.marker.stroke,
              node:d3.select(this).select('path'),
              visibility: visible
          };
          DrawUtil.drawGraph(parameter, effectManager);
          return "translate(" + axisValue.scale(point.val)+ "," + (xScale(index) + xScale.rangeBand() / 2)  + ")"; 
        });

        axisValue.markers.push(markerArr);
      });
    }

    function processOneAxisDeselectAll(valueAxis,  xIndex)
    {
      if(selectedMarkerNum === 0 || !valueAxis.selectedMarkers || valueAxis.selectedMarkers.length === 0){
        return;
      }
      
      for(var seriesIndex = 0; seriesIndex < valueAxis.selectedMarkers.length; ++seriesIndex)
      {
        for(var groupIndex = 0; groupIndex < valueAxis.selectedMarkers[0].length; ++groupIndex)
        {
          if(!valueAxis.selectedMarkers[seriesIndex][groupIndex]) {continue;}
          
          if(groupIndex === xIndex)
          {
            changeOneMarker(seriesIndex, groupIndex, bgColor, valueAxis);
            if(!props.marker.visible){
              d3.select(valueAxis.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY ).attr("visibility", "visible");
            }
          }
          else
          {
            changeOneMarker(seriesIndex, groupIndex, props.style.marker.stroke, valueAxis);
            if(!props.marker.visible){
              d3.select(valueAxis.markers[seriesIndex][groupIndex]).attr("visibility", "hidden");
            }
          }
          valueAxis.selectedMarkers[seriesIndex][groupIndex] = false;
        }
      }
    }

    function deselectedAllHandler()
    {
      var ypoint =  (d3.event ? d3.event.clientY : 0) - g.node().getBoundingClientRect().top ;
      var xIndex = getCategoryIndex(ypoint);
      processOneAxisDeselectAll(valueAxis1Data, xIndex);
      processOneAxisDeselectAll(valueAxis2Data, xIndex);
      selectedMarkerNum = 0;
    }

    
    
    function renderChart(selection)
    {
      getCSSStyle();
      eDispatch.startToInit();
      if(!g) {
        g = selection.append("svg:g");  
      }

      if(!mouseMoveLine){
        mouseMoveLine = g.append("svg:line");
      }

      mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", width).attr("y2", 0)
      .attr("stroke-width", 1).attr("stroke", hoverColor)
      .attr("visibility", "hidden").attr("stroke-linejoin", "round");
      if(!svgLinesGroup)
      {
        svgLinesGroup = g.append("svg:g").attr("class", "datalines");
        svgLightLinesGroup = g.append("svg:g").attr("class", "lightLines");
        svgMarkersGroup = g.append("svg:g").attr("class", "markers datashapesgroup");
      }
      if(!clipRect){
        clipRect = g.append("svg:defs").append("svg:clipPath").attr("id", "clip1_" + randomSuffix).append("rect");
      }
      
      clipRect.attr("x", 0).attr("y", (enableDataLoadingAnimation ? height : 0)).attr("height", (enableDataLoadingAnimation ? 0 : height)).attr("width", width);
      selectedMarkerNum = 0;
      lightAll();
      svgMarkersGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLightLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");

      if(enableDataLoadingAnimation)
      {
        bAnimationComplete = true;

        var totalNumber = 0;
        var interval = height / 50;
        var func = setInterval(function(d){
          if(totalNumber >= height)
          {
            clearInterval(func);
            eDispatch.initialized();
          }
          else
          {
            totalNumber += interval;
            clipRect.attr("height", totalNumber);
            clipRect.attr("y", height - totalNumber);
          }
        },
        20);
      }else{
        eDispatch.initialized();
      }
      processOneAxis(valueAxis1Data, PREFIXAXIS1);
      processOneAxis(valueAxis2Data, PREFIXAXIS2);

    }

    function lightAll() {
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS1).selectAll(".lightLine").attr("visibility", "hidden");
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS2).selectAll(".lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", 1);
      if(UADetector.isIE()){
        svgLinesGroup.selectAll(".lines").attr("visibility", "visible");
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.marker").selectAll(".datapoint").attr("opacity", 1);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.marker").selectAll(".datapoint").attr("opacity", 1);
    }

    function grayAll() {
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS1).selectAll(".lightLine").attr("visibility", "hidden");
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS2).selectAll(".lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", OPACITY);
      if(UADetector.isIE()){
        svgLinesGroup.selectAll(".lines").attr("visibility", "visible");
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.marker").selectAll(".datapoint").attr("opacity", OPACITY);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.marker").selectAll(".datapoint").attr("opacity", OPACITY);
    }
    
    function getCSSStyle() {
      if (!props.style){
        props.style = {};
      }
      
      var cssDef;
      cssDef = ctx.styleManager.query('viz-plot-background');
      if (cssDef) {
        if (cssDef['fill']) {
          bgColor = cssDef['fill'];
        }
      }
      
      if (!props.style.marker)
      {
        props.style.marker = {};
      }
      props.style.marker.stroke = "transparent";
   
      cssDef = ctx.styleManager.query('viz-plot-hoverline');
      if(cssDef)
      {
        if (cssDef['stroke']){
          hoverColor = cssDef['stroke'];
        }
      }
    }
    
    horizontalline.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    
    horizontalline.width = function(value) {
      if (!arguments.length){
        return width;
      }
      width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return horizontalline;
    };

    horizontalline.height = function(value) {
      if (!arguments.length){
        return height;
      }
      height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return horizontalline;
    };
    
    /*;
     * get/set properties
     */
    horizontalline.properties = function(_) {
      if (!arguments.length){
        return props;
      }
        
      Objects.extend(true, props, _);
      if(props.marker.size < 4 || props.marker.size > 32) { props.marker.size = 6;}
      if(props.width < 1 || props.width > 7) {props.width = 2;}
      enableDataLoadingAnimation =  props.animation.dataLoading;
      
      getCSSStyle();
      
      createColorPalette();
      return horizontalline;
    };
    
    horizontalline.primaryAxisColor = function(){
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
          return effectManager.register({graphType:"line", fillColor: valueAxis1Data.colorPalette[0]});
        }else{
          return null;
        }
      };
        
      horizontalline.secondAxisColor = function(){
        return effectManager.register({graphType:"line", fillColor:  valueAxis2Data.colorPalette[0]});
      };     
    /**
     * get/set your event dispatch if you support event
     */
    horizontalline.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return horizontalline;
    };
          
    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    horizontalline.data = function(value){
      if (!arguments.length){
        return data_;
      }
      data_ = value;
      var obj = MNDHandler(data_);
      valueAxis1Data.data = obj["MG1"];
      valueAxis2Data.data = obj["MG2"];

      hasMND = obj["hasMND"];
      bMNDOnColor = obj["MNDOnColor"];
      bMNDInner = obj["MNDInner"];
      //alex su
      tooltipData = TooltipDataHandler.dataTransform(obj);
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      createColorPalette();
      return horizontalline;        
    };

    horizontalline.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      horizontalline.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
    /**
     * get color palette
     */
    horizontalline.getColorPalette = function() {
      if(colorPalette.length === 0)
      {
        createColorPalette();
      }
      return colorPalette;
    };


    horizontalline.shapePalette = function(_){
      if(!arguments.length){
        return [props.marker.shape];
      }
      return horizontalline;
    };


    horizontalline.primaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis1Data.scale;
      }
      valueAxis1Data.scale = scale;
      return horizontalline;
    };

    horizontalline.secondaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis2Data.scale;
      }
      valueAxis2Data.scale = scale;
      return horizontalline;
    };

    horizontalline.categoryScale = function(scale)
    {
      if(!arguments.length)
      {
        return xScale;
      }
      xScale = scale;
      return horizontalline;

    };

    horizontalline.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis1Data.scale.domain()[0],
          max: valueAxis1Data.scale.domain()[1]
        };
      }
      if (range !== null) {
          valueAxis1Data.topValue = range.max;
          valueAxis1Data.bottomValue = range.min;
          if (range.from === 'axis') {
            valueAxis1Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis1Data);
          }
      }
      return horizontalline;
    };

    horizontalline.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis2Data.scale.domain()[0],
          max: valueAxis2Data.scale.domain()[1]
        };
      }
      if (range !== null) {
          valueAxis2Data.topValue = range.max;
          valueAxis2Data.bottomValue = range.min;
          if (range.from === 'axis') {
            valueAxis2Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis2Data);
          }
      }
      return horizontalline;
    };
    
    horizontalline.parent = function() { 
      return g;
    };
    
    horizontalline.dataLabel = function(_){
     
    }
    /**
     * get/set size
     */
    horizontalline.size = function(w, h) {
      if (arguments.length === 0){
        return {
          width : horizontalline.width(),
          height : horizontalline.height()
        };
      }
      horizontalline.width(w).height(h);
      return horizontalline;
    };
    
    horizontalline.clear = function (gray) {
      deselectedAllHandler();
      if (gray === null || gray === undefined){
        lightAll();
      } else {
        grayAll();
      }
    };

    horizontalline.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }

      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        if(!processOneAxisSelect(valueAxis1Data, marker )){
          processOneAxisSelect(valueAxis2Data, marker );
        }
      }
    };
    
    horizontalline.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];

        if(!processOneAxisDeselect(valueAxis1Data, marker)){
          processOneAxisDeselect(valueAxis2Data, marker);
        }
      }
    };
    horizontalline.hoverOnPoint = function(point)
    {  
      var point0 = point.x, point1 = point.y;
      if(point1 < 0 || point1 > height){
        return;
      }

      var xIndex = getCategoryIndex(point1);
      if(preHighLightIndex === xIndex) { return; }
      var yCoord = xScale(xIndex) + xScale.rangeBand() / 2;
      changeGroupMarker(preHighLightIndex, "hidden", props.style.marker.stroke);
      changeGroupMarker(xIndex, "visible", bgColor);  

      preHighLightIndex = xIndex;
      if (props.hoverline.visible) {
        mouseMoveLine.attr("y1", yCoord).attr("y2", yCoord);
        mouseMoveLine.attr("visibility", "visible");
      } else {
        mouseMoveLine.attr("visibility", "hidden");
      }
      if (props.tooltip.enabled) {
        var pt = {};
        var matrix = g.node().getTransformToElement(g.node().ownerSVGElement);
        pt.x = width * 3 / 4 + matrix.e;
        pt.y = yCoord + matrix.f;
        //var globalPoint = pt.matrixTransform(g.node().parentNode.parentNode.getScreenCTM().inverse());
        //var tData = generateTooltipData(xIndex);
        //alex su
        var tData = _tooltipDataHandler.generateTooltipData(data_, 
               tooltipData, 
               xIndex, 
               colorPalette, 
               [props.marker.shape]);
        tData.point = pt;
        tData.plotArea = {
            x : matrix.e,
            y : matrix.f,
            width : width,
            height : height
          };
        eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
    };
    
    horizontalline.blurOut = function()
    {  
      mouseMoveLine.attr("visibility", "hidden");
      changeGroupMarker(preHighLightIndex, "hidden", props.style.marker.stroke);
      preHighLightIndex = null;
      if (props.tooltip.enabled) { 
        eDispatch.hideTooltip();
      }
    };
    
    props = manifest.props(null);
    return horizontalline;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.horizontalline',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.horizontalline',
    'name' : 'horizontalline',
    base : 'sap.viz.modules.line',
    
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalCombinationChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalCombination',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
}
],
function Setup (Manifest) {
  var chart={
    base : 'riv/basehorizontalchart',
    id:'viz/horizontal_combination',
    name:'IDS_HORIZONTALCOMBINATIONCHART',
    modules:{
      tooltip : {
        configure : {
        properties : {
          chartType : 'horizontalline',
          orientation : 'left'
        }
        }
      },
      main:{
        controllers : {
          'interaction' : {
          id : 'sap.viz.modules.controller.interaction',
          configure : {
            propertyCategory : 'selectability'
          }
          }
        },        
        modules:{
          plot:{
            id:'sap.viz.modules.horizontalcombination',
            configure:{
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory:'plotArea'
            }
          },
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                position : 'outside'
              }
            }
          }
        }
      }
    },
    feeds : {
        secondaryValues: null
    },
    dependencies:{
      attributes:[
        {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
          targetModule:'legend',
          target:'shapes',
          sourceModule:'main.plot',
          source:'shapePalette'
        },{
            targetModule : 'legend',
            target : 'setSelectionMode',
            sourceModule : 'main.interaction',
            source : 'getSelectionMode'
        }
      ],
      events : [ 
        {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        }, {
            targetModule : 'main.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'legend',
            type : 'highlightedByLegend'
        }, {
                targetModule : 'legend',
              listener : 'deselectLegend',
              sourceModule : 'main.interaction',
              type : 'deselectLegend'
        } , {
          targetModule : 'main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'main.plot',
          type : 'startToInit.datalabel'
        } 
      ]      
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualHorizontalCombinationChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalCombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalCombination',
  version : '4.0.0'
}
],
 function Setup (Manifest, Constants) {
  var chart={
    id:'viz/dual_horizontal_combination',
    name:'IDS_DUALHORIZONTALCOMBINATIONCHART',
    base : 'viz/horizontal_combination',
    modules:{
      main:{
        modules:{
                  plot: {
                    configure: {
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: true
                        },
                        secondaryValuesColorPalette: {
                          isExported: true
                        },
                        dataShape:{
                          secondAxis:{
                            isExported: true
                          }
                        }
                      }
                    }
                  },
                  xAxis:{
                        id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                      propertiesOverride:{
                        title:{
                          applyAxislineColor:{
                            isExported: true
                          }
                        }
                      }
                    }
                  },
          'xAxis2' : {
            'id' : 'sap.viz.modules.axis',
            'configure' : {
                        'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
            'propertyCategory' : 'xAxis2',
            'properties' : {
              'type' : 'value',
              'position' : 'top',
              'gridline' : {
                'visible' : false
              }
            },
            propertiesOverride:{
              title:{
                applyAxislineColor:{
                  isExported: true
                }
              }
            }
            }
          }
          
        }
      }
    },
    feeds:{
      secondaryValues: {
        min: 1,
        max: Number.POSITIVE_INFINITY 
      }
    },
    dependencies:{
      attributes:[
        {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'main.xAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        },{
          targetModule : 'main.xAxis2',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'secondAxisColor'
        },{
          targetModule : 'main.xAxis',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'main.xAxis2',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'secondAxisTitle'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
          targetModule:'legend',
          target:'shapes',
          sourceModule:'main.plot',
          source:'shapePalette'
        }
      ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.CombinationChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
}
],
function Setup (Manifest) {
  var chart={
    base : 'riv/baseverticalchart',
    id:'viz/combination',
    name:'IDS_COMBINATIONCHART',
    modules:{
      tooltip : {
        configure : {
        properties : {
          chartType : 'line',
          orientation : 'left'
        }
        }
      },
      main:{
        controllers : {
          'interaction' : {
          id : 'sap.viz.modules.controller.interaction',
          configure : {
            propertyCategory : 'interaction'
          }
          }
        },        
        modules:{
          plot:{
            id:'sap.viz.modules.combination',
            configure:{
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory:'plotArea'
            }
          },
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                position : 'outside'
              }
            }
          }
        }
      }
    },
    feeds : {
          secondaryValues: null
    },
    dependencies:{
      attributes:[
        {
          targetModule : 'main.plot',
          target : 'primaryDataRange',
          sourceModule : 'main.yAxis',
          source : 'range'
        },{
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'main.yAxis',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
          targetModule:'legend',
          target:'shapes',
          sourceModule:'main.plot',
          source:'shapePalette'
        },{
            targetModule : 'legend',
            target : 'setSelectionMode',
            sourceModule : 'main.interaction',
            source : 'getSelectionMode'
        }
      ],
      events : [ 
        {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        }, {
            targetModule : 'main.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'legend',
            type : 'highlightedByLegend'
        }, {
                targetModule : 'legend',
              listener : 'deselectLegend',
              sourceModule : 'main.interaction',
              type : 'deselectLegend'
        },{
          targetModule : 'main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'main.plot',
          type : 'startToInit.datalabel'
        } 
      ]      
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualCombinationChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.CombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.0'
}
],
 function Setup (Manifest, Constants) {
  var chart={
    id:'viz/dual_combination',
    name:'IDS_DUALCOMBINATIONCHART',
    base : 'viz/combination',
    modules:{
      main:{
        modules:{
                  plot: {
                    configure: {
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: true
                        },
                        secondaryValuesColorPalette: {
                          isExported: true
                        },
                        dataShape:{
                          secondAxis:{
                            isExported: true
                          }
                        }
                      }
                    }
                  },
                  yAxis:{
                        id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                      propertiesOverride:{
                        title:{
                          applyAxislineColor:{
                            isExported: true
                          }
                        }
                      }

                    }
                  },
          yAxis2 : {
            id : 'sap.viz.modules.axis',
            configure : {
                        'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
            propertyCategory : 'yAxis2',
            properties : {
              type : 'value',
              position : 'right',
              gridline : {
                visible : false
              }
            },
            propertiesOverride:{
              title:{
                applyAxislineColor:{
                  isExported: true
                }
              }
            }
            }
          }
                  
        }
      }
    },
    feeds:{
      secondaryValues: {
        min: 1,
        max: Number.POSITIVE_INFINITY 
      }
    },
    dependencies:{
      attributes:[
        {
          targetModule : 'main.plot',
          target : 'primaryDataRange',
          sourceModule : 'main.yAxis',
          source : 'range'
        },{
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.plot',
          target : 'secondDataRange',
          sourceModule : 'main.yAxis2',
          source : 'range'
        },{
          targetModule : 'main.yAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'main.yAxis',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'primaryAxisTitle'
        }, {
          targetModule : 'main.yAxis2',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'secondAxisTitle'
        },{
          targetModule : 'main.yAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        },{
          targetModule : 'main.yAxis2',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'secondAxisColor'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
          targetModule:'legend',
          target:'shapes',
          sourceModule:'main.plot',
          source:'shapePalette'
        }
      ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.LineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/line',
    name : 'IDS_LINECHART',
    base: 'riv/baseverticalchart',
    
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'line',
            orientation : 'left'
          }
        }
      },
      main : {
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction',
                    properties : {
                      supportedEventNames: ['mouseup', 'mousemove']
                    }
                  }
                }
              },
        'modules' : {
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                position : 'outside',
                automaticInOutside : false,
                positionPreference : true
              }
            }
          },
          plot : {
            id : 'sap.viz.modules.line',
            configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        }
      }
     
    },
    feeds:{
      secondaryValues: null
    },
    dependencies : {
      attributes : [ {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'main.plot',
        target : 'primaryDataRange',
        sourceModule : 'main.yAxis',
        source : 'range'
      }, {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'primaryScale'
      }, {
      targetModule : 'main.yAxis',
      target : 'title',
      sourceModule : 'main.plot',
      source : 'primaryAxisTitle'
    }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      }, {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main.plot',
            type : 'initialized.interaction'
            }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
        }, {
            targetModule : 'legend',
          listener : 'deselectLegend',
          sourceModule : 'main.interaction',
          type : 'deselectLegend'
          }, {
            targetModule : 'main.dataLabel',
            listener : 'showLabel',
            sourceModule : 'main.plot',
            type : 'initialized.datalabel'
          }, {
            targetModule : 'main.dataLabel',
            listener : 'removeLabel',
            sourceModule : 'main.plot',
            type : 'startToInit.datalabel'
          } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.LineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/dual_line',
    name : 'IDS_DIUALLINECHART',
    base: 'viz/line',
    'modules' : {
    
      /**
       * 'sizeLegend' : {}
       */
      main : {
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction'
                  }
                }
              },
       
        modules : {
         
          /**
           * 'xAxis2' : { },
           */
        
            plot : {
              configure: {
                propertiesOverride:{
                  primaryValuesColorPalette:{
                    isExported: true
                  },
                  secondaryValuesColorPalette: {
                    isExported: true
                  }
                }
              }
            },
            yAxis:{
                  id : 'sap.viz.modules.axis',
             configure:{
                'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                propertiesOverride:{
                  title:{
                    applyAxislineColor:{
                      isExported: true
                    }
                  }
                }
              }
            },
          yAxis2 : {
            id : 'sap.viz.modules.axis',
            configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
              propertyCategory : 'yAxis2',
              properties : {
                type : 'value',
                position : 'right',
                gridline : {
                  visible : false
                }
              },
              propertiesOverride:{
                title:{
                  applyAxislineColor:{
                    isExported: true
                  }
                }
              }
            }
          }
      
        }
      }
    },
    
    feeds:{
      secondaryValues: {
        min : 1,
        max : Number.POSITIVE_INFINITY 
      },
       axisLabels:{
        acceptMND : -1,
        max: 1
        },
      regionColor:{
        acceptMND: 0
      }
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
      dependencies : {
        attributes : [ {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        }, {
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'getColorPalette'
        }, {
          targetModule : 'main.plot',
          target : 'primaryDataRange',
          sourceModule : 'main.yAxis',
          source : 'range'
        }, {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.plot',
          target : 'secondDataRange',
          sourceModule : 'main.yAxis2',
          source : 'range'
        }, {
          targetModule : 'main.yAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondaryScale'
        }, {
      targetModule : 'main.yAxis',
      target : 'title',
      sourceModule : 'main.plot',
      source : 'primaryAxisTitle'
      }, {
      targetModule : 'main.yAxis2',
      target : 'title',
      sourceModule : 'main.plot',
      source : 'secondAxisTitle'
      },{
            targetModule : 'main.yAxis',
            target : 'color',
            sourceModule : 'main.plot',
            source : 'primaryAxisColor'
          }, {
            targetModule : 'main.yAxis2',
            target : 'color',
            sourceModule : 'main.plot',
            source : 'secondAxisColor'
          },{
          targetModule : 'legend',
          target : 'shapes',
          sourceModule : 'main.plot',
          source : 'shapePalette'
        } ]
      }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/horizontal_line',
    name : 'IDS_HORIZONTALLINECHART',
    base : 'riv/basehorizontalchart',
    'modules' : {
     tooltip : {
        configure : {
          properties : {
            chartType : 'horizontalline',
            orientation : 'left'
          }
        }
      },
          
      'main' : {
         controllers : {
            'interaction' : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousemove']
                }
              }
            }
          },
        'modules' : {
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                position : 'outside',
                automaticInOutside : false,
                positionPreference : true
              }
            }
          },
          'plot' : {
            'id' : 'sap.viz.modules.horizontalline',
            'configure' : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              'propertyCategory' : 'plotArea'
            }
          }
        }
      }
    },
    feeds:{
      secondaryValues: null
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
    dependencies : {
      attributes : [ {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.xAxis',
        target : 'title',
        sourceModule : 'main.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapePalette'
      } , {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      }],
      events : [ {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      }, {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main.plot',
            type : 'initialized.interaction'
      }  , {
            targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
        }, {
            targetModule : 'legend',
          listener : 'deselectLegend',
          sourceModule : 'main.interaction',
          type : 'deselectLegend'
          }, {
            targetModule : 'main.dataLabel',
            listener : 'showLabel',
            sourceModule : 'main.plot',
            type : 'initialized.datalabel'
          }, {
            targetModule : 'main.dataLabel',
            listener : 'removeLabel',
            sourceModule : 'main.plot',
            type : 'startToInit.datalabel'
          }]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualHorizontalLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalLineChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    'id' : 'viz/dual_horizontal_line',
    'name' : 'IDS_DUALHORIZONTALLINECHART',
    'base' : 'viz/horizontal_line',
     'modules' : {
      
      /**
       * 'sizeLegend' : {}
       */
      'main' : {
        'id' : 'sap.viz.modules.xycontainer',
        'modules' : {
       
            plot: {
               configure: {
                propertiesOverride:{
                  primaryValuesColorPalette:{
                    isExported: true
                  },
                  secondaryValuesColorPalette: {
                    isExported: true
                  }
                }
              }
            },
            xAxis:{
                  id : 'sap.viz.modules.axis',
              configure:{
                'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                propertiesOverride:{
                  title:{
                    applyAxislineColor:{
                      isExported: true
                    }
                  }
                }
              }
            },
          'xAxis2' : {
            'id' : 'sap.viz.modules.axis',
            'configure' : {
                'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
              'propertyCategory' : 'xAxis2',
              'properties' : {
                'type' : 'value',
                'position' : 'top',
                'gridline' : {
                  'visible' : false
                }
              }
            },
            propertiesOverride:{
              title:{
                applyAxislineColor:{
                  isExported: true
                }
              }
            }
          }
          
        }
      }
    },
    
    feeds:{
      secondaryValues: {
        min : 1,
        max : Number.POSITIVE_INFINITY 
      },
      axisLabels:{
        acceptMND : -1,
        max: 1
        },
        regionColor:{
          acceptMND: 0
        }
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
    dependencies : {
      attributes : [ {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'secondaryScale'
      }, {
        targetModule : 'main.xAxis',
        target : 'title',
        sourceModule : 'main.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'main.xAxis2',
        target : 'title',
        sourceModule : 'main.plot',
        source : 'secondAxisTitle'
      }, {
          targetModule : 'main.xAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.xAxis2',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'secondAxisColor'
        },{
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapePalette'
      } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.stackedwaterfall',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, langManager, NumberUtils, Scaler, ColorSeries, Objects, TooltipDataHandler, boundUtil) {
  var stackedwaterfall = function(manifest, ctx) {
    var options, width, height, originData, chartData, primaryAxisMinValue, primaryAxisMaxValue, categoryLen, measureLength, 
        tooltipVisible, decorativeShape, barInfo, isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false,
        lastHovered = null, dimensionData, measureData, isShowTotal, isShowSubtotal,
        eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    var defaultString = langManager.get('IDS_ISNOVALUE'),
        colorPalette = ColorSeries.sap32().range(), 
        shapePalette = ['squareWithRadius'],
        totalIntervalTime = 1200, sWrapper;
    
    var effectManager = ctx.effectManager, drawingEffect = 'normal';
    
    var categoryScale = d3.scale.ordinal(), primaryScale = d3.scale.linear();

    var chart = function(selection) {
      boundUtil.drawBound(selection, width, height);
      
      if(!TypeUtils.isExist(primaryScale)){
        return;
      }
      selection.each(function(){
        //calculate information
        barInfo = _getBarInfo();
        var barSize = barInfo.barSize;
        //TODO start from zero. Do we support start from certain position? 
        var intialValue = 0;
        var interval = totalIntervalTime / categoryLen;
        
        sWrapper = d3.select(this);
        
        // append decorativeShape bar
        if (decorativeShape === undefined) {
          decorativeShape = sWrapper.append('rect').style('visibility', 'hidden').attr('fill', 'rgba(133,133,133, 0.2)');
        } else {
          decorativeShape.style('visibility', 'hidden');
        }
        //set decorative shape info.
        if(options.isHorizontal === false){
          decorativeShape.attr('width', categoryScale.rangeBand() - barInfo.barGap).attr('height', height);
        }else{
          decorativeShape.attr('height', categoryScale.rangeBand() - barInfo.barGap).attr('width', width);
        }
       
        if(isDataSchemaChanged === true){
          //Data structure changed. reset. 
          sWrapper.selectAll('g.waterfallgroup').remove();
          sWrapper.selectAll('g.datashapesgroup').remove();
        }
        //create stacked waterfall group
        var mainShapesWrapper = sWrapper.selectAll('g.datashapesgroup');
        if(mainShapesWrapper.empty()){
          mainShapesWrapper = sWrapper.append('g').attr('class', 'datashapesgroup');
        }
        var wrap = mainShapesWrapper.selectAll('g.waterfallgroup').data(chartData);
        wrap.enter().append('g').attr('class', 'waterfallgroup');
        wrap.exit().remove();
        
        var hasAnmation = true;
        if(isDataLoading){
          hasAnmation = options.animation.dataLoading;
        }else if(isDatasetChanged){
          hasAnmation = options.animation.dataUpdating;
        }else if(isSizeChanged){
          hasAnmation = options.animation.resizing;
        }
        
        wrap.each(function(dw, m){
          var categoryPos =  categoryScale(m) + barInfo.barGap;
          //each bar group
          var dataShape = d3.select(this).selectAll('g.datashape').data(function(){return dw.items;});
          var dataShapeEnter = dataShape.enter().append('g').attr('class','datashape');
          dataShapeEnter.append('rect').attr('class', 'datapoint').attr('fill-opacity', 1);
          
          if(!hasAnmation){
            //************No animation**************
            dataShape.exit().remove();
            
            dataShape.each(function(d, j){
              //each rect item
              var shapeWrap = d3.select(this);
              var rectElement = shapeWrap.selectAll('rect');
              if(options.isHorizontal === false){
                shapeWrap.attr('transform', function(){
                  var y=(d.val > 0) ? primaryScale(intialValue + d.after) : primaryScale(intialValue + d.before);
                  return 'translate('+categoryPos+','+y+')';
                });
                
                rectElement.attr('fill',function(){
                      var parameters = {
                      drawingEffect : drawingEffect,
                      fillColor : colorPalette[j % colorPalette.length],
                      direction : 'horizontal'
                    };
                    return effectManager.register(parameters);
                  })
                  .attr('width', barSize)
                  .attr('height', function(){
                    return Math.abs(primaryScale(d.after)-primaryScale(d.before));
                  });
              }else{
                shapeWrap.attr('transform', function(){
                  var x= (d.val > 0) ? primaryScale(intialValue + d.before) : primaryScale(intialValue + d.after);
                  return 'translate('+x+','+categoryPos+')';
                });
                
                rectElement.attr('fill',function(){
                      var parameters = {
                      drawingEffect : drawingEffect,
                      fillColor : colorPalette[j % colorPalette.length],
                      direction : 'vertical'
                    };
                    return effectManager.register(parameters);
                  })
                  .attr('height', barSize)
                  .attr('width', function(){
                    return Math.abs(primaryScale(d.after)-primaryScale(d.before));
                  });
              }
            });
            eDispatch.initialized();
          }else{
            //************with animation**************
            //Set enter data shape info
            if(options.isHorizontal === false){
              dataShapeEnter.selectAll('rect').attr('height', 0);
              dataShapeEnter.attr('transform', function(d){
                var y = primaryScale(intialValue + d.before); 
                return 'translate('+categoryPos+','+y+')';
              });
            }else{
              dataShapeEnter.selectAll('rect').attr('width', 0);
              dataShapeEnter.attr('transform', function(d){
                var x = primaryScale(intialValue + d.before);
                return 'translate('+x+','+categoryPos+')';
              });
            }
            //remove data shape
            dataShape.exit()
              .transition()
              .duration(interval)
              .attr('height', 0)
              .attr('width', 0)
              .remove();
            
            dataShape.each(function(d, j){
              //each rect item
              var rectElement = d3.select(this).selectAll('rect');
              if(options.isHorizontal === false){
                d3.select(this).transition()
                  .duration(interval)
                  .delay(function(){
                    return m*interval;
                  })
                  .attr('transform', function(){
                    var y = (d.val > 0) ? primaryScale(intialValue + d.after) : primaryScale(intialValue + d.before);
                    return 'translate('+categoryPos+','+y+')';
                  });
                
                rectElement.attr('fill',function(){
                  var parameters = {
                      drawingEffect : drawingEffect,
                      fillColor : colorPalette[j % colorPalette.length],
                      direction : 'horizontal'
                    };
                    return effectManager.register(parameters);
                  })
                  .attr('width', barSize)
                  .transition()
                    .duration(interval)
                    .delay(function(){
                      return m*interval;
                    })
                    .attr('height', function(){
                      return Math.abs(primaryScale(d.after)-primaryScale(d.before));
                    })
                    .each('end', function(){
                      if(m === categoryLen -1 && j === dw.items.length - 1){
                        eDispatch.initialized();
                      }
                    });
              }else{
                d3.select(this).transition()
                  .duration(interval)
                  .delay(function(){
                    return m*interval;
                  })
                  .attr('transform', function(){
                    var x = (d.val > 0) ? primaryScale(intialValue + d.before) : primaryScale(intialValue + d.after);
                    return 'translate('+x+','+categoryPos+')';
                  });
                rectElement.attr('fill',function(){
                  var parameters = {
                      drawingEffect : drawingEffect,
                      fillColor : colorPalette[j % colorPalette.length],
                      direction : 'vertical'
                    };
                    return effectManager.register(parameters);
                  })
                  .attr('height', barSize)
                  .transition()
                    .duration(interval)
                    .delay(function(){
                      return m*interval;
                    })
                    .attr('width', function(){
                      return Math.abs(primaryScale(d.after)-primaryScale(d.before));
                    })
                    .each('end', function(){
                      if(m === categoryLen -1 && j === dw.items.length - 1){
                        eDispatch.initialized();
                      }
                  });
              }
            });
          }
        });
        //reset flags
        isDataLoading = false;
        isSizeChanged = false;
        isDatasetChanged = false;
      });
    };
    chart.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    
    chart.hoverOnPoint = function(point) {
      var xOnModule = point.x, yOnModule = point.y;
      var posModule;
      if(options.isHorizontal === false){
        //vertical stacked waterfall bar chart
        posModule = xOnModule;
      }else{
        //horizontal stacked waterfall bar chart
        posModule = yOnModule;
      }
      // find the closet dimension
      var i = -1;
      var groupCount = chartData.length;
      while (i < groupCount) {
        if (Math.abs(posModule - categoryScale.rangeBand() * i - 0.5 * categoryScale.rangeBand()) <= 0.5 * categoryScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (groupCount - 1) || i < 0) {
        decorativeShape.style('visibility', 'hidden');
        return;
      }
      if(options.isHorizontal === false){
        decorativeShape.attr('x', categoryScale.rangeBand() * i + barInfo.barGap / 2);
      }else{
        decorativeShape.attr('y', categoryScale.rangeBand() * i + barInfo.barGap / 2 );
      }
      decorativeShape.style('visibility', 'visible');
      
      if (lastHovered !== i) {
        if (tooltipVisible) {
          lastHovered = i;
          // this.parentNode point to plot graphic. it is different from bar
          // chart as in bar chart it should get the yoffset which can get it
          // from mian graphic element
          var transform = sWrapper.node().getTransformToElement(sWrapper.node().ownerSVGElement);
          var tData = _getTooltipData(i);
          if (options.isHorizontal === false) {
            // vertical stacked waterfall bar chart
            tData.point = {
              x : categoryScale.rangeBand() * i + 0.5 * categoryScale.rangeBand() + transform.e,
              y : d3.event.layerY
            };
          } else {
            // horizontal stacked waterfall bar chart
            tData.point = {
              x : d3.event.layerY,
              y : categoryScale.rangeBand() * i + 0.5 * categoryScale.rangeBand() + transform.f
            };
          }
          
          eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
        }
      }

    };

    chart.blurOut = function() {
      decorativeShape.style('visibility', 'hidden');
      lastHovered = null;
      if (tooltipVisible) {
        eDispatch.hideTooltip();
      }
    };
  
    chart.highlight = function(elems) {
      if (elems instanceof Array) {
        for ( var i = 0, len = elems.length; i < len; i++) {
          elems[i].setAttribute('fill-opacity', 1);
        }
      } else {
        elems.setAttribute('fill-opacity', 1);
      }
    };

    chart.unhighlight = function(elems) {
      if (elems instanceof Array) {
        for ( var i = 0, len = elems.length; i < len; i++) {
          elems[i].setAttribute('fill-opacity', 0.2);
        }
      } else {
        elems.setAttribute('fill-opacity', 0.2);
      }
    };

    chart.clear = function(gray) {
      if (gray === undefined) {
        sWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
      } else {
        sWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
      }
    };

    chart.parent = function() {
      return sWrapper;
    };
    
    chart.data = function(_) {
      if (!arguments.length) {
        return originData;
      }
      originData = _;
      _parseOriginData(_);
      
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        _makeScale();
      }
      return chart;
    };

    chart.properties = function(props) {
      if (!arguments.length) {
        return options;
      }
      
      Objects.extend(true, options, props);
      colorPalette = options.colorPalette;
      drawingEffect = options.drawingEffect;
      tooltipVisible = options.tooltip.enabled;
      
      if(isShowTotal !== options.isShowTotal || isShowSubtotal !== options.subtotal.visible){
        //isShowTotal is changed, update dataset.
        isShowTotal = options.isShowTotal;
        isShowSubtotal = options.subtotal.visible;
        _parseOriginData(originData);
      }
      return chart;
    };

    chart.width = function(_) {
      if (!arguments.length) {
        return width;
      }
      isSizeChanged = (!isSizeChanged && (_ === width)) ? false : true;
      width = _;
      _makeScale();
      return chart;
    };

    chart.height = function(_) {
      if (!arguments.length) {
        return height;
      }
      isSizeChanged = (!isSizeChanged && (_ === height)) ? false : true;
      height = _;
      _makeScale();
      return chart;
    };

    chart.primaryAxisTitle = function(_) {
      if(!arguments.length){
        var titles =  originData.getMeasureValuesGroupDataByIdx(0), title = [];
        if(titles){
          for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
          }
        }
        return title.join('/');
      }
      return chart;
    };

    chart.secondAxisTitle = function(_) {
      if(!arguments.length){
        var titles =  originData.getMeasureValuesGroupDataByIdx(1), title = [];
        if(titles){
          for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
          }
        }
        return title.join('/');
      }
      return chart;
    };

    chart.categoryScale = function(scale) {
      if (!arguments.length) {
        return categoryScale;
      }
      categoryScale = scale;
      return chart;
    };

    chart.primaryScale = function(scale) {
      if (!arguments.length) {
        return primaryScale;
      }
      primaryScale = scale;
      return chart;
    };
    
    chart.colorPalette = function(_){
      if(!arguments.length){
        return colorPalette;
      }
      colorPalette = _;
      return this;
    };

    chart.dispatch = function(_) {
      if (!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return chart;
    };

    chart.dataLabel = function(_) {
      return chart;
    };
    
    chart.dimensionData = function(_){
      if (!arguments.length) {
        return dimensionData;
      }
      dimensionData = _;
    };
    
    var _getBarInfo = function(){
      //Calculate bar size and bar gap.
      var defaultBarSize = 2 * (categoryScale.rangeBand()) / 3;
      var defaultBarGap = defaultBarSize / 2;
      var customizeBarGap = options.barGap;
      var barGap = defaultBarGap, barSize = defaultBarSize;
      
      if(customizeBarGap !== undefined){
        var customizeBarSize = categoryScale.rangeBand() - customizeBarGap;
        if(!(customizeBarGap < 5 || customizeBarSize < 0)){
          barSize = customizeBarSize;
          barGap = customizeBarGap;
        }
      }
      
      //bar gap = single side gap width
      return {
        'barSize': barSize,
        'barGap' : barGap/2
      };
    };
    
    var _getTooltipData = function(index) {
      var body = {
        'name' : null,
        'val' : []
      };
      var aa1 = originData.getAnalysisAxisDataByIdx(0);
      var aa2 = originData.getAnalysisAxisDataByIdx(1);
      body.name = originData.getMeasureValuesGroupDataByIdx(0).values[0].col;
      var item, itemRows = measureData.values[0].rows, colorRows;
      if(aa2 !== null){
        colorRows = aa2.values[0].rows;
      }
      for(var i = 0; i < itemRows.length; i++){
        if(itemRows[i][index] !== undefined){
          item = {
            'shape' : 'squareWithRadius',
            'color' : colorPalette[i % colorPalette.length],
            'value' : itemRows[i][index]
          };
          if(colorRows!==undefined){
            item.label = colorRows[i];
          }
          body.val.push(item);
        }
      }
      var footer = {
        'label' : aa1.values[0].col,
        'value' : aa1.values[0].rows[index]
      };
      var tooltipData = {
        'body' : [],
        'footer' : []
      };
      tooltipData.body.push(body);
      tooltipData.footer.push(footer);
      return tooltipData;
    };
      
    var _makeScale = function(){
      var domain = [];
      for (var i=0; i < categoryLen; i++){
           domain.push(i);
      }
      //when all data is 0 or null, we make primaryScale.domain from 0 to 1
      if(options.isHorizontal === true){
        categoryScale.domain(domain).rangeBands([0, height]);
        if( primaryAxisMinValue === 0 && primaryAxisMaxValue === 0){
          primaryScale.domain([0, 1]).range([0, width]).nice();
        }else{
          primaryScale.domain([primaryAxisMinValue, primaryAxisMaxValue]).range([0, width]).nice();
        }
      }else{
        categoryScale.domain(domain).rangeBands([0, width]);
        if( primaryAxisMinValue === 0 && primaryAxisMaxValue === 0){
          primaryScale.domain([0, 1]).range([height, 0]).nice();
        }else{
          primaryScale.domain([primaryAxisMinValue, primaryAxisMaxValue]).range([height, 0]).nice();
        }
        
      }
      Scaler.perfect(primaryScale);
    };
    
    var _parseOriginData = function(data){
      //set dimension data for category axis
      dimensionData = {};
      measureData = {};
      dimensionData = data.getAnalysisAxisDataByIdx(0);
      $.extend(true, measureData, data.getMeasureValuesGroupDataByIdx(0));
      
      var obj = MNDHandler(data);
      var mgData = obj["MG1"], start = 0;  //default start position is 0
      isDataSchemaChanged = false;
      
      //Check update type: update dataset, data schema or data loading
      if(categoryLen===undefined && measureLength===undefined){
        //Data loading
        isDataLoading = true;
      }else{
        isDatasetChanged = true;
      }
      //Check new dataset structure. 
      if((categoryLen!==undefined && measureLength!==undefined) && (categoryLen !== mgData[0].length || measureLength !== mgData.length)){
        isDataSchemaChanged = true;
      }
      
      var positive_start, negative_start, totalValue = 0, eachValueItem = {}, items = [], itemValue, before, after, sum = 0; //total is for each bar group, sum means total value of all value 
      positive_start = negative_start = start;
      chartData = [], primaryAxisMinValue = 0, primaryAxisMaxValue = 0;
      
      categoryLen = mgData[0].length;
      measureLength = mgData.length;
      
      //check sub-group and add sub-total value
      var subIndex, tmpCategoryLen, subGroups;
      if(options.subtotal.visible === true){
        subIndex = 0;
        tmpCategoryLen = categoryLen;
        subGroups = options.subtotal.subGroups;
      }
      
      for ( var i = 0; i < categoryLen; i++) {
        //positive and negative start from the same position.
        positive_start = negative_start = start;
        //reset
        items = [], totalValue = 0;

        for ( var j = 0; j < measureLength; j++) {
          //Handle each value
          itemValue = _handleNullValue(mgData[j][i].val);
          if(itemValue !== defaultString){
            
            //except Null value
            totalValue = totalValue + itemValue;
            
            //adjust before and after value
            if(itemValue > 0){
              before = positive_start;
              after = positive_start + itemValue;
              positive_start = after;
            } else {
              before = negative_start;
              after = negative_start + itemValue;
              negative_start = after;
            }
            
            //Set primaryAxisMinValue, primaryAxisMaxValue
            if(after > primaryAxisMaxValue){
              primaryAxisMaxValue = after;
            }
            if(after < primaryAxisMinValue){
              primaryAxisMinValue = after;
            }
            
            eachValueItem = {
                "val": mgData[j][i].val,
                "before": before,
                "after": after,
                "ctx": mgData[j][i].ctx
            };
            items.push(eachValueItem);
          }
        }
        chartData.push({
          "total": totalValue,
          "start": start,
          "items": items
        });
        
        //reset sum
        sum = sum + totalValue;
        
        if(options.subtotal.visible === true){
          //Add sub-total value
          if(i === subGroups[subIndex] - 1){
            //last category bar in this bar group. And add sub-total
            if(options.subtotal.isRuntimeTotal){
              _addTotalItemToChartData(i+subGroups[subIndex], subIndex, start, totalValue, "sub-total-"+subIndex);
            }else{
              _addTotalItemToChartData(i+subGroups[subIndex], subIndex, 0, sum, "sub-total-"+subIndex);
            }
            subIndex++;
            tmpCategoryLen++;
          }
        }
        //reset start position.
        start = start + totalValue;
      }
      
      if(tmpCategoryLen !== undefined){
        categoryLen = tmpCategoryLen;
      }
      
      if(isShowTotal){
        _addTotalItemToChartData(categoryLen, subIndex, 0, sum, "total");
        categoryLen++;
      }
      
    };

    var _addTotalItemToChartData = function(index, subIndex, start, sum, dimensionName){
      chartData.push({
        "total": sum,
        "start": start,
        "items": [{
          "val": sum,
          "before": start,
          "after": start + sum,
          "ctx": {
            "path" : {
              "mg" : sum,
              "mi" : 0
            }
          }
        }]
      });
      dimensionData.values[0].rows.splice(index, 0, {val: dimensionName});
      measureData.values[0].rows[0].splice(index, 0, {val:sum});
      for(var i = 1; i < measureData.values[0].rows.length; i++){
        measureData.values[0].rows[i].splice(index, 0, undefined);
      }
    };
    
    var _handleNullValue = function(value){
      return (value === null || value === undefined) ? defaultString : value;
    };
    
    options = manifest.props(null);
    return chart;
  };
  return stackedwaterfall;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.StackedWaterfall',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.stackedwaterfall',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
    var module = {
      'id' : 'sap.viz.modules.stackedwaterfall',
      'name' : 'stackedwaterfall',
      base : "sap.viz.modules.xy.bar.base",
      'properties' : {
        'isRoundCorner' : null,
        'primaryValuesColorPalette' : null,
        'secondaryValuesColorPalette' : null,
        'isHorizontal' : {
          'name' : 'isHorizontal',
          'supportedValueType' : 'Boolean',
          'defaultValue' : false,
          'description' : 'Set stacked waterfall orientaion.',
          'isExported' : false
        },
        'isShowTotal' : {
          'name' : 'isShowTotal',
          'supportedValueType' : 'Boolean',
          'defaultValue' : false,
          'description' : 'Set stacked waterfall show/hide total value.',
          'isExported' : false
        },
        'subtotal' : {
          'name' : 'subtotal',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'visible' : {
              'name' : 'visible',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set visibility of subtotal.'
            }, 
            'isRuntimeTotal' : {
              'name' : 'isRuntimeTotal',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set isRuntimeTotal of subtotal.'
            },
            'subGroups' : {
              'name' : 'subGroups',
              'supportedValueType' : 'StringArray',
              'defaultValue' : [],
              'description' : 'Set bar groups.',
                'isExported' : false
            }
          },
          'isExported' : false,
          'description' : 'Settings for subtotal related properties.'
        },
        'barGap': {
          'name' : 'barGap',
          'supportedValueType' : 'PositiveInt',
          'defualtValue' : undefined,
          'min' : '5',
          'description': "Set the distance between bars. Default value is the same as bar size.",
          'isExported' : true
        }
      },
      fn : fn,
      'feeds' : {
        configure : {
          'secondaryValues' : null,
          'regionColor': {
            acceptMND : -1,
            min : 1,
            max : 1
          },
          'axisLabels' : {
            max : 1,
            acceptMND : -1
          },
          'primaryValues' : {
            max : 1
          }
        }
      }
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.StackedWaterfallChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedWaterfall',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/stacked_waterfall',
      name : 'IDS_STACKEDWATERFALLCHART',
      base : 'riv/baseverticalchart',
      modules : {
        main : {
        controllers : {
            'interaction' : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                }
              }
            }
          },
          modules : {
            plot : {
              id : 'sap.viz.modules.stackedwaterfall',
              configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
              }
            },
            dataLabel : {
              id : 'sap.viz.modules.datalabel',
              configure : {
                properties : {
                  automaticInOutside : false,
                  isStackMode : true,
                  showZero : false
                },
                propertiesOverride : {
                  position : {
                    isExported : false
                  }
                }
              }
            }
          }
        }
      },
      feeds : {
        axisLabels : {
          maxStackedDims : 1
        }
      },
      dependencies : {
        attributes : [ undefined, undefined, undefined,
         {
          targetModule : 'main.yAxis',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'main.yAxis',
          target : 'independentData',
          sourceModule : 'main.plot',
          source : 'dimensionData'
        } ],
       events : [ {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
        }, {
          targetModule : 'legend',
          listener : 'deselectLegend',
          sourceModule : 'main.interaction',
          type : 'deselectLegend'
        }, {
          targetModule : 'main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'main.plot',
          type : 'startToInit.datalabel'
        } ]
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalStackedWaterfallChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedWaterfall',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedWaterfallChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/horizontal_stacked_waterfall',
    name : 'IDS_HORIZONTALSTACKEDWATERFALL',
    base : "viz/stacked_waterfall",
    modules : {
      tooltip : {
        id : 'sap.viz.modules.tooltip',
        configure : {
          propertyCategory : 'tooltip',
          properties : {
            chartType : 'bar'
          }
        }
      },
      main : {
        modules : {
          plot : {
            id : 'sap.viz.modules.stackedwaterfall',
            configure : {
              propertyCategory : 'plotArea',
              properties : {
                'isHorizontal' : true
              }
            }
          },
          xAxis : {
            id : 'sap.viz.modules.axis',
            configure : {
              'description' : 'Settings for the value axis of an XY chart.',
              propertyCategory : 'xAxis',
              properties : {
                type : 'value',
                position : 'bottom',
                gridline : {
                  visible : true
                }
              }
            }
          },

          yAxis : {
            id : 'sap.viz.modules.axis',
            data : {
              aa : [ 1 ]
            },
            configure : {
              'description' : 'Settings for the category axis of an XY chart.',
              propertyCategory : 'yAxis',
              properties : {
                type : 'category',
                position : 'left',
                gridline : {
                  visible : false
                }
              },
              propertiesOverride : {
                gridline : {
                  isExported : false
                },
                label : {
                  isExported : false
                },
                axisline : {
                  isExported : false
                }
              }
            }
          },
          background : {
            id: 'sap.viz.modules.background',
            configure : {
              propertyCategory : 'background',
              properties : {
                direction : 'horizontal'
              }
            }
          },
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              properties : {
                automaticInOutside : false,
                isStackMode : true,
                showZero : false
              },
              propertiesOverride : {
                position : {
                  isExported : false
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      axisLabels : {
        maxStackedDims : 1
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScale'
      }, undefined, {
        targetModule : 'main.xAxis',
        target : 'title',
        sourceModule : 'main.plot',
        source : 'primaryAxisTitle'
      },{
        targetModule : 'main.xAxis',
        target : 'independentData',
        sourceModule : 'main.plot',
        source : 'dimensionData'
      } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.WaterfallChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedWaterfall',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/waterfall',
      name : 'IDS_WATERFALLCHART',
      base : 'riv/baseverticalchart',
      modules : {
          legend : null,        
          main : {
      controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction',
                    properties : {
                      supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                    }
                  }
                }
              },
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      showZero : false,
                      outsideVisible : false
                    }
                  }
                },
                plot : {
                    id : 'sap.viz.modules.stackedwaterfall',
                    configure : {
                        'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea',
                        propertiesOverride : {
                          isShowTotal : {
                            isExported : true
                          }
                        }
                    }
                }
              }
          }
      },
      feeds:{
        'regionColor' : null
      },
      dependencies : {
          attributes : [ {
            targetModule : 'main.yAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'primaryScale'
          },{
            targetModule : 'main.xAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'categoryScale'
          },null,{
      targetModule : 'main.yAxis',
            target : 'title',
            sourceModule : 'main.plot',
            source : 'primaryAxisTitle'
      }],
           events : [ {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main.plot',
            type : 'initialized.interaction'
          }, {
            targetModule : 'main.dataLabel',
            listener : 'showLabel',
            sourceModule : 'main.plot',
            type : 'initialized.datalabel'
          }, {
            targetModule : 'main.dataLabel',
            listener : 'removeLabel',
            sourceModule : 'main.plot',
            type : 'startToInit.datalabel'
          } ]
        }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalWaterfallChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedWaterfall',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/horizontal_waterfall',
      name : 'IDS_HORIZONTALWATERFALLCHART',
      base : 'riv/basehorizontalchart',
      modules : {
          legend : null, 
          main : {
            controllers : {
                  'interaction' : {
                    id : 'sap.viz.modules.controller.interaction',
                    configure : {
                      propertyCategory : 'interaction',
                      properties : {
                        supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                      }
                    }
                  }
              },
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      showZero : false,
                      outsideVisible : false
                    }
                  }
                },
                plot : {
                    id : 'sap.viz.modules.stackedwaterfall',
                    configure : {
                        'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea',
                        properties : {
                          'isHorizontal' : true
                        },
                        propertiesOverride : {
                          isShowTotal : {
                            isExported : true
                          }
                        }
                    }
                }
              }
          }
      },
      feeds:{
        'regionColor' : null
      },
      dependencies : {
          attributes : [ {
            targetModule : 'main.xAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'primaryScale'
          },{
            targetModule : 'main.yAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'categoryScale'
          },null,{
        targetModule : 'main.xAxis',
            target : 'title',
            sourceModule : 'main.plot',
            source : 'primaryAxisTitle'
      }],
          events : [ {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main.plot',
            type : 'hideTooltip'
          }, {
              targetModule : 'main.interaction',
              listener : 'registerEvent',
              sourceModule : 'main.plot',
              type : 'initialized.interaction'
           }, {
             targetModule : 'main.dataLabel',
             listener : 'showLabel',
             sourceModule : 'main.plot',
             type : 'initialized.datalabel'
           }, {
             targetModule : 'main.dataLabel',
             listener : 'removeLabel',
             sourceModule : 'main.plot',
             type : 'startToInit.datalabel'
           } ]
        }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/dual_bar',
    name : 'IDS_DUALBARCHART',
    base : 'viz/bar',
      modules : {
          main : {
              modules : {
                plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
                xAxis:{
                      id : 'sap.viz.modules.axis',
                  configure:{
                    'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                    propertiesOverride:{
                      title:{
                        applyAxislineColor:{
                          isExported: true
                        }
                      }
                    }
                  }
                },
                xAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'xAxis2',
                        properties : {
                            type : 'value',
                            position : 'top',
                            gridline : {
                                visible : false
                            }
                        },
                        propertiesOverride:{
                          title:{
                            applyAxislineColor:{
                              isExported: true
                            }
                          }
                        }

                    }
                }
         
              }
          }
      },
    feeds:{
    secondaryValues: {
      min : 1,
      max : Number.POSITIVE_INFINITY 
    }// or null
    },
      dependencies : {
        attributes : [ {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.xAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondScale'
        }, {
          targetModule : 'main.xAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.xAxis2',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'secondAxisColor'
        }, {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'main.xAxis',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'primaryAxisTitle'
    }, {
      targetModule : 'main.xAxis2',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'secondAxisTitle'
    },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/dual_column',
    name : 'IDS_DUALVERTICALBARCHART',
    base : 'viz/column',
      modules : {
          main : {
              modules : {
                plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
              yAxis:{
                      id : 'sap.viz.modules.axis',
                  configure:{
                    'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                    propertiesOverride:{
                      title:{
                        applyAxislineColor:{
                          isExported: true
                        }
                      }
                    }
                  }
                },
                yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                        'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'yAxis2',
                        properties : {
                            type : 'value',
                            position : 'right'
                        },
                        propertiesOverride:{
                          title:{
                            applyAxislineColor:{
                              isExported: true
                            }
                          }
                        }
                    }
                }
              }
          }
      },
    feeds:{
      secondaryValues: {
        min : 1,
        max : Number.POSITIVE_INFINITY 
      }
    },
      dependencies : {
        attributes : [ {
          targetModule : 'main.plot',
          target : 'primaryDataRange',
          sourceModule : 'main.yAxis',
          source : 'range'
        }, {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.plot',
          target : 'secondDataRange',
          sourceModule : 'main.yAxis2',
          source : 'range'
        }, {
          targetModule : 'main.yAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondScale'
        }, {
          targetModule : 'main.yAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.yAxis2',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'secondAxisColor'
        }, {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        }, {
      targetModule : 'main.yAxis2',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'secondAxisTitle'
    },{
      targetModule : 'main.yAxis',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'primaryAxisTitle'
    },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
        } ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/stacked_column',
      name : 'IDS_STACKEDVERTICALBARCHART',
      base : 'viz/column',
      feeds:{
        secondaryValues: null
      },
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
              }
          }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
    var chart = {
      id : 'viz/dual_stacked_column',
      name : 'IDS_DUALSTACKEDVERTICALBARCHART',
      base : 'viz/dual_column',
      modules : {
          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  }
              }
          }
      }
    };
    
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualPercentageStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualStackedVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
    var chart = {
      id : 'viz/100_dual_stacked_column',
      name : 'IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART',
      base : 'viz/dual_stacked_column',
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                        properties : {
                             mode : 'percentage'
                        }
                    }
                  },
                  dataLabel : {
                      id : 'sap.viz.modules.datalabel',
                      configure : {
                        propertyCategory : 'dataLabel',
                        properties : {
                          isPercentMode : true,
                          showZero : true
                        }
                      }
                    },
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        isPercentMode : true
                      }
                    }
                  },
                  yAxis2 : {
                      id : 'sap.viz.modules.axis',
                      configure : {
                      'description': 'Settings for the value axis of an XY chart.',
                        propertyCategory : 'yAxis2',
                        properties : {
                          isPercentMode : true
                        }
                      }
                    }
              }
          },
      tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : '100_dual_stacked_column',
                  orientation : 'bottom'
                }
              }
          }
      }    
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/stacked_bar',
      name : 'IDS_STACKEDBARCHART',
      base : 'viz/bar',
      feeds:{
        secondaryValues: null
      },
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
              }
          }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
    var chart = {
      id : 'viz/dual_stacked_bar',
      name : 'IDS_DUALSTACKEDBARCHART',
      base : 'viz/dual_bar',
      modules : {
          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  }
              }
          }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualPercentageStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualStackedBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
    var chart = {
      id : 'viz/100_dual_stacked_bar',
      name : 'IDS_DUALPERCENTAGESTACKEDBARCHART',
      base : 'viz/dual_stacked_bar',
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                        properties : {
                             mode : 'percentage'
                        }
                    }
                  },
                  dataLabel : {
                      id : 'sap.viz.modules.datalabel',
                      configure : {
                        propertyCategory : 'dataLabel',
                        properties : {
                          isPercentMode : true,
                          showZero : true
                        }
                      }
                    },
                    xAxis : {
                        id : 'sap.viz.modules.axis',
                        configure : {
                        'description': 'Settings for the value axis of an XY chart.',
                          propertyCategory : 'xAxis',
                          properties : {
                            isPercentMode : true
                          }
                        }
                      },  
                      xAxis2 : {
                          id : 'sap.viz.modules.axis',
                          configure : {
                          'description': 'Settings for the value axis of an XY chart.',
                            propertyCategory : 'xAxis2',
                            properties : {
                              isPercentMode : true
                            }
                          }
                        }
              }
          },
       tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : '100_dual_stacked_bar',
                  orientation : 'left'
                }
              }
          }
      }  
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/100_stacked_bar',
      name : 'IDS_PERCENTAGESTACKEDBARCHART',
      base : 'viz/stacked_bar',
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                        properties : {
                             mode : 'percentage'
                        }
                    }
                  },            
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        isPercentMode : true
                      }
                    }
                  },
                  dataLabel : {
                      id : 'sap.viz.modules.datalabel',
                      configure : {
                        propertyCategory : 'dataLabel',
                        properties : {
                          type : 'value',
                          isPercentMode: true,
                          showZero : true
                        }
                      }
                    }
              }
          },
         
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : '100_stacked_bar',
                  orientation : 'left',
                  formatString: [["0.00%"],["0.00%"]]
                }
              }
          }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/100_stacked_column',
      name : 'IDS_PERCENTAGESTACKEDVERTICALBARCHART',
      base : 'viz/stacked_column',
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                        properties : {
                             mode : 'percentage'
                        }
                    }
                  } ,
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        isPercentMode : true
                      }
                    }
                  },
                  dataLabel : {
                      id : 'sap.viz.modules.datalabel',
                      configure : {
                        propertyCategory : 'dataLabel',
                        properties : {
                          type : 'value',
                          isPercentMode: true,
                          showZero : true
                        }
                      }
                    }
              }
          },
          tooltip : {
                  id : 'sap.viz.modules.tooltip',
                  configure : {
                    propertyCategory : 'tooltip',
                    properties : {
                      chartType : '100_stacked_column',
                      orientation : 'bottom',
                      formatString: [["0.00%"],["0.00%"]]
                    }
                  }
              }
              
          }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Pie',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var feeds = {
    id : "pie",
    feeds : [ {
      'id' : 'pieSectorColor',
      'name' : 'Sector Color',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1
    }, {
      'id' : 'pieSectorSize',
      'name' : 'Sector Size',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    }, {
      'id' : 'pieDepthSize',
      'name' : 'Depth Size',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 2
    } ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.pie',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.Pie',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.pie',
    'type' : Constants.Module.Type.Chart,
    'name' : 'pie',
    'properties' : {
      'animation' : {
        'name' : 'animation',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'dataLoading' : {
            'name' : 'dataLoading',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled data loading animation of plot area.'
          }
        },
        'description' : 'Settings for animation of plot area.'
      },
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.SAPColor,
        'description' : 'Set the color palette for sectors.'
      },
      'isDonut' : {
        'name' : 'isDonut',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether is a donut or pie.'
      },
      'isGeoPie' : {
        'name' : 'isGeoPie',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether is a geo pie.'
      },
      'valign' : {
        'name' : 'valign',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'top', 'center' ],
        'defaultValue' : "top",
        'description' : 'Set vertical aligment.',
        'isExported' : false
      },
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set whether tooltip is enabled.'
          },
          'valueFormat' : {
            'name' : 'valueFormat',
            'supportedValueType' : 'String',
            'defaultValue' : 'n',
            'description' : 'Set the number format of measure value in tooltip.'
          },
          'percentageFormat' : {
            'name' : 'percentageFormat',
            'supportedValueType' : 'String',
            'defaultValue' : ".0%",
            'description' : 'Set the number format of percentage label in tooltip.'
          },
          'formatString': {
        		'name' : 'formatString',
        		'supportedValueType': 'StringArray',
        	  'defaultValue' : null,
        		'description' : 'Set format string of tooltip. The first string is applied to value and the second is applied to percentage. '
          }
        },
        'description' : 'Settings for tooltip related properties.'
      },
      'drawingEffect' : {
        'name' : 'drawingEffect',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'normal', 'glossy' ],
        'defaultValue' : 'normal',
        'description' : 'Set drawing effect of Pie.',
        'isExported' : true
      }
    },
    'events' : {
      'initialized': Constants.Module.Event.Initialized.desc,
      'selectData' : Constants.Module.Event.SelectData.desc,
      'deselectData' : Constants.Module.Event.DeSelectData.desc
    },
    'feeds' : {
      id : "pie",
      configure : {
        pieDepthSize : null
      }
    },
    'css' : {
      '.viz-pie-tooltip-label-dimensions' : {
        'description' : 'Define style for the first label(dimension values) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '14px',
          'font-weight' : 'normal',
          'fill' : '#000'
        }
      },
      '.viz-pie-tooltip-label-value' : {
        'description' : 'Define style for the second label(measure value) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '18px',
          'font-weight' : 'bold',
          'fill' : '#000'
        }
      },
      '.viz-pie-tooltip-label-percentage' : {
        'description' : 'Define style for the third label(percentage) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '16px',
          'font-weight' : 'normal',
          'fill' : '#333'
        }
      },
      '.viz-pie-sector' : {
        'description' : 'Define style for sector in pie.',
        'value' : {
          'stroke' : 'transparent'
        }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPieChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var multiChart = {
    id : 'viz/multi_pie',
    name : 'IDS_MULTIPIECHART',
    base : 'riv/base/multiple',
    modules : {
      legend : {
        data : {
          aa : [ 2 ]
        }
      },
      main : {
        configure : {
          properties : {
            'cellPadding' : 5
          }
        },
        controllers : {
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames : [ 'mouseup', 'mouseover', 'mouseout',
                    'touchstart' ]
              }
            }
          }
        },
        modules : {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.pie',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea',
                  properties : {
                    valign : "center"
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'polarCoordinate',
                    visible : false,
                    formatString : [['0.00%'],[]],
                    automaticInOutside : false,
                    outsideVisible : true,
                    type : 'label and value'
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      multiplier : {
        acceptMND : 0,
        max : 2
      },
      pieSectorSize : {
        max : constants.Constraints.INF
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'main.interaction',
        listener : 'registerEvent',
        sourceModule : 'main',
        type : 'initialized.interaction'
      }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
      } , {
        targetModule : 'main.plot.dataLabel',
        listener : 'showLabel',
        sourceModule : 'main.plot.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'main.plot.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'main.plot.plot',
        type : 'startToInit.datalabel'
      }]
    }
  };

  Manifest.register(multiChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDonutChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiPieChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiChart = {
    id : 'viz/multi_donut',
    name : 'IDS_MULTIDONUTCHART',
    base : 'viz/multi_pie',
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.pie',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea',
                  properties : {
                      'isDonut' : true
                  }
                }
              },          
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    isDonut : true
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.piewithdepth',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.pie.sector',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.pie.selection',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.pie.tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(sectorModule, selectionModule, tooltip, TextUtils,
    ColorSeriesGenerator, dispatch, UADetector, FunctionUtils, TypeUtils,
    Repository, Objects, formatManager, langManager, BoundUtil) {

    var fn = function(manifest) {
        var width = 500, height = 300, padding = 0;
        var data = null, props = {};
        var zAngle = Math.PI / 4;
        var rx = 0, ry = 0, drx = 0, dry = 0, baseHeight = 0, bottomCX = 0, bottomCY = 0;
        var heightScale = d3.scale.linear();
        var color = ColorSeriesGenerator.sap32().range();
        var isDonut = false;
        var _selection;
        var rotationAngle = 0;
        var _dispatch = dispatch('initialized', 'startToInit');

        function pie(selection) {
            BoundUtil.drawBound(selection, width, height);
            _selection = selection;
            renderChart(selection);
            return pie;
        }


        pie.width = function(value) {
            if (!arguments.length) {
                return width;
            }
            width = value;
            if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
                getPieLayout();
                if (_selection) {
                    renderChart(_selection);
                }
            }
            return pie;
        };

        pie.height = function(value) {
            if (!arguments.length) {
                return height;
            }
            height = value;
            if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
                getPieLayout();
                if (_selection) {
                    renderChart(_selection);
                }
            }
            return pie;
        };

        pie.padding = function(value) {
            if (!arguments.length) {
                return padding;
            }
            padding = value;
            if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
                getPieLayout();
                if (_selection) {
                    renderChart(_selection);
                }
            }
            return pie;
        };

        pie.properties = function(_) {
            if (!arguments.length) {
                return props;
            }
            Objects.extend(true, props, _);
            parseOptions();
            return pie;
        };

        pie.parent = function() {
            return _selection;
        };
        
        pie.dispatch = function(_) {
            return _dispatch;
        };
        
        pie.afterUIComponentAppear = function(){
          _dispatch.initialized(); 
        };
        
        pie.dataLabel = function(_) {
        };

        pie.data = function(value) {
            if (!arguments.length) {
                return data;
            }
            data = value;
            return pie;
        };
        
        pie.colorPalette = function(_) {
            if (arguments.length === 0) {
                return color;
            }
            color = _;
            return pie;
        }; 
        
        pie.rotate = function(_) {
            if (arguments.length === 0) {
                return {
                    xAngle : 0,
                    yAngle : rotationAngle * 180 / Math.PI
                };
            }
            rotationAngle = _.yAngle * Math.PI / 180;
            renderChart(_selection);
            return pie;
        };


        function parseOptions() {
            color = props.colorPalette;
            isDonut = props.isDonut;
        };

        function getPieLayout() {
            var base = Math.min(width, height);
            rx = base / 2;
            ry = rx * Math.cos(zAngle);
            drx = rx / 2.414;
            dry = ry / 2.414;
            bottomCX = width / 2;
            bottomCY = height / 2 + base / 2 - ry;
            baseHeight = base - 2 * ry;
        };

        function renderChart(selection) {
            selection.select('.datashapesgroup').remove();
            var sectors = prepareData();
            var g = selection.append('g').attr('class', 'datashapesgroup');
            renderSectors(sectors, g);
        };

        function prepareData() {
            var sectorFeed = data.getMeasureValuesGroupDataByIdx(0);
            var depthFeed = data.getMeasureValuesGroupDataByIdx(1);

            var sum = 0, maxDepthVal = 0;
            for (var i = 0; i < sectorFeed.values[0].rows[0].length; i++) {
                sum += Math.abs(sectorFeed.values[0].rows[0][i].val);
                maxDepthVal = Math.max(maxDepthVal, Math.abs(depthFeed.values[0].rows[0][i].val));
            }

            heightScale.domain([0, maxDepthVal]).range([0, baseHeight]);
            var result = [];
            for (var i = 0, lastAngle = rotationAngle - Math.PI / 2; i < sectorFeed.values[0].rows[0].length; i++) {
                var obj = {
                    startAngle : lastAngle,
                    endAngle : lastAngle + Math.abs(sectorFeed.values[0].rows[0][i].val) / sum * Math.PI * 2,
                    cy : bottomCY - heightScale(Math.abs(depthFeed.values[0].rows[0][i].val)),
                    colorValue : color[i % color.length],
                    val : [
                        sectorFeed.values[0].rows[0][i].val,
                        depthFeed.values[0].rows[0][i].val
                    ],
                    ctx : [
                        sectorFeed.values[0].rows[0][i].ctx,
                        depthFeed.values[0].rows[0][i].ctx
                    ]
                };
                obj.topPoint1 = [bottomCX + rx * Math.cos(obj.startAngle), obj.cy + ry * Math.sin(obj.startAngle)];
                obj.topPoint2 = [bottomCX + rx * Math.cos(obj.endAngle), obj.cy + ry * Math.sin(obj.endAngle)];
                obj.bottomPoint1 = [bottomCX + rx * Math.cos(obj.startAngle), bottomCY + ry * Math.sin(obj.startAngle)];
                obj.bottomPoint2 = [bottomCX + rx * Math.cos(obj.endAngle), bottomCY + ry * Math.sin(obj.endAngle)];
                
                if (isDonut) {
                    obj.topPoint4 = [bottomCX + drx * Math.cos(obj.startAngle), obj.cy + dry * Math.sin(obj.startAngle)];
                    obj.topPoint3 = [bottomCX + drx * Math.cos(obj.endAngle), obj.cy + dry * Math.sin(obj.endAngle)];
                    obj.bottomPoint4 = [bottomCX + drx * Math.cos(obj.startAngle), bottomCY + dry * Math.sin(obj.startAngle)];
                    obj.bottomPoint3 = [bottomCX + drx * Math.cos(obj.endAngle), bottomCY + dry * Math.sin(obj.endAngle)];
                }

                result.push(obj);
                lastAngle = obj.endAngle;
            }
            return result;
        };

        function renderSectors(sectors, g) {
            // sort sectors to handle cover relationship
            sectors.sort(function(a, b) {
                var asa = getSimpleAngle(a.startAngle);
                var aea = getSimpleAngle(a.endAngle);
                var bsa = getSimpleAngle(b.startAngle);
                var bea = getSimpleAngle(b.endAngle);
                
                if (asa < Math.PI / 2 && aea > Math.PI / 2
                    || asa < Math.PI / 2 && aea < asa
                    || asa > Math.PI / 2 && aea > Math.PI / 2 && aea < asa) {
                    return 1;
                }
                if (bsa < Math.PI / 2 && bea > Math.PI / 2
                    || bsa < Math.PI / 2 && bea < bsa
                    || bsa > Math.PI / 2 && bea > Math.PI / 2 && bea < bsa) {
                    return -1;
                }
                if (aea < asa) {
                    return -1;   
                }
                if (bea < bsa) {
                    return 1;
                }
                return Math.max(a.bottomPoint1[1], a.bottomPoint2[1]) - Math.max(b.bottomPoint1[1], b.bottomPoint2[1]);
            });
            
            for (var i = 0; i < sectors.length; i++) {
                var sectorWrapper = g.append('g').attr('class', 'datashape');
                if (isDonut) {
                    renderDonutSide(sectors[i], sectorWrapper);
                    renderSectorCylinder(sectors[i], sectorWrapper);
                    renderDonutTop(sectors[i], sectorWrapper);
                } else {
                    renderSectorSide(sectors[i], sectorWrapper);
                    renderSectorCylinder(sectors[i], sectorWrapper);
                    renderSectorTop(sectors[i], sectorWrapper);
                }
                
            }
            
            _dispatch.initialized({
                name : 'initialized'
            });
        };
        
        function getSimpleAngle(angle) {
            if (angle >= - Math.PI / 2 && angle <= Math.PI / 2 * 3) {
                return angle;
            } else if (angle < - Math.PI / 2) {
                return getSimpleAngle(2 * Math.PI + angle);
            } else if (angle > Math.PI / 2 * 3) {
                return getSimpleAngle(angle - 2 * Math.PI);
            }
        };
        
        function getDarkColor(color) {
            var hsl = d3.rgb(color).hsl();
            return d3.hsl(hsl.h, hsl.s, hsl.l * 0.9).rgb().toString();
        };
        
        function renderSectorSide(sector, g) {
            var topPoint1, bottomPoint1, topPoint2, bottomPoint2;
            if (sector.bottomPoint1[1] >= sector.bottomPoint2[1]) {
                topPoint1 = sector.topPoint2;
                bottomPoint1 = sector.bottomPoint2;
                topPoint2 = sector.topPoint1;
                bottomPoint2 = sector.bottomPoint1;
            } else {
                topPoint1 = sector.topPoint1;
                bottomPoint1 = sector.bottomPoint1;
                topPoint2 = sector.topPoint2;
                bottomPoint2 = sector.bottomPoint2;
            }
            var def = 'M' + bottomCX + ',' + bottomCY
                    + 'L' + bottomCX + ',' + sector.cy
                    + 'L' + topPoint1[0] + ',' + topPoint1[1]
                    + 'L' + bottomPoint1[0] + ',' + bottomPoint1[1] + 'z';
            g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue));
            def = 'M' + bottomCX + ',' + bottomCY
                    + 'L' + bottomCX + ',' + sector.cy
                    + 'L' + topPoint2[0] + ',' + topPoint2[1]
                    + 'L' + bottomPoint2[0] + ',' + bottomPoint2[1] + 'z';
            g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue));
        };
        
        function renderDonutSide(sector, g) {
            var topPoint1, topPoint2, topPoint3, topPoint4, bottomPoint1, bottomPoint2, bottomPoint3, bottomPoint4;
            if (sector.bottomPoint1[1] >= sector.bottomPoint2[1]) {
                topPoint1 = sector.topPoint2;
                topPoint2 = sector.topPoint3;
                topPoint3 = sector.topPoint1;
                topPoint4 = sector.topPoint4;
                bottomPoint1 = sector.bottomPoint2;
                bottomPoint2 = sector.bottomPoint3;
                bottomPoint3 = sector.bottomPoint1;
                bottomPoint4 = sector.bottomPoint4;
            } else {
                topPoint1 = sector.topPoint1;
                topPoint2 = sector.topPoint4;
                topPoint3 = sector.topPoint2;
                topPoint4 = sector.topPoint3;
                bottomPoint1 = sector.bottomPoint1;
                bottomPoint2 = sector.bottomPoint4;
                bottomPoint3 = sector.bottomPoint2;
                bottomPoint4 = sector.bottomPoint3;
            }
            var def = 'M' + topPoint1[0] + ',' + topPoint1[1]
                    + 'L' + topPoint2[0] + ',' + topPoint2[1]
                    + 'L' + bottomPoint2[0] + ',' + bottomPoint2[1]
                    + 'L' + bottomPoint1[0] + ',' + bottomPoint1[1] + 'z';
            g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue));
            
            renderDonutCylinder(sector, g);
            
            def = 'M' + topPoint3[0] + ',' + topPoint3[1]
                    + 'L' + topPoint4[0] + ',' + topPoint4[1]
                    + 'L' + bottomPoint4[0] + ',' + bottomPoint4[1]
                    + 'L' + bottomPoint3[0] + ',' + bottomPoint3[1] + 'z';
            g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue));
        };

        function renderSectorCylinder(sector, g) {
            var sa = getSimpleAngle(sector.startAngle);
            var ea = getSimpleAngle(sector.endAngle);
            
            if (sa > 0 && ea > sa && ea < Math.PI) {
                var def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue));
            } else if ((sa < 0 || sa > Math.PI) && ea < Math.PI && ea > 0) {
                var def = 'M' + (bottomCX + rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX + rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue));
            } else if (sa > 0 && sa < Math.PI && (ea > Math.PI || ea < 0)) {
                var def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX - rx) + ',' + sector.cy
                    + 'L' + (bottomCX - rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue));
            } else if (sa <= 0 && (ea >= Math.PI || ea < sa) || sa >= Math.PI && ea >= Math.PI && ea < sa) {
                var def = 'M' + (bottomCX + rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX - rx) + ',' + sector.cy
                    + 'L' + (bottomCX - rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX + rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue));
            } else if (sa > 0 && sa < Math.PI && ea > 0 && ea > Math.PI && ea < sa) {
                var def1 = 'M' + (bottomCX + rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'L' + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX + rx) + ',' + bottomCY + 'z';
                var def2 = 'M' + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX - rx) + ',' + sector.cy
                    + 'L' + (bottomCX - rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1] + 'z';
                g.append('path').attr('d', def1).attr('fill', getDarkColor(sector.colorValue));
                g.append('path').attr('d', def2).attr('fill', getDarkColor(sector.colorValue));
            }
        };
        
        function renderDonutCylinder(sector, g) {
            var largeAngle = sector.endAngle - sector.startAngle > Math.PI ? '1' : '0';
            var def = 'M' + sector.topPoint4[0] + ',' + sector.topPoint4[1]
                    + 'A' + drx + ',' + dry + ' 0 ' + largeAngle + ',1 '
                    + sector.topPoint3[0] + ',' + sector.topPoint3[1]
                    + 'L' + sector.bottomPoint3[0] + ',' + sector.bottomPoint3[1]
                    + 'A' + drx + ',' + dry + ' 0 ' + largeAngle + ',0 '
                    + sector.bottomPoint4[0] + ',' + sector.bottomPoint4[1] + 'z';
            g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue));
        };


        function renderSectorTop(sector, g) {
            var def = 'M' + bottomCX + ',' + sector.cy 
                    + 'L' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                    + 'A' + rx + ',' + ry + ' 0 ' 
                    + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1] + 'z';
            g.append('path').attr('class', 'datapoint').attr('d', def).attr('fill', sector.colorValue).data(sector.val);
        };
        
        function renderDonutTop(sector, g) {
            var def = 'M' + bottomCX + ',' + sector.cy 
                    + 'L' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                    + 'A' + rx + ',' + ry + ' 0 ' 
                    + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.topPoint3[0] + ',' + sector.topPoint3[1]
                    + 'A' + drx + ',' + dry + ' 0 ' 
                    + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',0 ' 
                    + sector.topPoint4[0] + ',' + sector.topPoint4[1] + 'z';
            g.append('path').attr('class', 'datapoint').attr('d', def).attr('fill', sector.colorValue).data(sector.val);
        };
        
        props = manifest.props(null);
        return pie;
    };
  return fn;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.PieWithDepth',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.piewithdepth',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.piewithdepth',
    base : 'sap.viz.modules.pie',
    'name' : 'piewithdepth',

    'feeds' : {
      id : "pie",
      configure : null
    },
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var pieChart = {
    id : 'riv/base/single',
    name : 'IDS_BASESINGLECHART',
    base : 'riv/base',
    'abstract' : true,
    modules : {
      main : {
        id : 'sap.viz.modules.xycontainer'
      }
    }
  };

  Manifest.register(pieChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.pie.PieChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.DataLabel',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var pieChart = {
    id : 'viz/pie',
    name : 'IDS_PIECHART',
    base : 'riv/base/single',
    modules : {
      legend : {
        data : {
          aa : [ 1 ]
        }
      },
      main : {
        controllers : {
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames : [ 'mouseup', 'mouseover', 'mouseout',
                    'touchstart' ]
              }
            }
          }
        },
        modules : {
          plot : {
            id : 'sap.viz.modules.pie',
            configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          },
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                paintingMode : 'polarCoordinate',
                visible : false,
                type : 'label and value',
                formatString : [['0.00%'],[]],
                automaticInOutside : false,
                outsideVisible : true
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'main.interaction',
        listener : 'registerEvent',
        sourceModule : 'main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
      } , {
        targetModule : 'main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'main.plot',
        type : 'startToInit.datalabel'
      }]
    }
  };

  Manifest.register(pieChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.pie.PieWithDepthChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.pie.PieChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.PieWithDepth',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.DataLabel',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Rotate',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/pie_with_depth',
    name : 'IDS_PIEWITHDEPTHCHART',
    base : "riv/base/single",
    modules : {
      legend : {
        data : {
          aa : [ 1 ]
        }
      },
      main : {
        controllers : {
            'interaction' : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousemove', 'touchstart'],
                  selectability: {
                    mode: 'multiple',
                    selectWithCtrlKey: true
                  },
                  preserveSelectionWhenDragging: true
                }
              }
            },
            
            'rotate': {
              id : 'sap.viz.modules.controller.rotate',
              configure : {
                propertyCategory: 'rotate'
              }
            }
          },
        modules : {
          plot : {
            id : 'sap.viz.modules.piewithdepth',
            configure : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'colorPalette'
      }],
      events : [ {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'main.rotate',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.rotate'
        }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.pie.DonutWithDepthChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.pie.PieWithDepthChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var donutChart = {
    'id' : 'viz/donut_with_depth',
    'name' : 'IDS_DONUTWITHDEPTHCHART',
    base : 'viz/pie_with_depth',
    'modules' : {
      'main' : {
        'modules' : {
          'plot' : {
            'configure' : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              'propertyCategory' : 'plotArea',
              'properties' : {
                'isDonut' : true
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(donutChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.pie.DonutChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.pie.PieChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var donutChart = {
    'id' : 'viz/donut',
    'name' : 'IDS_DONUTCHART',
    base : 'viz/pie',
    'modules' : {
      'main' : {
        'modules' : {
          'plot' : {
            'configure' : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              'propertyCategory' : 'plotArea',
              'properties' : {
                'isDonut' : true
              }
            }
          },
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                isDonut : true
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(donutChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_line',
    name : 'IDS_MULTILINECHART',
    base : 'riv/base/multiple/xy',
    modules : {
      legend : {
        data : {
          aa : [ 3 ]
        }
      },
      tooltip : {
        configure : {
          properties : {
            chartType : 'line',
            orientation : 'left'
          }
        }
      },
    
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['primary']
          }
        },
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction'
                  }
                }
              },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              xAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  aa : [ 1 ]
                },
                configure : {
                  'description':'Settings for the category axis of an XY chart.',
                  propertyCategory : 'xAxis',
                  properties : {
                    title : {
                      visible : false
                    },
                    gridline : {
                      visible : false
                    },
                    type : 'category',
                    position : 'bottom'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    },
                    gridline : {
                isExported : false
                    },
                    label : {
                      isExported : false
                      },
                      axisline : {
                      isExported : false
                     }
                  }
                }
              },
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis of an XY chart.',
                  propertyCategory : 'yAxis',
                  properties : {
                    type : 'value',
                    position : 'left'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    position : 'outside',
                    automaticInOutside : false,
                    orientation : 'vertical',
                    outsidePosition : 'up',
                    positionPreference : true
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.line',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
      secondaryValues: null,
      axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      }
      ],
      events : [  {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main',
            type : 'showTooltip'
        }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main',
            type : 'hideTooltip'
        } , {
          targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
      }, {
          targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
        }, {
          targetModule : 'main.plot.dataLabel',
          listener : 'showLabel',
          sourceModule : 'main.plot.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'main.plot.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'main.plot.plot',
          type : 'startToInit.datalabel'
        } ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiHorizontalLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_horizontal_line',
    name : 'IDS_MULTIHORIZONTALLINECHART',
    base : 'viz/multi_line',
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'horizontalline',
            orientation : 'left'
          }
        }
      },  
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              background : {
                configure : {
                  properties : {
                    direction : 'horizontal'
                  }
                }
              },
              xAxis : {
                id : 'sap.viz.modules.axis',
                data : null,
                configure : {
                  'description':'Settings for the value axis of an XY chart.',
                  properties : {
                    type : 'value',
                    gridline : {
                      visible : true
                    }
                  },
                  propertiesOverride : {                   
                    gridline : {
              isExported : true
              },
              label : {
                    isExported : true
                    },
                    axisline : {
                    isExported : true
                   }
                  }
                }
              },
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  aa : [ 1 ]
                }, 
                configure : {
                     'description':'Settings for the category axis of an XY chart.',
                  properties : {
                    type : 'category',
                    gridline : {
                      visible : false
                    }
                  },
                  propertiesOverride : {                   
                    gridline : {
              isExported : false
              },
              label : {
                    isExported : false
                    },
                    axisline : {
                    isExported : false
                   }
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    position : 'outside',
                    automaticInOutside : false,
                    orientation : 'horizontal',
                    outsidePosition : 'right',
                    positionPreference : true
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.horizontalline',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
      axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },{
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, 
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapePalette'
      } ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualHorizontalLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiHorizontalLineChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var multiBarChart = {
    id : 'viz/multi_dual_horizontal_line',
    name : 'IDS_MULTIDUALHORIZONTALLINECHART',
    base : 'viz/multi_horizontal_line',
    modules : {
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['primary', 'second']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
                 plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
                xAxis:{
                      id : 'sap.viz.modules.axis',
                  configure:{
                    'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                  }
                },
              xAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'xAxis2',
                  properties : {
                    title : {
                      visible : false
                    },
                    type : 'value',
                    position : 'top'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues:
     {
       min: 1,
    max : Number.POSITIVE_INFINITY 
     },
      axisLabels:{
        max:1,
        acceptMND: -1
      },
      regionColor:{
        acceptMND: 1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main',
        target : 'secondDataRange',
        sourceModule : 'main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      },{
        targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'main.plot.xAxis2',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'secondaryScale'
      },{
        targetModule : 'main.plot.xAxis2',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'main.plot.xAxis2',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, 
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapePalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var multiVBarChart = {
    id : 'viz/multi_dual_line',
    name : 'IDS_MULTIDUALLINECHART',
    base : 'viz/multi_line',
    modules : {
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['primary', 'second']
          }
        },
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'selectability'
                  }
                }
              },
        modules: {
          plot : {
            modules : {
                 plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
              yAxis:{
                  id : 'sap.viz.modules.axis',
              configure:{
                'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
              }
            },
              yAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'yAxis2',
                  properties : {
                    title : {
                      visible : false
                    },
                    gridline : {
                      visible : false
                    },
                    type : 'value',
                    position : 'right'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues:
     {
       min: 1,
    max : Number.POSITIVE_INFINITY 
     },
    axisLabels:{
      max:1,
      acceptMND: -1
    },
    regionColor:{
      acceptMND: 1
    }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main',
        target : 'secondDataRange',
        sourceModule : 'main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      },{
        targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'main.plot.yAxis2',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'secondaryScale'
      }, {
        targetModule : 'main.plot.yAxis2',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisTitle'
      },
      
      {
        targetModule : 'main.plot.yAxis',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'main.plot.yAxis2',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      },
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapePalette'
      }
      ],
      events : [  {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main',
            type : 'showTooltip'
        }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main',
            type : 'hideTooltip'
        } ]
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Scatter',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var feeds = {
    id : "scatter",
    feeds : [ {
      'id' : 'regionColor',
      'name' : 'Region Color',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1
    }, {
      'id' : 'regionShape',
      'name' : 'Region Shape',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 2,
      'acceptMND': -1
    }, {
      'id' : 'primaryValues',
      'name' : 'Primary Values',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    }, {
      'id' : 'secondaryValues',
      'name' : 'Secondary Values',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 2
    }, {
      'id' : 'bubbleWidth',
      'name' : 'Bubble Width',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 3
    }, {
      'id' : 'bubbleHeight',
      'name' : 'Bubble Height',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 4
    } ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.bubble',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ShapeSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.lassoSelection',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(dispatch, ColorSeries, ShapeSeries, TypeUtils, Repository, TextUtils, lassoSelection, Scaler, NumberUtils, DrawUtil, langManager, tooltipDataHandler, Objects,formatManager, langManager, BoundUtil) 
{
    return function(manifest, ctx) 
    {
        var width = 500, height = 300, padding = 0;
        var data = null, props = {};
        var xScale = d3.scale.linear();
        var yScale = d3.scale.linear();
        var wScale, hScale;
        var wMax,wMin,hMax,hMin,xMax,xMin,yMax,yMin;
        //zhu alistar
        var randomSuffix = Repository.newId();
        function resetBoundaryValues(){
          wMax = 0; wMin = Number.MAX_VALUE;
          hMax = 0; hMin = Number.MAX_VALUE;
          xMax = 0; // max value for xAxis
          xMin = 0; // min value for xAxis
          yMax = 0; // max value for yAxis
          yMin = 0; // max value for yAxis  
        }
        resetBoundaryValues();
        var distinctValuesObj;
        var bubbleScale = 1/6;
        var color = ColorSeries.sap32().range(), shape = ShapeSeries.sapShapes().range();
        var markers = [];
        var g, defs, tooltipX, tooltipY, crossX, crossY;
        var selectionStatus = [];
        var tooltipVisible = true;
        var markerStyle = {
            'stroke' : '#ffffff',
            'stroke-width' : 1
        };
        var selectedMarkerStyle = {
            'stroke' : '#333333',
            'stroke-width' : 1
        };
        var animateTime = 1000;
        var enableDataLoadingAnimation = true,  // control initialization animation 
            enableDataUpdatingAnimation = true, // control data updating animation
            bFirstCreation = true;
        var eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
        var _selection;
        var sizeLegendTitle = null;
        var drawingEffect = 'normal';
        var effectManager = ctx.effectManager;
        var markerSize = 10;
        var animationComplete = false;
        var formatString ;
        
        function bubble(selection) {
            BoundUtil.drawBound(selection, width, height);
            _selection = selection;
            renderChart(selection);
            bFirstCreation = false;
            return bubble;
        }

        bubble.width = function(value) {
            if (!arguments.length){
                return width;
            }
            width = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
               computeScales();
            }
            return bubble;
        };

        bubble.height = function(value) {
            if (!arguments.length){
                return height;
            }
            height = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
              computeScales();
            }
            return bubble;
        };
        
        bubble.afterUIComponentAppear = function(){
          eDispatch.initialized(); 
        };
        
        
        bubble.padding = function(value){
            if(!arguments.length){
                return padding;
            }
            padding = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
              computeScales();
            }
            return bubble;
        };
        bubble.valueAxis1Scale = function(value){
          if(!arguments.length){
                return xScale;
          }
          xScale = value;
          return bubble;
        };
        bubble.valueAxis2Scale = function(value){
          if(!arguments.length){
            return yScale;
          }
          yScale = value;
          return bubble;
        };
        
        bubble.valueAxis1DataRange = function(range){
          if (!arguments.length){
            return {
              min: xMin,
              max: xMax
            };
          }
          xMax = range.max;
          xMin = range.min;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.valueAxis2DataRange = function(range){
          if (!arguments.length){
            return {
              min: yMin,
              max: yMax
            };
          }
          yMax = range.max;
          yMin = range.min;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.bubbleWidthDataRange = function(range){
          if (!arguments.length){
            return {
              distinctValuesObj : distinctValuesObj,
              min: wMin,
              max: wMax
            };
          }
          wMax = range.max;
          wMin = range.min;
          distinctValuesObj = range.distinctValuesObj;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.bubbleHeightDataRange = function(range){
          if (!arguments.length){
            return {
              min: hMin,
              max: hMax
            };
          }
          hMax = range.max;
          hMin = range.min;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.colorPalette = function(value){
        if(!arguments.length){
          return color;
        }
        color = value;
        return bubble;
      };
      bubble.shapes = function(value){
        if(!arguments.length){
          return shape;
        }
        shape = value;
        return bubble;
      };
      bubble.sizeLegend = function() {
           var heightFeed = data.getMeasureValuesGroupDataByIdx(3);
           var hasHeightFeed = (TypeUtils.isExist(heightFeed) && heightFeed.values.length > 0);
          return {      
              bubbleScale : bubbleScale,
              space : padding,
              scale : wScale,
              data : sizeData(),
              title : sizeLegendTitle,
              hasHeightFeed : hasHeightFeed
          };
      };
        bubble.dispatch = function(_){
            if(!arguments.length){
                return eDispatch;
            }
            eDispatch = _;
            return this;
        };
        
        bubble.dataLabel = function(_){
          
        };
        

         /**
            * set/get data, for some modules like Title, it doesn't need data
            */
        bubble.data = function(value){
            if (!arguments.length){
                return data;
            }
            data = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
              calculateBoundaryValues();
              computeScales();
            }
            return bubble;            
        };

        bubble.valueAxis1Title = function(_){
          if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              if (titles.values[i].col !== null && titles.values[i].col !== undefined)
              {
                  title.push(titles.values[i].col);
              }
              else
              {
                  title.push(langManager.get('IDS_ISNOVALUE'));
              }
            }
          }
          return title.join('/');
        }
        return this;
        };
        
        bubble.valueAxis2Title = function(_){
          if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              if (titles.values[i].col !== null && titles.values[i].col !== undefined)
              {
                  title.push(titles.values[i].col);
              }
              else
              {
                  title.push(langManager.get('IDS_ISNOVALUE'));
              }
            }
          }
          return title.join('/');
        }
        return this;
        };
        /**
        * set/get properties
        */
        bubble.properties = function(_){
            if (!arguments.length){
                return props;
            }
            Objects.extend(true, props, _);
            parseOptions();
            return bubble;            
        };
     
     function parseOptions() {
       color = props.colorPalette;
       shape = props.shapePalette;
       tooltipVisible = props.axisTooltip.visible;
       drawingEffect = props.drawingEffect;
       enableDataLoadingAnimation =  props.animation.dataLoading;
       enableDataUpdatingAnimation =  props.animation.dataUpdating;
       formatString = props.axisTooltip.formatString;
       // necessary to check, since markerSize is N/A for bubble chart
       var _markerSize = props.markerSize;
       markerSize = TypeUtils.isExist(_markerSize) && _markerSize <= 32 && _markerSize >= 4 ? _markerSize : markerSize;
       if(props.xScaleType && props.xScaleType === "log") {
         xScale = d3.scale.log();
       }
     }
        
      function calculateBoundaryValues() {
          resetBoundaryValues();
          var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
          var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
          var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
          var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
          distinctValuesObj = {};
          
          for (var i = 0; i < measureFeed1.values[0].rows.length; i++) {
              for (var j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
                  var x = measureFeed1.values[0].rows[i][j].val;
                  var y = measureFeed2.values[0].rows[i][j].val;
                  
                  if (NumberUtils.isNoValue(x) || NumberUtils.isNoValue(y)) {
                      continue;
                  }
                  
                  var w = bubbleWidthFeed && bubbleWidthFeed.values.length && TypeUtils.isExist(bubbleWidthFeed.values[0].rows[i][j].val) ? Math.abs(bubbleWidthFeed.values[0].rows[i][j].val) : null;
                  var h;
                  if (bubbleHeightFeed && bubbleHeightFeed.values.length) {
                      if (TypeUtils.isExist(bubbleHeightFeed.values[0].rows[i][j].val)) {
                          h = Math.abs(bubbleHeightFeed.values[0].rows[i][j].val);
                      } else {
                          h = null;
                      }
                  } else {
                      h = w;
                  }
      
                  if (!NumberUtils.isNoValue(w)) {
                      distinctValuesObj[w] = '';
                  } 
                  xMax = x > xMax ? x : xMax;
                  xMin = x < xMin ? x : xMin;
                  yMax = y > yMax ? y : yMax;
                  yMin = y < yMin ? y : yMin;
                  wMax = w > wMax ? w : wMax;
                  wMin = w < wMin ? w : wMin;
                  hMax = h > hMax ? h : hMax;
                  hMin = h < hMin ? h : hMin;
              }
          }
          
          
      }
    
        function computeScales() {

          var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
          var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
          if(props.xScaleRange){
            xScale.domain([props.xScaleRange.min, props.xScaleRange.max]).range([padding, width - padding]).nice();
          }else{
            //when xmax and xmin are 0, we make the xscale.domain(0,1)
            if( xMax === 0 && xMin === 0 ){
              xScale.domain([0, 1]).range([padding, width - padding]).nice();
            }else{
              xScale.domain([xMin * (1 + bubbleScale), xMax * (1 + bubbleScale)]).range([padding, width - padding]).nice();
            }
          }
          Scaler.perfect(xScale);
          //when ymin and ymax are 0 ,we make the yscale.domain(0,1)
          if( yMax === 0 && yMin === 0){
            yScale.domain([0,1]).range([height - padding, padding]).nice();  
          }else{
            yScale.domain([yMin * (1 + bubbleScale), yMax * (1 + bubbleScale)]).range([height - padding, padding]).nice();
          }
          Scaler.perfect(yScale);
          

          var rMax;
          //[Jimmi/8/17/2012]here we means if you don't feed data for width and height, we won't change the scale even if the data range
          //has been passed by  bubbleWidthDataRange and bubbleHeightDataRange
          if (bubbleWidthFeed && bubbleWidthFeed.values.length && wMax !== wMin) {
              if(props.wScaleMax){
                wScale = bubbleSizeScale(props.wScaleMax, true, bubbleHeightFeed);
              }
              else{
                wScale = bubbleSizeScale(wMax, true, bubbleHeightFeed);
              }
              sizeLegendTitle = bubbleWidthFeed.values[0].col;
          } else {
              wScale = function(value) {
                  return markerSize;
              };
          }
          
          if (bubbleHeightFeed && bubbleHeightFeed.values.length && hMax !== hMin) {
              hScale = bubbleSizeScale(hMax, false);
          } else {
            if(wScale && hMax > hMin){
              hScale = wScale;
            }else{
              hScale = function(value) {
                  return markerSize;
              };
            }
          }
        }
        
        function renderChart(selection) {
            // TODO: avoid repeat drawing data when re-draw
            if (g) {
                g.remove();
            }
            if (defs) {
                defs.remove();
            }
            
            eDispatch.startToInit();
            
            var i;//for iteration
            
            //we will share tooltip-x and tooltip-y between modules in a same chart
            var parent = d3.select(selection.node().ownerSVGElement.parentNode);
            if (tooltipVisible && parent.select('svg.sc-tooltip-x').node() === null) {
              parent.append('svg').style('position', 'absolute').attr('class', 'sc-tooltip-x').attr('pointer-events', 'none').attr('width', '0').attr('height', 0);
            }
            tooltipX = parent.select('svg.sc-tooltip-x');
            if (tooltipVisible && parent.select('svg.sc-tooltip-y').node() === null) {
              parent.append('svg').style('position', 'absolute').attr('class', 'sc-tooltip-y').attr('pointer-events', 'none').attr('width', '0').attr('height', 0);
            }
            tooltipY = parent.select('svg.sc-tooltip-y');
            
        //    getThemeStyleDef();
            
            var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
            var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
            var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
            var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
            var colorFeed = data.getAnalysisAxisDataByIdx(0);
            var shapeFeed = data.getAnalysisAxisDataByIdx(1);
            
           
            var clipPathId = 'edge-clip-' + randomSuffix;
            defs = selection.append('defs');
            defs.append('clipPath').attr('id', clipPathId).append('rect').attr('width', width).attr('height', height);
            
            g = selection.append('g').attr('class','datashapesgroup');  
            g.attr('clip-path', 'url(#' + clipPathId + ')');  
            
            g.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill-opacity', 0)
                    .attr('id', 'event-rect' + randomSuffix);
            crossX = g.append('line').attr('id', 'cross-x-' + randomSuffix).attr('stroke-width', 1).attr('stroke', '#cccccc').attr('shape-rendering','crispEdges').attr('visibility', 'hidden');
            crossY = g.append('line').attr('id', 'cross-y-' + randomSuffix).attr('stroke-width', 1).attr('stroke', '#cccccc').attr('shape-rendering','crispEdges').attr('visibility', 'hidden');
            
            var colorIndex = 0;
            var colorContainer = {};
            
            function renderByShape(i, renderShape, renderArray) {
                for (var j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
                    // Currently just group by the first dimension in hierarchy
                    var colorFeedVal = (colorFeed && colorFeed.values.length  > 0) ? colorFeed.values[0].rows[j].val : 0;
                    var colorValue;
                    if (colorContainer[colorFeedVal]) {
                        colorValue = colorContainer[colorFeedVal];
                    } else {
                        colorValue = color[colorIndex % color.length];
                        colorContainer[colorFeedVal] = colorValue;
                        colorIndex++;
                    }
                    var x = measureFeed1.values[0].rows[i][j].val;
                    var y = measureFeed2.values[0].rows[i][j].val;
                    var w = bubbleWidthFeed && bubbleWidthFeed.values.length ? bubbleWidthFeed.values[0].rows[i][j].val : null;
                    var h = bubbleHeightFeed && bubbleHeightFeed.values.length ? bubbleHeightFeed.values[0].rows[i][j].val : null;
                    
                    var renderData = {
                        x : x,
                        y : y,
                        w : w, 
                        h : h,
                        colorIndex : j,
                        shapeIndex : i,
                        colorValue : colorValue,
                        shapeValue : renderShape,
                        val : [x, y, w, h],
                        ctx : [
                            measureFeed1.values[0].rows[i][j].ctx, 
                            measureFeed2.values[0].rows[i][j].ctx,
                            bubbleWidthFeed && bubbleWidthFeed.values.length ? bubbleWidthFeed.values[0].rows[i][j].ctx : null,
                            bubbleHeightFeed && bubbleHeightFeed.values.length ? bubbleHeightFeed.values[0].rows[i][j].ctx : null
                        ]
                    };
                    
                    if (!NumberUtils.isNoValue(x) && !NumberUtils.isNoValue(y)) {
                        renderArray.push(renderData);
                    }
                }
            }
            
            
            
            
            var renderArray = [];
            var renderShape;
            if (shapeFeed && shapeFeed.values.length > 0) {
                i = 0;
                for (var shapeIndex = 0, shapeContainer = {}; i < shapeFeed.values[0].rows.length; i++) {
                    // Currently just group by the first dimension in hierarchy
                    var shapeFeedVal = shapeFeed.values[0].rows[i].val;
                    if (shapeContainer[shapeFeedVal]) {
                        renderShape = shapeContainer[shapeFeedVal];
                    } else {
                        renderShape = shape[shapeIndex % shape.length];
                        shapeContainer[shapeFeedVal] = renderShape;
                        shapeIndex++;
                    }
                    renderByShape(i, renderShape, renderArray);
                }
            } else {
                renderByShape(0, shape[0], renderArray);
            }

            // sort to draw big shape first
            renderArray.sort(function(a, b) {
                var ah = a.h === null ? a.w : a.h;
                var bh = b.h === null ? b.w : b.h;
                return Math.abs(b.w * bh) - Math.abs(a.w * ah);
            });
            
            var completedArray = 0;
            animationComplete = false;
            hideTooltip();
            function checkAnimationCompleted(d, m) {
                completedArray++;
                if (completedArray === renderArray.length) {
                  animationComplete = true;
                    eDispatch.initialized();
                }
            }
 
            var enableAnimation = (enableDataLoadingAnimation && bFirstCreation) || (enableDataUpdatingAnimation && !bFirstCreation);
            for (i = 0; i < renderArray.length; i++) {
                var x = renderArray[i].x, 
                    y = renderArray[i].y, 
                    w = renderArray[i].w, 
                    h = bubbleHeightFeed && bubbleHeightFeed.values.length ? renderArray[i].h : w, 
                    colorValue = renderArray[i].colorValue; 
                renderShape = renderArray[i].shapeValue;
                    
                    
                var markerShape;
                
                var rx = wScale(w) / 2,
                  ry = hScale(h) / 2;
                var aniTime = 0;
                if (enableAnimation){
                  aniTime = animateTime;
                }
                var newG = g.append('g').attr('class', 'datashape').attr('transform', 'translate(' + xScale(x) + ',' + yScale(y) + ')');
                var element = DrawUtil.createElements(newG, {shape: renderShape, className: "viz-correlation-marker datapoint"} );
                var parameter = {
                  drawingEffect: drawingEffect,
                  fillColor: colorValue,
                  graphType: renderShape,
                  direction: 'vertical',
                  rx: rx,
                  ry: ry,
                  borderWidth:  markerStyle['stroke-width'],
                  borderColor: markerStyle['stroke'],
                  node:element,
                  visibility: "visible",
                  animateTime: aniTime,
                  endFunc: checkAnimationCompleted
                };

                DrawUtil.drawGraph(parameter, effectManager).attr('opacity', '0.8');    
            }
            selection.selectAll('.viz-correlation-marker').data(renderArray);
            
            if (!enableAnimation) {
              animationComplete = true;
                eDispatch.initialized();
            }
        }
        
        function bubbleSizeScale(vMax, wh, heightFeed) {
            // even 0 value for bubble size, still render a small size shape
            return function(value) {
                if (NumberUtils.isNoValue(value)) {
                    return 4;
                }
                var range;
                if (wh) {
                    range = !heightFeed && height < width ? height : width;
                } else {
                    range = height;
                }
                var r = Math.pow(Math.abs(value) / vMax, 0.5) * (range - padding) * bubbleScale;
                return r > 4 ? r : 4;
            };
        }
        
//        function getThemeStyleDef() {
//            var markerThemeStyle = ctx.styleManager.query('viz-correlation-marker');
//            if(markerThemeStyle){
//                if(markerThemeStyle['stroke']){
//                    markerStyle['stroke'] = markerThemeStyle['stroke'];
//                }
//                if(markerThemeStyle['stroke-width']){
//                    markerStyle['stroke-width'] = markerThemeStyle['stroke-width'];
//                }
//            }
//            var selectedMarkerThemeStyle = ctx.styleManager.query('viz-correlation-marker-selected');
//            if(selectedMarkerThemeStyle){
//                if(selectedMarkerThemeStyle['stroke']){
//                    selectedMarkerStyle['stroke'] = selectedMarkerThemeStyle['stroke'];
//                }
//                if(selectedMarkerThemeStyle['stroke-width']){
//                    selectedMarkerStyle['stroke-width'] = selectedMarkerThemeStyle['stroke-width'];
//                }
//            }
//        }
        
        function sizeData() {
            var wDistinctValues = 0;
            for (var i in distinctValuesObj) {
              if(distinctValuesObj.hasOwnProperty(i)){
                wDistinctValues++;
              }
            }
            if (wDistinctValues === 0) {
                return [];
            } else if (wDistinctValues === 1) {
                return [wMax];
            } else if (wDistinctValues === 2) {
                return [wMax, wMin];
            } else {
                return [wMax, (wMax + wMin) / 2, wMin];
            }
        }
        
        bubble.parent = function() {
            return _selection;
        };

        bubble.mouseover = function(target) {
            var item = d3.select(target);
            if(item === undefined || item.node() === null || !animationComplete){
              return;
            }
            if (item.attr('id') !== null && (item.attr('id') === ('event-rect' + randomSuffix) 
                || item.attr('id').indexOf('cross-x-') >= 0
                || item.attr('id').indexOf('cross-y-') >= 0)) {
                return;
            }
            var val = item.datum();
            item.attr('opacity', '1');
            crossX.attr('visibility', 'visible')
                    .attr('x1', 0)
                    .attr('y1', yScale(val.y))
                    .attr('x2', width)
                    .attr('y2', yScale(val.y));
            crossY.attr('visibility', 'visible')
                    .attr('x1', xScale(val.x))
                    .attr('y1', 0)
                    .attr('x2', xScale(val.x))
                    .attr('y2', height);
            showTooltip(val, _selection[0][0].getTransformToElement(_selection[0][0].ownerSVGElement));
            
        };
        
        bubble.mouseout = function(target, isHighlighted) {
            var item = d3.select(target);
            if(item === undefined || item.node() === null || !animationComplete) {return;}
            if (item.attr('id') === ('event-rect' + randomSuffix)) {
                return;
            }

            if (isHighlighted) {
                item.attr('opacity', '0.8');
            } else {
                item.attr('opacity', '0.2');
            }
            
            crossX.attr('visibility', 'hidden');
            crossY.attr('visibility', 'hidden');
            
            hideTooltip();
        };
        
        function showTooltip(val, transform) {
            var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
            var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
            var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
            var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
            var colorFeed = data.getAnalysisAxisDataByIdx(0);
            var shapeFeed = data.getAnalysisAxisDataByIdx(1);
            
            var tooltipData = {
                body: [],
                footer: []
            };
            var footer;//for iteration
            //push color footer to tooltipData
            for (var i = 0, len = (colorFeed ? colorFeed.values.length : 0); i < len; i++) {
              footer = {};
              footer.label = colorFeed.values[i].col.val;
              footer.value = colorFeed.values[i].rows[val.colorIndex].val;
              tooltipData.footer.push(footer);
            }
            //push shape footer to tooltipData
            for (var j = 0, jlen = (shapeFeed ? shapeFeed.values.length : 0); j < jlen; j++) {
              footer = {};
              footer.label = shapeFeed.values[j].col.val;
              footer.value = shapeFeed.values[j].rows[val.shapeIndex].val;
              tooltipData.footer.push(footer);
            }
            
            tooltipData.body.push({
              name : !TypeUtils.isExist(measureFeed1.values[0].col) ? langManager.get('IDS_ISNOVALUE') : measureFeed1.values[0].col,
              val : [{
                color : val.colorValue,
                shape : val.shapeValue,
                value : val.x
              }]
            });
            
            tooltipData.body.push({
              name : !TypeUtils.isExist(measureFeed2.values[0].col) ? langManager.get('IDS_ISNOVALUE') : measureFeed2.values[0].col,
              val :[{
                color : val.colorValue,
                shape : val.shapeValue,
                value : val.y
              }]
            });
            
            if (bubbleWidthFeed && bubbleWidthFeed.values.length > 0) {
              tooltipData.body.push({
                  name : !TypeUtils.isExist(bubbleWidthFeed.values[0].col) ? langManager.get('IDS_ISNOVALUE') : bubbleWidthFeed.values[0].col,
                  val : [{
                    color : val.colorValue,
                    shape : val.shapeValue,
                    value : NumberUtils.isNoValue(val.w) ? langManager.get('IDS_ISNOVALUE') : val.w
                  }]
                });
            }
            if (bubbleHeightFeed && bubbleHeightFeed.values.length > 0) {
              tooltipData.body.push({
                  name : !TypeUtils.isExist(bubbleHeightFeed.values[0].col) ? langManager.get('IDS_ISNOVALUE') : bubbleHeightFeed.values[0].col,
                  val : [{
                    color : val.colorValue,
                    shape : val.shapeValue,
                    value : NumberUtils.isNoValue(val.h) ? langManager.get('IDS_ISNOVALUE') : val.h
                  }]
                });
            }

            tooltipData.point = {
               x : xScale(val.x),
               y : yScale(val.y) + transform.f
            };
            tooltipData.plotArea = {
               x : transform.e,
               y : transform.f,
               width : width,
               height : height
            };
            
            eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
            
            if (tooltipVisible) {
                var xAxisValue, yAxisValue;
                if (TypeUtils.isExist(formatString)) {
                    xAxisValue = formatManager.format(val.x, formatString[0]);
                    yAxisValue = formatManager.format(val.y, formatString[1]);
                } else {
                    xAxisValue = val.x;
                    yAxisValue = val.y;
                }
                drawXYTooltip(xAxisValue, tooltipX, {
                    x : xScale(val.x),
                    y : yScale(val.y)
                }, transform, 'x');
                drawXYTooltip(yAxisValue, tooltipY, {
                    x : xScale(val.x),
                    y : yScale(val.y)
                }, transform, 'y');
            }

        }
        
        function hideTooltip() {
            eDispatch.hideTooltip();
            if (tooltipVisible) {
                tooltipX.selectAll('g').remove();
                tooltipY.selectAll('g').remove();
            }
        }
        
        function drawXYTooltip(value, container, point, transform, axis) {
            var font = {
                size : '12px',
                weight : 'bold',
                family : '"Open Sans", Arial, Helvetica, sans-serif'
            };
            var valueSize = TextUtils.fastMeasure(value, font.size, font.weight, font.family);
            container.attr('width', valueSize.width + 20).attr('height', valueSize.height + 10);
            container.wrapper = container.append('g');
            container.wrapper.append('rect')
                    .attr('x', 1)
                    .attr('y', 1)
                    .attr('rx', 4)
                    .attr('ry', 4)
                    .attr('width', valueSize.width + 18)
                    .attr('height', valueSize.height + 8)
                    .attr('fill', '#ffffff')
                    .attr('stroke', '#000000')
                    .attr('stroke-width', 1);
            container.wrapper.append('text')
                    .attr('x', 10)
                    .attr('y', valueSize.height + 3)
                    .attr('fill', '#000000')
                    .style('font', font.weight + ' ' + font.size + ' ' + font.family)
                    .text(value);
            if ('y' === axis) {
                container.style('left', transform.e - container.attr('width') + 1 + 'px').style('top',( point.y + transform.f - container.attr('height') / 2 ) + 'px');
            } else if ('x' === axis) {
                container.style('left', point.x + transform.e -  container.attr('width') / 2 + 'px').style('top', transform.f + height - 1 + 'px');
            }
        }

        function getChangedValues(changedArray) {
            var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
            var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
            var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
            var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
            var result = [];
            for (var i = 0; i < changedArray.length; i++) {
                var colorIndex = changedArray[i].colorIndex;
                var shapeIndex = changedArray[i].shapeIndex;
                
                result.push([
                    measureFeed1.values[0].rows[shapeIndex][colorIndex],
                    measureFeed2.values[0].rows[shapeIndex][colorIndex],
                    bubbleWidthFeed && bubbleWidthFeed.values.length > 0 ? bubbleWidthFeed.values[0].rows[shapeIndex][colorIndex] : null,
                    bubbleHeightFeed && bubbleHeightFeed.values.length > 0 ? bubbleHeightFeed.values[0].rows[shapeIndex][colorIndex] : null
                ]);
            }
            return result;
        }
        
        bubble.highlight = function(elems) {
            if (TypeUtils.isArray(elems)) {
                for (var i = 0, len = elems.length; i < len; i++) {
                    d3.select(elems[i]).attr('class', 'viz-correlation-marker-selected datapoint').attr('opacity', '0.8').attr('stroke', selectedMarkerStyle['stroke']).attr('stroke-width', selectedMarkerStyle['stroke-width']);
                }
            } else {
                d3.select(elems).attr('class', 'viz-correlation-marker-selected datapoint').attr('opacity', '0.8').attr('stroke', selectedMarkerStyle['stroke']).attr('stroke-width', selectedMarkerStyle['stroke-width']);
            }
        };
        
        bubble.unhighlight = function(elems) {
            if (TypeUtils.isArray(elems)) {
                for (var i = 0, len = elems.length; i < len; i++) {
                    d3.select(elems[i]).attr('class', 'viz-correlation-marker datapoint').attr('opacity', '0.2').attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                }
            } else {
                d3.select(elems).attr('class', 'viz-correlation-marker datapoint').attr('opacity', '0.2').attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            }
        };
        
        bubble.clear = function(gray) {
            var allMarks = _selection.selectAll('.datapoint').attr('class', 'viz-correlation-marker datapoint').attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            if (gray) {
                allMarks.attr('opacity', '0.2');
            } else {
                allMarks.attr('opacity', '0.8');
            }
            
        };
        props = manifest.props(null);
        return bubble;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Bubble',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.bubble',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.Scatter',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.bubble',
    'type' : Constants.Module.Type.Chart,
    'name' : 'bubble',
    'data' : 'DATA STRUCTURE DOC',
    'properties' : {
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.SAPColor,
        'description' : 'Set marker color of bubble.'
      },
      'shapePalette' : {
        'name' : 'shapePalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : [ 'circle', 'square', 'diamond', 'triangle-up',
            'triangle-down', 'triangle-left', 'triangle-right', 'cross', 'intersection' ],
        'supportedValues' : [ 'circle', 'square', 'diamond', 'triangle-up',
              'triangle-down', 'triangle-left', 'triangle-right', 'cross', 'intersection' ],
        'description' : 'Set marker shape of bubble.'
      },
      'axisTooltip' : {
        'name' : 'axisTooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'enabled/disabled tooltip.'
          },
          'formatString': {
      		'name' : 'formatString',
      		'supportedValueType': 'StringArray',
      		'defaultValue' : null,
      		'description' : 'Set format string for small tooltip.The first one is applied to xAxis and the second one is applied to yAxis'
          }
        },
        
        'description' : 'Set tooltip related properties.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'enable/disable data loading animation of bubble/scatter.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'enable/disable data updating animation of bubble/scatter.'
            }
          },
          'description' : 'Set animation of bubble/scatter.'
        },
        'drawingEffect':{
          'name' : 'drawingEffect',
           'supportedValueType' : 'List',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'description' : 'Drawing effect of bubble marker.',
            'isExported' : true
        }
    },
    'events' : {
      'initialized': Constants.Module.Event.Initialized.desc,
        'selectData' : Constants.Module.Event.SelectData.desc,
        'deselectData' : Constants.Module.Event.DeSelectData.desc,
        'showTooltip' : Constants.Module.Event.TooltipShow.desc,
        'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    'feeds' : {
      id : "scatter",
      configure : {
        bubbleWidth:
        {
          min:1
        }
      }
    },
  
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Bubble',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants) {
  var module = {
    'id' : 'sap.viz.modules.scatter',
    base : 'sap.viz.modules.bubble',
    'name' : 'scatter',
    'properties' : {
        'markerSize' : {
            'name' : 'markerSize',
              'supportedValueType' : 'PositiveInt',
              'defaultValue' : "10",
              'description' : 'Set marker size of data point. The available range is from 4 to 32.'
        }
    },
    'feeds' : {
      configure : {
        bubbleWidth : null,
        bubbleHeight : null
      }
    }
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.ScatterInMatrix',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants) {
    var module = {
      'id' : 'sap.viz.modules.scatterInMatrix',
      base : 'sap.viz.modules.scatter',
      'name' : 'scatterInMatrix',
      'feeds' : null
    };
    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.ScatterMatrix',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
    var feeds = {
      id : "scattermatrix",
      feeds : [ {
        'id' : 'regionColor',
        'name' : 'Region Color',
        'type' : constants.Type.Dimension,
        'min' : 0,
        'max' : 1,
        'aaIndex' : 1,
        'acceptMND': -1
      }, {
        'id' : 'regionShape',
        'name' : 'Region Shape',
        'type' : constants.Type.Dimension,
        'min' : 0,
        'max' : 1,
        'aaIndex' : 2,
        'acceptMND': -1
      }, {
        'id' : 'primaryValues',
        'name' : 'Primary Values',
        'type' : constants.Type.Measure,
        'min' : 2,
        'max' : constants.Constraints.INF,
        'mgIndex' : 1
      }]
    };
    Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.scattermatrixcontainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.MultiChartDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TypeUtils, Objects, Functions, layout, MultiChartDataHandler, Manifest, TextUtils, dispatch, langManager, boundUtil) {

    return function(manifest, ctx) {
        var width = 0, height = 0, subWidth = 0, subHeight = 0,
        properties = {}, data = {}, config = {}, modules = {}, selections = {}, parent = null, // a d3 selection
        dataHandler = null, plotLabels = [];
        var plotTitleVisible = true;
        var isTitleHidden = false;
        var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), avaPlotCount = 0;
        var font = {};
        var innerProperties = manifest.props(null);

        var handleNull = function(_) {
          if (_ === null || _ === undefined) {
            return langManager.get('IDS_ISNOVALUE');
          } else {
            return _;
          }
        };
    
        function load(moduleId) {
            return Manifest.module.get(moduleId).execute(ctx);
        }
        
        function getThemeStyleDef() {
            var titleStyle = ctx.styleManager.query('viz-matrix-sub-title');
            if(titleStyle) {
                if(titleStyle['fill']){
                    font.fill = titleStyle['fill'];
                }
                if(titleStyle['font-family']){
                    font.family = titleStyle['font-family'];
                }
                if(titleStyle['font-size']){
                    font.size = titleStyle['font-size'];
                }
                if(titleStyle['font-weight']){
                    font.weight = titleStyle['font-weight'];
                }
            }
        };
        
        function initializePlot() {
          var plotConfig = config.modules.plot;
          if (!plotConfig)
              return;
          delete modules.plot;
          modules.plot = [];
          var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
          for (var colI = 0; colI < measureNum; colI++) {
              for (var rowI = 0; rowI < measureNum; rowI++) {
                  var plotI = modules.plot[rowI * measureNum + colI] = load(plotConfig.id);
                  plotI.config(plotConfig);
                  avaPlotCount++;
                  if(plotI.dispatch){
                      var dis =  plotI.dispatch();
                        if(dis.initialized) dis.on('initialized.scattermatrixcontainer', initialized);
                        if(dis.showTooltip) dis.on('showTooltip.scattermatrixcontainer', showTooltip);
                        if(dis.hideTooltip) dis.on('hideTooltip.scattermatrixcontainer', hideTooltip);
                   }
              }
          }
        }
        
        function updatePlotProperties() {
          if (TypeUtils.isExist(properties.multiLayout) && TypeUtils.isExist(properties.multiLayout.plotTitle) && TypeUtils.isExist(properties.multiLayout.plotTitle.visible)) {
            plotTitleVisible = properties.multiLayout.plotTitle.visible;
            innerProperties.plotTitle.visible = properties.multiLayout.plotTitle.visible;              
          }
          
          var plots = modules.plot;
          if(plots){
            var plotConfig = config.modules.plot;
            if (!plotConfig)
                return;
            var props;
            if (plotConfig.configure) {
                if (plotConfig.configure.propertyCategory) {
                  props = Objects.extend(true, {}, properties[ plotConfig.configure.propertyCategory ]);
               }
            } else {
                props = properties;
            }

            for(var i = 0, len = plots.length; i < len; i++){
              if (props) {
                plots[i].properties(props);
              }
            }
          }
          getThemeStyleDef();
        }
        
        function updatePlotData() {
          plotLabels = [];//can we split data label updating outside?
          dataHandler = new MultiChartDataHandler(data, "measures");
          var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
          for (var colI = 0; colI < measureNum; colI++) {
              for (var rowI = 0; rowI < measureNum; rowI++) {
                  var dataI = dataHandler.getSubDataAdapterByMeasures({
                      row : rowI,
                      col : colI
                  });
                  var plotI = modules.plot[rowI * measureNum + colI];
                  plotI.data(dataI);
                  
                  var plotLabel = plotLabels[rowI * measureNum + colI];
                  if(!plotLabel) plotLabel = plotLabels[rowI * measureNum + colI] = {};
                  //we may already have other members here in plotLabel, do not remove them while updating
                  plotLabel.empty = (colI == rowI);
                  plotLabel.label = (colI == rowI 
                          ? handleNull(dataI.getMeasureValuesGroupDataByIdx(0).values[0].col) 
                          : handleNull(dataI.getMeasureValuesGroupDataByIdx(0).values[0].col) + ' - ' + handleNull(dataI.getMeasureValuesGroupDataByIdx(1).values[0].col));
              }
          }
        }
        
        function initializePlotElements() {
          delete selections.plot;
          parent.select('.plot').remove();
          if (modules.plot && !selections.plot) {
            var splots = selections.plot = [];
            var plotRoot = selections.plotRoot = parent.append('g').attr('class', 'plot');
            for (var i = 0, len = modules.plot.length; i < len; i++) {
                splots[i] = plotRoot.append('g').attr('class', 'plot' + i);

                var plotI = modules.plot[i];
                var subModules = plotI.parent(splots[i]).modules();

                for (var m in subModules )
                if (subModules.hasOwnProperty(m))
                    modules['plot[' + i + ']' + '.' + m] = subModules[m];
            }
          }
        }

        function initialize() {
            if (TypeUtils.isEmptyObject(config))
                Functions.error('Container configuration missing');

            avaPlotCount = 0;
            initializePlot();
            updatePlotProperties();
            updatePlotData();
            initializePlotElements();
        };
        
        function relayout() {
            if (TypeUtils.isEmptyObject(modules) || !width || !height)
                return;
            
            getThemeStyleDef();
            var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
            subWidth = width / measureNum;
            subHeight = height / measureNum;
            var labelSize = getMaxLabelSize();
            var labelHeight = labelSize.height;
            if (!plotTitleVisible || labelSize.width > subWidth || labelSize.height > subHeight / 3) {
                labelSize.height = 0;
                isTitleHidden = true;
            }
            for (var colI = 0; colI < measureNum; colI++) {
                for (var rowI = 0; rowI < measureNum; rowI++) {
                    
                    var plotI = modules.plot[rowI * measureNum + colI];
                    var splotI = selections.plot[rowI * measureNum + colI];
                    plotI.width(subWidth).height(subHeight - labelHeight);
                    splotI.attr('transform', 'translate(' + (subWidth * colI) + ',' + (subHeight * rowI) + ')');
                }
            }
        };

        function container(selection) {
            selection.each(function(data) {
                parent = selection;
                boundUtil.drawBound(selection, width, height);
                if (TypeUtils.isEmptyObject(modules)){
                    initialize();
                }
                relayout();
                render();
            });
            return container;
        }


        container.width = function(_) {
            if (!arguments.length)
                return width;
            if (width !== _) {
                width = _;
                relayout();
            }
            return container;
        };

        container.height = function(_) {
            if (!arguments.length)
                return height;
            if (height !== _) {
                height = _;
                relayout();
            }
            return container;
        };

        container.size = function(_) {
            if (!arguments.length)
                return {
                    'width' : width,
                    'height' : height
                };
            if (height !== _.height || width !== _.width) {
                height = _.height;
                width = _.width;
                relayout();
            }
            return container;
        };

        container.data = function(_) {
            if (!arguments.length)
                return data;
            data = _;
            if(!TypeUtils.isEmptyObject(modules)){
              //TODO Jimmy/9/11/2012 currently we can't know
              //whether it's a data change only (without schema change)
              //but we do have chance in new data model. for now, we just
              //update everything

              avaPlotCount = 0;
              initializePlot();
              updatePlotProperties();
              updatePlotData();
              initializePlotElements();
            }
            return container;
        };

        container.properties = function(_) {
            if (!arguments.length)
                return innerProperties;
            properties = _;
            if(!TypeUtils.isEmptyObject(modules)){
              updatePlotProperties();
            }
            return container;
        };

        container.config = function(_) {
            if (!arguments.length)
                return config;
            config = _;
            return container;
        };

        container.modules = function(_) {
            if (!arguments.length) {
                if (TypeUtils.isEmptyObject(modules)) {
                    initialize();
                }
                return modules;
            }
            modules = _;
            return container;
        };

        container.parent = function(_) {
            if (!arguments.length)
                return parent;
            parent = _;
            return container;
        };

        container.dispatch = function(_){
          if( !arguments.length){
            return eDispatch;
          }
          eDispatch = _;
          return container;
        };
        
        function render() {

            if (selections.plot) {
                for (var i = 0, len = selections.plot.length; i < len; i++) {
                    if (plotLabels[i].empty) {
                        renderLabel(selections.plot[i], plotLabels[i], subHeight / 2);
                        initialized();
                    } else {
                        selections.plot[i].datum(modules.plot[i].data()).call(modules.plot[i]);
                        renderLabel(selections.plot[i], plotLabels[i], subHeight);
                    }
                    
                }
            }
            isTitleHidden = false;
        };
        
        function renderLabel(plot, labelObj, ybaseline) {
            if (labelObj.shape) {
                labelObj.shape.remove();
            }
            
            if (isTitleHidden) {
                return;
            }
            
            var labelSize = TextUtils.fastMeasure(labelObj.label, font.size, font.weight, font.family);
            
            labelObj.shape = plot.append('text').attr('class', 'sub-plot-title')
                    .attr('text-anchor', 'middle')
                    .attr('x', subWidth / 2)
                    .attr('y', ybaseline - labelSize.height / 2)
                    .attr('fill', font.fill)
                    .style('font-weight', font.weight).style('font-size', font.size).style('font-family', font.family)
                    .attr('dominant-baseline', 'middle')
                    .style('cursor', 'default');
            TextUtils.ellipsis(labelObj.label, labelObj.shape.node(), subWidth - 5 /* leave some padding */, "font:" + font.weight + ' ' + font.size + ' ' + font.family);
        };
        
        function getMaxLabelSize() {
            var maxWidth = 0, maxHeight = 0;
            for (var i = 0, len = plotLabels.length; i < len; i++) {
                var size = TextUtils.fastMeasure(plotLabels[i].label, font.size, font.weight, font.family);
                maxHeight = size.height > maxHeight ? size.height : maxHeight;
                maxWidth = size.width > maxWidth ? size.width : maxWidth;
            }
            return {
                width : maxWidth,
                height : maxHeight
            };
        }
        
        var initializedPlots = 0;
        function initialized(){
          if(++initializedPlots == avaPlotCount){
            initializedPlots = 0;
            eDispatch.initialized();
          }
        }
        
        function showTooltip(evt){
          eDispatch.showTooltip(evt);
        };
        
        function hideTooltip(evt){
          eDispatch.hideTooltip(evt);
        };
        
        return container;
    };

});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.ScatterMatrixContainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.scattermatrixcontainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.ScatterMatrix',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
    
    var module = {
      'id' : 'sap.viz.modules.scattermatrixcontainer',
        'type' : Constants.Module.Type.Container,
        'name' : 'Scatter Matrix Container',
        'description': 'Settings for the subcharts layout of Scatter Matrix chart.',
        'properties' : {
            'plotTitle' : {
              'name' : 'plotTitle',
        'description': 'Settings for plot title.',
              'supportedValueType' : 'Object',
              'supportedValues' : {
                'visible' : {
                  'name' : 'visible',
                  'supportedValueType' : 'Boolean',
                  'defaultValue' : true,
                  'description' : 'Set visibility of sub plot title.'
                }
              },
            }
        },
        'css' : {
            '.viz-matrix-sub-title' : {
                'description' : 'Define style for the sub plot title.',
                'value' : {
                    'fill' : 'black',
                    'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
                    'font-size' : '12px',
                    'font-weight' : 'bold'
                }
            }
        },
        'feeds' : { 
            id : 'scattermatrix'
        },
    'events' : {
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
        'fn' : fn
    };
    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.ScatterMatrixChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.ScatterMatrixContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.ScatterInMatrix',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var scatterMatrix = {
        id : 'viz/scatter_matrix',
        name : 'IDS_SCATTERMATRIXCHART',
        base : 'riv/base',
        modules : {

            legend : {
                data : { 
                    aa :[1, 2]
                }, 
                configure : { 
                    properties : { 
                        type :'BubbleColorLegend'
                    }
                }
            },

            tooltip : { 
                id : 'sap.viz.modules.tooltip',
                configure : { 
                    propertyCategory : 'tooltip',
                    properties : { 
            chartType: 'scattermatrix',
                        orientation :'left'
                    }
                }
            },

            main : {
                id : 'sap.viz.modules.scattermatrixcontainer',
                
                configure : {
                    propertyCategory : 'multiLayout'
                },
                  
                controllers : {
                    'interaction' : { 
                        id : 'sap.viz.modules.controller.interaction',
                        configure : { 
                            propertyCategory :'interaction'
                        }
                    }
                },
                
                modules : {
                    plot : {
                        id : 'sap.viz.modules.xycontainer',
                        modules : {
                            xAxis : {
                                id : 'sap.viz.modules.axis',
                                data : {
                                    mg : [1]
                                },
                                configure : {
                                'description': 'Settings for the x axis of a normal bubble or scatter plot.',
                                    propertyCategory : 'xAxis',
                                    properties : {
                                        type : 'value',
                                        position : 'bottom',
                                        gridline : {
                                            visible : false
                                        }
                                    }
                                }
                            },

                            yAxis : {
                                id : 'sap.viz.modules.axis',
                                data : {
                                    mg : [2]
                                },
                                configure : {
                              'description': 'Settings for the y axis of a normal bubble or scatter plot.',
                                   propertyCategory : 'yAxis',
                                    properties : {
                                        type : 'value',
                                        position : 'left',
                                        gridline : {
                                            visible : false
                                        }
                                    }
                                }
                            },
              
              background : {
                id: 'sap.viz.modules.background',
                configure : {
                  propertyCategory : 'background',
                  properties : {
                    direction : 'vertical'
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'rectCoordinate',
                    visible : false,
                    position : 'outside'
                  }
                }
              },
              
                            plot : {
                                id : 'sap.viz.modules.scatterInMatrix',
                                configure : {
                              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                                    propertyCategory : 'plotArea'
                                }
                            }
                        }
                    }
                }
            }
        },
        dependencies : {
            attributes : [{
                targetModule : 'main.plot.yAxis',
                target : 'scale',
                sourceModule : 'main.plot.plot',
                source : 'valueAxis2Scale'
            }, {
                targetModule : 'main.plot.xAxis',
                target : 'scale',
                sourceModule : 'main.plot.plot',
                source : 'valueAxis1Scale'
            }, {
                targetModule : 'main.plot.xAxis',
                target : 'title',
                sourceModule : 'main.plot.plot',
                source : 'valueAxis1Title'
            }, {
                targetModule : 'main.plot.yAxis',
                target : 'title',
                sourceModule : 'main.plot.plot',
                source : 'valueAxis2Title'
            }, {
                targetModule : 'legend',
                target : 'colorPalette',
                sourceModule : 'main.plot.plot',
                source : 'colorPalette'
            }, {
                targetModule : 'legend',
                target : 'shapes',
                sourceModule : 'main.plot.plot',
                source : 'shapes'
            }, {
          targetModule : 'legend',
          target : 'setSelectionMode',
          sourceModule : 'main.interaction',
          source : 'getSelectionMode'
            }],

            events :[{
                targetModule : 'tooltip',
                listener : 'showTooltip',
                sourceModule : 'main',
                type : 'showTooltip'
            }, {
                targetModule : 'tooltip',
                listener : 'hideTooltip',
                sourceModule : 'main',
                type : 'hideTooltip'
            }, {
                targetModule : 'main.interaction',
                listener : 'registerEvent',
                sourceModule : 'main',
                type : 'initialized.interaction'
            }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
      }, {
        targetModule : 'main.plot.dataLabel',
        listener : 'showLabel',
        sourceModule : 'main.plot.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'main.plot.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'main.plot.plot',
        type : 'startToInit.datalabel'
      } ]

        }
    };

    Manifest.register(scatterMatrix);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiScatterChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_scatter',
    name : 'IDS_MULTISCATTERCHART',
    base : 'riv/base/multiple/xy',
   
    modules : {
      legend : {
        data : {
          aa : [ 2,3 ]
        },
        configure : {
         properties : {
            type : 'BubbleColorLegend'
          }
        }
      },
      tooltip : {
        configure : {
          properties : {
            chartType : 'scatter',
            orientation : 'left'
          }
        }
      },
      main : {
        controllers : {
            'interaction' : { 
                    id : 'sap.viz.modules.controller.interaction',
                configure : { 
                    propertyCategory :'interaction'
                }
            }
        },
          
        configure : {
          properties : {
            'mergeDataRange' : ['valueAxis1', 'valueAxis2']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                'description': 'Settings for the x axis of a normal bubble or scatter plot.',
                 propertyCategory : 'xAxis',
                  properties : {
                    title : {
                      visible : false
                    },
                    type : 'value',
                    position : 'bottom'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    automaticInOutside : false,
                    orientation : 'vertical',
                    position : 'outside',
                    outsideVisible : true
                  }
                }
              },
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                'description': 'Settings for the y axis of a normal bubble or scatter plot.',
                  propertyCategory : 'yAxis',
                  properties : {
                    title : {
                      visible : false
                    },
                    type : 'value',
                    position : 'left'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.scatter',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
        acceptMND:-1
       }
   },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'valueAxis1DataRange',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'valueAxis1DataRange',
        sourceModule : 'main',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'main',
        target : 'valueAxis2DataRange',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'valueAxis2DataRange',
        sourceModule : 'main',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1Scale'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1Title'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2Scale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2Title'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapes'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
    }
      ],
      events : [  {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main',
            type : 'showTooltip'
        }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main',
            type : 'hideTooltip'
        },{
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
        }, {
          targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
        }, {
          targetModule : 'main.plot.dataLabel',
          listener : 'showLabel',
          sourceModule : 'main.plot.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'main.plot.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'main.plot.plot',
          type : 'startToInit.datalabel'
        }]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiBubbleChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiScatterChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_bubble',
    name : 'IDS_MULTIBUBBLECHART',
    base : 'viz/multi_scatter',
    modules : {
      legend : {
        data : {
          aa : [ 2, 3 ]
        }
      },
      sizeLegend : {
        id : 'sap.viz.modules.legend',
        configure : {
          'description': 'The size legend is a box mapping the charts data shapes\' size to the value by some typical symbols and associated indication values.',
          propertyCategory : 'sizeLegend',
          properties : {
            type : 'SizeLegend'
          }
        }
      },
      tooltip : {
        configure : {
          properties : {
            chartType : 'bubble',
            orientation : 'left'
          }
        }
      },
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['valueAxis1', 'valueAxis2', 'bubbleWidth', 'bubbleHeight']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    automaticInOutside : true
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.bubble',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{
        multiplier:{
          acceptMND:-1
         },
         secondaryValues: {
         max: 1
      }// or null
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'valueAxis1DataRange',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'valueAxis1DataRange',
        sourceModule : 'main',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'main',
        target : 'valueAxis2DataRange',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'valueAxis2DataRange',
        sourceModule : 'main',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'main',
        target : 'bubbleWidthDataRange',
        sourceModule : 'main.plot.plot',
        source : 'bubbleWidthDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'bubbleWidthDataRange',
        sourceModule : 'main',
        source : 'bubbleWidthDataRange'
      },
      {
        targetModule : 'main',
        target : 'bubbleHeightDataRange',
        sourceModule : 'main.plot.plot',
        source : 'bubbleHeightDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'bubbleHeightDataRange',
        sourceModule : 'main',
        source : 'bubbleHeightDataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1Scale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2Scale'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1Title'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2Title'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapes'
      }, {
          targetModule : 'sizeLegend',
          target : 'sizeLegendInfo',
          sourceModule : 'main.plot.plot',
          source : 'sizeLegend'
        }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.scatter.BaseBubbleChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/scatter/single/base',
    name : 'IDS_BASEBUBBLECHART',
    'abstract' : true,
    base : 'riv/base/single',
    modules : {
      legend : {
        data : {
          aa : [ 1, 2 ]
        },
        configure : {
          properties : {
            type : 'BubbleColorLegend'
          },
          propertiesOverride:{
            isHierarchical:{
              isExported: false
            }
          }
        }
      },
      tooltip : {
        id : 'sap.viz.modules.tooltip',
        configure : {
          propertyCategory : 'tooltip',
          properties : {
            orientation : 'left'
          }
        }
      },
      main : {

            controllers : {
                'interaction' : { 
                    id : 'sap.viz.modules.controller.interaction',
                    configure : { 
                        propertyCategory :'interaction'
                    }
                }
            },

        modules : {
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                paintingMode : 'rectCoordinate',
                orientation : 'vertical',
                visible : false,
                position : 'outside',
                outsideVisible : true
              }
            }
          },
          xAxis : {
            id : 'sap.viz.modules.axis',
            data : {
              mg : [ 1 ]
            },
            configure : {
              'description': 'Settings for the x axis of a normal bubble or scatter plot.',
              propertyCategory : 'xAxis',
              properties : {
                type : 'value',
                position : 'bottom',
                gridline : {
                  visible : false
                }
              }
            }
          },
          yAxis : {
            id : 'sap.viz.modules.axis',
            data : {
              mg : [ 2 ]
            },
            configure : {
                'description': 'Settings for the y axis of a normal bubble or scatter plot.',
              propertyCategory : 'yAxis',
              properties : {
                type : 'value',
                position : 'left',
                gridline : {
                  visible : true
                }
              }
            }
          },
        
        background : {
        id: 'sap.viz.modules.background',
        configure : {
          propertyCategory : 'background',
          properties : {
            direction : 'vertical'
          }
        }
        }
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'valueAxis1Scale'
      }, {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'valueAxis2Scale'
      }, {
        targetModule : 'main.xAxis',
        target : 'title',
        sourceModule : 'main.plot',
        source : 'valueAxis1Title'
      }, {
        targetModule : 'main.yAxis',
        target : 'title',
        sourceModule : 'main.plot',
        source : 'valueAxis2Title'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapes'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      }],
      events : [ {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      }, {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
        }, {
        targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
        }, {
          targetModule : 'main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'main.plot',
          type : 'startToInit.datalabel'
        }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.scatter.ScatterChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.scatter.BaseBubbleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/scatter',
    name : 'IDS_SCATTERCHART',
    base : "viz/scatter/single/base",
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'scatter'
          }
        }
      },
      main : {
        modules : {
          plot : {
            id : 'sap.viz.modules.scatter',
            configure : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          },
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              properties : {
                automaticInOutside : false
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.scatter.BubbleChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.scatter.BaseBubbleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Bubble',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/bubble',
    name : 'IDS_BUBBLECHART',
    base : "viz/scatter/single/base",
    modules : {
      sizeLegend : {
        id : 'sap.viz.modules.legend',
        configure : {
          'description': 'The size legend is a box mapping the charts data shapes\' size to the value by some typical symbols and associated indication values.',
          propertyCategory : 'sizeLegend',
          properties : {
            type : 'SizeLegend'
          },
          propertiesOverride :{
            isHierarchical : {
                  isExported : false
              },
            formatString: {
              isExported: true
            }
          }

        }
      },
      tooltip : {
        configure : {
          properties : {
            chartType : 'bubble'
          }
        }
      },
      main : {
        modules : {
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              properties : {
                automaticInOutside : true
              }
            }
          },
          plot : {
            id : 'sap.viz.modules.bubble',
            configure : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [  
        undefined, undefined, undefined, undefined, undefined, undefined, undefined,
     {
        targetModule : 'sizeLegend',
        target : 'sizeLegendInfo',
        sourceModule : 'main.plot',
        source : 'sizeLegend'
      } ],
      events : [ {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      } ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.TreeMap',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var rectangleTitleFeed = {
    'id' : 'rectangleTitle',
    'name' : 'Rectangle Title',
    'type' : constants.Type.Dimension,
    'min' : 1,
    'max' : 1,
    'aaIndex' : 1,
    'acceptMND': -1,
    'maxStackedDims' : 6
  };

  var rectangleWeightFeed = {
    'id' : 'rectangleWeight',
    'name' : 'Rectangle Weight',
    'type' : constants.Type.Measure,
    'min' : 1,
    'max' : 1,
    'mgIndex' : 1
  };

  var rectangleColorFeed = {
    'id' : 'rectangleColor',
    'name' : 'Rectangle Color',
    'type' : constants.Type.Measure,
    'min' : 0,
    'max' : 1,
    'mgIndex' : 2
  };
  var feeds = {
    id : "treeMap",
    feeds : [ rectangleTitleFeed, rectangleColorFeed, rectangleWeightFeed ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.util.MeasureBasedColoring',
  version : '4.0.0'},
[

],
function Setup() {
  var MeasureBasedColoring = {
    getScale : function(minVal, maxVal, ticksCount, startColor, endColor) {
      var colorScale = d3.scale.linear().domain([ minVal, maxVal ])
        .range([ startColor, endColor ]).nice();
     
      var colorScaleNice = colorScale.domain(); 
      var t1 = getAccFormat(colorScaleNice[0]), t2 = getAccFormat(colorScaleNice[1]);
      var totalPrecision = t1 > t2 ? t1 : t2;
      totalPrecision++;
      
      var niceDomain = colorScale.domain();
      niceDomain = formatRange(niceDomain, totalPrecision);
      
      minVal = niceDomain[0];
      maxVal = niceDomain[1];
      
      if(minVal === maxVal){
        //only one value in range.
        ticksCount = 1;
      }
      var span = maxVal - minVal, ticks = [], step, precision = 0;
      if(span / ticksCount > 1){
        if (span % ticksCount === 0) {
          // divied properly
          step = format(span / ticksCount, totalPrecision + 1);
          precision = getAccFormat(step);
          
          for ( var i = 0; i < ticksCount + 1; i++) {
            ticks.push(minVal + format(i * step, precision));
          }
        } else {
          step = Math.ceil(span / ticksCount);
          precision = getAccFormat(step);
          var start = Math.floor(minVal / step) * step;
          if(start === 0 || (start + step*ticksCount < maxVal)) start = minVal;
          
          for ( var i = 0; i < ticksCount + 1; i++) {
            ticks.push(start + format(i * step, precision));
          }
        }
      }else{
        //Can't be divided with integrate. 
        start = minVal, step = format(span / ticksCount, totalPrecision + 1);
        precision = getAccFormat(step);
        
        for(var i = 0; i < ticksCount; i++){
          ticks.push(start + format(i * step, precision));
        }
        ticks.push(format(maxVal, precision));
      }
      
      //format all values
      for(var i = 0, len = ticks.length; i < len; i++){
        ticks[i] = format(ticks[i], precision);
      }
      
      //reset color scale
      colorScale = d3.scale.linear().domain([ 0, ticksCount-1 ]).range([ startColor, endColor ]);
      
      var domainRg = [], rangeRg = [];
      for ( var i = 0, len = ticks.length - 1; i < len; i++) {
        domainRg.push([ ticks[i], ticks[i + 1] ]);
        rangeRg.push(colorScale(i));
      }

      var fontColorScale = d3.scale.ordinal().domain(domainRg).range(rangeRg);
      return fontColorScale;
    }
  };
  
  var formatRange = function(range, precision){
    for(var i = 0, len = range.length; i < len; i++){
      range[i] = format(range[i], precision);
    }
    return range;
  };
  
  var getAccFormat = function(value){
    var t = value.toString().split(".");
    return t.length > 1 ? t[1].length : 0;
  };
  
  var format = function(value, precision){
    return Math.round(Math.pow(10, precision) * value) / Math.pow(10, precision);
  };
  
  return MeasureBasedColoring;
});sap.riv.module(
{
  qname : 'sap.viz.modules.treemap',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.MeasureBasedColoring',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(dispatch, ColorSeries, tooltipDataHandler, NumberUtils, 
               TypeUtils, NumberUtils, TextUtils, MeasureBasedColoring, langManager, 
               Repository, Objects, boundUtil) {
    //treemap has no MND
    var treeMap = function(manifest, ctx) {

//--------------------------start of internal vars-----------------------------
        var randomSuffix = Repository.newId();              //diff all the id
        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };      

        var m_selectionList = [];

        var m_width, m_height;
        var m_props =
        {
            "emptycolor":"#e0e0e0",
            'animation': {
                dataLoading : true,
                dataUpdating : false,
                resize : true,
            },
            'colornumber': 5,
            'discretecolor' : false,
            'colorPalette': [],
            tooltip: {
                enabled: true,
            }
        };
        
        m_props = extendObj(m_props, manifest.props(null));

        var m_propsOutput = manifest.props(null);

        var m_styleTooltipFont = "'Open Sans', Arial, Helvetica, sans-serif";

        var m_data;

        var m_HLElement;

        var m_redrawAll = true;

        var m_className = "tree";
        var m_classNameItem = "treeItem";

        var m_padding;

        var m_xScale = d3.scale.ordinal();
        var m_yScale = d3.scale.ordinal();

        var m_dispatch = new dispatch('selectData', 'deselectData', 'initialized', 'showTooltip', 'hideTooltip', 'startToInit');

        var m_styleLineColor = "#ffffff";
        
        var m_dataDimensions;
        var m_dataRectWeight;
        var m_dataRectColor;

        var m_dataRects;

        var m_selection = null;

        var m_tooltipElement = null;
        var m_guidline = null;

        var m_effectManager = ctx.effectManager;
        var m_maxDimensionLevel = 6;

        var m_colorScale = null;
        
        var m_defaultString = langManager.get('IDS_ISNOVALUE');

        var m_styleLabel = {};
        m_styleLabel.fontSize = "12px";
        m_styleLabel.fontWeight = "normal";
        m_styleLabel.fontFamily = "'Open Sans', Arial, Helvetica, sans-serif";
        m_styleLabel.fill = "#ffffff";

//--------------------------end of internal vars-------------------------------
//--------------------------start of internal functions------------------------
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.fastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        }        

        var stringNoValueHandler = function(str)
        {
            if(str === null || str === undefined)
            {
                str = langManager.get('IDS_ISNOVALUE');
            }
            return str;
        }

        var generateTooltipData = function(dataIndex){

            var tooltipData = {
                body:[],
                footer:[]
            };
            var dataItem = m_dataRects[dataIndex];
            var weightValue = {
                    'name': stringNoValueHandler(dataItem.weight.col),
                    val:[{
                        value: NumberUtils.isNoValue(dataItem.weight.row.val)?m_defaultString:dataItem.weight.row.val
                    }]
            };
            
            tooltipData.body.push(weightValue);

            if(m_dataRectColor)
            {
                var colorValue = {
                        'name': stringNoValueHandler(dataItem.color.col),
                        val:[{
                            value: NumberUtils.isNoValue(dataItem.color.row.val)?m_defaultString:dataItem.color.row.val
                        }]
                };
                
                tooltipData.body.push(colorValue);
            }

            if(TypeUtils.isExist(m_dataDimensions)){
                for(var tval = m_dataDimensions.values, len = tval.length, i = len -1; i  >= 0; i--){
                    var footer = {};
                    footer.label = tval[i].col;
                    footer.value = tval[i].rows[dataIndex%tval[i].rows.length];
                    tooltipData.footer.push(footer);
                }
            }
                        
            return tooltipData;
        };

        var HLCell = function(item)
        {
            if(!NumberUtils.isNoValue(item.datum().val))
            {
                m_HLElement.attr("visibility", "visible");

                var iLeft = item.datum().left+m_padding;
                var iRight = item.datum().left + item.datum().width-m_padding;
                var iTop = item.datum().top+m_padding;
                var iBottom = item.datum().top + item.datum().height-m_padding;

                m_HLElement.select(".HLLeft").attr("x1",iLeft).attr("y1",iTop).attr("x2",iLeft).attr("y2",iBottom);
                m_HLElement.select(".HLRight").attr("x1",iRight).attr("y1",iTop).attr("x2",iRight).attr("y2",iBottom);
                m_HLElement.select(".HLTop").attr("x1",iLeft).attr("y1",iTop).attr("x2",iRight).attr("y2",iTop);
                m_HLElement.select(".HLBottom").attr("x1",iLeft).attr("y1",iBottom).attr("x2",iRight).attr("y2",iBottom);
            }
        };

        var unHLCell = function(item)
        {
            m_HLElement.attr("visibility", "hidden");
        };

        var endAnimation = function(d, i)
        {   
            if(  (d && d.index === (m_dataRects.length - 1) && d.children.length === 0 )//the last datapoint
               || (m_dataRects.length === 0) //no data
               || (d === undefined && i === undefined) //not in "each"
              )
            {
                m_dispatch.initialized();
            }
        };

        var drawTreeMapItems = function(treeLevelRoot, rectObjs, redrawAll, iLevel)
        {
            if(rectObjs.length <= 0)
            {
                return;
            }

            //rectObjs.length > 0
            var isLeafItem = (rectObjs[0].children.length === 0);
            
            //draw this level
            if(redrawAll)
            {
                treeLevelRoot = treeLevelRoot.append("g").attr("class", m_className + "Level" + rectObjs[0].level);
            }
            else
            {
                treeLevelRoot = treeLevelRoot.select("." + m_className + "Level" + rectObjs[0].level);
            }

            var rectObjArrayToDraw = [];
            for(var i = 0; i < rectObjs.length; i++)
            {
                if(rectObjs[i].level === iLevel)
                {
                    rectObjArrayToDraw.push(rectObjs[i]);
                }
            }

            var rootClassName = treeLevelRoot.attr("class");
            var items = treeLevelRoot.selectAll("." + rootClassName + " > ." + m_classNameItem);

            items = items.data(rectObjArrayToDraw,function(d){return d.index;});
                                 
            var toDrawItems = items.enter();
            var toDeleteItems = items.exit();

            var gItems;//items of this level

            //help functions
            var textLength = function(data)
            {
                var style = {};
                style['font-size'] = m_styleLabel.fontSize;
                style['font-weight'] = m_styleLabel.fontWeight;
                style['font-family'] = m_styleLabel.fontFamily;

                var textHeight = fastMeasure(data.label, style).height;
                var textLength = 0;
                if(textHeight > data.height)
                {
                    textLength = -1;//do not show text
                }
                else
                {
                    textLength = data.width - 6;
                }
                return textLength;
            }

            var xLocation = function(d)
            {
//                return d.left+d.width/2;
              return (isLeafItem)?(d.width/2):(d.left+d.width/2);
            }

            var yLocation = function(d)
            {
                var style = {};
                style['font-size'] = m_styleLabel.fontSize;
                style['font-weight'] = m_styleLabel.fontWeight;
                style['font-family'] = m_styleLabel.fontFamily;
                var labelHeight = fastMeasure(d.label, style).height;

                if(d.children.length === 0)
                {
//                    return d.top + d.height/2 + labelHeight/2 - labelHeight/10;
                  return (isLeafItem)?(d.height/2 + labelHeight/2 - labelHeight/10):(d.top + d.height/2 + labelHeight/2 - labelHeight/10);
                }
                else
                {
                    return d.top + labelHeight - labelHeight/10;
                }
            }

            var getText = function(d)
            {
                var styleStr = "font-size:" + m_styleLabel.fontSize;
                styleStr += "font-weight:" + m_styleLabel.fontWeight;
                styleStr += "font-family:" + m_styleLabel.fontFamily;

                var text = "";
                if(d.showLabel)
                {
                    text = TextUtils.ellipsis(d.label, this, textLength(d), styleStr);
                }
                return text;
            }

            var textLocation = function(d)
            {
                return "middle";
            }

            var textColor = function(d)
            {
                var tColor;
                if(d.children.length === 0)
                {
                    tColor = "white";
                }
                else
                {
                    if(d.level === (d.levelNum -1))//leaf
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 6)
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 5)
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 4)
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 3)
                    {
                        tColor = "#595959";
                    }
                    else//((d.levelNum - d.level) === 2)
                    {
                        tColor = "#464646";
                    }
                }

                return tColor;
            }

            var drawRect = function(rect)
            {
                var rectRes = rect.attr("x", function(d){return (isLeafItem)?(0):(d.left+m_padding);})
                .attr("y", function(d){return (isLeafItem)?(0):(d.top+m_padding);})
                .attr("width", function(d){return d.width-2*m_padding>0?d.width-2*m_padding:0;})
                .attr("height",function(d){return d.height-2*m_padding>0?d.height-2*m_padding:0;})
                .attr("fill",function(d){
                    var parameter = {
                        drawingEffect:'normal',
                        fillColor : d.color};
                    return m_effectManager.register(parameter);
                    })
                .attr("shape-rendering", "crispEdges");

                return rectRes;
            }

            var drawLabels = function(labels)
            {
              var labelsRes = null;
              
              if (isLeafItem) {
                labelsRes = labels.attr("x", xLocation)
                .attr("y", yLocation)
                .attr('class', 'treemapdatalabel')
                //ie does not support this property
                //.attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
                .attr("text-anchor", textLocation) // text-align
                .attr("fill", textColor)
                .style("font-size", m_styleLabel.fontSize)
                .style("font-family", m_styleLabel.fontFamily)
                .attr('pointer-events', 'none');
               } else {
                 labelsRes = labels.attr("x", xLocation)
                 .attr("y", yLocation)       
                  //ie does not support this property
                  //.attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
                 .attr("text-anchor", textLocation) // text-align
                 .attr("fill", textColor)
                 .style("font-size", m_styleLabel.fontSize)
                 .style("font-family", m_styleLabel.fontFamily)
                 .attr('pointer-events', 'none');
               } 
              
              labelsRes.text(getText);
              return labelsRes;
            };

            if(redrawAll)
            {
              var className = m_classNameItem;
              if(isLeafItem) {
                className += ' datashape';
              }
              
              gItems = toDrawItems.append("g").attr('class', className);
              if (isLeafItem) {
                gItems.attr('transform', function(d) {return 'translate(' + (d.left+m_padding) + ',' + (d.top+m_padding) + ')';});
               }
                //add rect
                var rects = gItems.append("rect");
                drawRect(rects);

                if(isLeafItem)
                {
                    rects.attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                         .attr('class', 'datapoint');
                }

                //add labels
                var labels = gItems.append("text");
                drawLabels(labels);

            }
            else
            {

                gItems = items;

                //move rects and labels
                var rect = items.select("rect");
                var labels = items.select("text");

                if(m_props.animation.resize)
                {
                    rect = rect.transition();
                    labels = labels.transition();
                }
                
                if (isLeafItem) {
                  gItems.attr('transform', function(d) {
                    var transformStr = 'translate(' + (d.left+m_padding) + ',' + (d.top+m_padding) + ')';
                    return transformStr;
                    });
                }
                
                rect = drawRect(rect);
                labels = drawLabels(labels);
                        
                var aTime = 500;
                if(m_props.animation.resize)
                {
                    rect.delay(0).duration(aTime).each('end',endAnimation);
                    labels.delay(0).duration(aTime);
                }
                else
                {
                    endAnimation();
                }
            }
            
            //draw children recursively
            var eachSubFun = function(thisObj, d, i)
            {
                var thisItem = d3.select(thisObj);
                var da = thisItem.datum().children;

                drawTreeMapItems(thisItem, thisItem.datum().children, redrawAll, iLevel + 1);
            }

            gItems.each(function(d, i)
                {
                    eachSubFun(this, d, i);
                }
            );

            //animation
            gItems = treeLevelRoot.selectAll("." + m_classNameItem);
            if(redrawAll)
            {
                if(m_props.animation.dataLoading)
                {
                    gItems.attr('opacity', 0);
                    gItems.transition()
                        .delay(0)
                        .duration(1000).attr('opacity', 1).each('end',endAnimation);
                }
                else
                {
                    endAnimation();
                }
            }
            else
            {
                endAnimation();
            }

            return gItems;
        };

        var drawTreeMap = function(selection, rectObjs)
        {
            if(m_redrawAll)
            {
                selection.selectAll("*").remove();
            }
            boundUtil.drawBound(selection, m_width, m_height);

            var treeLevelRoot = selection;
            
            var datashapesgroup = selection.selectAll('g.datashapesgroup');
            if(!TypeUtils.isExist(datashapesgroup[0][0])){
              datashapesgroup = selection.append('g').attr('class', 'datashapesgroup');
            }
            drawTreeMapItems(datashapesgroup, rectObjs, m_redrawAll, 0);
        
            //the HLCell Rectange
            if(m_redrawAll)
            {
                m_HLElement = selection.append('g').attr('class', 'HLElement').attr("visibility", "hidden");
                m_HLElement.append('line').attr('class', 'HLLeft').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr('class', 'HLRight').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr('class', 'HLTop').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr('class', 'HLBottom').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
            }
            else
            {
                if(m_HLElement)
                {
                    m_HLElement.attr("visibility", "hidden");
                }
            }

            m_redrawAll = false;
        }

        var buildColorScale = function()
        {
            //return a color scale like
            //var domainRg = [ [10,40], [40, 100] ];
            //var rangeRg = ['#ff0000', '#00ff00' ];
            //d3.scale.ordinal().domain(domainRg).range(rangeRg);
            if(m_dataRectColor)
            {
                var colorObjArray = [];

                var hData = m_dataRectColor.values[0].rows[0];
                //add the data to heatObjArray. the number of rectanges is the number of rectanglecolor.valuies.
                for(var i = 0; i < hData.length; i++)
                {
                    colorObjArray.push(hData[i]);
                }

                //count the max and min value of heatObjArray[i].val
                var maxVal = -Number.MAX_VALUE;
                var minVal = Number.MAX_VALUE;

                for(var iObj = 0; iObj < colorObjArray.length; iObj++)
                {
                    if(!NumberUtils.isNoValue(colorObjArray[iObj].val))
                    {
                        if(maxVal < colorObjArray[iObj].val)
                        {
                            maxVal = colorObjArray[iObj].val;
                        }

                        if(minVal > colorObjArray[iObj].val)
                        {
                            minVal = colorObjArray[iObj].val;
                        }
                    }
                }
                //has "novalue" or not
                var hasNullValue = false;
                for(var i = 0; i < colorObjArray.length; i++)
                {
                    if( NumberUtils.isNoValue(colorObjArray[i].val))
                    {
                        hasNullValue = true;
                    }
                }
            }
            
            var numS = m_props.colornumber;

            var fontColorScale;
            if(minVal === Number.MAX_VALUE && maxVal === -Number.MAX_VALUE
                || (!m_dataRectColor)    
            ){
                //do not show the scale if there is no color measure, or there are just "No values"
                fontColorScale = undefined;
            } else {
                var fontColorScale = MeasureBasedColoring.getScale(minVal, maxVal, numS, m_props.startColor, m_props.endColor);
                if(hasNullValue){
                    var domains = fontColorScale.domain();
                    var ranges = fontColorScale.range();
                    domains.push([]);
                    ranges.push(m_props.emptycolor);
                }
            }

            return fontColorScale;
        }

//----------------layout function: squarifiedTreeMapLayout-----------------------------------------------
        //please refer to http://www.win.tue.nl/~vanwijk/stm.pdf
        var squarifiedTreeMapLayout = function(rectObjs)
        {
            var squarifiedLayout = function (rectObjs, baseRect, isCurrentLevelShowLabel)
            {
                //the function will set 
                //item.left
                //item.top
                //item.height
                //item.width
                //item.labelHeight
                //item.labelWidth
                //item.showLabel
                //item.needMoreHeightToShowLabel
                //for all rectObjs items, and may change items order
                var allWeight = 0;
                for(var i = 0; i < rectObjs.length; i++)
                {
                    allWeight += rectObjs[i].val;
                }

                //to make the sort stable, we must use a stable sort. But Javascript sort may not stable in 
                //Chrome. So using bubble sort here (do not use rectObjs.sort)
                //sort it!
                var weightOrder = function(objA, objB)
                {
                    var compareObjs = 0; 
                    if(objB.val !== objA.val)
                    {
                        compareObjs = objA.val - objB.val;
                    }
                    return compareObjs;
                }
                var tmpObj;
                for (var time = 0; time < rectObjs.length - 1; time++)
                {
                    for (var i = rectObjs.length - 1; i> time; i--)
                    {
                        if (weightOrder(rectObjs[i], rectObjs[i - 1]) > 0)
                        {
                            tmpObj = rectObjs[i - 1];
                            rectObjs[i - 1] = rectObjs[i];
                            rectObjs[i] = tmpObj;
                        }
                    }
                }

                //the current row rectangle
                var currentRowRect = {
                        left:0,
                        top:0,
                        width:0,
                        height:0,
                        weight:0,
                        items:[],//indexs of items
                        worstRadio:0, 
                    };

                //currentRow rect + space rect
                var currentLiveRect = {
                        left:0,
                        top:0,
                        width:0,
                        height:0,
                        weight:0,
                        vertical:false,
                    };
                
                //layout this level
                for(var i = 0; i < rectObjs.length; i++)
                {
                    squarify(rectObjs, i, allWeight, currentRowRect, currentLiveRect, baseRect);
                }

                //Now some additional work.
                for(var itemIndex = 0; itemIndex < rectObjs.length; itemIndex++)
                {
                    //make sure no "NaN"
                    if(!rectObjs[itemIndex].left)
                    {
                        rectObjs[itemIndex].left = 0;
                    }

                    if(!rectObjs[itemIndex].top)
                    {
                        rectObjs[itemIndex].top = 0;
                    }

                    if(!rectObjs[itemIndex].width)
                    {
                        rectObjs[itemIndex].width = 0;
                    }

                    if(!rectObjs[itemIndex].height)
                    {
                        rectObjs[itemIndex].height = 0;
                    }

                    //draw label or not
                    var miniLabel = "";
                    if(rectObjs[itemIndex].label && rectObjs[itemIndex].label.length && rectObjs[itemIndex].label.length > 0)
                    {
                        var strBegin = rectObjs[itemIndex].label[0];
                        miniLabel = strBegin.concat("...");
                    }

                    var style = {};
                    style['font-size'] = m_styleLabel.fontSize;
                    style['font-weight'] = m_styleLabel.fontWeight;
                    style['font-family'] = m_styleLabel.fontFamily;

                    rectObjs[itemIndex].labelHeight = fastMeasure(miniLabel, style).height;
                    rectObjs[itemIndex].labelWidth = fastMeasure(miniLabel, style).width;

                    rectObjs[itemIndex].needMoreHeightToShowLabel = false;

                    if((rectObjs[itemIndex].labelHeight < rectObjs[itemIndex].height)
                        && (rectObjs[itemIndex].labelWidth < rectObjs[itemIndex].width))
                    {
                        rectObjs[itemIndex].showLabel = true;
                    }
                    else
                    {
                        rectObjs[itemIndex].showLabel = false;
                        if(rectObjs[itemIndex].labelHeight >= rectObjs[itemIndex].height)
                        {
                            rectObjs[itemIndex].needMoreHeightToShowLabel = true;
                        }
                    }
                }
                
                var isLeafNodeNeedMoreHeight = true;
                //check each leaf
                for(var itemIndex = 0; itemIndex < rectObjs.length; itemIndex++)
                {
                    if(rectObjs[itemIndex].level === (rectObjs[itemIndex].levelNum - 1))
                    {
                        if(!rectObjs[itemIndex].needMoreHeightToShowLabel)
                        {
                            isLeafNodeNeedMoreHeight = false;
                            break;
                        }
                    }
                    else
                    {
                        isLeafNodeNeedMoreHeight = false;
                    }
                }

                var hideLabelFun = function(i)
                {
                    if(rectObjs[i].level !== (rectObjs[i].levelNum - 1))
                    {
                        rectObjs[i].showLabel = false;
                    }

                    //adjust base rect for children
                    baseRectForChild.top = rectObjs[i].top + m_padding*2;
                    baseRectForChild.left = rectObjs[i].left + m_padding*2;
                    baseRectForChild.width = rectObjs[i].width - m_padding*2 - m_padding;
                    baseRectForChild.height = rectObjs[i].height - m_padding*2 - m_padding;
                }

                if(!isLeafNodeNeedMoreHeight)
                {
                    for(var i = 0; i < rectObjs.length; i++)
                    {
                        if(rectObjs[i].children.length > 0)
                        {
                            var showLabelForChildren = true;
                            if(!isCurrentLevelShowLabel)
                            {
                                showLabelForChildren = false;
                            }

                            var labelHeight = rectObjs[i].labelHeight;

                            var baseRectForChild = {};
                            baseRectForChild.top = rectObjs[i].top + m_padding*2 + labelHeight;
                            baseRectForChild.left = rectObjs[i].left + m_padding*2;
                            baseRectForChild.width = rectObjs[i].width - m_padding*2 - m_padding;
                            baseRectForChild.height = rectObjs[i].height - m_padding*2 - m_padding - labelHeight;

                            if(!showLabelForChildren)
                            {
                                hideLabelFun(i);
                            }

                            isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs[i].children, baseRectForChild, showLabelForChildren);
                            if((isLeafNodeNeedMoreHeight || !rectObjs[i].showLabel) && showLabelForChildren)//relayout
                            {
                                hideLabelFun(i);
                                isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs[i].children, baseRectForChild, false);
                            }
                        }
                    }
                }
                
                return isLeafNodeNeedMoreHeight;
            }

            var rectAspectRatio = function(rect)
            {
                //radio >= 1
                var radio;
                if(rect.height > rect.width)
                {
                    radio = rect.height/rect.width;
                }
                else
                {
                    radio = rect.width/rect.height;
                }

                radio = Math.floor(radio*1000);
                return radio;
            }

            var worstAspectRatio = function(rectObjs, newItemWeight, isInCurrentRow, currentRowRect, currentLiveRect)
            {
                //return the worst AspectRatio in the (changed) currentRow and the new item. 
                var worstRadio = 0;

                var newItemRect = {};
                if(isInCurrentRow)
                {
                    //if currentLiveRect is vertical, 
                    //it means items in currentRow is horizontal.
                    if(currentLiveRect.vertical)
                    {
                        newItemRect.width = currentLiveRect.width * (newItemWeight / (currentRowRect.weight + newItemWeight));
                        newItemRect.height = currentLiveRect.height * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                    }
                    else
                    {
                        newItemRect.height = currentLiveRect.height * (newItemWeight / (currentRowRect.weight + newItemWeight));
                        newItemRect.width = currentLiveRect.width * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                    }

                    worstRadio = rectAspectRatio(newItemRect);

                    //adjust items in currentRowRect, count the worstRadio
                    for(var i = 0; i < currentRowRect.items.length; i++)
                    {
                        var objIndex = currentRowRect.items[i];
                        var currentItemRect = {};
                        if(currentLiveRect.vertical)
                        {
                            currentItemRect.width = currentRowRect.width * (rectObjs[objIndex].val / (currentRowRect.weight + newItemWeight));
                            currentItemRect.height = currentLiveRect.height * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                        }
                        else
                        {
                            currentItemRect.height = currentRowRect.height * (rectObjs[objIndex].val / (currentRowRect.weight + newItemWeight));
                            currentItemRect.width = currentLiveRect.width * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                        }

                        //current item radio
                        var currentItemRadio = rectAspectRatio(currentItemRect);

                        //update the worst
                        if(worstRadio < currentItemRadio)
                        {
                            worstRadio = currentItemRadio;
                        }
                    }
                }
                else
                {
                    worstRadio = currentRowRect.worstRadio;
                }

                return worstRadio;
            }

            var getCurrentSpaceRect = function(currentRowRect, currentLiveRect)
            {
                var currentSpaceRect = {};
                currentSpaceRect.weight = currentLiveRect.weight - currentRowRect.weight;

                if(currentLiveRect.width === currentRowRect.width)
                {
                    currentSpaceRect.left = currentLiveRect.left;
                    currentSpaceRect.top = currentRowRect.top + currentRowRect.height;
                    currentSpaceRect.width = currentLiveRect.width;
                    currentSpaceRect.height = currentLiveRect.height - currentRowRect.height;
                }
                else
                {
                    currentSpaceRect.left = currentRowRect.left + currentRowRect.width;
                    currentSpaceRect.top = currentLiveRect.top;
                    currentSpaceRect.width = currentLiveRect.width - currentRowRect.width;
                    currentSpaceRect.height = currentLiveRect.height;
                }

                return currentSpaceRect;
            }

            var squarify = function (rectObjs, itemIndex, allWeight, currentRowRect, currentLiveRect, baseRect)
            {
                //itemIndex : const
                //allWeight : const
                //currentRowRect : be changed
                //currentLiveRect : be changed
                if(itemIndex === 0)
                {
                    rectObjs[itemIndex].left = baseRect.left;
                    rectObjs[itemIndex].top = baseRect.top;

                    if(baseRect.width > baseRect.height)
                    {
                        //layout the item
                        rectObjs[itemIndex].height = baseRect.height;
                        rectObjs[itemIndex].width = baseRect.width * (rectObjs[itemIndex].val / allWeight);
                        currentLiveRect.vertical = false;
                    }
                    else
                    {
                        //layout the item
                        rectObjs[itemIndex].width = baseRect.width;
                        rectObjs[itemIndex].height = baseRect.height * (rectObjs[itemIndex].val / allWeight);
                        currentLiveRect.vertical = true;
                    }
                    
                    //adjust currentRowRect
                    currentRowRect.left = baseRect.left;
                    currentRowRect.top = baseRect.top;
                    currentRowRect.width = rectObjs[itemIndex].width;
                    currentRowRect.height = rectObjs[itemIndex].height;
                    currentRowRect.weight = rectObjs[itemIndex].val;
                    currentRowRect.items.push(itemIndex);
                    currentRowRect.worstRadio = rectAspectRatio(currentRowRect);

                    //adjust currentLiveRect
                    currentLiveRect.left = baseRect.left;
                    currentLiveRect.top = baseRect.top;
                    currentLiveRect.width = baseRect.width;
                    currentLiveRect.height = baseRect.height;
                    currentLiveRect.weight = allWeight;
                }
                else if(itemIndex === (rectObjs.length -1))
                {
                    //just put it into the space
                    var currentSpaceRect = getCurrentSpaceRect(currentRowRect, currentLiveRect);
                    rectObjs[itemIndex].left = currentSpaceRect.left;
                    rectObjs[itemIndex].top = currentSpaceRect.top;
                    rectObjs[itemIndex].width = currentSpaceRect.width;
                    rectObjs[itemIndex].height = currentSpaceRect.height;
                }
                else
                {                
                    var inRowWorstRadio = (worstAspectRatio(rectObjs, rectObjs[itemIndex].val, true, currentRowRect, currentLiveRect));
                    var newRowWorstRadio = (worstAspectRatio(rectObjs, rectObjs[itemIndex].val, false, currentRowRect, currentLiveRect));

                    if(inRowWorstRadio < newRowWorstRadio)
                    {
                        //update the worstRadio
                        currentRowRect.worstRadio = inRowWorstRadio;

                        //adjust currentRowRect
                        currentRowRect.items.push(itemIndex);
                        currentRowRect.weight += rectObjs[itemIndex].val;

                        if(currentLiveRect.vertical)
                        {
                            currentRowRect.height = currentLiveRect.height * (currentRowRect.weight / currentLiveRect.weight);
                        }
                        else
                        {
                            currentRowRect.width = currentLiveRect.width * (currentRowRect.weight / currentLiveRect.weight);
                        }

                        //adjust items in currentRowRect
                        for(var i = 0; i < currentRowRect.items.length; i++)
                        {
                            var objIndex = currentRowRect.items[i];
                            if(currentLiveRect.vertical)
                            {
                                rectObjs[objIndex].width = currentRowRect.width * (rectObjs[objIndex].val / currentRowRect.weight);
                                rectObjs[objIndex].height = currentLiveRect.height * (currentRowRect.weight / currentLiveRect.weight);

                                rectObjs[objIndex].top = currentRowRect.top;
                                
                                if(i === 0)//for the first item in the row
                                {
                                    rectObjs[objIndex].left = currentRowRect.left;
                                }
                                else
                                {
                                    rectObjs[objIndex].left = rectObjs[objIndex-1].left + rectObjs[objIndex-1].width;
                                }
                            }
                            else
                            {
                                rectObjs[objIndex].height = currentRowRect.height * (rectObjs[objIndex].val / currentRowRect.weight);
                                rectObjs[objIndex].width = currentLiveRect.width * (currentRowRect.weight / currentLiveRect.weight);

                                rectObjs[objIndex].left = currentRowRect.left;
                                
                                if(i === 0)//for the first item in the row
                                {
                                    rectObjs[objIndex].top = currentRowRect.top;
                                }
                                else
                                {
                                    rectObjs[objIndex].top = rectObjs[objIndex-1].top + rectObjs[objIndex-1].height;
                                }
                            }
                        }

                        //do not need to adjust currentLiveRect.
                    }
                    else
                    {
                        //make a new currentLiveRect
                        var newCurrentLiveRect = getCurrentSpaceRect(currentRowRect, currentLiveRect);
                        
                        currentLiveRect.left = newCurrentLiveRect.left;
                        currentLiveRect.top = newCurrentLiveRect.top;
                        currentLiveRect.width = newCurrentLiveRect.width;
                        currentLiveRect.height = newCurrentLiveRect.height;
                        currentLiveRect.weight = newCurrentLiveRect.weight;

                        if(currentLiveRect.width > currentLiveRect.height)
                        {
                            currentLiveRect.vertical = false;
                        }
                        else
                        {
                            currentLiveRect.vertical = true;
                        }

                        //make a new currentRowRect
                        currentRowRect.left = currentLiveRect.left;
                        currentRowRect.top = currentLiveRect.top;
                        currentRowRect.weight = rectObjs[itemIndex].val;
                        if(currentLiveRect.vertical) 
                        {
                            currentRowRect.width = currentLiveRect.width;
                            currentRowRect.height = currentLiveRect.height * (rectObjs[itemIndex].val / currentLiveRect.weight);
                        }
                        else
                        {
                            currentRowRect.height = currentLiveRect.height;
                            currentRowRect.width = currentLiveRect.width * (rectObjs[itemIndex].val / currentLiveRect.weight);
                        }

                        currentRowRect.worstRadio = rectAspectRatio(currentRowRect);        
                        currentRowRect.items = [];
                        currentRowRect.items.push(itemIndex);

                        //layout the item
                        rectObjs[itemIndex].width = currentRowRect.width;
                        rectObjs[itemIndex].height = currentRowRect.height;
                        rectObjs[itemIndex].top = currentRowRect.top;
                        rectObjs[itemIndex].left = currentRowRect.left;
                    }
                }
            }
            //the entry of squarifiedTreeMapLayout
            var baseRect = {};
            baseRect.top = 0;
            baseRect.left = 0;
            baseRect.width = m_width;
            baseRect.height = m_height;
            
            var isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs, baseRect, true);
            if(isLeafNodeNeedMoreHeight)//relayout
            {
                squarifiedLayout(rectObjs, baseRect, false);
            }
        }
//----------------end of layout function: squarifiedTreeMapLayout-----------------------------------------------
        var buildTreeData = function(m_dataRects, iLevel, levelNum, startIndex, endIndex)
        {
            if(iLevel >= levelNum)
            {
                return [];
            }

            var rectObjArray = [];

            //each item:
            //color:#333333
            //colorValue:2
            //ctx:(color m ctx)
            //label:
            //val:(the weight) (if it is a negative value, we set it to 0)
            //children: a rectObjArray or []
            //level: leaf is 0
            //levelNum
            //index (id)
            var lastDimensionName = undefined;
            
            var childrenStartIndex = startIndex;
            var childrenEndIndex = childrenStartIndex + 1;

            for(var i = startIndex; i < endIndex; i++)
            {
                var rectObjItem = {};
                var currentDimensionName = m_dataRects[i].dimensions[iLevel].row.val;
                if(currentDimensionName !== lastDimensionName || 
                    iLevel === levelNum - 1) //for leaf items, we do not merge
                {
                    //set rectObjItem.color and rectObjItem.colorValue
                    var color = setItemColor(i, iLevel, levelNum, rectObjItem);

                    rectObjItem.label = m_dataRects[i].dimensions[iLevel].row.val;
                    rectObjItem.level = iLevel;
                    rectObjItem.levelNum = levelNum;
                    rectObjItem.isTreeMap = true;
                    
                    if(iLevel === levelNum - 1)//leaf node
                    {
                        rectObjItem.ctx = m_dataRects[i].weight.row.ctx;//legned is for weight
                    }
                    else
                    {
                        rectObjItem.ctx = null;
                    }
                    rectObjItem.index = i;
                    
                    if(m_dataRects[i].weight.row.val >= 0)
                    {
                        rectObjItem.val = m_dataRects[i].weight.row.val;
                    }
                    else
                    {
                        //https://tipjira.pgdev.sap.corp/browse/BITVIZA-137 "Treat negative value as zero."
                        rectObjItem.val = 0;
                    }

                    //we should update the children of previous item
                    if(rectObjArray.length >0)
                    {
                        rectObjArray[rectObjArray.length -1].children = buildTreeData(m_dataRects,
                                       (iLevel + 1), levelNum, childrenStartIndex, childrenEndIndex);

                        childrenStartIndex = i;
                        childrenEndIndex = childrenStartIndex + 1;
                    }

                    //add new item and update childrenIndexs
                    rectObjArray.push(rectObjItem);
                }
                else
                {
                    //update the last item
                    if(m_dataRects[i].weight.row.val >= 0)
                    {
                        rectObjArray[rectObjArray.length -1].val += m_dataRects[i].weight.row.val;
                    }
                    
                    childrenEndIndex++;
                }
                lastDimensionName = currentDimensionName;

                if(i === endIndex - 1)
                {
                    //we should update the children of previous item
                    if(rectObjArray.length >0)
                    {
                        rectObjArray[rectObjArray.length -1].children = buildTreeData(m_dataRects,
                                       (iLevel + 1), levelNum, childrenStartIndex, childrenEndIndex);
                    }
                }
            }

            return rectObjArray;
        }

        var setItemColor = function(index, iLevel, levelNum, rectObjItem)
        {
            if(iLevel !== (levelNum - 1))//not leaf
            {
                //set rectObjItem.color
                var level = (levelNum -1 - iLevel);
                if(level === 1)
                {
                    rectObjItem.color = "#f9f9f9";
                }
                else if(level === 2)
                {
                    rectObjItem.color = "#e3e3e3";
                }
                else if(level === 3)
                {
                    rectObjItem.color = "#bfbfbf";
                }
                else if(level === 4)
                {
                    rectObjItem.color = "#989898";
                }
                else if(level === 5)
                {
                    rectObjItem.color = "#717171";
                }
                //set rectObjItem.colorValue
                rectObjItem.colorValue = Number.MAX_VALUE;
            }
            else
            {
                if(m_dataRects[index].color)
                {
                    //set colorValue
                    rectObjItem.colorValue = m_dataRects[index].color.row.val;

                    //set rectObjItem.color. m_colorScale is set
                    if(m_colorScale)
                    {
                        var domainArray = m_colorScale.domain();

                        if(NumberUtils.isNoValue(rectObjItem.colorValue))
                        {
                            rectObjItem.color = m_props.emptycolor;
                        }
                        else
                        {
                            var domainValue;
                            for( var j = 0; j<domainArray.length; j++)
                            {
                                var tdv = domainArray[j];
                                if ((j == domainArray.length-1) || (domainArray[j+1].length == 0)) {
                                    domainValue = tdv;
                                    break;
                                }
                                if ((rectObjItem.colorValue >= tdv[0]) && (rectObjItem.colorValue < tdv[1])) {
                                    domainValue = tdv;
                                    break;
                                }
                            }
                            rectObjItem.color = m_colorScale(domainValue);
                        }
                    }
                    else
                    {
                        rectObjItem.color = m_props.emptycolor;
                    }
                }
                else
                {
                    rectObjItem.colorValue = Number.MAX_VALUE;

                    //set rectObjItem.color
                    var colorArray = ColorSeries.sap32().range();
                    rectObjItem.color = colorArray[0];
                }
            }
        }

//--------------------------end of internal functions--------------------------
//--------------------------external functions---------------------------------

        function chart(selection) {
            m_selection = selection;
            m_dispatch.startToInit();
            if(m_props.border && m_props.border.visible)
            {
                m_padding = 1;
            }
            else
            {
                m_padding = 0;
            }
            //build color scale
            m_colorScale = buildColorScale();

            //prepare tree data, and draw the treeMap level by level
            var levelNum = m_dataRects[0].dimensions.length;

            var rectObjArray = buildTreeData(m_dataRects, 0, levelNum, 0, m_dataRects.length);

            //existing data is read-only in layout and draw functions
            //layout it recursively
            squarifiedTreeMapLayout(rectObjArray);

            //draw the treemap recursively (update it, or redraw it)
            drawTreeMap(selection, rectObjArray);

            return chart;
        };

        chart.dataLabel = function(_){
          
        };
        
        chart.afterUIComponentAppear = function(){
          m_dispatch.initialized(); 
        };
        
        
        chart.mouseover = function(elem){
            var item = d3.select(d3.event.target);
            var clickedItemID = item.attr('id');
            if(clickedItemID && m_props.tooltip.enabled)
            {
              var tmpLength = clickedItemID.toString().length - randomSuffix.toString().length - 2;
                var dataIndex = clickedItemID.toString().substr(2 , tmpLength);
                
                var transform = m_selection.node().getTransformToElement(m_selection.node().ownerSVGElement);
                var svgBoundingBox = m_selection.node().ownerSVGElement.getBoundingClientRect();
                var rectBoundingBox =  elem.getBoundingClientRect();
                //showTooltip(dataIndex);
                var tooltipData = generateTooltipData(dataIndex);
                tooltipData.point = {
                        x : rectBoundingBox.left - svgBoundingBox.left + rectBoundingBox.width/2,
                        y : (rectBoundingBox.height > 16) ? rectBoundingBox.top - svgBoundingBox.top + 8 : rectBoundingBox.top - svgBoundingBox.top + rectBoundingBox.height/2
                };
                tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : m_width,
                        height : m_height
                };
                m_dispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
                HLCell(item);
            }

        };
        
        chart.mouseout = function(){
            if(m_props.tooltip.enabled)
            {
                m_dispatch.hideTooltip();
            }

            if(d3.event)
            {
                var item = d3.select(d3.event.target);
                unHLCell(item);
            }
        };

        /*
         * Add mouse interaction functions.
         */
        chart.parent = function(){
            return m_selection;
        };

        chart.highlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 1);
                }
            }else{
                elems.setAttribute('opacity', 1);
            }
        };
        
        chart.unhighlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 0.2);
                }
            }else{
                elems.setAttribute('opacity', 0.2);
            }
        };
        
        chart.clear = function(gray){
            if( gray == null){
                m_selection.selectAll('.datapoint').attr('opacity', 1);
            }else{
                m_selection.selectAll('.datapoint').attr('opacity', 0.2);
            }
        };
        
        chart.width = function(_width){
            if (!arguments.length){
              return m_width;
            }
            m_width = _width;
            return chart;
        };

        chart.height = function(_height){
            if (!arguments.length){
              return m_height;
            }
            m_height = _height;
            return chart;       
        };

        chart.data = function(value){
            if (!arguments.length){
                return m_data;
            }

            m_data = value;
            m_redrawAll = true;
            
            m_dataDimensions = m_data.getAnalysisAxisDataByIdx(0);
            m_dataRectWeight = m_data.getMeasureValuesGroupDataByIdx(0);
            m_dataRectColor = m_data.getMeasureValuesGroupDataByIdx(1);

            var dataDimensions = m_data.getAnalysisAxisDataByIdx(0);
            var dataRectWeight = m_data.getMeasureValuesGroupDataByIdx(0);
            var dataRectColor = m_data.getMeasureValuesGroupDataByIdx(1);

            //make the rect array which has all datas(not a tree)
            m_dataRects = [];

            //add weight
            var vArray = dataRectWeight.values[0].rows[0];
            for(var i = 0; i < vArray.length; i++)
            {
                var dataRectItem = {};

                var weightObj = {};
                weightObj.col = dataRectWeight.values[0].col;
                weightObj.row = vArray[i];

                dataRectItem.weight = weightObj;

                m_dataRects.push(dataRectItem);
            }

            //add color
            if(dataRectColor)
            {
                var vArray = dataRectColor.values[0].rows[0];
                for(var i = 0; i < m_dataRects.length; i++)
                {
                    var dataRectItem = m_dataRects[i];

                    var colorObj = {};
                    colorObj.col = dataRectColor.values[0].col;
                    colorObj.row = vArray[i];

                    dataRectItem.color = colorObj;
                }
            }

            //add dimensions (6 levels at most)
            var vArray = dataDimensions.values;
            for(var i = 0; i < m_dataRects.length; i++)
            {
                var dataRectItem = m_dataRects[i];

                var dimensionArray = [];
                var levels = vArray.length;
                if(levels > m_maxDimensionLevel)
                {
                    levels = m_maxDimensionLevel;
                }
                for(var j = 0; j < levels; j++)
                {
                    var dimensionItem = {};
                    dimensionItem.col = dataDimensions.values[j].col;
                    dimensionItem.row = dataDimensions.values[j].rows[i];

                    dimensionArray.push(dimensionItem);
                }

                dataRectItem.dimensions = dimensionArray;
            }
            
            return chart;
        };

        chart.properties = function(props){
            if (!arguments.length){
                return m_propsOutput;
            }           
            Objects.extend(true, m_props, props);
            Objects.extend(true, m_propsOutput, props);
            m_redrawAll = true;
            return chart;           
        };

        /**
         * interfaces for MBC legend selection
         * @param {Object} selectedData 
         * <pre>
         * {
         * ctx: {
         *   ranges: {
         *    endValue:100
         *    isLeftOpen:false
         *    isRightOpen:true
         *    startValue:84
         *   }
         * },
         * val: 84   
         * }
         * @returns {Array} d3 selections in the given range  
         */
        chart.getDatapointsByRange = function(selectedData){
          var datapoints = d3.selectAll('.datapoint')[0], ctxDatapoints = [], ranges = selectedData.ctx.ranges, data;
          for(var i = 0, len = datapoints.length; i < len; i++){
            data = datapoints[i].__data__.colorValue;
            if(NumberUtils.isNoValue(selectedData.val)){
              if(NumberUtils.isNoValue(data)){
                ctxDatapoints.push(datapoints[i]);
              }
            }else{
              if(data < ranges.endValue && data > ranges.startValue){
                ctxDatapoints.push(datapoints[i]);
              }else{
                if(!ranges.isLeftOpen && data === ranges.startValue) {
                  ctxDatapoints.push(datapoints[i]);
                }else if(!ranges.isRightOpen && data === ranges.endValue){
                  ctxDatapoints.push(datapoints[i]);
                }
              }
            }
          }
          return ctxDatapoints;
        };
         
        /**
         * for MBC legend
         */
        chart.mbcLegendInfo = function(){
            var hColor = buildColorScale();
            var title = "";
            if(m_dataRectColor)
            {
                title = m_dataRectColor.values[0].col;
            }
            return {
                'colorScale' : hColor,
                'title': title,
            };
        };

        /**
         * required by the layout
         */
        chart.getPreferredSize = function(){  
          
        };

        /**
         * get/set your event dispatch if you support event
         */
        chart.dispatch = function(_){
            if(!arguments.length)
                return m_dispatch;
            m_dispatch = _;
            return chart;
        };
        return chart;
    };

    return treeMap;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.TreeMap',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.treemap',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.TreeMap',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn)
{
    var module =
    {
      'id' : 'sap.viz.modules.treemap',
      'type' : Constants.Module.Type.Chart,
      'name' : 'treemap',
      'properties' : {
        'border' : {
          'name' : 'border',
          'description' : 'Settings for border.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'visible' : {
                'name' : 'visible',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set visibility of zone edge.'
            },
          },
        },

        'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enabled/disabled data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enabled/disabled data updating animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.'
        },
        'startColor' : {
          'name' : 'startColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#C2E3A9",
          'description' : 'Set treeMap startColor.'
        },
      
        'endColor' : {
          'name' : 'endColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#73C03C",
          'description' : 'Set treeMap endColor.'
        },

        'tooltip' : {
          'name' : 'tooltip',
          'description' : 'Settings for tooltip.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
              'visible': {
                    'name' : 'enabled',
                    'supportedValueType' : 'Boolean',
                    'defaultValue' : true,
                    'description' : 'Set enabled/disabled tooltip.'
              },
          },
          'isExported': false
        }
      },
      'events' :
      {
        'initialized': Constants.Module.Event.Initialized.desc,
        'selectData' : Constants.Module.Event.SelectData.desc,
        'deselectData' : Constants.Module.Event.DeSelectData.desc,
        'showTooltip' : Constants.Module.Event.TooltipShow.desc,
        'hideTooltip' : Constants.Module.Event.TooltipHide.desc
      },
      'feeds' :{
          id:"treeMap"
      },
      'css' : {},
      'configure' : null,
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.TreeMapChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TreeMap',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/treemap',
    name : 'IDS_TREEMAPCHART',
      base : 'riv/base/single',
    modules : {
        
      legend : {
          id : 'sap.viz.modules.legend',
        configure : {
          'description': 'The measure based coloring legend is a bar containing segments with different colors and a value scale on side to indicate the relationship between the values and colors in the chart. ',
          properties : {
              type : 'MeasureBasedColoringLegend'
            },
            propertiesOverride : {
              isHierarchical : {
                isExported : false
              },
              formatString: {
                isExported: true
              }
            }
        }
      },
    tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
              chartType : 'treemap',
              orientation : 'bottom'
            }
          }
        },

      main : {
        modules : {
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                paintingMode : 'rectCoordinate',
                visible : false,
                orientation : 'vertical',
                position : 'inside',
                automaticInOutside : false,
                showZero : true,
                isStackMode : false,
                isPercentMode : false,
                outsideVisible : false
              }
            }
          },
          plot : {
            id : 'sap.viz.modules.treemap',
            configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        },
        controllers : {
             'interaction' : {
                   id : 'sap.viz.modules.controller.interaction',
                   configure : {
                       propertyCategory : 'interaction',
                        properties : {
                          supportedEventNames: ['mouseup', 'mouseover', 'mouseout', 'touchstart']
                        }
                   }
             }
        }
      }
    },
    dependencies : {
      attributes : [ 
      {
        targetModule : 'legend',
        target : 'mbcLegendInfo',
        sourceModule : 'main.plot',
        source : 'mbcLegendInfo'
      }, {
          targetModule : 'legend',
          target : 'setSelectionMode',
          sourceModule : 'main.interaction',
          source : 'getSelectionMode'
      }],
    
          events : [ {
              targetModule : 'main.interaction',
              listener : 'registerEvent',
              sourceModule : 'main.plot',
              type : 'initialized.interaction'
          }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
      }, {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'main.plot',
          type : 'startToInit.datalabel'
        }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.HeatMap',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var mainLabelAxisFeed = {
      'id' : 'mainLabelAxis',
      'name' : 'Main Category Axis',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
       'acceptMND': -1
    };

    var rectangleColorFeed = {
      'id' : 'rectangleColor',
      'name' : 'Rectangle Color',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    };

    var secondLabelAxisFeed = {
      'id' : 'secondaryLabelAxis',
      'name' : 'Secondary Category Axis',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 2,
       'acceptMND': -1
    };
  var feeds = {
    id : "heatMap",
    feeds : [ mainLabelAxisFeed, rectangleColorFeed, secondLabelAxisFeed ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.heatmap',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.EffectManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.MeasureBasedColoring',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(dispatch, ColorSeries, tooltipDataHandler, NumberUtils,EffectManager, TypeUtils, NumberUtils, TextRuler, MeasureBasedColoring, langManager, Repository, Objects, BoundUtil) {
    //heatmap has no MND
    var heatMap = function(manifest, ctx) {
    
      var randomSuffix = Repository.newId();              //diff all the id
        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };      

        var m_selectionList = [];

        var m_width, m_height;
        var m_props =
        {
            "emptycolor":"#e0e0e0",
            'animation': {
                dataLoading : true,
            },
            'colornumber': 5,
            'discretecolor' : false,
            'guideline' : 
            {
                visible: false,
                color: "#ffff90",
            },
            'drawemptycell': true,
            'colorPalette': [],
            tooltip: {
                enabled: true,
            }
        };
        
        m_props = extendObj(m_props, manifest.props(null));

        var m_propsOutput = manifest.props(null);
        
        var m_styleTooltipFont = "'Open Sans', Arial, Helvetica, sans-serif";

        var m_data;

        var m_HLElement;

        var m_redrawAll = true;

        var m_className = "heatMap";
        var m_classEmptyValue = "heatMap_emptyValue";

        var m_padding = 1;

        var m_xScale = d3.scale.ordinal();
        var m_yScale = d3.scale.ordinal();

        var m_dispatch = new dispatch('selectData', 'deselectData', 'initialized', 'showTooltip', 'hideTooltip', 'startToInit');

        var hColor = undefined; //Color Scale

        var m_styleLineColor = "#ffffff";
        
        var m_dataXAxis;
        var m_dataYAxis;
        var m_dataRect;

        var m_heatMapBody;//the root class
        var m_rects;//rects in the heatmap

        var m_selection = null;

        var m_tooltipElement = null;
        var m_guidline = null;

        //we need to draw some recs. So I will build a obj array, each item is a rec.
        var m_heatObjArray = [];

        var m_effectManager = ctx.effectManager;
        
        var m_defaultString = langManager.get('IDS_ISNOVALUE');
        
        var m_dataShape = null;
        
        function chart(selection){
          BoundUtil.drawBound(selection, m_width, m_height);
          m_dispatch.startToInit();
            m_selection = selection;
            //console.log(m_redrawAll);

            //prepare data
            m_heatObjArray = [];
            
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                //build labels
                var labelArray = [];
                var vArray = m_dataRect.values[0].rows[0];
                //add the data to m_heatObjArray. the number of rectanges is the number of rectanglecolor.valuies.
                for(var i = 0; i < vArray.length; i++)
                {
                    m_heatObjArray.push(vArray[i]);
                }

                //build labelArray
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    var label = "";
                    for(var j = 0; j < m_dataXAxis.values.length; j++)
                    {
                        label += m_dataXAxis.values[j].rows[i].val;
                        if(j != (m_dataXAxis.values.length-1))
                        {
                            label += " / ";
                        }
                    }
                    labelArray.push(label);
                }

                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].label = labelArray[i];
                    m_heatObjArray[i].isOnlyOneCategory = true;
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                for(var i = 0; i < numRow; i++)
                {
                    for(var j = 0; j < numCol; j++)
                    {
                        m_heatObjArray.push(hData[i][j]);
                    }
                }
                
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                  m_heatObjArray[i].isOnlyOneCategory = false;
                }
            }

            // //count the max and min value of m_heatObjArray[i].val
            // var maxVal = -Number.MAX_VALUE;
            // var minVal = Number.MAX_VALUE;

            // for(var iObj = 0; iObj < m_heatObjArray.length; iObj++)
            // {
                // if(!NumberUtils.isNoValue(m_heatObjArray[iObj].val))
                // {
                    // if(maxVal < m_heatObjArray[iObj].val)
                    // {
                        // maxVal = m_heatObjArray[iObj].val;
                    // }

                    // if(minVal > m_heatObjArray[iObj].val)
                    // {
                        // minVal = m_heatObjArray[iObj].val;
                    // }
                // }
            // }

            //var numS = m_props.colornumber;

            hColor = buildColorScale();
            var domainArray = hColor.domain();
            for(var i = 0; i < m_heatObjArray.length; i++)
            {
                var domainValue;
                if(NumberUtils.isNoValue(m_heatObjArray[i].val)) {
                    m_heatObjArray[i].color = m_props.emptycolor;
                } else {
                    for (var j=0; j<domainArray.length; j++) {
                        var tdv = domainArray[j];
                        if ((j == domainArray.length-1) || (domainArray[j+1].length == 0)) {
                            domainValue = tdv;
                            break;
                        }
                        if ((m_heatObjArray[i].val >= tdv[0]) && (m_heatObjArray[i].val < tdv[1])) {
                            domainValue = tdv;
                            break;
                        }
                    }
                    m_heatObjArray[i].color = hColor(domainValue);
                }
                
                
                // for(var j = 0; j < numS; j++)
                // {
                     // if(NumberUtils.isNoValue(m_heatObjArray[i].val))
                    // {
                        // m_heatObjArray[i].color = m_props.emptycolor;
                        // break;
                    // }
                     // else if( m_heatObjArray[i].val == maxVal )
                    // {
                        // m_heatObjArray[i].color = hColor([(minVal + (maxVal-minVal)/numS*(numS-1)), maxVal]);
                        // break;
                    // }
                    // else if(m_heatObjArray[i].val >= (minVal + (maxVal-minVal)/numS*j) && m_heatObjArray[i].val < (minVal + (maxVal-minVal)/numS*(j+1)))
                    // {
                        // m_heatObjArray[i].color = hColor( [(minVal + (maxVal-minVal)/numS*j), (minVal + (maxVal-minVal)/numS*(j+1))]  );
                       
                    // }
                    
                // }
            }

            if(isOnlyOneCategroy)
            {
                //build the rect size. The rule is making the rect width and height have similar values
                var score = -Number.MAX_VALUE;//the bigger the better

                var rHeight;
                var rWidth;
                
                var iRow;
                var iCol;

                var emptyCellNum;

                var scoreArray = [];
                var varianceRec;

                if(m_heatObjArray.length == 1)
                {
                    rHeight = m_height;
                    rWidth = m_width;
                    iCol = 1;
                    iRow = 1;
                }
                else
                {

                    for(iRow = 1; iRow <= m_heatObjArray.length; iRow++)
                    {
                        //count the height
                        rHeight = m_height/iRow;

                        //count the num of one row. 
                        var iCol = m_heatObjArray.length;
                        for(; iCol >= 0; iCol--)
                        {
                            if((iCol * iRow) < m_heatObjArray.length)
                            {
                                iCol++;
                                break;
                            }
                        }

                        //count the width
                        rWidth = m_width/iCol;

                        emptyCellNum = (iCol * iRow) - m_heatObjArray.length;
                        varianceRec = (rHeight - rWidth)*(rHeight - rWidth);

                        if(varianceRec < 1)
                        {
                            varianceRec = 1; //to avoid 1/varianceRec huge number
                        }

                        var score;
                        if(emptyCellNum == 0 && varianceRec == 0)
                        {
                            score = 1 + 1;
                        }
                        else if(emptyCellNum == 0 && varianceRec != 0)
                        {
                            score = 1 + 1/varianceRec;
                        }
                        else if(emptyCellNum != 0 && varianceRec == 0)
                        {
                            score = 1 + 1;
                        }
                        else
                        {
                            score = 1 + 1/varianceRec;
                        }
                        
                        scoreArray.push(
                        {
                            "iRow":iRow,
                            "iCol":iCol,
                            "rHeight":rHeight,
                            "rWidth":rWidth,
                            "varianceRec":varianceRec,
                            "emptyCellNum":emptyCellNum,
                            "score":score
                        });
                    }
                    //select the best score
                    var maxS = 0;
                    var iChoose = -1;
                    for(var i = 0; i < scoreArray.length; i++)
                    {
                        if(scoreArray[i].score > maxS)
                        {
                            maxS = scoreArray[i].score;
                            iChoose = i;
                        }
                    }

                    rHeight = scoreArray[iChoose].rHeight;
                    rWidth = scoreArray[iChoose].rWidth;
                    iCol = scoreArray[iChoose].iCol;
                    iRow = scoreArray[iChoose].iRow;
                    
                }



                //build the rect height, width, and left, right
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].width = rWidth;
                    m_heatObjArray[i].height = rHeight;

                    m_heatObjArray[i].left = rWidth * (i%iCol);
                    m_heatObjArray[i].top = rHeight * (Math.floor(i/iCol));
                }
            }
            else
            {
                //build the rect height, width, and left, right
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].width = m_width/numCol;
                    m_heatObjArray[i].height = m_height/numRow;

                    m_heatObjArray[i].left = (m_width/numCol) * (i%numCol);
                    //the Y is from the bottom
                    m_heatObjArray[i].top = (m_height-m_height/numRow) - ((m_height/numRow) * (Math.floor(i/numCol)));
                }
            }

            if(m_redrawAll)
            {
                selection.select("." + m_className).remove();
            }

            if(isOnlyOneCategroy)
            {
              var datashapesgroup = selection.selectAll('g.datashapesgroup');
              if(!TypeUtils.isExist(datashapesgroup[0][0])){
                datashapesgroup = selection.append('g').attr('class', 'datashapesgroup');
              }
                //draw the rects
                if(m_redrawAll)
                {
                    m_heatMapBody = datashapesgroup.append("g").attr("class", m_className);
                }
                else
                {
                    m_heatMapBody = datashapesgroup.select("." + m_className);
                }

                var m_heatObjArrayToDraw = [];
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    if(!m_props.drawemptycell && !m_heatObjArray[i].val)
                    {
                        continue;
                    }
                    else
                    {
                        m_heatObjArray[i].index = i;
                        m_heatObjArrayToDraw.push(m_heatObjArray[i]);
                    }
                }
                //draw rects 
                var item = m_heatMapBody.selectAll("rect")
                     .data(m_heatObjArrayToDraw,function(d){return d.index;});
                    
                     
                var toDrawItems = item.enter();
                var toDeleteItems = item.exit();

                var rects;

                if(m_redrawAll)
                {
                  m_dataShape = toDrawItems.append("g").attr("class","datashape");
                  m_dataShape.attr('transform', function(d) {return 'translate(' + (d.left+m_padding) + ',' + (d.top+m_padding) + ')';});
                  
                    rects = m_dataShape.append("rect")
                            .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                            .attr('class', 'datapoint')
                            .attr("x", 0)
                            .attr("y", 0)
                            .attr("width", function(d){return d.width-2*m_padding;})
                            .attr("height",function(d){return d.height-2*m_padding;})
                            .attr("fill",function(d){ 
                                var parameter = {
                                    drawingEffect:'normal',
                                    fillColor : d.color};
                                return m_effectManager.register(parameter);
                                })
                            .attr("shape-rendering", "crispEdges");
                }
                else
                {
                    if (m_dataShape)
                    {
                        m_dataShape.attr('transform', function(d) {return 'translate(' + (d.left+m_padding) + ',' + (d.top+m_padding) + ')';});
                    }

                    if(m_props.animation.dataUpdating)
                    {
                        rects = item
                                .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                                .attr('class', 'datapoint')
                                .transition()
                                .delay(0)
                                .duration(500)
                                .attr("x", 0)
                                .attr("y", 0)
                                .attr("width", function(d){return d.width-2*m_padding;})
                                .attr("height",function(d){return d.height-2*m_padding;})
                                .attr("fill",function(d){ 
                                    var parameter = {
                                        drawingEffect:'normal',
                                        fillColor : d.color};
                                    return m_effectManager.register(parameter);
                                    })
                                .attr("shape-rendering", "crispEdges")
                                .each('end',endAnimation);
                    }
                    else
                    {
                        rects = item
                                .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                                .attr('class', 'datapoint')
                                .attr("x", 0)
                                .attr("y", 0)
                                .attr("width", function(d){return d.width-2*m_padding;})
                                .attr("height",function(d){return d.height-2*m_padding;})
                                .attr("fill",function(d){ 
                                    var parameter = {
                                        drawingEffect:'normal',
                                        fillColor : d.color};
                                    return m_effectManager.register(parameter);
                                    })
                                .attr("shape-rendering", "crispEdges");
                        
                    }
                    //unselect all of them
                    rects.attr('opacity', 1);
                }


                if(!m_props.border || (m_props.border && m_props.border.visible))
                {
                    rects.attr("stroke",m_styleLineColor)
                           .attr("stroke-width","1");
                }

                if(m_redrawAll)
                {
                    if(m_props.animation.dataLoading){
                        rects.attr('opacity', 0);

                        rects.transition()
                            .delay(0)
                            .duration(1000).attr('opacity', 1)
                            .each('end',endAnimation);
                    }
                    else
                    {
                        endAnimation();
                    }
                }
                else
                {
                    endAnimation();
                }

                //labels
                if(m_redrawAll)
                {
                  if (m_dataShape) {
                    m_dataShape.append("text")
                                .attr("class", "heatmapdatalabel")
                                .attr("x", function(d){return d.width/2;})
                                .attr("y", function(d){return d.height/2;})
//                                .attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
                                .attr("text-anchor", "middle") // text-align
                                .text(function(d){return d.label;})
                                .attr("fill", "#ffffff")
                                .style("font-size", "12px")
                                .style("font-family", "'Open Sans', Arial, Helvetica, sans-serif")
                                .attr('pointer-events', 'none')
                                .each(function(d) {
                                    //Jimmy, BITVIZ-384, add padding before text
                                    TextRuler.ellipsis(d.label, this, d.width - 5, "fill:#ffffff;font-family:'Open Sans', Arial, Helvetica, sans-serif;font-size:12px;");
                                });
                  }
                }
                else
                {
                     m_heatMapBody.selectAll("text").remove();
                     m_heatMapBody.selectAll("rect").data(m_heatObjArrayToDraw,function(d){return d.index;}).enter();
                     
                     m_dataShape.append("text")
                     .attr("class", "heatmapdatalabel")
                    .attr("x", function(d){return d.width/2;})
                    .attr("y", function(d){return d.height/2;})
//                    .attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
                    .attr("text-anchor", "middle") // text-align
                    .text(function(d){return d.label;})
                    .attr("fill", "#ffffff")
                    .style("font-size", "12px")
                    .style("font-family", "'Open Sans', Arial, Helvetica, sans-serif")
                    .attr('pointer-events', 'none')
                    .each(function(d) {
                        //Jimmy, BITVIZ-384, add padding before text
                        TextRuler.ellipsis(d.label, this, d.width - 5, "fill:#ffffff;font-family:'Open Sans', Arial, Helvetica, sans-serif;font-size:12px;");
                    });
                }

                m_rects = rects;
            }
            else
            {
              var datashapesgroup = selection.selectAll('g.datashapesgroup');
              if(!TypeUtils.isExist(datashapesgroup[0][0])){
                datashapesgroup = selection.append('g').attr('class', 'datashapesgroup');
              }
                //draw the rects
                if(m_redrawAll)
                {
                    m_heatMapBody = datashapesgroup.append("g").attr("class", m_className);
                }
                else
                {
                    m_heatMapBody = datashapesgroup.select("." + m_className);
                }

                if(!m_props.drawemptycell)
                {
                    //draw a rect
                    if(m_redrawAll)
                    {
                        m_heatMapBody.append('rect')
                                   .attr("x", 0)
                                   .attr("y", 0)
                                   .attr("width", m_width)
                                   .attr("height",m_height)
                                   .attr("fill",m_props.emptycolor)
                                   .attr("class", m_classEmptyValue)
                                   .attr("shape-rendering", "crispEdges");
                    }
                    else
                    {
                        m_heatMapBody.select("." + m_classEmptyValue)
                                   .attr("x", 0)
                                   .attr("y", 0)
                                   .attr("width", m_width)
                                   .attr("height",m_height)
                                   .attr("fill",m_props.emptycolor)
                                   .attr("class", m_classEmptyValue)
                                   .attr("shape-rendering", "crispEdges");

                    }
                }

                var m_heatObjArrayToDraw = [];
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    if(!m_props.drawemptycell && !m_heatObjArray[i].val)
                    {
                        continue;
                    }
                    else
                    {
                        m_heatObjArray[i].index = i;
                        m_heatObjArrayToDraw.push(m_heatObjArray[i]);
                    }
                }
                
                //draw rects 
                var item = m_heatMapBody.selectAll("rect")
                     .data(m_heatObjArrayToDraw,function(d){return d.index;});

                var toDrawItems = item.enter();
                var toDeleteItems = item.exit();

                var rects;
                if(m_redrawAll)
                {
                  m_dataShape = toDrawItems.append("g").attr("class","datashape");
                  m_dataShape.attr('transform', function(d) {return 'translate(' + (d.left) + ',' + (d.top) + ')';});
                  
                    rects = m_dataShape.append("rect")
                        .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                        .attr('class', 'datapoint')
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", function(d){return d.width;})
                        .attr("height",function(d){return d.height;})
                        .attr("fill",function(d){ 
                            var parameter = {
                                drawingEffect:'normal',
                                fillColor : d.color};
                            return m_effectManager.register(parameter);
                            })
                        .attr("shape-rendering", "crispEdges");
                }
                else
                {
                  if (m_dataShape) {
                    m_dataShape.attr('transform', function(d) {return 'translate(' + (d.left) + ',' + (d.top) + ')';});
                  }
                    if(m_props.animation.dataUpdating)
                    {
                        rects = item
                            .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                            .attr('class', 'datapoint')
                            .transition()
                            .delay(0)
                            .duration(500)
                            .attr("x", 0)
                            .attr("y", 0)
                            .attr("width", function(d){return d.width;})
                            .attr("height",function(d){return d.height;})
                            .attr("fill",function(d){ 
                                var parameter = {
                                    drawingEffect:'normal',
                                    fillColor : d.color};
                                return m_effectManager.register(parameter);
                                })
                            .attr("shape-rendering", "crispEdges")
                            .each('end',endAnimation);
                    }
                    else
                    {
                        rects = item
                            .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                            .attr('class', 'datapoint')
                            .attr("x", 0)
                            .attr("y", 0)
                            .attr("width", function(d){return d.width;})
                            .attr("height",function(d){return d.height;})
                            .attr("fill",function(d){ 
                                var parameter = {
                                    drawingEffect:'normal',
                                    fillColor : d.color};
                                return m_effectManager.register(parameter);
                                })
                            .attr("shape-rendering", "crispEdges");
                    }
                    //unselect all of them
                    rects.attr('opacity', 1);
                }


                if(!m_props.border || (m_props.border && m_props.border.visible))
                {
                    rects.attr("stroke",m_styleLineColor)
                           .attr("stroke-width","1");
                }

                if(m_redrawAll)
                {
                    if(m_props.animation.dataLoading){
                        rects.attr('opacity', 0);

                        rects.transition()
                            .delay(0)
                            .duration(1000).attr('opacity', 1)
                            .each('end',endAnimation);
                    }
                    else
                    {
                        endAnimation();
                    }
                }
                else
                {
                    endAnimation();
                }

                m_rects = rects;
            }
            //the HLCell Rectange
            if(m_redrawAll)
            {
                m_HLElement = m_heatMapBody.append('g').attr('class', 'HLElement').attr("visibility", "hidden");
                m_HLElement.append('line').attr('class', 'HLLeft').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr('class', 'HLRight').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr('class', 'HLTop').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr('class', 'HLBottom').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
            }
            else
            {
                if(m_HLElement)
                {
                    m_HLElement.attr("visibility", "hidden");
                }
            }

            //tooltip
            if(m_redrawAll)
            {
                m_tooltipElement = m_heatMapBody.append('g').attr('class', 'heatMapTooltip');
                m_tooltipElement.append('rect').attr('ry', 6).attr('rx', 6).attr('opacity', 0.8).attr("stroke-width","1").attr("stroke","#666666");

                var rectText = m_dataRect.values[0].col;
                var xText = m_dataXAxis.values[0].col.val;
                var yText = "";
                if(m_dataYAxis)
                {
                    yText = m_dataYAxis.values[0].col.val;
                }
                
                m_tooltipElement.append('text').attr('text-anchor', 'start').attr('font-size', '12px') 
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr('font-weight', "bold")
                                               .attr("x", 20).attr("y", 18).attr("fill", "#333333").text(rectText);

                m_tooltipElement.append('text').attr('text-anchor', 'start').attr('font-size', '12px').attr("class", "valText")
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr("x", 30).attr("y", 33).attr("fill", "#333333");


                m_tooltipElement.append('line').attr("x1", 0).attr("y1", 40)
                                               .attr("x2", 160).attr("y2", 40).attr("stroke", "#666666");

                m_tooltipElement.append('text').attr('text-anchor', 'end').attr('font-size', '11px') 
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr('font-weight', "bold")
                                               .attr("x", 80).attr("y", 55).attr("fill", "#333333").text(xText);

                m_tooltipElement.append('text').attr('text-anchor', 'start').attr('font-size', '10px').attr("class", "valXValue")
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr("x", 85).attr("y", 55).attr("fill", "#333333");

                m_tooltipElement.append('text').attr('text-anchor', 'end').attr('font-size', '11px') 
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr('font-weight', "bold")
                                               .attr("x", 80).attr("y", 70).attr("fill", "#333333").text(yText);

                m_tooltipElement.append('text').attr('text-anchor', 'start').attr('font-size', '10px').attr("class", "valYValue")
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr("x", 85).attr("y", 70).attr("fill", "#333333");

                m_tooltipElement.attr('visibility', 'hidden');
            }


            //guidline
            if(m_redrawAll)
            {
                m_guidline = m_heatMapBody.append('g').attr('class', 'heatMapGuideline');
                m_guidline.append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", m_height).attr("stroke", m_props.guideline.color).attr("shape-rendering", "crispEdges").attr('class', 'xGuidline');
                m_guidline.append("line").attr("x1", 0).attr("y1", 0).attr("x2", m_width).attr("y2", 0).attr("stroke", m_props.guideline.color).attr("shape-rendering", "crispEdges").attr('class', 'yGuidline');
                m_guidline.attr('visibility', 'hidden');
            }

            m_redrawAll = false;
            return chart;
        };
        
        var endAnimation = function(d, i)
        {
            if(  (i === (m_heatObjArray.length - 1))//the last datapoint
               || (m_heatObjArray.length === 0) //no data
               || (d === undefined && i === undefined) //not in "each"
              )
            {
                m_dispatch.initialized();
            }
        };

        function deregisterEvent(){
            
        };
        
        function registerEvent(){
            
        };

        var showTooltip = function(dataIndex){ 
            var dataItem = m_heatObjArray[dataIndex];
            var valXValue = "";
            var valYValue = "";



           var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                valXValue = m_dataXAxis.values[0].rows[dataIndex].val;
                if(m_dataYAxis)
                {
                    valYValue = m_dataYAxis.values[0].rows[dataIndex].val;
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                valXValue = m_dataXAxis.values[0].rows[dataIndex%numCol].val;
                valYValue = m_dataYAxis.values[0].rows[Math.floor(dataIndex/numCol)].val;
            }

            m_tooltipElement.select("rect").attr("width", 160).attr("height", 78).attr("fill" , "rgb(255,255,255)");
            m_tooltipElement.attr("transform", "translate(" + (dataItem.left + dataItem.width/2 + 5) + "," + (dataItem.top + dataItem.height/2 + 5) + ")");
            if(!NumberUtils.isNoValue(dataItem.val))
            {
                m_tooltipElement.select(".valText").text(dataItem.val);
                m_tooltipElement.select(".valXValue").text(valXValue);
                m_tooltipElement.select(".valYValue").text(valYValue);

                m_tooltipElement.attr('visibility', 'visible');

                //guideline
                if(m_props.guideline.visible)
                {
                    m_guidline.select(".xGuidline").attr("x1", m_heatObjArray[dataIndex].left + m_heatObjArray[dataIndex].width/2).attr("x2", m_heatObjArray[dataIndex].left + m_heatObjArray[dataIndex].width/2);
                    m_guidline.select(".yGuidline").attr("y1", m_heatObjArray[dataIndex].top + m_heatObjArray[dataIndex].height/2).attr("y2", m_heatObjArray[dataIndex].top + m_heatObjArray[dataIndex].height/2);
                    m_guidline.attr('visibility', 'visible');
                }
            }            
        };

        var stringNoValueHandler = function(str)
        {
            if(str === null || str === undefined)
            {
                str = langManager.get('IDS_ISNOVALUE');
            }
            return str;
        }
        
        var generateTooltipData = function(dataIndex){
            //for heatmap, we only have one measure so that the body's length is always 1
            var tooltipData = {
                body:[],
                footer:[]
            };
            var dataItem = m_heatObjArray[dataIndex];
            var body = {
                    'name': stringNoValueHandler(m_dataRect.values[0].col),
                    val:[{
                        color: dataItem.color,
                        value: NumberUtils.isNoValue(dataItem.val)?m_defaultString:dataItem.val
                    }]
            };
            
            tooltipData.body.push(body);
            
            if(TypeUtils.isExist(m_dataXAxis)){
                for(var tval = m_dataXAxis.values, len = tval.length, i = len -1; i  >= 0; i--){
                    var footer = {};
                    footer.label = tval[i].col;
                    footer.value = tval[i].rows[dataIndex%tval[i].rows.length];
                    tooltipData.footer.push(footer);
                }
            }
            
            if(TypeUtils.isExist(m_dataYAxis)){
                var dataIndexInYAxis = Math.floor(dataIndex / m_dataXAxis.values[0].rows.length);
                for(var tval = m_dataYAxis.values, len = tval.length, i = len -1; i >= 0; i--){
                    var footer = {};
                    footer.label = tval[i].col;
                    footer.value = tval[i].rows[dataIndexInYAxis%tval[i].rows.length];
                    tooltipData.footer.push(footer);
                }
            }
            
            return tooltipData;
        };
        
        var hideTooltip = function(){
            m_tooltipElement.attr('visibility', 'hidden');
            m_guidline.attr('visibility', 'hidden');
        };

        var HLCell = function(item)
        {
            if(!NumberUtils.isNoValue(item.datum().val))
            {
                m_HLElement.attr("visibility", "visible");

                var iLeft = item.datum().left;
                var iRight = item.datum().left + item.datum().width;
                var iTop = item.datum().top;
                var iBottom = item.datum().top + item.datum().height;

                m_HLElement.select(".HLLeft").attr("x1",iLeft).attr("y1",iTop).attr("x2",iLeft).attr("y2",iBottom);
                m_HLElement.select(".HLRight").attr("x1",iRight).attr("y1",iTop).attr("x2",iRight).attr("y2",iBottom);
                m_HLElement.select(".HLTop").attr("x1",iLeft).attr("y1",iTop).attr("x2",iRight).attr("y2",iTop);
                m_HLElement.select(".HLBottom").attr("x1",iLeft).attr("y1",iBottom).attr("x2",iRight).attr("y2",iBottom);
            }
        };

        var unHLCell = function(item)
        {
            m_HLElement.attr("visibility", "hidden");
        };

        chart.mouseover = function(elem){
            var item = d3.select(d3.event.target);
            var clickedItemID = item.attr('id');
            if(clickedItemID && m_props.tooltip.enabled)
            {
              var tmpLength = clickedItemID.toString().length - randomSuffix.toString().length - 2;
                var dataIndex = clickedItemID.toString().substr(2 , tmpLength);
                
                var transform = m_selection.node().getTransformToElement(m_selection.node().ownerSVGElement);
                var svgBoundingBox = m_selection.node().ownerSVGElement.getBoundingClientRect();
                var rectBoundingBox =  elem.getBoundingClientRect();
                //showTooltip(dataIndex);
                var tooltipData = generateTooltipData(dataIndex);
                tooltipData.point = {
                        x : rectBoundingBox.left - svgBoundingBox.left + rectBoundingBox.width/2,
                        y : (rectBoundingBox.height > 16) ? rectBoundingBox.top - svgBoundingBox.top + 8 : rectBoundingBox.top - svgBoundingBox.top + rectBoundingBox.height/2
                };
                tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : m_width,
                        height : m_height
                };
                m_dispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
                HLCell(item);
            }

        };
        
        chart.afterUIComponentAppear = function(){
          m_dispatch.initialized(); 
        };
        
        
        chart.mouseout = function(){
            if(m_props.tooltip.enabled)
            {
                m_dispatch.hideTooltip();
            }

            if(d3.event)
            {
                var item = d3.select(d3.event.target);
                unHLCell(item);
            }
        };



        /*
         * Add mouse interaction functions.
         */
        chart.parent = function(){
            return m_selection;
        };

        chart.highlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 1);
                }
            }else{
                elems.setAttribute('opacity', 1);
            }
        };
        
        chart.unhighlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 0.2);
                }
            }else{
                elems.setAttribute('opacity', 0.2);
            }
        };
        
        chart.clear = function(gray){
            if( gray == null){
                m_selection.selectAll('.datapoint').attr('opacity', 1);
            }else{
                m_selection.selectAll('.datapoint').attr('opacity', 0.2);
            }
        };
        
        chart.width = function(_width){
            if (!arguments.length){
              return m_width;
            }
            m_width = _width;

            makeXScale();
            return chart;
        };

        chart.height = function(_height){
            if (!arguments.length){
              return m_height;
            }
            m_height = _height;
            
            makeYScale();
            return chart;       
        };

        chart.data = function(value){
            if (!arguments.length){
                return m_data;
            }

            m_data = value;
            m_redrawAll = true;
            
            m_dataXAxis = m_data.getAnalysisAxisDataByIdx(0);
            m_dataYAxis = m_data.getAnalysisAxisDataByIdx(1);
            m_dataRect = m_data.getMeasureValuesGroupDataByIdx(0);
            
            return chart;
        };

        chart.properties = function(props){
            if (!arguments.length){
                return m_propsOutput;
            }           
            Objects.extend(true, m_props, props);
            Objects.extend(true, m_propsOutput, props);
            m_redrawAll = true;
            return chart;           
        };

        /**
         * interfaces for MBC legend selection
         * @param {Object} selectedData 
         * <pre>
         * {
         * ctx: {
         *   ranges: {
         *    endValue:100
         *    isLeftOpen:false
         *    isRightOpen:true
         *    startValue:84
         *   }
         * },
         * val: 84   
         * }
         * @returns {Array} d3 selections in the given range  
         */
        chart.getDatapointsByRange = function(selectedData){
          var datapoints = d3.selectAll('.datapoint')[0], ctxDatapoints = [], ranges = selectedData.ctx.ranges, data;
          for(var i = 0, len = datapoints.length; i < len; i++){
            data = datapoints[i].__data__.val;
            if(NumberUtils.isNoValue(selectedData.val)){
              if(NumberUtils.isNoValue(data)){
                ctxDatapoints.push(datapoints[i]);
              }
            }else{
              if(data < ranges.endValue && data > ranges.startValue){
                ctxDatapoints.push(datapoints[i]);
              }else{
                if(!ranges.isLeftOpen && data === ranges.startValue) {
                  ctxDatapoints.push(datapoints[i]);
                }else if(!ranges.isRightOpen && data === ranges.endValue){
                  ctxDatapoints.push(datapoints[i]);
                }
              }
            }
          }
          return ctxDatapoints;
        };
         
        chart.mbcLegendInfo = function(){
            var hColor = buildColorScale();
            return {
                'colorScale' : hColor,
                'title': m_dataRect.values[0].col
            };
        };

        chart.getPreferredSize = function(){
            
        };

        chart.categoryScaleX = function(){
            return m_xScale;
        };
       
        chart.isDrawXaxisBody = function(){
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            return (!isOnlyOneCategroy);
        };

        chart.categoryScaleY = function(){
            return m_yScale;
        };

        chart.dataLabel = function(_){
          
        };
        
        var buildColorScale = function()
        {
            //return a color scale like
            //var domainRg = [ [10,40], [40, 100] ];
            //var rangeRg = ['#ff0000', '#00ff00' ];
            //hColor = d3.scale.ordinal().domain(domainRg).range(rangeRg);

            var hColor = d3.scale.ordinal();

            //we need to draw some recs. So I will build a obj array, each item is a rec.
            var heatObjArray = [];
            
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                var hData = m_dataRect.values[0].rows[0];
                //add the data to heatObjArray. the number of rectanges is the number of rectanglecolor.valuies.
                for(var i = 0; i < hData.length; i++)
                {
                    heatObjArray.push(hData[i]);
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                for(var i = 0; i < numRow; i++)
                {
                    for(var j = 0; j < numCol; j++)
                    {
                        heatObjArray.push(hData[i][j]);
                    }
                }
            }

            //count the max and min value of heatObjArray[i].val
            var maxVal = -Number.MAX_VALUE;
            var minVal = Number.MAX_VALUE;

            for(var iObj = 0; iObj < heatObjArray.length; iObj++)
            {
                if(!NumberUtils.isNoValue(heatObjArray[iObj].val))
                {
                    if(maxVal < heatObjArray[iObj].val)
                    {
                        maxVal = heatObjArray[iObj].val;
                    }

                    if(minVal > heatObjArray[iObj].val)
                    {
                        minVal = heatObjArray[iObj].val;
                    }
                }
            }
            //has "novalue" or not
            var hasNullValue = false;
            for(var i = 0; i < heatObjArray.length; i++)
            {
                if( NumberUtils.isNoValue(heatObjArray[i].val))
                {
                    hasNullValue = true;
                }
            }
            
            var numS = m_props.colornumber;

            var fontColorScale;
            if(minVal === Number.MAX_VALUE && maxVal === -Number.MAX_VALUE){
                fontColorScale = d3.scale.ordinal().domain([[]]).range([m_props.emptycolor]);
            } else {
                var fontColorScale = MeasureBasedColoring.getScale(minVal, maxVal, numS, m_props.startColor, m_props.endColor);
                if(hasNullValue){
                    var domains = fontColorScale.domain();
                    var ranges = fontColorScale.range();
                    domains.push([]);
                    ranges.push(m_props.emptycolor);
                }
            }
            return fontColorScale;
            // //build the color
            // var heatColor = d3.scale.linear()
                // .domain([minVal, maxVal])
                // .range([m_props.startcolor, m_props.endcolor]);

            // //build a d3.scale.ordinal() for legend
            // var domainRg = [];
            // var rangeRg = [];
            // for(var j = 0; j < (numS-1); j++)
            // {
                // domainRg.push( [minVal + (maxVal-minVal)/numS*j, (minVal + (maxVal-minVal)/numS*(j+1))] );
                // rangeRg.push( heatColor(minVal + (maxVal-minVal)/(numS-1)*j) );
            // }

            // domainRg.push( [minVal + (maxVal-minVal)/numS*(numS-1), maxVal] );
            // rangeRg.push( heatColor(maxVal) );



            // if(m_props.discretecolor)
            // {
                // var colorArray;
                // if(m_props.colorPalette.length == 0)
                // {
                    // colorArray = ColorSeries.sap32().range();
                // }
                // else
                // {
                    // colorArray = m_props.colorPalette;
                // }

                // var j = 0;
                // for(var i = 0; i < rangeRg.length; i++)
                // {
                    // rangeRg[i] = colorArray[j];
                    // j = (j+1)%(colorArray.length);
                // }
            // }

            // if(hasNULL) //no value
            // {
                // domainRg.push([]);
                // rangeRg.push(m_props.emptycolor);
            // }


            // hColor = d3.scale.ordinal().domain(domainRg).range(rangeRg);

            // return hColor;
        }

        var makeXScale = function()
        {
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            

            var hCol = m_dataXAxis.values[0].rows;
            var dArray = [];
            for(var i = 0; i < hCol.length; i++)
            {
                dArray.push(i);
            }

            m_xScale = m_xScale.domain(dArray)
                                .rangeBands([0, m_width]);
        };

        var makeYScale = function()
        {
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            
            if(isOnlyOneCategroy)
            {
                //no yAxis
                m_yScale = m_yScale.domain([0,0])
                                .rangeBands([0,0]);
            }
            else
            {
                var hRow = m_dataYAxis.values[0].rows;
                var dArray = [];
                for(var i = 0; i < hRow.length; i++)
                {
                    dArray.push(i);
                }

                //y is from bottom
                m_yScale = m_yScale.domain(dArray)
                                .rangeBands([m_height, 0]);
            }
        };

        /**
         * get/set your event dispatch if you support event
         */
        chart.dispatch = function(_){
            if(!arguments.length)
                return m_dispatch;
            m_dispatch = _;
            return chart;
        };
        
        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };
        return chart;
    };

    return heatMap;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.HeatMap',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.heatmap',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.HeatMap',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {

    var module = {
      'id' : 'sap.viz.modules.heatmap',
      'type' : Constants.Module.Type.Chart,
      'name' : 'heatmap',
      'properties' : {
        'border' : {
          'name' : 'border',
      'description' : 'Settings for border.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'visible' : {
                'name' : 'visible',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set visibility of zone edge.'
            },
          },
        },

        'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enabled/disabled data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : false,
              'description' : 'Set enabled/disabled data updating animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.'
        },
        'startColor' : {
          'name' : 'startColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#C2E3A9",
          'description' : 'Set heatMap startColor.'
        },
      
        'endColor' : {
          'name' : 'endColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#73C03C",
          'description' : 'Set heatMap endColor.'
        },

        'tooltip' : {
          'name' : 'tooltip',
      'description' : 'Settings for tooltip.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
              'visible': {
                    'name' : 'enabled',
                    'supportedValueType' : 'Boolean',
                    'defaultValue' : true,
                    'description' : 'Set enabled/disabled tooltip.'
              },
          },
        'isExported' : false
        }
      },
      'events' : {
        'initialized': Constants.Module.Event.Initialized.desc,
        'selectData' : Constants.Module.Event.SelectData.desc,
      'deselectData' : Constants.Module.Event.DeSelectData.desc,
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc

      },
      'feeds' :{
          id:"heatMap"
      },
      'css' : {},
      'configure' : null,
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.HeatMapChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.HeatMap',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/heatmap',
    name : 'IDS_HEATMAPCHART',
      base : 'riv/base/single',
    modules : {
        
      legend : {
          id : 'sap.viz.modules.legend',
        configure : {
          'description': 'The measure based coloring legend is a bar containing segments with different colors and a value scale on side to indicate the relationship between the values and colors in the chart. ',
          properties : {
              type : 'MeasureBasedColoringLegend'
            },
            propertiesOverride : {
              isHierarchical : {
                isExported : false
              },
              formatString: {
                isExported: true
              }
            }
        }
      },
    tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
              chartType : 'heatmap',
              orientation : 'bottom'
            }
          }
        },

      main : {
        modules : {
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                paintingMode : 'rectCoordinate',
                visible : false,
                orientation : 'vertical',
                position : 'inside',
                automaticInOutside : false,
                showZero : true,
                isStackMode : false,
                isPercentMode : false,
                outsideVisible : false
              }
            }
          },
          xAxis : {
            id : 'sap.viz.modules.axis',
            data : {
              aa : [ 1 ]
            },
            configure : {
            'description': 'Settings for the x axis of a normal heatmap.',
              propertyCategory : 'xAxis',
              properties : {
                type : 'category',
                position : 'bottom',
                gridline : {
                  visible : false
                }
              },
              propertiesOverride : {
                gridline : {
                  isExported : false
                },
                label : {
                  isExported : false
                },
                axisline : {
                  isExported : false
                }
              }
            }
          },
          
          yAxis : {
            id : 'sap.viz.modules.axis',
            data : {
              aa : [ 2 ]
            },
            configure : {
            'description': 'Settings for the y axis of a normal heatmap.',
              propertyCategory : 'yAxis',
              properties : {
                type : 'category',
                position : 'left',
                gridline : {
                  visible : false
                }
              },
              propertiesOverride : {
                gridline : {
                  isExported : false
                },
                label : {
                  isExported : false
                },
                axisline : {
                  isExported : false
                }
              }
            }
          },          
        
          plot : {
            id : 'sap.viz.modules.heatmap',
            configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        },


        controllers : {
             'interaction' : {
                   id : 'sap.viz.modules.controller.interaction',
                   configure : {
                       propertyCategory : 'interaction',
                        properties : {
                          supportedEventNames: ['mouseup', 'mouseover', 'mouseout', 'touchstart']
                        }
                   }
               }
          }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScaleX'
      },{
        targetModule : 'main.xAxis',
        target : 'isDrawBody',
        sourceModule : 'main.plot',
        source : 'isDrawXaxisBody'
      }, {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScaleY'
      },
      {
        targetModule : 'legend',
        target : 'mbcLegendInfo',
        sourceModule : 'main.plot',
        source : 'mbcLegendInfo'
      }, {
          targetModule : 'legend',
          target : 'setSelectionMode',
          sourceModule : 'main.interaction',
          source : 'getSelectionMode'
      }],
    
          events : [ {
              targetModule : 'main.interaction',
              listener : 'registerEvent',
              sourceModule : 'main.plot',
              type : 'initialized.interaction'
          }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
      }, {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        },  {
          targetModule : 'main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'main.plot',
          type : 'startToInit.datalabel'
        }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.TagCloud',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var feeds = {
    id : "tagCloud",
    feeds : [ {
      'id' : 'tagName',
      'name' : 'Tags Name',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1,
      'maxStackedDims' : 1 
      
    }, {
      'id' : 'tagWeight',
      'name' : 'Tags Weight',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    }, {
      'id' : 'tagFamily',
      'name' : 'Tags Family',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 2
    } ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud.wordleLayout',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(TextRuler, NumberUtils) {
  var wordleLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';

    var wordle = function() {

    };
    wordle.width = function(_) {
      if (!arguments.length) {
        return width;  
      }
        
      width = _;
      return wordle;
    };

    wordle.height = function(_) {
      if (!arguments.length) {
        return height;
      }
        
      height = _;
      return wordle;
    };

    wordle.data = function(_) {
      if (!arguments.length) {
        return chartData; 
      }
       

      _.sort(function(a, b) {
        if (a.wordSize && b.wordSize) {
          return b.wordSize.val - a.wordSize.val;
        }
      });
      chartData = _;
      return wordle;
    };

    wordle.font = function(_) {
      if (!arguments.length) {
        return font;
      }
       
      font = _;
      return wordle;
    };

    wordle.layout = function() {
      var relayout = false, layoutCount = 0;
      while (!relayout) {
        relayout = _layout(++layoutCount);
      }
      return wordle;
    };

    var _layout = function(layoutCount) {
      var tagArr = chartData, textSize, d, root;
      for ( var i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];

        if (NumberUtils.isNoValue(d.fontSize)) {
          continue;
        }

        textSize = TextRuler.fastMeasure(tagArr[i].word.val + 'i',
            tagArr[i].fontSize + 'px', 'normal', font);

        d.width = textSize.width;
        d.height = textSize.height;

        d.x = undefined;
        d.y = undefined;

        d.rect = new rect(d.width, d.height);

        var flag;
        if (!root) {
          var rotate;
          if (d.width <= width && d.height <= height) {
            rotate = false;
          } else if (d.height <= width && d.width <= height) {
            rotate = true;
          }
          if (rotate !== null) {
            root = d;
            if (rotate){
              d.rect.rotate();
            }
            d.rect.position(width / 2, height / 2);
            flag = true;
          }

        } else {
          var list = [];
          list.push(root);
          while (list.length !== 0) {
            var parent = list.shift();

            if (parent.child){
              parent.child.forEach(function(c) {
                if (c){
                  list.push(c);
                }
              });
            }

            flag = placeTag(d, parent, root);
            if (flag){
              break;
            }
          }
        }

        if (flag) {
          d.x = d.rect.x;
          d.y = d.rect.y;
          d.rotate = d.rect.rotated ? 90 : 0;
        }
      }

      tagArr.forEach(function(d) {
        delete d.child;
        delete d.rect;
      });

      return true;
    };

    function placeTag(tag, parent, root) {
      var rect = tag.rect;
      var child = parent.child;
      if (!child) {
        child = [];
        parent.child = child;
      }
      for ( var j = 0; j < 2; j++) {
        if (j === 1) {
          rect.rotate();
        }

        for ( var i = 0; i < 4; i++) {
          if (child[i]){
            continue;
          }

          var x, y;
          switch (i) {
          case 0:
            x = parent.x;
            y = parent.rect.y0 - rect.h / 2;
            break;
          case 1:
            y = parent.y;
            x = parent.rect.x1 + rect.w / 2;
            break;
          case 2:
            x = parent.x;
            y = parent.rect.y1 + rect.h / 2;
            break;
          case 3:
            y = parent.y;
            x = parent.rect.x0 - rect.w / 2;
            break;
          }

          rect.position(x, y);

          if (rect.x0 >= 0 && rect.y0 >= 0 && rect.x1 <= width && rect.y1 <= height) {
            if (validPosition(rect, parent, root)) {
              child[i] = tag;
              return true;
            }
          }
        }
      }

      rect.rotate();

      return false;
    }

    function validPosition(rect, parent, root) {
      if (root !== parent){
        if (!rect.notInterects(root.rect)){
          return false;
        }
      }

      for ( var i = 0, child = root.child, len = child ? child.length : 0; i < len; i++) {
        if (child[i] && !validPosition(rect, parent, child[i])){
          return false;
        }
      }

      return true;
    }

    function rect(w, h) {
      this.w = w;
      this.h = h;
      this.rotated = false;
    }

    rect.prototype = {
      position : function(x, y) {
        this.x = x;
        this.y = y;

        var _x = this.w / 2, _y = this.h / 2;
        this.x0 = x - _x;
        this.x1 = x + _x;
        this.y0 = y - _y;
        this.y1 = y + _y;
      },

      notInterects : function(rect) {
        return this.x1 <= rect.x0 || this.x0 >= rect.x1 || this.y1 <= rect.y0 || this.y0 >= rect.y1;
      },

      rotate : function() {
        this.rotated = !this.rotated;
        var t = this.h;
        this.h = this.w;
        this.w = t;
      }
    };

    return wordle;
  };
  return wordleLayout;
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud.columnLayout',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(TextRuler, NumberUtils) {
  var columnLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';

    var column = function() {

    };
    column.width = function(_) {
      if (!arguments.length) {
          return width;  
      }
        
      width = _;
      return column;
    };

    column.height = function(_) {
      if (!arguments.length) {
          return height;
      }
        
      height = _;
      return column;
    };

    column.data = function(_) {
      if (!arguments.length) {
          return chartData;  
      }
       
      chartData = _;
      return column;
    };

    column.font = function(_) {
      if (!arguments.length) {
          return font;  
      }
        
      font = _;
      return column;
    };

    column.layout = function() {
      _layout();
      return column;
    };

    var _layout = function() {
      var tagArr = chartData;
      var d, textSize;
      for ( var i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        textSize = TextRuler.fastMeasure(tagArr[i].word.val+'i', tagArr[i].fontSize+'px', 'normal', font);
        d.width = textSize.width;
        d.height = textSize.height;
      }

      var startX = 0, startY = 0;
      for ( var j = 0, jlen = tagArr.length; j < jlen; j++) {
        d = tagArr[j];
        if(NumberUtils.isNoValue(tagArr[j].fontSize)) {
          continue;
        }
        startY = startY + d.height;
        d.x = startX;
        d.y = startY;
        d.rotate = undefined;
      }
    };
    return column;
  };
  return columnLayout;
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud.rowLayout',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(TextRuler, NumberUtils) {
  var rowLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';

    var row = function() {

    };
    row.width = function(_) {
      if (!arguments.length){
        return width;
      }
      width = _;
      return row;
    };

    row.height = function(_) {
      if (!arguments.length){
        return height;
      }
      height = _;
      return row;
    };

    row.data = function(_) {
      if (!arguments.length){
        return chartData;
      }
      chartData = _;
      return row;
    };

    row.font = function(_) {
      if (!arguments.length){
        return font;
      }
      font = _;
      return row;
    };

    row.layout = function() {
      _layout();
      return row;
    };

    var _layout = function() {
      var tagArr = chartData;
      var d, textSize, i, len;
      for (i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        textSize = TextRuler.fastMeasure(tagArr[i].word.val+'i', tagArr[i].fontSize+'px', 'normal', font);
        d.width = textSize.width;
        d.height = textSize.height;
      }

      var startX = 0;
      var maxRowHeight = tagArr[0].height, startY = 0, newLineIndex = 0;
      for (i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        
        if(NumberUtils.isNoValue(tagArr[i].fontSize)){
          continue;
        }
        
        if (startX + d.width > width) {
          // New Row
          startX = 0;
          _adjustLastLineTagPosition(newLineIndex, i, startY + maxRowHeight);
          
          newLineIndex = i;
          startY = startY + maxRowHeight;
          maxRowHeight = tagArr[i].height;
        }
        if(d.height > maxRowHeight){
          maxRowHeight = d.height;
        }
        d.x = startX;
        d.y = startY;
        startX = startX + d.width;
        d.rotate = undefined;
      }
      _adjustLastLineTagPosition(newLineIndex, i, startY + maxRowHeight);
    };
    
    /*
     * Set last line tag position.
     */
    var _adjustLastLineTagPosition = function(startIndex, endIndex, newYPosition){
      var dArr;
      for(var j = startIndex; j < endIndex; j++){
        dArr = chartData[j];
        dArr.y = newYPosition;
      }
    };
    return row;
  };
  return rowLayout;
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tagcloud.rowLayout',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tagcloud.columnLayout',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tagcloud.wordleLayout',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.MeasureBasedColoring',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, ColorSeries, langManager, RowLayout, ColumnLayout, WordleLayout, MeasureBasedColoring, NumberUtils, Repository, tooltipDataHandler, Objects, boundUtil) {
  var tagCloud = function(manifest, ctx) {
    var width = 400, height = 200, wrap = null, chartData = {}, tagArr = [], maxfont = 48, minfont = 12, fontColorScale, selectionList = [], effectManager = ctx.effectManager;
    var randomSuffix = Repository.newId();
    var minFontFamily = Number.MAX_VALUE, maxFontFamily = Number.MIN_VALUE, hasNullValue = false, tooltipVisible = true, isDatasetChanged = false;
    var tagStyle = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'color' : '#555555'
    };
    var options, opacity = 1, defaultString = langManager.get('IDS_ISNOVALUE');
    var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'); //, 'showTooltip', 'hideTooltip'
      
    var decorativeShape = null;
    
    var chart = function(selection) {
      selection.each(function() {
        boundUtil.drawBound(selection, width, height);
        
        _calculateTagPosition();
        
        if(decorativeShape === null){
          decorativeShape = selection.append('rect').attr('fill', 'rgba(133,133,133, 0.2)').style('visibility', 'hidden');
        }else{
          decorativeShape.attr('width', 0).attr('height', 0).attr('x', 0).attr('y', 0).style('visibility', 'hidden');
        }
        
        //filter hidden data
        var labelsData = _filterData();
        
        wrap = d3.select(this);

        //remove old data item while updateing dataset
        if(isDatasetChanged && !wrap.selectAll('g.word').empty()){
          isDatasetChanged = false;
          wrap.selectAll('g.word').remove();
        }
        
        wrap.attr('style', 'cursor:default');//.on('click', clickHandler).on('mouseover', mouseOverHandler).on('mouseout', mouseOutHandler);
        var wordsWrap = wrap.selectAll('g.word').data(labelsData, function(d, i){
          return (d.word ? d.word.val : "") + " " + (d.wordFontFamily ? d.wordFontFamily.val : "") + " " + (d.wordSize ? d.wordSize.val : "");
        });
        
        wordsWrap.selectAll('text').data(function(d, i){
          return d;
        }).text(function(d, i){ 
          return d.word.val;
        });
        
        var wordsWrapEnter = wordsWrap.enter().append('g').attr('class', 'word').append('text').text(function(d, i){ 
            return d.word.val;
          })
          .attr('id', function(d, i){
            return 'TAG_ID_' + i + randomSuffix;
          })
          .attr('class', 'datapoint')
          .attr('visibility', function(d, i){
            var isVisible = 'visible';
            if(NumberUtils.isNoValue(d.fontSize) || d.x === undefined || d.y === undefined){
              isVisible = 'hidden';
            }
            return isVisible;
          })  
          .attr('font-size', function(d, i){
            return d.fontSize;
          }).attr('font-family', tagStyle.fontfamily);
//        wordsWrap.exit().remove();
        
//        wordsWrap.transition().attr('dx', function(d, i){
//            return d.x;
//          }).attr('dy', function(d, i){
//            return d.y;
//          }).duration(800).delay(100);
        
//        wordsWrap.append('line').attr('stroke', 'red').attr('x1', function(d, i){
//              return d.x + d.x0;
//            }).attr('y1', function(d, i){
//              return d.y;
//            }).attr('x2', function(d, i){
//              return d.x + d.x1;
//            }).attr('y2', function(d, i){
//              return d.y;
//            }).attr('fill', 'none');
        wordsWrap.exit().attr('transform', 'translate(-1000, -1000)');
        wordsWrap.selectAll('.datapoint').attr("fill",function(d, i){
          var color;
          if(fontColorScale && d.wordFontFamily !== null && d.wordFontFamily.val !== null){
            var j, len, domain = fontColorScale.domain();
            for(j = 0, len = domain.length - 1; j < len; j++){
              if(d.wordFontFamily.val!==null && (domain[j][1] > d.wordFontFamily.val)){
                break;
              }
            }
            color = fontColorScale(domain[j]);
          }else{
            color = tagStyle.color;
          }  
          var parameter = {
            fillColor:color,
            drawingEffect:"normal"
          };
          return effectManager.register(parameter);
        }).attr('text-anchor', function(){
          if(options.layout === 'Wordle'){
            return 'middle';
          }else{
            return 'start';
          }
        });
        wordsWrap.selectAll('text').attr('fill-opacity', opacity);
        
        if(options.animation.dataLoading){
          wordsWrap.transition().attr('transform', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined && d.y < height && d.x < width){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            return translate;
          }).duration(800).delay(100).each('end', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined && d.y < height && d.x < width){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            this.setAttribute('transform', translate);
            
            if(i === labelsData.length-1){
              eDispatch.initialized();
            }
          });
        }else{
          wordsWrap.attr('transform', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            return translate;
          });
          eDispatch.initialized(); 
        }
      });
    };
      
      /**
      * set/get width
      */
      chart.width = function(_){
          if (!arguments.length){
            return width;
          }
          width = _;
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(_){
        if (!arguments.length){
          return height;
         }
        height = _;
         return chart;        
      };

      /**
      * set/get data, for some modules like Title, it doesn't need data
      */
      chart.data = function(_){
        if (!arguments.length){
          return chartData;
         }
        var data = {};
        data.words = _.getAnalysisAxisDataByIdx(0).values[0];

        var wordsData = _.getMeasureValuesGroupDataByIdx(0);
        if(wordsData && _.getMeasureValuesGroupDataByIdx(0).values.length > 0){
          data.wordsSize = _.getMeasureValuesGroupDataByIdx(0).values[0];
        }else{
          data.wordsSize = undefined;
        }
        
        var wordsFontFamilySata = _.getMeasureValuesGroupDataByIdx(1);
        if(wordsFontFamilySata && wordsFontFamilySata.values.length > 0){
          data.wordsFontFamily = _.getMeasureValuesGroupDataByIdx(1).values[0];
        }else{
          data.wordsFontFamily = undefined;
          fontColorScale = undefined;
        }
        _parseData(data);
        
        //Check dataset is changed.
        isDatasetChanged = _isDatasetChanged(data);
        chartData = data;
         return chart;        
      };

      /**
      * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
          return options;
         }
         Objects.extend(true, options, props);
         tooltipVisible = options.tooltip.enabled;
      if (fontColorScale) {
        _calculateFontFamily(minFontFamily, maxFontFamily, hasNullValue);
      }
         return chart;
      };
      
      /**
     * get/set your event dispatch if you support event
     */
      chart.dispatch = function(_){
        if(!arguments.length){
          return eDispatch;
        }
        eDispatch = _;
        return chart;
      };
      
      
      /*
       * Font color scale.
       */
      chart.mbcLegendInfo = function(){
        var title = chartData.wordsFontFamily ? chartData.wordsFontFamily.col : '';
        return {
          'colorScale' : fontColorScale,
          'title' : title
        };
      };
      
      /*
       * Add mouse interaction functions.
       */
      chart.parent = function(){
        return wrap;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
//            opacity = 0.2;
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
//          opacity = 0.2;
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray === undefined){
          wrap.selectAll('.datapoint').attr('fill-opacity', 1);
          opacity = 1;
        }else{
          wrap.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      
      chart.mouseover = function(point){
        var item = d3.select(d3.event.target);
        var clickedItemID = item.attr('id');
        if(clickedItemID && tooltipVisible){
          var tooltipData = generateTooltipData(item.datum());
          var transform = wrap.node().getTransformToElement(wrap.node().ownerSVGElement);
          var svgRect = wrap.node().ownerSVGElement.getBoundingClientRect();
          var itemRect = item.node().getBoundingClientRect(), wrapRect = wrap.node().getBoundingClientRect();
          
          decorativeShape.attr('width', itemRect.width).attr('height', itemRect.height).attr('x', itemRect.left - wrapRect.left).attr('y', itemRect.top - wrapRect.top).style('visibility', 'visible');
          tooltipData.point = {
            x: itemRect.left - svgRect.left + itemRect.width/2,
            y: itemRect.top - svgRect.top
          };
          
          tooltipData.plotArea = {
            x : transform.e,
          y : transform.f,
          width : width,
          height : height
          };
          
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
      };
      
      chart.mouseout = function(){
        decorativeShape.attr('width', 0).attr('height', 0).attr('x', 0).attr('y', 0).style('visibility', 'hidden');
        if(tooltipVisible){
          eDispatch.hideTooltip();
        }
      };
      
      /**
       * interfaces for MBC legend selection
       * @param {Object} selectedData 
       * <pre>
       * {
       * ctx: {
       *   ranges: {
       *    endValue:100
       *    isLeftOpen:false
       *    isRightOpen:true
       *    startValue:84
       *   }
       * },
       * val: 84   
       * }
       * @returns {Array} d3 selections in the given range  
       */
      chart.getDatapointsByRange = function(selectedData){
        var datapoints = d3.selectAll('.datapoint')[0], ctxDatapoints = [], ranges = selectedData.ctx.ranges, data;
        for(var i = 0, len = datapoints.length; i < len; i++){
          data = datapoints[i].__data__.wordFontFamily.val;
          if (NumberUtils.isNoValue(selectedData.val)) {
          if (NumberUtils.isNoValue(data)) {
            ctxDatapoints.push(datapoints[i]);
          }
        } else {
          if (data < ranges.endValue && data > ranges.startValue) {
            ctxDatapoints.push(datapoints[i]);
          } else {
            if (!ranges.isLeftOpen && data === ranges.startValue) {
              ctxDatapoints.push(datapoints[i]);
            } else if (!ranges.isRightOpen && data === ranges.endValue) {
              ctxDatapoints.push(datapoints[i]);
            }
          }
        }
        }
        return ctxDatapoints;
      };
    
    var _isDatasetChanged = function(newData){
      var oldData = chartData, isDatasetChanged = false;
      if(oldData.words && newData.words){
        if(oldData.words.rows.length !== newData.words.rows.length){
          isDatasetChanged = true;
        }else if((oldData.wordsFontFamily && !newData.wordsFontFamily) || (!oldData.wordsFontFamily && newData.wordsFontFamily)){
          isDatasetChanged = true;
        }else{
          var oldWords = oldData.words.rows, newWords = newData.words.rows;
          for(var i = 0, iLen = oldWords.length; i < iLen; i++){
            if(oldWords[i].val !== newWords[i].val){
              isDatasetChanged = true;
              break;
            }
          }
        }
      }
      return isDatasetChanged;
    };
      
    var _filterData = function(){
      var labelsData = [], item;
      for(var i = 0, len = tagArr.length; i < len; i++){
        item = tagArr[i];
        if(!(NumberUtils.isNoValue(item.fontSize) || item.x === undefined || item.y === undefined || item.y > height || item.x > width)){
          //Hide this tag, remove it.
          labelsData.push(item);
        }
      }
      return labelsData;
    };
    
      var generateTooltipData = function(data){
        var tooltipData = {
            body: [],
            footer: []
        };
        
        if(chartData.wordsSize){
          tooltipData.body.push({
            name: chartData.wordsSize.col,
            val:[{
              value: data.wordSize
            }]
          });
        }
        
        if(chartData.wordsFontFamily){
          tooltipData.body.push({
            name:chartData.wordsFontFamily.col,
            val:[{
              value: data.wordFontFamily
            }]
          });
        }
        
        if(chartData.words){
          tooltipData.footer.push({
            label: chartData.words.col,
            value: data.word
          });
        }
        
        return tooltipData;
      };
        
      var _parseData = function(data){
      tagArr = [];
      var minFontSize, maxFontSize, fontfamilyValue, tagItem;
      minFontFamily = undefined, maxFontFamily = undefined, hasNullValue = false;
      
      for(var i=0, len = data.words.rows.length; i < len; i++){
        if(data.words && data.words.rows[i].val && data.wordsSize && data.wordsSize.rows[0][i] && !NumberUtils.isNoValue(data.wordsSize.rows[0][i].val)){
          tagItem = {};
          tagItem.word = data.words.rows[i];
          tagItem.wordSize = (data.wordsSize ? data.wordsSize.rows[0][i] : undefined);
          tagItem.wordFontFamily = (data.wordsFontFamily ? data.wordsFontFamily.rows[0][i] : undefined);
          
          //For selection event data.
          tagItem.val = [data.words.rows[i].val];
          tagItem.ctx = [data.words.rows[i].ctx];
        
          if(tagItem.wordSize){
            tagItem.val.push(data.wordsSize.rows[0][i].val);
            tagItem.ctx.push(data.wordsSize.rows[0][i].ctx);
            
            if(tagItem.wordSize.val !== null){
              if(minFontSize === undefined || tagItem.wordSize.val < minFontSize){
                minFontSize = tagItem.wordSize.val; 
              }
              if(maxFontSize === undefined || tagItem.wordSize.val > maxFontSize){
                maxFontSize = tagItem.wordSize.val; 
              }
            }
          }
          
          if(tagItem.wordFontFamily){
            tagItem.val.push(tagItem.wordFontFamily.val);
            tagItem.ctx.push(tagItem.wordFontFamily.ctx);
            
            fontfamilyValue = tagItem.wordFontFamily.val;
            
            if(fontfamilyValue === null){
              hasNullValue = true;
            }else{
              if(minFontFamily === undefined || fontfamilyValue < minFontFamily){
                minFontFamily = tagItem.wordFontFamily.val; 
              }
              if(maxFontFamily === undefined || fontfamilyValue > maxFontFamily){
                maxFontFamily = tagItem.wordFontFamily.val; 
              }
            }
          }
          tagArr.push(tagItem);
        }
      }
      
      //Linear font weight scale. Add more scale type here.
      _calculateFontSize(minFontSize, maxFontSize);
      if(data.wordsFontFamily){
        _calculateFontFamily(minFontFamily, maxFontFamily, hasNullValue);
      }else{
        fontColorScale = undefined;
      }
    };
    
    /*
     * Calculate font size by font-weight
     */
    var _calculateFontSize = function(min, max){
      //Generate font size arguments
      var count = tagArr.length;
      var a, b, fsize;
      
      if (min === 0){
              min = 1;
              max += 1;
          }
      
      if (count > 1) {
        b = (maxfont - (minfont * (max / min))) / (1 - (max / min));
        a = (minfont - b) / min;
      } else {
        b = 0;
        a = maxfont / (min < 0 ? -min : min);
      }
      
      for(var i=0, len = tagArr.length; i < len; i++){
        //Set Font Size
        if(tagArr[i].wordSize && min !== max){
          fsize = Math.round(a * tagArr[i].wordSize.val + b);
        }else{
          fsize = minfont;
        }
        tagArr[i].fontSize = (tagArr[i].wordSize.val === null) ? null : fsize;
      }
    };
    
    /*
     * Calculate font color family.
     */
    var _calculateFontFamily = function(minVal, maxVal, hasNullValue){
      if(minVal === undefined && maxVal === undefined){
        fontColorScale = d3.scale.ordinal().domain([[]]).range([tagStyle.color]);
      }else{
        fontColorScale = MeasureBasedColoring.getScale(minVal, maxVal, 5, options.startColor, options.endColor);
        
        if(hasNullValue){
          var domains = fontColorScale.domain();
          var ranges = fontColorScale.range();
          domains.push([]);
          ranges.push(tagStyle.color);
        }
      }
    };
    
    var _calculateTagPosition = function(){
      var layout;
      if(options.layout === 'Column'){
        layout = ColumnLayout();
      } else if(options.layout === 'Row'){
        layout = RowLayout();
      } else if(options.layout === 'Wordle'){
        layout = WordleLayout();
      }
      
      if(layout !== undefined){
        //TODO remove me
        var start = (new Date()).valueOf();
        layout.width(width).height(height).data(tagArr).font(tagStyle.fontfamily).layout();
        var end = (new Date()).valueOf();
        //console.log(options.layout, start, end, end-start);
      }
    };
    
    var _handleNullValue = function(value){
      return (value === null || value === undefined) ? defaultString : value;
    };
    
    options = manifest.props(null);
      return chart;
  };
  return tagCloud;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.TagCloud',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tagcloud',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.TagCloud',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.tagcloud',
    'type' : Constants.Module.Type.Chart,
    'name' : 'tagcloud',
    'properties' : {
      'layout' : {
        'name' : 'layout',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'Row', 'Column', 'Wordle' ],
        'defaultValue' : 'Wordle',
        'description' : 'Set layout fo tag cloud.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enabled/disabled data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : false,
              'description' : 'Set enabled/disabled data updating animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.'
        },
      'startColor' : {
          'name' : 'startColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#C2E3A9",
          'description' : 'Set tagCloud start color.'
        },
        
        'endColor' : {
          'name' : 'endColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#73C03C",
          'description' : 'Set tagCloud endcolor.'
        },
        'tooltip' : {
          'name' : 'tooltip',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'enabled' : {
              'name' : 'enabled',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enabled/disabled tooltip.'
            }
          },
          'isExported' : false,
          'description' : 'Settings for tooltip related properties.'
        }
    },
    'events' : {
      'initialized': Constants.Module.Event.Initialized.desc,
        'selectData' : Constants.Module.Event.SelectData.desc,
        'deselectData' : Constants.Module.Event.DeSelectData.desc,
        'showTooltip' : Constants.Module.Event.TooltipShow.desc,
        'hideTooltip' : Constants.Module.Event.TooltipHide.desc

    },
    'feeds' : {
      id : "tagCloud"
    },
    'css' : {},
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.TagCloudChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TagCloud',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/tagcloud',
    name : 'IDS_TAGCLOUDCHART',
    base : 'riv/base/single',
    modules : {
      legend : {
        feeds : [],
        configure : {
          'description': 'The measure based coloring legend is a bar containing segments with different colors and a value scale on side to indicate the relationship between the values and colors in the chart. ',
          properties : {
            type : 'MeasureBasedColoringLegend'
          },
          propertiesOverride : {
            isHierarchical : {
              isExported : false
            },
            formatString: {
              isExported: true
            }
          }
        }
      },
    tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
              chartType : 'tagcloud',
              orientation : 'bottom'
            }
          }
        },
    
      main : {
        modules : {
          dataLabel:null,
          plot : {
            id : 'sap.viz.modules.tagcloud',
            configure : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        },
        controllers : {
             'interaction' : {
                   id : 'sap.viz.modules.controller.interaction',
                   configure : {
                       propertyCategory : 'interaction',
                        properties : {
                          supportedEventNames: ['mouseup', 'mouseover', 'mouseout', 'touchstart']
                        }
                   }
               }
          }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'legend',
        target : 'mbcLegendInfo',
        sourceModule : 'main.plot',
        source : 'mbcLegendInfo'
      }, {
          targetModule : 'legend',
          target : 'setSelectionMode',
          sourceModule : 'main.interaction',
          source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'main.interaction',
        listener : 'registerEvent',
        sourceModule : 'main.plot',
        type : 'initialized.interaction'
      },  {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
      }, {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.RadarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Radar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/radar',
    name : 'IDS_RADARCHART',
    base : "riv/base/single",
    modules : {
      legend : {
        id : "sap.viz.modules.legend",
        data : {
          aa : [ 2, 3 ]
        }
      },
      tooltip : {
        id : "sap.viz.modules.tooltip",
        configure : {
        propertyCategory : 'tooltip',
          properties : {
            chartType : "radar",
            orientation : "left"
          }
        }
      },
      main : {
        id : 'sap.viz.modules.xycontainer',
        controllers : {
          interaction : {
            id : "sap.viz.modules.controller.interaction",
            configure : {
              propertyCategory : "interaction",
              properties : {
                supportedEventNames : [ "mousemove", "mouseup", "touchstart" ]
              }
            }
          }
        },
        modules : {
          plot: {
            id : 'sap.viz.modules.radar',
            configure : {
            'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }    
          },
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                paintingMode : 'rectCoordinate',
                visible : false,
                orientation : 'vertical',
                position : 'outside',
                automaticInOutside : false,
                showZero : true,
                isStackMode : false,
                isPercentMode : false,
                outsideVisible : true,
                outsidePosition : 'up'
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [{
        targetModule : "legend",
        target : "colorPalette",
        sourceModule : "main.plot",
        source : "colorPalette"
      },  {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapes'
      }, {
          targetModule : 'legend',
          target : 'setSelectionMode',
          sourceModule : 'main.interaction',
          source : 'getSelectionMode'
      } ],
      events : [{
        targetModule : "main.interaction",
        listener : "registerEvent",
        sourceModule : "main.plot",
        type : "initialized.interaction"
      },{
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
      }, {
        targetModule : "tooltip",
        listener : "showTooltip",
        sourceModule : "main.plot",
        type : "showTooltip"
      }, {
        targetModule : "tooltip",
        listener : "hideTooltip",
        sourceModule : "main.plot",
        type : "hideTooltip"
      }, {
        targetModule : 'main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'main.plot',
        type : 'startToInit.datalabel'
      }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.load',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.RadarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.TagCloudChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.HeatMapChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.TreeMapChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.scatter.BubbleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.scatter.ScatterChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiScatterChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiBubbleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.ScatterMatrixChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiHorizontalLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualHorizontalLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.pie.DonutChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.pie.DonutWithDepthChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.pie.PieChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.pie.PieWithDepthChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiPieChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDonutChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.PercentageStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.PercentageStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualPercentageStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualPercentageStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalWaterfallChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.WaterfallChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedWaterfallChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalStackedWaterfallChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualHorizontalLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.LineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.CombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualCombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalCombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualHorizontalCombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.VerticalBoxplotChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalBoxplotChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.MekkoChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.PercentageMekkoChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalMekkoChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.PercentageHorizontalMekkoChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.AreaChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.PercentageAreaChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalAreaChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.PercentageHorizontalAreaChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xyz.Column3DChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xyz.Bar3DChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiRadarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiPercentageStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiPercentageStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualPercentageStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualPercentageStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiAreaChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiPercentageAreaChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiHorizontalAreaChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiPercentageHorizontalAreaChart',
  version : '4.0.0'
}
],
function Setup() {
  return;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.VizAppDelegate',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(FuncUtils) {
	/**
	 * The abstract application delegate class. Application delegate is used to
	 * plug in your specific application logic. The object is created by
	 * VizApplication automatically
	 * 
	 * @name sap.viz.mvc.VizAppDelegate
	 * @constructor
	 */
	var VizAppDelegate = function() {
		this._publicMethodsRegistry = {};
		//this._theme = ThemeManager.defaultTheme();
		this._application;
	};

	var vp = VizAppDelegate.prototype;

	vp._afterLaunched = function(application, launchOption) {
		this._application = application;
		this.appDidFinishLaunching(application, launchOption);
		var rootController = this.rootController();
		rootController._setApplication_(this._application);
		this._application._setRootController(rootController);
	};

	/**
	 * This method will be called after the application fully launched, the
	 * Application will pass launchOption (if any) to this method. Any
	 * application specific initialization should be put here, e.g. initialize
	 * necessary data structure.
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#appDidFinishLaunching
	 * @function
	 * @param {Object}
	 *            launchOption the launchOption which is passed in
	 *            VizApplication constructor
	 */
	vp.appDidFinishLaunching = FuncUtils.noop;

	/**
	 * Subclass <b>MUST</b> implement this method to return the root controller
	 * of the application
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#rootController
	 * @return {sap.viz.mvc.UIController}
	 */
	vp.rootController = FuncUtils.unimplemented;

	/**
	 * This method is used to register any method specific to the current
	 * visualization implementation, and exposed to the consumer. This method is
	 * expected to be called during initialization phase, like in
	 * appDidFinishLaunching. The 'this' object of the function during invoking
	 * will be pointing to delegate object.
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#registerPublicMethod
	 * @param {String}
	 *            methodName the name of the method to be exposed
	 * @param {Function}
	 *            func the function of the method.
	 */
	vp.registerPublicMethod = function(methodName, func) {
		this._publicMethodsRegistry[methodName] = func;
	};

	vp._invokePublicMethod = function(publicMethodName, options) {
		if (this._publicMethodsRegistry.hasOwnProperty(publicMethodName)) {
			return this._publicMethodsRegistry[publicMethodName].call(this, options);
		}
	};

	vp._currentTheme = function() {
		return this._theme;
	};

	vp._applyTheme = function(theme) {
		if (this._theme !== theme) {
			this.rootController().doThemeApplied(theme);
		}
	};

	vp._updateThemeSetting = function(theme, key, oldValue, newValue) {
		if (this._theme === theme) {
			this.rootController().doThemeUpdated(key, oldValue, newValue);
		}
	};
	/**
	 * Subclass should implement this method to return plain object contains all
	 * of the modifiable properties and their current value.
	 * 
	 * 
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#getProperties
	 * 
	 * @returns {Object} property bag
	 * 
	 */
	vp.getProperties = function() {
		return {};
	};

	/**
	 * Subclass should implement this method to accept a property bag.
	 * 
	 * 
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#updateProperties
	 * @param {Object}
	 *            propBag
	 * 
	 */
	vp.updateProperties = FuncUtils.noop;

	/**
	 * Subclass should implement this method to accept a dataset.
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#setDataset
	 * @param {Object}
	 */
	vp.setDataset = FuncUtils.noop;
	
	/**
     * Subclass should implement this method to get dataset.
     * 
     * @name sap.viz.mvc.VizAppDelegate#getDataset
     * 
     * @returns {Object} dataset
     */
    vp.getDataset = FuncUtils.noop;

	/**
	 * Subclass should implement this method to return a list of assets(only
	 * image supported) to be preload.
	 * 
	 * 
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#getPreloadAssets
	 * 
	 * @returns {[]} the item in the array should follow below structure
	 * 
	 * <pre>
	 * [ {
	 * 	id : 'IMAGE_ID',
	 * 	url : 'IMAGE_URL'
	 * } ]
	 * </pre>
	 */
	vp.getPreloadAssets = function() {
		return [];
	};
	/**
	 * Subclass should implement this method to return a list of supported
	 * events that could be listened by visualization user.
	 * 
	 * 
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#getSupportedEvents
	 * 
	 * @returns {[]} the list of event names
	 * 
	 */
	vp.getSupportedEvents = function() {
		return [];
	};

	vp.getSupportedMethods = function() {
		var ret = [];
		for ( var p in this._publicMethodsRegistry) {
			ret.push(p);
		}
		return ret;
	};
	return VizAppDelegate;
});sap.riv.module(
{
  qname : 'sap.viz.base.Logger',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(FncUtils) {
    var noop = FncUtils.noop;
    // var noop = function() {
    // };
    Date.now = Date.now ||
    function() {
        return +new Date();
    };

    var dispatcherIdleCounter = 0;

    function callAppender(appender) {
        var logTime, logLevel, logCate, logMsg, appenderLevel;

        if(logBuffer[0].length > 0) {
            if(appender) {
                appenderLevel = appender.getLevel();
                for(var i = 0, bl = logBuffer[0].length; i < bl; i++) {
                    logTime = logBuffer[0][i];
                    logLevel = logBuffer[1][i];
                    logCate = logBuffer[2][i];
                    logMsg = logBuffer[3][i];
                    if(logBuffer[1][i] >= appenderLevel)
                        appender.doAppend(logTime, logLevel, logCate, logMsg);
                }
                return;
            }

            //call all appenders
            //var appender;
            var appenderLevelMap = {};
            for(var appenderKey in appenders) {
                if(appenders.hasOwnProperty(appenderKey)) {
                    appenderLevelMap[appenderKey] = appenders[appenderKey].getLevel();
                }
            }
            while(logBuffer[0].length) {
                logTime = logBuffer[0].shift();
                logLevel = logBuffer[1].shift();
                logCate = logBuffer[2].shift();
                logMsg = logBuffer[3].shift();
                for(appenderKey in appenders) {
                    if(appenders.hasOwnProperty(appenderKey)) {
                        appender = appenders[appenderKey];
                        if(logLevel >= appenderLevelMap[appenderKey])
                            appender.doAppend(logTime, logLevel, logCate, logMsg);
                    }
                }
            }
            return;
        } else if(++dispatcherIdleCounter === 3)
            //pause on third time loop an empty Buffer
            pause();
    }

    function dispatcher() {
        callAppender();
        if(!paused)
            setTimeout(function() {
                dispatcher();
            }, 100);
    }

    var ConsoleAppender = function() {
        this.threshold = Logger.LEVEL.INFO;
        this.layout = new Logger.DefaultLayout();
        this.print = typeof console !== undefined ? function(msg) {
            console.log(msg);
        } : noop;
    };
    ConsoleAppender.prototype = {
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.print(this.layout.format(logTime, logLevel, logCate, logMsg));
        },
        setLayout : function(layout) {
            layout.format && (this.layout = layout);
        },
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        }
    };
    var DefaultLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    DefaultLayout.prototype.format = function(logTime, logLevel, logCate, logMsg) {
        return "[" + logTime + "]" + "[" + getLevelStr(logLevel) + "]" + "[" + (logCate || "main") + "]-" + logMsg;
    };
    var DivAppender = function(div) {
        if(!$) {
            throw "need jQuery";
        }
        this.threshold = Logger.LEVEL.INFO;
        this.divSl = $(div);
        this.layout = new HTMLLayout();
    };
    DivAppender.prototype = {
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        },
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.divSl.append(this.layout.format(logTime, logLevel, logCate, logMsg));
        }
    };
    var HTMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    HTMLLayout.prototype = {
        getStyle : function(logLevel) {
            var style;
            if(logLevel === Logger.LEVEL.ERROR) {
                style = 'color:red';
            } else if(logLevel === Logger.LEVEL.WARN) {
                style = 'color:orange';
            } else if(logLevel === Logger.LEVEL.DEBUG) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.TRACE) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.INFO) {
                style = 'color:grey';
            } else {
                style = 'color:yellow';
            }
            return style;
        },
        format : function(logTime, logLevel, logCate, logMsg) {
            return "<div style=\"" + this.getStyle(logLevel) + "\">[" + logTime + "]" + "[" + getLevelStr(logLevel) + "][" + (logCate || "main") + "]-" + logMsg + "</div>";
        }
    };
    var FifoBuffer = function() {
        this.array = [];
    };

    FifoBuffer.prototype = {

        /**
         * @param {Object} obj any object added to buffer
         */
        push : function(obj) {
            this.array[this.array.length] = obj;
            return this.array.length;
        },
        /**
         * @return first putted in Object
         */
        pull : function() {
            if(this.array.length > 0) {
                var firstItem = this.array[0];
                for(var i = 0; i < this.array.length - 1; i++) {
                    this.array[i] = this.array[i + 1];
                }
                this.array.length = this.array.length - 1;
                return firstItem;
            }
            return null;
        },
        length : function() {
            return this.array.length;
        }
    };
    var AjaxAppender = function(url) {
        this.loggingUrl = url;
        this.isInProgress = false;
        this.threshold = Logger.LEVEL.INFO;
        this.bufferSize = 20;
        this.timeout = 2000;
        this.loggingEventMap = [];
        this.layout = new Logger.JSONLayout();
        this.httpRequest = null;
        this.timer = undefined;
    };
    function tryAppend() {
        var appender = this;
        if(this.isInProgress === true) {
            setTimeout(function() {
                tryAppend.call(appender);
            }, 100);
        }else{
            this.send();
        }
    }


    AjaxAppender.prototype = {
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        },
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.loggingEventMap.push([logTime, logLevel, logCate, logMsg]);
            if(this.loggingEventMap.length <= this.bufferSize || this.isInProgress === true) {
                var appender = this;
                if(this.timer === undefined) {
                    this.timer = setTimeout(function() {
                        tryAppend.call(appender);
                    }, 100);
                }
            }

            if(this.loggingEventMap.length >= this.bufferSize && this.isInProgress === false) {
                //if bufferSize is reached send the events and reset current bufferSize
                if(this.timer !== undefined)
                    clearTimeout(this.timer);
                this.send();
            }
        },
        send : function() {
            if(this.loggingEventMap.length > 0) {
                this.isInProgress = true;
                var a = [];
                var loggingEvent;
                for(var i = 0, lml = this.loggingEventMap.length; i < lml && i < this.bufferSize; i++) {
                    loggingEvent = this.loggingEventMap.shift();
                    a.push(this.layout.format(loggingEvent[0], loggingEvent[1], loggingEvent[2], loggingEvent[3]));
                }

                var content = this.layout.getHeader();
                content += a.join(this.layout.getSeparator());
                content += this.layout.getFooter();

                var appender = this;
                if(this.httpRequest === null) {
                    this.httpRequest = this.getXmlHttpRequest();
                }
                this.httpRequest.onreadystatechange = function() {
                    appender.onReadyStateChanged.call(appender);
                };

                this.httpRequest.open("POST", this.loggingUrl, true);
                // set the request headers.
                this.httpRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                this.httpRequest.setRequestHeader("Content-length", content.length);
                //this.httpRequest.setRequestHeader("Content-type", this.layout.getContentType());
                this.httpRequest.send(content);
                appender = this;

                try {
                    setTimeout(function() {
                        appender.httpRequest.onreadystatechange = function() {
                        };
                        appender.httpRequest.abort();
                        //this.httpRequest = null;
                        appender.isInProgress = false;

                        if(appender.loggingEventMap.length > 0) {
                            appender.send();
                        }
                    }, this.timeout);
                } catch (e) {
                }
            }
        },
        onReadyStateChanged : function() {
            var req = this.httpRequest;
            if(this.httpRequest.readyState !== 4) {
                return;
            }

            var success = (( typeof req.status === "undefined") || req.status === 0 || (req.status >= 200 && req.status < 300));

            if(success) {

                //ready sending data
                this.isInProgress = false;

            } else {
            }
        },
        getXmlHttpRequest : function() {

            var httpRequest = false;

            try {
                if(window.XMLHttpRequest) {// Mozilla, Safari, IE7...
                    httpRequest = new XMLHttpRequest();
                    if(httpRequest.overrideMimeType) {
                        httpRequest.overrideMimeType(this.layout.getContentType());
                    }
                } else if(window.ActiveXObject) {// IE
                    try {
                        httpRequest = new ActiveXObject("Msxml2.XMLHTTP");
                    } catch (e) {
                        httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
                    }
                }
            } catch (e) {
                httpRequest = false;
            }

            if(!httpRequest) {
                throw "browser don't support AJAX";
            }

            return httpRequest;
        }
    };
    var JSONLayout = function() {

    };
    JSONLayout.prototype = {
        /**
         * Implement this method to create your own layout format.
         * @param {Log4js.LoggingEvent} loggingEvent loggingEvent to format
         * @return formatted String
         * @type String
         */
        format : function(logTime, logLevel, logCate, logMsg) {

            var jsonString = "{\n \"LoggingEvent\": {\n";
            jsonString += "\t\"category\": \"" + (logCate || "main") + "\",\n";
            jsonString += "\t\"level\": \"" + getLevelStr(logLevel) + "\",\n";
            jsonString += "\t\"message\": \"" + logMsg + "\",\n";
            // jsonString += "\t\"referer\": \"" + referer + "\",\n";
            // jsonString += "\t\"useragent\": \"" + useragent + "\",\n";
            jsonString += "\t\"timestamp\": \"" + logTime + "\"\n";
            jsonString += "}\n}";

            return jsonString;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/json";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "{" + "\"ClientInfo\" : {\n" + "\t\"useragent\": \"" + useragent + "\",\n" + "\t\"referer\": \"" + referer + "\"\n},\n" + "\"VizLogger\": [\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "\n]}";
        },
        getSeparator : function() {
            return ",\n";
        }
    };

    /**
     * Get the XMLHttpRequest object independent of browser.
     * @private
     */
    var XMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    XMLLayout.prototype = {
        format : function(logTime, logLevel, logCate, logMsg) {

            var content = "<vizLogger:event category=\"";
            content += (logCate || "main") + "\" level=\"";
            content += getLevelStr(logLevel) + "\" timestamp=\"";
            content += logTime + "\">\n";
            content += "\t<vizLogger:message><![CDATA[" + this.escapeCdata(logMsg) + "]]></vizLogger:message>\n";
            content += "</vizLogger:event>";

            return content;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/xml";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "<vizLogger:eventSet useragent=\"" + useragent + "\" referer=\"" + referer.replace(/&/g, "&amp;") + "\">\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "</vizLogger:eventSet>\n";
        },
        getSeparator : function() {
            return "\n";
        },
        /**
         * Escape Cdata messages
         * @param str {String} message to escape
         * @return {String} the escaped message
         * @private
         */
        escapeCdata : function(str) {
            return str.replace(/\]\]>/, "]]>]]&gt;<![CDATA[");
        }
    };

    function getLevelStr(levelInt) {
        switch(levelInt) {
            case Logger.LEVEL.TRACE:
                return "TRACE";
            case Logger.LEVEL.DEBUG:
                return "DEBUG";
            case Logger.LEVEL.INFO:
                return "INFO";
            case Logger.LEVEL.WARN:
                return "WARN";
            case Logger.LEVEL.ERROR:
                return "ERROR";
        }
    }

    var enabled = false;
    var paused = false;
    var logBuffer = [[/*logTime*/], [/*level*/], [/*category*/], [/*message*/]];
    var MaxBufferSize = 2000;
    var doLog = function(level, category, message) {
        if(logBuffer[0].length === MaxBufferSize)
            callAppender();
        logBuffer[0].push(Date.now());
        logBuffer[1].push(level);
        logBuffer[2].push(category);
        logBuffer[3].push(message.toString());
    };
    var awakeThenLog = function(level, category, message) {
        resume();
        doLog(level, category, message);
    };
    var log = noop;
    var pause = function() {
        paused = true;
        log = awakeThenLog;
    };
    var resume = function() {
        paused = false;
        log = doLog;
        setTimeout(function() {
            dispatcher();
        }, 100);
    };
    // id for appender
    var id = 0;
    var nextId = function() {
        return id++;
    };
    var appenders = {};
    /*
     * singleton Logger
     *
     */
    var Logger = {
        LEVEL : {
            TRACE : 5000,
            DEBUG : 10000,
            INFO : 20000,
            WARN : 30000,
            ERROR : 40000,
            NO : Number.MAX_VALUE
        },
        isEnabled : function() {
            return enabled;
        },
        enable : function() {
            log = doLog;
            enabled = true;
            setTimeout(function() {
                dispatcher();
            }, 100);
        },
        disable : function() {
            callAppender();
            log = noop;
            enabled = false;
        },
        toggleEnable : function() {
            if(enabled)
                this.disable();
            else
                this.enable();
        },
        addAppender : function(/*[key,] appender*/) {
            var _nextId = nextId();
            var key, appender;
            if(arguments.length === 1) {
                key = _nextId;
                appender = arguments[0];
            } else if(arguments.length >= 2) {
                key = arguments[0];
                appender = arguments[1];
            }
            if( typeof appender === "object" && appender.doAppend) {
                if(appenders[key] !== undefined)
                    return;
                callAppender();
                appenders[key] = appender;
                return key;
            }

        },
        setAppenders : function(apds) {
            appenders = [];
            for(var i = 0, l = apds.length; i < l; i++) {
                var appender = apds[i];
                if(appender.appenderKey)
                    this.addAppender(appender.appenderKey, appender.appender);
                else
                    this.addAppender(appender.appender);
            }
        },
        removeAppender : function(key) {
            if(appenders[key] === undefined)
                return false;
            //append immediately before remove
            callAppender(appenders[key]);
            return (
            delete appenders[key]);
        },
        getAppender : function(key) {
            return appenders[key];
        },
        ConsoleAppender : ConsoleAppender,
        DivAppender : DivAppender,
        AjaxAppender : AjaxAppender,
        //[time][level][category]-message [yyyy-MM-ddThh:mm:ss:ms][INFO][function1]-this is a piece of log.
        DefaultLayout : DefaultLayout,
        HTMLLayout : HTMLLayout,
        XMLLayout : XMLLayout,
        JSONLayout : JSONLayout,
        trace : function(message, category) {
            log(Logger.LEVEL.TRACE, category, message);
        },
        debug : function(message, category) {
            log(Logger.LEVEL.DEBUG, category, message);
        },
        info : function(message, category) {
            log(Logger.LEVEL.INFO, category, message);
        },
        warn : function(message, category) {
            log(Logger.LEVEL.WARN, category, message);
        },
        error : function(message, category) {
            log(Logger.LEVEL.ERROR, category, message);
        }
    };
    appenders["[default]"] = new Logger.ConsoleAppender();
    return Logger;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(FuncUtils) {
	/**
	 * Iterator for LinkedHashMap, to get an iterator for a linkedHashMap
	 * instance, use {@link sap.viz.base.utils.LinkedHashMap#getIterator}
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator
	 * @constructor
	 */
	var lhmItr = function(lhm, reverseOrder) {
		this._lhm = lhm;
		this._reverse = reverseOrder || false;
		this._count = lhm._length;
		this._cursor = this._reverse ? this._lhm._last : this._lhm._head;
		if (this._reverse) {
			this.hasMore = this._hasMoreInReverse;
		} else {
			this.hasMore = this._hasMoreInOrder;
		}
	};

	lhmItr.prototype._hasMoreInOrder = function() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._head;
			} else {
				this._cursor = this._cursor.next;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	};

	lhmItr.prototype._hasMoreInReverse = function() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._last;
			} else {
				this._cursor = this._cursor.prev;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	};
	/**
	 * Find if there is more item to iterate, calling this method will move the
	 * cursor forward to next item
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#hasMore
	 * @function
	 * @returns {Boolean}
	 */
	lhmItr.prototype.hasMore = FuncUtils.noop;

	/**
	 * Get the entry at the current cursor, calling this method without calling
	 * hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#next
	 * @function
	 * @returns {Object} with key & value property indicating the entry's key
	 *          and value object
	 */
	lhmItr.prototype.next = function() {
		var ret = {
			key : this._cursor.key,
			value : this._cursor.value
		};
		return ret;
	};
	/**
	 * Get the value of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#nextValue
	 * @function
	 * @returns {Object}
	 */
	lhmItr.prototype.nextValue = function() {
		return this._cursor.value;
	};
	/**
	 * Get the key of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#nextKey
	 * @function
	 * @returns {String}
	 */
	lhmItr.prototype.nextKey = function() {
		return this._cursor.key;
	};
	/**
	 * Reset the iterator to initial state
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#reset
	 * @function
	 */
	lhmItr.prototype.reset = function() {
		this._count = this._lhm._length;
	};
	/**
	 * Create an empty LinkedHashMap
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap
	 * @constructor
	 */
	var LinkedHashMap = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	var lhmp = LinkedHashMap.prototype;

	/**
	 * Add one entry, if the key for the entry is already existing, then the old
	 * value will be replaced.
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#add
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @returns {undefined|Object} undefined if key is new, otherwise will be
	 *          the replaced value
	 */
	lhmp.add = function(key, value) {
		var m = this._map;
		var ret = null;
		var node = {
			prev : null,
			key : key,
			value : value,
			next : null
		};
		if (!this._length) {
			this._head = this._last = node;
		}
		if (!m.hasOwnProperty(key)) {
			m[key] = node;
			this._length++;
			node.prev = this._last;
			this._last.next = node;
			this._last = node;
			this._last.next = this._head;
			this._head.prev = this._last;
		} else {
			ret = m[key].value;
			m[key].value = value;
		}
		return ret;
	};
	/**
	 * Add entries from an existing linked hash map, the duplicated entry will
	 * be replaced silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#addAll
	 * @function
	 * @param {sap.viz.base.utils.LinkedHashMap}
	 *            linkedHashMap another linkedHashMap to added
	 */
	lhmp.addAll = function(linkedHashMap) {
		var itr = linkedHashMap.getIterator();
		var entry;
		while (itr.hasMore()) {
			entry = itr.next();
			this.add(entry.key, entry.value);
		}
	};
	/**
	 * Insert the entry before one entry, if the inserted entry exists or the
	 * entry to be inserted before doesn't exist, insertion will fail silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#insertBefore
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            beforeKey the key of the entry to be inserted before
	 * @returns {Object} the value inserted
	 */
	lhmp.insertBefore = function(key, value, beforeKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(beforeKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[beforeKey];
			if (anode !== this._head) {
				nnode.prev = anode.prev;
				anode.prev.next = nnode;
			} else {
				this._head = nnode;
				nnode.prev = this._last;
			}
			nnode.next = anode;
			anode.prev = nnode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Insert the entry after one entry, if the inserted entry exists or the
	 * entry to be inserted after doesn't exist, insertion will fail silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#insertAfter
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            afterKey the key of the entry to be inserted after
	 * @returns {Object} the value inserted
	 */
	lhmp.insertAfter = function(key, value, afterKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(afterKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[afterKey];
			if (anode !== this._last) {
				nnode.next = anode.next;
				anode.next.prev = nnode;
			} else {
				this._last = nnode;
				this._last.next = this._head;
			}
			anode.next = nnode;
			nnode.prev = anode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Replace the existing entry with new entry, including key in place
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#replace
	 * @function
	 * @param {String}
	 *            key the key for the entry to be replaced
	 * @param {withKey}
	 *            withKey the key for the entry to be added
	 * @param {Object}
	 *            andValue the value of the entry to be added
	 * @returns {Object} the value to be replaced
	 */
	lhmp.replace = function(key, withKey, andValue) {
		var m = this._map;
		if (!m.hasOwnProperty(withKey) && m.hasOwnProperty(key)) {
			var nnode = {
				prev : null,
				key : withKey,
				value : andValue,
				next : null
			};
			var rnode = m[key];
			nnode.prev = rnode.prev;
			nnode.next = rnode.next;
			rnode.prev.next = nnode;
			rnode.next.prev = nnode;
			if (this._head === rnode)
				this._head = nnode;
			if (this._last === rnode)
				this._last = nnode;
			m[withKey] = nnode;
			delete m[key];
			return rnode.value;
		}
	};
	/**
	 * Get the value for the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#get
	 * @function
	 * @param {String}
	 *            key the key for the entry to get
	 * 
	 * @returns {undefined|Object} the value for the key or undefined if key is
	 *          non-existing
	 */
	lhmp.get = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key)) {
			return m[key].value;
		}
		return null;
	};
	/**
	 * Get the first inserted entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getFirstInsert
	 * @function
	 * 
	 * @returns {Object} the value first inserted
	 */
	lhmp.getFirstInsert = function() {
		return this._head ? this._head.value : null;
	};
	/**
	 * Get the last inserted entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getLastInsert
	 * @function
	 * 
	 * @returns {Object} the value last inserted
	 */
	lhmp.getLastInsert = function() {
		return this._last ? this._last.value : null;
	};
	/**
	 * Move entry associated with key to the last of the link
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#moveToLast
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 */
	lhmp.moveToLast = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._last.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.prev = this._last;
			node.next = this._last.next;
			this._last.next = node;
			this._last = node;
			this._head = node.next;
			this._head.prev = node;

		}
	};
	/**
	 * Move entry associated with key to the first of the link
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#moveToFirst
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 */
	lhmp.moveToFirst = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._head.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.next = this._head;
			node.prev = this._head.prev;
			this._head.prev = node;
			this._head = node;
			this._last = node.prev;
			this._last.next = node;
		}
	};
	/**
	 * Check whether having the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#has
	 * @function
	 * @param {String}
	 *            key the key of the entry to check
	 * @returns {Boolean}
	 */
	lhmp.has = function(key) {
		var m = this._map;
		return m.hasOwnProperty(key);
	};
	/**
	 * Remove the entry associated with the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#remove
	 * @function
	 * @param {String}
	 *            key the key of the entry to remove
	 * @returns {undefined|Object} the removed item or undefined if key is
	 *          non-existing
	 */
	lhmp.remove = function(key) {
		var m = this._map;
		var ret;
		if (m.hasOwnProperty(key)) {
			var node = m[key];
			ret = node.value;
			if (node === this._head) {
				this._head = node.next;
			} else if (node === this._last) {
				this._last = node.prev;
			} else {
				node.prev.next = node.next;
				node.next.prev = node.prev;
			}
			delete m[key];
			this._length--;
			if (this._length === 0) {
				this._head = this._last = undefined;
			}
			return ret;
		}
	};
	/**
	 * Remove all entries added before
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#purgeAll
	 * @function
	 * 
	 */
	lhmp.purgeAll = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	/**
	 * Whether the map is empty
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#isEmpty
	 * @function
	 * 
	 * @returns {Boolean}
	 */
	lhmp.isEmpty = function() {
		return this._length == 0;
	};
	/**
	 * Length of the map
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#length
	 * @function
	 * @returns {Integer}
	 */
	lhmp.length = function() {
		return this._length;
	};
	/**
	 * Get the iterator of the map
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getIterator
	 * @function
	 * @param {Boolean}
	 *            reverseOrder whether iterate in reverse order
	 * @returns {sap.viz.base.utils.LinkedHashMap.Iterator}
	 */
	lhmp.getIterator = function(reverseOrder) {
		return new lhmItr(this, reverseOrder);
	};
	return LinkedHashMap;
});sap.riv.module(
{
  qname : 'sap.viz.base.Observable',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(typeUtils) {
	/**
	 * To utilize observable object, You have to extend your object from it, and
	 * set the 'events' property as Array of event name to the constructor 
	 * 
	 * @name sap.viz.base.Observable
	 * @constructor
	 */
	var ob = function(option) {
		this._events = {};
		var cclazz = this.constructor;
		while (cclazz) {
			var events = cclazz.prototype.events, len;
			if (events) {
				len = events.length;
				while (len--) {
					this.addEvents(events[len]);
				}
			}
			cclazz = cclazz.superclazz;
		}
		if (option) {
			if (option.listeners) {
				this.addListeners(option.listeners);
				delete option.listeners;
			}
		}
	};

	var obp = ob.prototype;

	/**
	 * Add events that could be monitored
	 * 
	 * @name sap.viz.base.Observable#addEvents
	 * @function
	 * @parameter {String|String|...} event1,event2,event3... variable length
	 *            arguments of String
	 */
	obp.addEvents = function(/* event1, event2,...,eventn */) {
		var es = this._events, a = arguments, len = arguments.length;
		while (len--) {
			if (typeof a[len] === 'string') {
				es[a[len]] = es[a[len]] || [];
			}
		}
	};
	/**
	 * Get the supported events
	 * 
	 * @name sap.viz.base.Observable#getSupportedEvents
	 * @function
	 * @return {Array} an array of event names
	 */
	obp.getSupportedEvents = function() {
		var ret = [];
		for ( var e in this._events) {
			ret.push(e);
		}
		return ret;
	};
	/**
	 * Add event listeners
	 * 
	 * @name sap.viz.base.Observable#addListeners
	 * @function
	 * @param {Object|[Object]}
	 *            o single event listener or array of event listener
	 * @param {String}
	 *            o.eventName the event to be monitored
	 * @param {Function}
	 *            o.listener the function to be called back when event is fired
	 * @param {Object}
	 *            [o.scope] the scope in which the listener will be executed
	 * @param {Object}
	 *            [o.optionalArgs] the additional arguments that will be passed
	 *            in the listener
	 */
	obp.addListeners = function(o) {
		var ls;
		if (typeUtils.isArray(o)) {
			ls = o;
		} else {
			ls = [ o ];
		}
		var len = ls.length, l, en;
		var es = this._events;
		while (len--) {
			l = ls[len];
			en = l.eventName;
			if (es.hasOwnProperty(en)) {
				var lList = es[en];
				if (!this.isListening(en, l.listener, l.scope)) {
					lList[lList.length] = {
						fn : l.listener,
						scp : l.scope,
						optArgs : l.optionalArgs
					};
				}
			}
		}
		return this;
	};

	/**
	 * Find the listener that registered before
	 * 
	 * @name sap.viz.base.Observable#findListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * 
	 * 
	 * @returns {-1|Integer} returning -1 means not found otherwise return the
	 *          position order in which the listener to be invoked
	 */
	obp.findListener = function(eventName, fn, scope) {
		var es = this._events;
		if (!es.hasOwnProperty(eventName)) {
			return -1;
		}
		var lList = es[eventName], len = lList.length, lis;
		while (len--) {
			lis = lList[len];
			if (scope) {
				if (lis.fn == fn && lis.scp == scope) {
					return len;
				}
			} else {
				if (lis.fn == fn) {
					return len;
				}
			}
		}
		return -1;
	};
	/**
	 * Check whether the listener is listening on the event
	 * 
	 * @name sap.viz.base.Observable#isListening
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * @returns {Boolean}
	 */
	obp.isListening = function(eventName, fn, scope) {
		return this.findListener(eventName, fn, scope) > -1;
	};

	/**
	 * Remove the previous registered listener listening on the given event
	 * 
	 * @name sap.viz.base.Observable#removeListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * @returns {this} return the observable object itself
	 */
	obp.removeListener = function(eventName, fn, scope) {
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			var lList = es[eventName];
			var len = lList.length, idx;
			while (len--) {
				idx = this.findListener(eventName, fn, scope);
				if (idx > -1) {
					lList.splice(idx, 1);
					len = lList.length;
				}
			}
		}
		return this;
	};

	/**
	 * Remove all the listeners currently watching the event
	 * 
	 * @name sap.viz.base.Observable#removeAllListeners
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {this} return the observable object itself
	 */
	obp.removeAllListeners = function(eventName) {
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			es[eventName] = [];
		}
		return this;
	};
	/**
	 * Check whether there is any listener watching the event
	 * 
	 * @name sap.viz.base.Observable#hasListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {Boolean}
	 */
	obp.hasListener = function(eventName) {
		return this._events[eventName] && this._events[eventName].length > 0;
	};

	/**
	 * Purge all listeners registered on the observable object
	 * 
	 * @name sap.viz.base.Observable#purgeListeners
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {Boolean}
	 */
	obp.purgeListeners = function() {
		var es = this._events;
		for ( var e in es) {
			es[e] = [];
		}
	};

	/**
	 * Fire a event, with optional details attached
	 * 
	 * @name sap.viz.base.Observable#fireEvent
	 * @function
	 * @param {String}
	 *            eventName name of the event to be fired
	 * @param {Object}
	 *            details variable length arguments,var1, var2..varn, the
	 *            details to be passed in each listener call.
	 */
	obp.fireEvent = function(eventName /* details */) {
		var details = Array.prototype.slice.call(arguments, 1);
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			var lList = es[eventName], l;
			for ( var i = 0, len = lList.length; i < len; i++) {
				l = lList[i];
				if (l.optArgs) {
					details.push(l.optArgs);
				}
				l.fn.apply(l.scp || this || window, details);
			}
		}
	};

	/**
	 * Same as addListeners
	 * 
	 * @name sap.viz.base.Observable#on
	 * @function
	 * @see sap.viz.base.Observable#addListeners
	 */
	obp.on = obp.addListeners;
	/**
	 * Same as removeListener
	 * 
	 * @name sap.viz.base.Observable#un
	 * @function
	 * @see sap.viz.base.Observable#removeListener
	 */
	obp.un = obp.removeListener;
	return ob;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.Observable',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(Observable, ObjectUtils, LinkedHashMap, FuncUtils) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}

	/**
	 * The mask used to specify the auto resizing behavior
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing
	 * @class
	 */
	var ar = {
		/**
		 * Mark width & height is not flexible when its parent component's size
		 * changed
		 * 
		 * @field
		 * 
		 */
		None : 0,
		/**
		 * Mark the left margin is flexible
		 * 
		 * @field
		 */
		FlexibleLeftMargin : 1 << 0,
		/**
		 * Mark the width is flexible
		 * 
		 * @field
		 */
		FlexibleWidth : 1 << 1,
		/**
		 * Mark the right margin is flexible
		 * 
		 * @field
		 */
		FlexibleRightMargin : 1 << 2,
		/**
		 * Mark the top margin is flexible
		 * 
		 * @field
		 */
		FlexibleTopMargin : 1 << 3,
		/**
		 * Mark the height is flexible
		 * 
		 * @field
		 */
		FlexibleHeight : 1 << 4,
		/**
		 * Mark the bottom margin is flexible
		 * 
		 * @field
		 */
		FlexibleBottomMargin : 1 << 5
	};

	var id = 0;
	var nextId = function() {
		return id++;
	};

	/**
	 * This class defines UI component which serves as the super class of every
	 * controls
	 * 
	 * @name sap.viz.mvc.UIComponent
	 * @class
	 * @augments sap.viz.base.utils.Observable
	 */
	var UIComponent = ObjectUtils
			.derive(
					Observable,
					/**
					 * @lends sap.viz.mvc.UIComponent
					 * 
					 */
					{
						events : [ 'widthChanged', 'heightChanged', 'sizeChanged', 'positionChanged', 'anchorChanged',
								'beforeShow', 'afterShow', 'beforeHide', 'afterHide', 'focusin', 'focusout', 'focus',
								'blur', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'mousemove', 'click',
								'dblclick', 'touchstart', 'touchmove', 'touchend', 'touchcancel' ],
						/**
						 * @constructs
						 * @param {Object}
						 *            options the options to initialize the UI
						 *            component
						 * @param {Boolean}
						 *            [options.hidden] whether the UI component
						 *            is hidden
						 * @param {Integer}
						 *            [options.autoresizingMask] the bitwise
						 *            combination of the autoresizing mask,
						 *            default is
						 *            {@link  sap.viz.mvc.UIComponent.Autosizing#None}
						 * @param {Object}
						 *            [options.anchor] the anchor point of the
						 *            UI component, default is
						 * 
						 * <pre>
						 * {
						 * 	x : 0.5,
						 * 	y : 0.5
						 * }
						 * </pre>
						 * 
						 * @param {Object}
						 *            [options.position] the position of the UI
						 *            component, default is
						 * 
						 * <pre>
						 * {
						 * 	x : 0,
						 * 	y : 0
						 * }
						 * </pre>
						 * 
						 * @param {Object}
						 *            [options.size] the size of the UI
						 *            component, default is
						 * 
						 * <pre>
						 * {
						 * 	w : 0,
						 * 	h : 0
						 * }
						 * </pre>
						 */
						constructor : function(options) {
							options = options || {};

							var _nextId = nextId();

							this._id = options.id ? options.id + '_' + _nextId : _nextId;

							this._attached = false;// a internal flag indicates
							// if the underlying div is
							// attached to DOM tree

							this._container = undefined;// DOM div container for
							// this ui component

							this._superComp = undefined;

							this._subComps = new LinkedHashMap();

							this._hidden = false;

							this._clipToBound = true;

							this._parentVisible = false;

							this._printable = true;

							this._autoresizeSubComponents = true;

							this._autoresizingMask = ar.None;

							this._gestureDetectors = [];

							this._bounds = {
								x : 0,
								y : 0,
								width : 1,
								height : 1
							};
							this._position = {
								x : 0,
								y : 0
							};
							this._anchorPoint = {
								x : 0.5,
								y : 0.5
							};
							this._init_(options);
						},

						_init_ : function(options) {
							this._container = $(document.createElement('div')).attr('id', this._id).css('position',
									'absolute').css({
								'font-size' : '10px',
								'box-sizing' : 'border-box',
								'-moz-box-sizing' : 'border-box',
								'-ms-box-sizing' : 'border-box',
								'-webkit-box-sizing' : 'border-box'
							}).data('selfComp', this);
							if (options.clipToBound === false) {
								this._container.css('overflow', 'visible');
								this._clipToBound = false;
							} else {
								this._container.css('overflow', 'hidden');
							}
							if (options.hidden === true) {
								this._container.css('display', 'none');
								this._hidden = true;
							}
							if (options.autoSizingMask != undefined) {
								this._autoresizingMask = options.autoSizingMask;
							}
							if (options.anchor) {
								this._anchorPoint.x = options.anchor.x;
								this._anchorPoint.y = options.anchor.y;
								delete options.anchor;
							}
							if (options.position) {
								this._position.x = options.position.x;
								this._position.y = options.position.y;

								this._container
										.css('left', this._position.x - this._anchorPoint.x * this._bounds.width);
								this._container
										.css('top', this._position.y - this._anchorPoint.y * this._bounds.height);
								delete options.position;
							}

							if (options.size) {
								this._bounds.width = options.size.w;
								this._bounds.height = options.size.h;
								this._container.width(this._bounds.width);
								this._container.height(this._bounds.height);
								delete options.size;
							}

							this._registerMandatoryHandler();

						},

						_registerMandatoryHandler : function() {
							this.on([ {
								eventName : 'sizeChanged',
								listener : this._updateContainerSize,
								scope : this
							}, {
								eventName : 'heightChanged',
								listener : this._updateContainerHeight,
								scope : this
							}, {
								eventName : 'widthChanged',
								listener : this._updateContainerWidth,
								scope : this
							}, {
								eventName : 'positionChanged',
								listener : this._updateContainerPos,
								scope : this
							}, {
								eventName : 'anchorChanged',
								listener : this._updateContainerAnchor,
								scope : this
							} ]);
						},

						_updateContainerSize : function(os, ns) {
							this._container.width(ns.width);
							this._container.height(ns.height);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('left', this._position.x - this._anchorPoint.x * ns.width);
								this._container.css('top', this._position.y - this._anchorPoint.y * ns.height);
							}
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerWidth : function(ow, nw) {
							this._container.width(nw);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('left', this._position.x - this._anchorPoint.x * nw);
							}
							var os = {
								height : this._bounds.height,
								width : ow
							}, ns = {
								height : this._bounds.height,
								width : nw
							};
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerHeight : function(oh, nh) {
							this._container.height(nh);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('top', this._position.y - this._anchorPoint.y * nh);
							}
							var os = {
								height : oh,
								width : this._bounds.width
							}, ns = {
								height : nh,
								width : this._bounds.width
							};
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerPos : function(op, np) {
							this._container.css('left', np.x - this._anchorPoint.x * this._bounds.width);
							this._container.css('top', np.y - this._anchorPoint.y * this._bounds.height);
						},

						_updateContainerAnchor : function(oap, nap) {
							this._container.css('left', this._position.x - nap.x * this._bounds.width);
							this._container.css('top', this._position.y - nap.y * this._bounds.height);
						},

						_markAttached_ : function() {
							this._attached = true;
							var subCompItr = this._subComps.getIterator();
							while (subCompItr.hasMore()) {
								subCompItr.next().value._markAttached_();
							}
							this._handleSubCompShow(this);
						},

						_markDetached_ : function() {
							this._attached = false;
							var subCompItr = this._subComps.getIterator();
							while (subCompItr.hasMore()) {
								subCompItr.next().value._markDetached_();
							}
						},

						/**
						 * Get the id of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#id
						 * @function
						 * @returns {String} the unique id of the component
						 */
						id : function() {
							return this._id;
						},
						/**
						 * Mark the component as hidden, if the component is
						 * already marked as hidden, nothing will happen;
						 * Whether the component will be shown and whether the
						 * events <b>beforeHide</b>, <b>afterHide</b> and the
						 * call-back methods <b>doBeforeHide</b>,
						 * <b>doAfterHide</b> will get triggered depend on
						 * whether two more conditions are true: 1, all of its
						 * ancestors are marked as shown. 2, the component is
						 * currently attached to DOM.
						 * 
						 * @name sap.viz.mvc.UIComponent#markHide
						 * @function
						 * @returns {this}
						 */
						markHide : function() {
							if (this._hidden === false) {
								if (this._attached && this._parentVisible) {
									this.doBeforeHide();
									this.fireEvent('beforeHide');
								}
								this._hidden = true;
								this._container.css('display', 'none');
								if (this._attached && this._parentVisible) {
									this.doAfterHide();
									this.fireEvent('afterHide');
									var subCompItr = this._subComps.getIterator();
									while (subCompItr.hasMore()) {
										this._handleSubCompHide(subCompItr.next().value);
									}
								}
							}
							return this;
						},

						_handleSubCompHide : function(comp) {
							if (comp._parentVisible && !comp._hidden) {
								comp.doBeforeHide();
								comp.fireEvent('beforeHide');
								comp.doAfterHide();
								comp.fireEvent('afterHide');
							}
							// mark all the descendant components's
							// parentVisible as false.
							comp._parentVisible = false;
							var subCompItr = comp._subComps.getIterator();
							while (subCompItr.hasMore()) {
								comp._handleSubCompHide(subCompItr.next().value);
							}
						},

						/**
						 * Mark the component as shown, if the component is
						 * already marked as shown, nothing will happen; Whether
						 * the component will be shown and whether the events
						 * <b>beforeShow</b>, <b>afterShow</b> and the
						 * call-back methods <b>doBeforeShow</b>,
						 * <b>doAfterShow</b> will get triggered depend on
						 * whether two more conditions are true: 1, all of its
						 * ancestors are marked as shown. 2, the component is
						 * currently attached to DOM.
						 * 
						 * @name sap.viz.mvc.UIComponent#markShow
						 * @function
						 * @returns {this}
						 */
						markShow : function() {
							if (this._hidden === true) {
								if (this._attached && this._parentVisible) {
									this.doBeforeShow();
									this.fireEvent('beforeShow');
								}
								this._hidden = false;
								this._container.css('display', 'block');
								if (this._attached && this._parentVisible) {
									this.doAfterShow();
									this.fireEvent('afterShow');
									var subCompItr = this._subComps.getIterator();
									while (subCompItr.hasMore()) {
										this._handleSubCompShow(subCompItr.next().value);
									}
								}
							}
							return this;
						},

						_handleSubCompShow : function(comp) {
							// whether parent is visible
							var superComp = comp.superComponent();
							comp._parentVisible = !superComp._hidden && superComp._parentVisible;
							if (comp._parentVisible && !comp._hidden) {
								// whether needs to show
								comp.doBeforeShow();
								comp.fireEvent('beforeShow');
								comp.doAfterShow();
								comp.fireEvent('afterShow');
							}
							var subCompItr = comp._subComps.getIterator();
							while (subCompItr.hasMore()) {
								comp._handleSubCompShow(subCompItr.next().value);
							}
						},

						clipToBound : function(clipToBound) {
							if (clipToBound !== undefined) {
								if (this._clipToBound !== clipToBound) {
									this._clipToBound = clipToBound;
									if (this._clipToBound) {
										this._container.css('overflow', 'hidden');
									} else {
										this._container.css('overflow', 'visible');
									}
								}
								return this;
							} else {
								return this._clipToBound;
							}
						},

						/**
						 * Get the current visibility of the component, the
						 * visibility is affected by the component's
						 * hidden/shown status, whether it's attached to DOM,
						 * whether it's ancestor components are shown.
						 * 
						 * 
						 * @name sap.viz.mvc.UIComponent#visibility
						 * @function
						 * @returns {Boolean}
						 */
						visibility : function() {
							return !this._hidden && this._attached && this._parentVisible;
						},

						/**
						 * Get and set the printable property of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#printable
						 * @function
						 * @param {undefined|Boolean}
						 *            printable
						 * @returns {this|Boolean}
						 */
						printable : function(printable) {
							if (printable !== undefined) {
								if (this._printable !== printable) {
									this._printable = printable;
								}
								return this;
							} else {
								return this._printable;
							}
						},

						/**
						 * Get and set whether the component should resize
						 * automatically when its parent's size changed
						 * 
						 * @name sap.viz.mvc.UIComponent#printable
						 * @function
						 * @param {undefined|Boolean}
						 *            autoresize
						 * @returns {this|Boolean}
						 */
						autoresizeSubComponents : function(autoresize) {
							if (autoresize !== undefined) {
								if (this._autoresizeSubComponents !== autoresize) {
									this._autoresizeSubComponents = autoresize;
								}
								return this;
							} else {
								return this._autoresizeSubComponents;
							}
						},

						/**
						 * Get and set the autoresizing mask of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#autoresizingMask
						 * @function
						 * @param {undefined|Integer}
						 *            mask
						 * @returns {this|Integer}
						 */
						autoresizingMask : function(mask) {
							if (mask !== undefined) {
								if (this._autoresizingMask !== mask) {
									this._autoresizingMask = mask;
								}
								return this;
							} else {
								return this._autoresizingMask;
							}
						},
						/**
						 * Get and set the bounds of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#bounds
						 * @function
						 * @param {undefined|Object}
						 *            bounds the new bounds of the component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 *      width : ##,
						 *      height : ##
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						bounds : function(bounds) {
							if (bounds) {
								var ob = this._bounds, nb = bounds;
								this._bounds.x = nb.x;
								this._bounds.y = nb.y;
								if (ob.width !== nb.width || ob.height !== nb.height) {
									var os = {
										width : ob.width,
										height : ob.height
									};
									var ns = {
										width : nb.width,
										height : nb.height
									};
									this._bounds.width = nb.width;
									this._bounds.height = nb.height;
									this.fireEvent('sizeChanged', os, ns);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._bounds);
							}
						},
						/**
						 * Get the position of the component, the position is in
						 * Page coordinate system
						 * 
						 * @name sap.viz.mvc.UIComponent#pagePosition
						 * @function
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {Object}
						 */
						pagePosition : function() {
							var offset = this._container.offset();
							return {
								x : offset.left,
								y : offset.top
							};
						},
						/**
						 * Get and set the position of the component, the
						 * position is in it's direct super component's
						 * coordinate system
						 * 
						 * @name sap.viz.mvc.UIComponent#position
						 * @function
						 * @param {undefined|Object}
						 *            position the new position of the
						 *            component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						position : function(position) {
							if (position) {
								var op = this._position, np = position;
								if (op.x !== np.x || op.y !== np.y) {
									var o = {
										x : op.x,
										y : op.y
									};
									var n = {
										x : np.x,
										y : np.y
									};
									op.x = np.x;
									op.y = np.y;
									this.fireEvent('positionChanged', o, n);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._position);
							}
						},
						/**
						 * Get and set the size of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#size
						 * @function
						 * @param {undefined|Object}
						 *            size the new size of the component:
						 * 
						 * <pre>
						 * {
						 *      width : ##,
						 *      height : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object}
						 */
						size : function(size) {
							if (size) {
								var os = {
									width : this._bounds.width,
									height : this._bounds.height
								};
								if (os.width !== size.width || os.height !== size.height) {
									this._bounds.width = size.width;
									this._bounds.height = size.height;
									this.fireEvent('sizeChanged', os, size);
								}
								return this;
							} else {
								return {
									width : this._bounds.width,
									height : this._bounds.height
								};
							}
						},
						/**
						 * Get and set the width of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#width
						 * @function
						 * @param {undefined|Number}
						 *            width the new width of the component:
						 * 
						 * 
						 * @returns {this|Number}
						 */
						width : function(width) {
							if (width) {
								var ow = this._bounds.width;
								if (ow !== width) {
									this._bounds.width = width;
									this.fireEvent('widthChanged', ow, width);
								}
								return this;
							} else {
								return this._bounds.width;
							}
						},
						/**
						 * Get and set the height of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#height
						 * @function
						 * @param {undefined|Number}
						 *            height the new height of the component:
						 * 
						 * 
						 * @returns {this|Number}
						 */
						height : function(height) {
							if (height) {
								var oh = this._bounds.height;
								if (oh !== height) {
									this._bounds.height = height;
									this.fireEvent('heightChanged', oh, height);
								}
								return this;
							} else {
								return this._bounds.height;
							}
						},
						/**
						 * Get and set the anchor of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#anchorPoint
						 * @function
						 * @param {undefined|Object}
						 *            anchorPoint the new anchor of the
						 *            component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						anchorPoint : function(anchorPoint) {
							if (anchorPoint) {
								var oap = this._anchorPoint, nap = anchorPoint;
								if (oap.x !== nap.x || oap.y !== nap.y) {
									var o = {
										x : oap.x,
										y : oap.y
									};
									var n = {
										x : nap.x,
										y : nap.y
									};
									oap.x = nap.x;
									oap.y = nap.y;
									this.fireEvent('anchorChanged', o, n);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._anchorPoint);

							}
						},
						/**
						 * Get and set the frame of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#frame
						 * @function
						 * @param {undefined|Object}
						 *            rect the new frame of the component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 *      width : ##,
						 *      height : ##
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						frame : function(rect) {
							if (rect) {
								var ob = this._bounds, op = this._position;
								var npx = rect.x + rect.width * this._anchorPoint.x;
								var npy = rect.y + rect.height * this._anchorPoint.y;
								var posChanged = false, o = undefined, n = undefined, sizeChanged = false,os = {
										width : ob.width,
										height : ob.height
									};
									ns = {
										width : rect.width,
										height : rect.height
									};
								if (ob.width !== rect.width || ob.height !== rect.height) {
									ob.width = rect.width;
									ob.height = rect.height;
									sizeChanged = true;
								}
								if (op.x !== npx || op.y !== npy) {
									o = {
										x : op.x,
										y : op.y
									};
									n = {
										x : npx,
										y : npy
									};
									op.x = npx;
									op.y = npy;
									posChanged = true;
								}
								if (posChanged) {
									this.fireEvent('positionChanged', o, n);
								}
								if (sizeChanged || (os.width===5 && os.height===5)) {
									this.fireEvent('sizeChanged', os, ns);
								}
								return this;
							} else {
								return {
									x : this._position.x - this._anchorPoint.x * this._bounds.width,
									y : this._position.y - this._anchorPoint.y * this._bounds.height,
									width : this._bounds.width,
									height : this._bounds.height
								};
							}
						},
						/**
						 * Get the parent component
						 * 
						 * @name sap.viz.mvc.UIComponent#superComponent
						 * @function
						 * @param {sap.viz.mvc.UIComponent}
						 * 
						 */
						superComponent : function() {
							return this._superComp;
						},
						/**
						 * Get the parent component
						 * 
						 * @name sap.viz.mvc.UIComponent#subComponents
						 * @function
						 * @param {sap.viz.base.utils.LinkedHashMap}
						 * 
						 */
						subComponents : function() {
							return this._subComps;
						},
						/**
						 * Add a component as a child component, the visibility
						 * related events and call-back methods will get
						 * triggered on the component tree rooted at the
						 * detached component, if the component in the tree is
						 * visible.
						 * 
						 * @name sap.viz.mvc.UIComponent#addSubComponent
						 * @function
						 * @param {this}
						 *            return this component
						 * @throws {ExistedParent}
						 */
						addSubComponent : function(subComp) {
							if (subComp) {
								if (subComp._superComp === undefined) {
									subComp._superComp = this;
									this._subComps.add(subComp.id(), subComp);
									this._container.append(subComp._container);
									if (this._attached) {
										subComp._markAttached_();
									}
									return this;
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Detach this component from its parent, the detached
						 * component is not destroyed and could be reattached
						 * later. the visibility related events and call-back
						 * methods will get triggered on the component tree
						 * rooted at the detached component, if the component in
						 * the tree is visible.
						 * 
						 * @name sap.viz.mvc.UIComponent#detachFromSuperComponent
						 * @function
						 */
						detachFromSuperComponent : function() {
							if (this._superComp) {
								if (this._superComp._attached) {
									this._superComp._handleSubCompHide(this);
									this._markDetached_();
								}
								this._superComp._subComps.remove(this.id());
								this._container.detach();
								this._superComp = undefined;
							}
						},
						/**
						 * Remove this component from its parent, the remove
						 * component is destroyed including its subcomponent,
						 * and should not intend for reuse.
						 * 
						 * @name sap.viz.mvc.UIComponent#detachFromSuperComponent
						 * @function
						 */
						removeFromSuperComponent : function() {
							if (this._superComp) {
								this._superComp._subComps.remove(this.id());
								this._container.remove();
								if (this._superComp._attached)
									this._markDetached_();
								this._superComp = undefined;

							}
						},
						/**
						 * Insert a component as a child component before other
						 * component, the visibility related events and
						 * call-back methods will get triggered on the component
						 * tree rooted at the detached component, if the
						 * component in the tree is visible.
						 * 
						 * @name sap.viz.mvc.UIComponent#insertBeforeSubComponent
						 * @function
						 * @param {sap.viz.mvc.UIComponent}
						 *            subComp the component to insert
						 * @param {sap.viz.mvc.UIComponent}
						 *            beforeComp the component to be inserted
						 *            before
						 */
						insertBeforeSubComponent : function(subComp, beforeComp) {
							if (subComp && beforeComp) {
								if (subComp._superComp === undefined) {
									var newKey = subComp.id();
									var beforeKey = beforeComp.id();
									if (this._subComps.has(beforeKey) && newKey !== beforeKey) {
										subComp._superComp = this;
										this._subComps.insertBefore(newKey, subComp, beforeKey);
										subComp._container.before(beforeComp._container);
										if (this._attached) {
											subComp._markAttached_();
										}
									}
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Insert a component as a child component after other
						 * component, the visibility related events and
						 * call-back methods will get triggered on the component
						 * tree rooted at the detached component, if the
						 * component in the tree is visible.
						 * 
						 * @name sap.viz.mvc.UIComponent#insertAfterSubComponent
						 * @function
						 * @param {sap.viz.mvc.UIComponent}
						 *            subComp the component to insert
						 * @param {sap.viz.mvc.UIComponent}
						 *            afterComp the component to be inserted
						 *            before
						 */
						insertAfterSubComponent : function(subComp, afterComp) {
							if (subComp && afterComp) {
								if (subComp._superComp === undefined) {
									var newKey = subComp.id();
									var afterKey = afterComp.id();
									if (this._subComps.has(afterKey) && newKey !== afterKey) {
										subComp._superComp = this;
										this._subComps.insertAfter(newKey, subComp, afterKey);
										subComp._container.after(afterComp._container);
										if (this._attached) {
											subComp._markAttached_();
										}
									}
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Bring the sub component to the front of other sub
						 * components
						 * 
						 * @name sap.viz.mvc.UIComponent#bringToFront
						 * @function
						 * @param {sap.viz.mvc.UIComponent}
						 *            subComp the sub component to move
						 */
						bringToFront : function(subComp) {
							if (subComp && this._subComps.has(subComp.id())
									&& this._subComps.getLastInsert().id() !== subComp.id()) {
								this._subComps.moveToLast(subComp.id());
								subComp._container.detach();
								this._container.append(subComp._container);
							}
						},
						/**
						 * Send the sub component to the back of other sub
						 * component
						 * 
						 * @name sap.viz.mvc.UIComponent#sendToBack
						 * @function
						 * @param {sap.viz.mvc.UIComponent}
						 *            subComp the sub component to move
						 */
						sendToBack : function(subComp) {
							if (subComp && this._subComps.has(subComp.id())
									&& this._subComps.getFirstInsert().id() !== subComp.id()) {
								this._subComps.moveToFirst(subComp.id());
								subComp._container.detach();
								this._container.prepend(subComp._container);
							}
						},

						/**
						 * Convert the point in parent's coordinate system to
						 * local point
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointFromSuper
						 * @function
						 * @param {Object}
						 *            pointInSuper
						 * @returns {Object}
						 */
						convertPointFromSuper : function(pointInSuper) {
							var frame = this.frame();
							return {
								x : pointInSuper.x - frame.x,
								y : pointInSuper.y - frame.y
							};
						},
						/**
						 * Convert the point to point in parent's coordinate
						 * system
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointToSuper
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @returns {Object}
						 */
						convertPointToSuper : function(pointInLocal) {
							var frame = this.frame();
							return {
								x : pointInLocal.x + frame.x,
								y : pointInLocal.y + frame.y
							};
						},
						/**
						 * Convert the point in global coordinate system to
						 * local point
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointFromGlobal
						 * @function
						 * @param {Object}
						 *            globalPoint
						 * @returns {Object}
						 */
						convertPointFromGlobal : function(globalPoint) {
							var path = [ this ];
							var currentLevel = this;
							var pointInProgress = globalPoint;
							while (currentLevel._superComp) {
								path.push(currentLevel._superComp);
								currentLevel = currentLevel._superComp;
							}
							while (path.length) {
								currentLevel = path.pop();
								pointInProgress = currentLevel.convertPointFromSuper(pointInProgress);
							}
							return pointInProgress;
						},

						/**
						 * Convert the point to point in global coordinate
						 * system
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointToGlobal
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @returns {Object}
						 */
						convertPointToGlobal : function(pointInLocal) {
							var currentLevel = this;
							var pointInProgress = pointInLocal;
							while (currentLevel) {
								pointInProgress = currentLevel.convertPointToSuper(pointInProgress);
								currentLevel = currentLevel._superComp;
							}
							return pointInProgress;
						},

						/**
						 * Convert the point in source component's coordinate
						 * system to local coordinate system. Two components
						 * should rooted at same component.
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointFromComp
						 * @function
						 * @param {Object}
						 *            pointInSourceComp
						 * @param {sap.viz.mvc.UIComponent}
						 *            sourceComp
						 * @returns {Object}
						 */
						convertPointFromComp : function(pointInSourceComp, sourceComp) {
							return this.convertPointFromGlobal(sourceComp.convertPointToGlobal(pointInSourceComp));
						},

						/**
						 * Convert the point in local coordinate system to
						 * target Component's coordinate system. Two components
						 * should rooted at same component.
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointToComp
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @param {sap.viz.mvc.UIComponent}
						 *            targetComp
						 * @returns {Object}
						 */
						convertPointToComp : function(pointInLocal, targetComp) {
							return targetComp.convertPointFromGlobal(this.convertPointToGlobal(pointInLocal));
						},

						_resizeSubComp : function(subComp, oldsize, newsize) {
							var origFrame = subComp.frame();
							var x = origFrame.x, y = origFrame.y, width = origFrame.width, height = origFrame.height;
							var ml = x, mr = oldsize.width - x - width, mt = y, mb = oldsize.height - y - height;
							var wdiff = newsize.width - oldsize.width, hdiff = newsize.height - oldsize.height;
							var arMask = subComp._autoresizingMask;
							var horizontalMask = ar.FlexibleLeftMargin | ar.FlexibleWidth | ar.FlexibleRightMargin;
							var verticalMask = ar.FlexibleTopMargin | ar.FlexibleHeight | ar.FlexibleBottomMargin;
							switch (arMask & horizontalMask) {
							case ar.None:
								if (ml !== 0) {
									x += wdiff * ml / (ml + mr);
								}
								break;
							case ar.FlexibleLeftMargin:
								x += wdiff;
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleRightMargin:
							case ar.FlexibleRightMargin:
								break;
							case ar.FlexibleWidth:
								width += wdiff;
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleWidth:
								if (width !== 0) {
									x += wdiff * ml / (ml + width);
									width += wdiff * width / (ml + width);
								}
								break;
							case ar.FlexibleRightMargin | ar.FlexibleWidth:
								if (width !== 0) {
									width += wdiff * width / (mr + width);
								}
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleWidth | ar.FlexibleRightMargin:
								if (oldsize.width !== 0) {
									var r = wdiff / oldsize.width;
									x += x * r;
									width += width * r;
								}
								break;
							}
							switch (arMask & verticalMask) {
							case ar.None:
								if (mt !== 0) {
									y += hdiff * mt / (mt + mb);
								}
								break;
							case ar.FlexibleTopMargin:
								y += hdiff;
								break;
							case ar.FlexibleTopMargin | ar.FlexibleBottomMargin:
							case ar.FlexibleBottomMargin:
								break;
							case ar.FlexibleHeight:
								height += hdiff;
								break;
							case ar.FlexibleTopMargin | ar.FlexibleHeight:
								if (height !== 0) {
									y += hdiff * mt / (mt + height);
									height += hdiff * height / (mt + height);
								}
								break;
							case ar.FlexibleBottomMargin | ar.FlexibleHeight:
								if (height != 0) {
									height += hdiff * height / (mb + height);
								}
								break;
							case ar.FlexibleTopMargin | ar.FlexibleHeight | ar.FlexibleBottomMargin:
								if (oldsize.height) {
									var r = hdiff / oldsize.height;
									y += y * r;
									height += height * r;
								}
								break;
							}
							return {
								x : x,
								y : y,
								height : height,
								width : width
							};
						},

						_layout : function(oldsize, newsize) {
							if (this._autoresizeSubComponents) {
								var subCompItr = this._subComps.getIterator();
								var subComp, newFrame;
								while (subCompItr.hasMore()) {
									subComp = subCompItr.next().value;
									newFrame = this._resizeSubComp(subComp, oldsize, newsize);
									subComp.frame(newFrame);
								}
							} else if (this.doLayout != FuncUtils.noop && this.doLayout !== undefined) {
								this.doLayout();
							}
						},

						_fireEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								this._superComp._fireEvent_(event);
							}
						},

						_fireMouseEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								event._setCurrentLocalXY_({
									x : event.currentLocalXY().x + this._position.x - this._anchorPoint.x
											* this._bounds.width,
									y : event.currentLocalXY().y + this._position.y - this._anchorPoint.y
											* this._bounds.height
								});
								this._superComp._fireMouseEvent_(event);
							}
						},

						_fireTouchEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								this._superComp._fireTouchEvent_(event);
							}
						},

						/**
						 * Remove all listeners currently attached to the
						 * component
						 * 
						 * @name sap.viz.mvc.UIComponent#purgeListeners
						 * @function
						 */
						purgeListeners : function() {
							this.callParent('purgeListeners');
							this._registerMandatoryHandler();
						},
						/**
						 * Remove all listeners currently listening on the given
						 * event
						 * 
						 * @name sap.viz.mvc.UIComponent#removeAllListeners
						 * @function
						 * @param {String}
						 *            eventName
						 */
						removeAllListeners : function(eventName) {
							this.callParent('removeAllListeners', eventName);
							switch (eventName) {
							case 'sizeChanged':
								this.on({
									eventName : 'sizeChanged',
									listener : this._updateContainerSize,
									scope : this
								});
								break;
							case 'heightChanged':
								this.on({
									eventName : 'heightChanged',
									listener : this._updateContainerHeight,
									scope : this
								});
								break;
							case 'widthChanged':
								this.on({
									eventName : 'widthChanged',
									listener : this._updateContainerWidth,
									scope : this
								});
								break;
							case 'positionChanged':
								this.on({
									eventName : 'positionChanged',
									listener : this._updateContainerPos,
									scope : this
								});
								break;
							case 'anchorChanged':
								this.on({
									eventName : 'anchorChanged',
									listener : this._updateContainerAnchor,
									scope : this
								});
								break;
							}
						},
						/**
						 * Add a gesture detector to this component
						 * 
						 * @name sap.viz.mvc.UIComponent#addGestureDetector
						 * @function
						 * @param {sap.viz.mvc.GestureDetector}
						 *            detector
						 */
						addGestureDetector : function(detector) {
							if (detector !== undefined) {
								detector._setOwnerComp_(this);
								this._gestureDetectors.push(detector);
							}
						},
						/**
						 * remove a previously added gesture detector to this
						 * component
						 * 
						 * @name sap.viz.mvc.UIComponent#addGestureDetector
						 * @function
						 * @param {sap.viz.mvc.GestureDetector}
						 *            detector
						 */
						removeGestureDetector : function(detector) {
							for ( var i = 0, len = this._gestureDetectors.length; i < len; i++) {
								if (this._gestureDetectors[i] === detector) {
									this._gestureDetectors.splice(i, 1);
									detector._setOwnerComp_(undefined);
									len--;
								}
							}
						},

						/**
						 * Returns the farthest descendant uicomponent in the
						 * hierarchy rooted at this component, that contains the
						 * specified point.
						 * 
						 * @name sap.viz.mvc.UIComponent#hitTest
						 * @param {POINT}
						 *            localXY
						 * @returns {sap.viz.mvc.UIComponent#}
						 */
						hitTest : function(localXY) {
							var pStack = [ {
								comp : this,
								pointInLocal : localXY,
								subCompsItr : this._subComps.getIterator(true)
							} ];
							var levelInTest, localPoint, comp, subCompsItr;
							while (pStack.length) {
								levelInTest = pStack[pStack.length - 1];
								comp = levelInTest.comp;
								localPoint = levelInTest.pointInLocal;
								subCompsItr = levelInTest.subCompsItr;
								if (comp.visibility()) {
									if (subCompsItr.hasMore()) {
										var subComp = subCompsItr.next().value;
										pStack.push({
											comp : subComp,
											pointInLocal : subComp.convertPointFromSuper(localPoint),
											subCompsItr : subComp._subComps.getIterator(true)
										});
										continue;
									} else if (comp.containsPoint(localPoint)) {
										// find the top layer which contains the
										// point and can
										// respond to event
										return comp;
									}
									pStack.pop();
								} else {
									pStack.pop();
								}
							}
						},

						/**
						 * Test whether the given local point(point in local
						 * coordinate system) is contained in the component's
						 * boundary
						 * 
						 * @name sap.viz.mvc.UIComponent#containsPoint
						 * @function
						 * @param {Object}
						 *            localPoint the point to test
						 * @returns {Boolean}
						 */
						containsPoint : function(localPoint) {
							var bounds = this.bounds();
							return localPoint.x >= bounds.x && localPoint.x <= (bounds.x + bounds.width)
									&& localPoint.y >= bounds.y && localPoint.y <= (bounds.y + bounds.height);
						},

						printTo : function(drawingCtx) {
							drawingCtx.clearRect(0, 0, this._bounds.width, this._bounds.height);
							this.doPrint(drawingCtx);
						},

						/**
						 * Implement this method to do adhoc sub-components
						 * layout, this method will be called on super component
						 * when its size changed.
						 * 
						 * @name sap.viz.mvc.UIComponent#doLayout
						 * @function
						 */
						doLayout : FuncUtils.noop,

						/**
						 * Resize component's visual content, when the
						 * component's size changed, this method will be invoked
						 * before layout sub components
						 * 
						 * @name sap.viz.mvc.UIComponent#doContentResize
						 * @function
						 * @param {Object}
						 *            os the old size of the component
						 * @param {Object}
						 *            ns the new size of the component
						 */
						doContentResize : FuncUtils.noop,

						/**
						 * Print the component visual content into the passed-in
						 * drawing context
						 * 
						 * @name sap.viz.mvc.UIComponent#doPrint
						 * @function
						 * @param {sap.viz.graphic.DrawingContext}
						 */
						doPrint : FuncUtils.noop,

						/**
						 * This method will get called before the component
						 * becoming hidden
						 * 
						 * @name sap.viz.mvc.UIComponent#doBeforeHide
						 * @function
						 */
						doBeforeHide : FuncUtils.noop,
						/**
						 * This method will get called after the component is
						 * hided
						 * 
						 * @name sap.viz.mvc.UIComponent#doAfterHide
						 * @function
						 */
						doAfterHide : FuncUtils.noop,
						/**
						 * This method will get called before the component
						 * becoming visible
						 * 
						 * @name sap.viz.mvc.UIComponent#doBeforeShow
						 * @function
						 */
						doBeforeShow : FuncUtils.noop,
						/**
						 * This method will get called after the component is
						 * visible
						 * 
						 * @name sap.viz.mvc.UIComponent#doAfterShow
						 * @function
						 */
						doAfterShow : FuncUtils.noop
					});
	UIComponent.Autosizing = ar;
	return UIComponent;
});sap.riv.module(
{
  qname : 'sap.viz.base.Math',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
}
],
function Setup(UADetector) {
    var OptMath = {
        PI : Math.PI,
        E : Math.E,
        LN10 : Math.LN10,
        LN2 : Math.LN2,
        LOG2E : Math.LOG2E,
        LOG10E : Math.LOG10E,
        SQRT1_2 : Math.SQRT1_2,
        SQRT2 : Math.SQRT2,

        abs : (function() {
            if(UADetector.isSafari() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)) {
                return function(n) {
                    return n < 0 ? -n : n;
                };
            } else {
                return Math.abs;
            }
        })(),

        acos : (function() {
            return Math.acos;
        })(),

        asin : (function() {
            return Math.asin;
        })(),

        atan : (function() {
            return Math.atan;
        })(),

        atan2 : (function() {
            return Math.atan2;
        })(),

        /**
         * Get the ceil of a number.
         *
         * @name sap.viz.base.Math#ceil
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the ceil of number
         */
        ceil : (function() {
            // if (UADetector.isFirefox()) {
            // return function(n) {
            // var i = n | 0;
            // return n <= 0 ? i : (i == n ? i : i + 1);
            // };
            // }
            // else if (UADetector.isChrome()) {
            // return function(n) {
            // return n <= 0 ? n | 0 : Math.ceil(n);
            // };
            // }
            // else {
            return Math.ceil;
            // }
        })(),

        cos : (function() {
            return Math.cos;
        })(),

        exp : (function() {
            return Math.exp;
        })(),

        /**
         * Get the floor of a number.
         *
         * @name sap.viz.base.Math#floor
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the floor of number
         */
        floor : (function() {
            // if(UADetector.isFirefox()) {
            // return function(n) {
            // var a = n | 0;
            // return n < 0 ? (a == n ? a : a - 1) : a;
            // };
            // } else
            return Math.floor;
        })(),

        log : (function() {
            return Math.log;
        })(),

        /**
         * Get the maximum number in an array.
         *
         * @name sap.viz.base.Math#max
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the maximum number in array
         */
        max : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.max;
            // } else
                // return function() {
                    // var max = arguments[0];
                    // var length = arguments.length;
                    // for(var i = 1; i < length; i++) {
                        // max = arguments[i] > max ? arguments[i] : max;
                    // }
                    // return max;
                // };
        })(),

        /**
         * Get the minimum number in an array.
         *
         * @name sap.viz.base.Math#min
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the minimum number in array
         */
        min : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.min;
			// }
			// else return function(){
		        // var min = arguments[0];
		        // var length = arguments.length;
				// for (var i=1; i<length; i++){
					// min = arguments[i] > min ? min : arguments[i];
				// }
				// return min;
            // };
        })(),

        pow : (function() {
            return Math.pow;
        })(),

        random : (function() {
            return Math.random;
        })(),

        /**
         * Get the round of a number.
         *
         * @name sap.viz.base.Math#round
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the round of number
         */
        round : (function() {
            return Math.round;
            //			if(UADetector.isFirefox() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)){
            //				return function(n) {
            //					return (n >= 0) ? (n + 0.5) | 0 : (n - 0.4999999999999999) | 0;
            //				};
            //			}
            //			else if(UADetector.isChrome()){
            //				return function(n) {
            //					return Math.floor(n + 0.5);
            //				};
            //			}
            //			else return Math.round;
        })(),

        sin : (function() {
            return Math.sin;
        })(),

        sqrt : (function() {
            return Math.sqrt;
        })(),

        tan : (function() {
            return Math.tan;
        })()
    };
    return OptMath;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.Event',
  version : '4.0.0'},
[

],
function Setup() {
	/**
	 * Event class
	 * 
	 * @name sap.viz.mvc.Event
	 * @constructor
	 */
	var Event = function(type, target, canBubbling) {
		this._type = type;
		this._target = this._currentTarget = target;
		this._canBubbling = canBubbling !== undefined ? canBubbling : true;
		this._timestamp = +new Date;
	};

	var Ep = Event.prototype;

	Ep._setCurrentTarget_ = function(currentTarget) {
		this._currentTarget = currentTarget;
	};

	/**
	 * Get the type of the event
	 * 
	 * @name sap.viz.mvc.Event#type
	 * @function
	 * @returns {String}
	 */
	Ep.type = function() {
		return this._type;
	};

	/**
	 * Get the timestamp of the event
	 * 
	 * @name sap.viz.mvc.Event#timestamp
	 * @function
	 * @returns {Integer}
	 */
	Ep.timestamp = function() {
		return this._timestamp;
	};

	/**
	 * Get the target component the event is originated from
	 * 
	 * @name sap.viz.mvc.Event#target
	 * @function
	 * @returns {sap.viz.mvc.UIComponent}
	 */
	Ep.target = function() {
		return this._target;
	};

	/**
	 * Get the current target component the event is currently going through it
	 * can be different with the target component
	 * 
	 * @name sap.viz.mvc.Event#currentTarget
	 * @function
	 * @returns {sap.viz.mvc.UIComponent}
	 */
	Ep.currentTarget = function() {
		return this._currentTarget;
	};

	/**
	 * Whether the event is in the bubbling phase
	 * 
	 * @name sap.viz.mvc.Event#isInBubbling
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.isInBubbling = function() {
		return this._target.id() != this._currentTarget.id();
	};
	/**
	 * Whether the event should be bubbled
	 * 
	 * @name sap.viz.mvc.Event#shouldBubble
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.shouldBubble = function() {
		return this._canBubbling;
	};
	/**
	 * Stop the event propagation in the bubbling phase
	 * 
	 * @name sap.viz.mvc.Event#stopPropagation
	 * @function
	 * 
	 */
	Ep.stopPropagation = function() {
		this._canBubbling = false;
	};
	return Event;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.TouchEvent',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.Event',
  version : '4.0.0'
}
],
function Setup(FuncUtils, ObjectUtils, Event) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	/**
	 * Touch class
	 * 
	 * @name sap.viz.mvc.Touch
	 * @constructor
	 */
	var Touch = function(identifier, target, localXY, pageXY) {
		this._id = identifier;
		this._target = target;
		this._localXY = localXY;
		this._pageXY = pageXY;
	};
	var tp = Touch.prototype;
	/**
	 * Get the identifier of the touch
	 * 
	 * @name sap.viz.mvc.Touch#identifier
	 * @function
	 * @returns {Number}
	 */
	tp.identifier = function() {
		return this._id;
	};

	/**
	 * Get the target component of the touch
	 * 
	 * @name sap.viz.mvc.Touch#target
	 * @function
	 * @returns {sap.viz.mvc.UIComponent}
	 */
	tp.target = function() {
		return this._target;
	};

	/**
	 * Get the local XY of the touch in touch's target component's coordinate
	 * system
	 * 
	 * @name sap.viz.mvc.Touch#localXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	tp.localXY = function() {
		return {
			x : this._localXY.x,
			y : this._localXY.y
		};
	};

	/**
	 * Get the page XY of the touch in document's coordinate system
	 * 
	 * @name sap.viz.mvc.Touch#pageXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	tp.pageXY = function() {
		return {
			x : this._pageXY.x,
			y : this._pageXY.y
		};
	};
	/**
	 * Touch List class
	 * 
	 * @name sap.viz.mvc.TouchList
	 * @constructor
	 */
	var TouchList = function(tArray, tMap) {
		this.tA = tArray, this.tM = tMap;
	};

	var tlp = TouchList.prototype;
	/**
	 * Return the length of the list
	 * 
	 * @name sap.viz.mvc.TouchList#length
	 * @function
	 * @returns {Number}
	 * 
	 */
	tlp.length = function() {
		return this.tA.length;
	};
	/**
	 * Get the touch at specified index
	 * 
	 * @name sap.viz.mvc.TouchList#item
	 * @function
	 * @param {Number}
	 *            index
	 * @returns {sap.viz.mvc.Touch}
	 */
	tlp.item = function(index) {
		if (index >= 0 && (index < this.tA.length)) {
			return this.tA[index];
		}
	};
	/**
	 * Get the touch with specified identifier
	 * 
	 * @name sap.viz.mvc.TouchList#identifiedTouch
	 * @function
	 * @param {Number}
	 *            identifier
	 * @returns {sap.viz.mvc.Touch}
	 */
	tlp.identifiedTouch = function(identifier) {
		if (identifier) {
			return this.tM[identifier];
		}
	};
	/**
	 * This class defines Touch Event
	 * 
	 * @name sap.viz.mvc.TouchEvent
	 * @class
	 * @augments sap.viz.mvc.Event
	 */
	var TouchEvent = ObjectUtils.derive(Event,
	/**
	 * @lends sap.viz.mvc.TouchEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, touches, targetTouches, changedTouches) {
			this._relatedTarget = undefined;
			this._touches = touches;
			this._targetTouches = targetTouches;
			this._changedTouches = changedTouches;
		},

		/**
		 * Get the all touches on the screen.
		 * 
		 * @name sap.viz.mvc.TouchEvent#touches
		 * @function
		 * @returns {sap.viz.mvc.TouchList}
		 */
		touches : function() {
			return this._touches;
		},
		/**
		 * Get the touches initiated from the same target
		 * 
		 * @name sap.viz.mvc.TouchEvent#targetTouches
		 * @function
		 * @returns {sap.viz.mvc.TouchList}
		 */
		targetTouches : function() {
			return this._targetTouches;
		},
		/**
		 * Get the touches lead to the event
		 * 
		 * @name sap.viz.mvc.TouchEvent#changedTouches
		 * @function
		 * @returns {sap.viz.mvc.TouchList}
		 */
		changedTouches : function() {
			return this._changedTouches;
		}
	});
	var _buildTouchListFromTouchList = function(touchlist) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchlist.length; i < len; i++) {
			targetComp = _findTargetComp(touchlist.item(i));
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchlist.item(i), targetComp);
				tArray.push(touch);
				tMap[touch.identifier()] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _buildTouchListFromTouchArray = function(touchArray) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchArray.length; i < len; i++) {
			targetComp = _findTargetComp(touchArray[i]);
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchArray[i], targetComp);
				tArray.push(touch);
				tMap[touch.identifier()] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _findTargetComp = function(touch) {
		var cnode = $(touch.target);
		while (cnode.length && !cnode.data('selfComp')) {
			cnode = cnode.parent();
		}
		return cnode.data('selfComp');
	};

	var _buildTouch = function(touch, targetComp) {
		var targetCompPagePosition = targetComp.pagePosition();
		var localXY = {
			x : touch.pageX - targetCompPagePosition.x,
			y : touch.pageY - targetCompPagePosition.y
		};
		// binding to UIComponent instead of Element
		return new Touch(touch.identifier, targetComp, localXY, {
			x : touch.pageX,
			y : touch.pageY
		});
	};
	TouchEvent.buildFrom3TouchArray = function(type, target, touches, changedTouches, targetTouches, canBubbling) {
		var _touches = _buildTouchListFromTouchArray(touches);
		var _targetTouches = _buildTouchListFromTouchArray(targetTouches);
		var _changedTouches = _buildTouchListFromTouchArray(changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	TouchEvent.buildFromDomTouchEvent = function(type, target, domTouchEvent, canBubbling) {
		var _touches = _buildTouchListFromTouchList(domTouchEvent.touches);
		var _targetTouches = _buildTouchListFromTouchList(domTouchEvent.targetTouches);
		var _changedTouches = _buildTouchListFromTouchList(domTouchEvent.changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	return TouchEvent;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.MouseEvent',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.Event',
  version : '4.0.0'
}
],
function Setup(ObjectUtils, Event) {
	/**
	 * This class defines Mouse Event
	 * 
	 * @name sap.viz.mvc.MouseEvent
	 * @class
	 * @augments sap.viz.mvc.Event
	 */
	var MouseEvent = ObjectUtils.derive(Event,
	/**
	 * @lends sap.viz.mvc.MouseEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, localXY, pageXY) {
			this._relatedTarget = undefined;
			this._currentLocalXY = this._targetLocalXY = localXY;
			this._pageXY = pageXY;
		},

		_setCurrentLocalXY_ : function(currentLocalXY) {
			this._currentLocalXY = currentLocalXY;
		},

		_setRelatedTarget_ : function(relatedTarget) {
			this._relatedTarget = relatedTarget;
		},

		/**
		 * Get the XY according to target component's coordinates system
		 * 
		 * @name sap.viz.mvc.MouseEvent#targetLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		targetLocalXY : function() {
			return {
				x : this._targetLocalXY.x,
				y : this._targetLocalXY.y
			};
		},

		/**
		 * Get the XY according to current component's coordinates system
		 * 
		 * @name sap.viz.mvc.MouseEvent#currentLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		currentLocalXY : function() {
			return {
				x : this._currentLocalXY.x,
				y : this._currentLocalXY.y
			};
		},
		/**
		 * Get the page XY of the event
		 * 
		 * @name sap.viz.mvc.MouseEvent#pageXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		pageXY : function() {
			return {
				x : this._pageXY.x,
				y : this._pageXY.y
			};
		}
	});
	return MouseEvent;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.DomWatcher',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.0'
}
],
function Setup(UADetector, LinkedHashMap) {
    var watcherId = 0;
    var domId = 1;
    var nextWatcherId = function() {
        return watcherId++;
    };
    var nextDomId = function() {
        return domId++;
    };
    var isEmpty = function(obj) {
        for(var prop in obj) {
            if(obj.hasOwnProperty(prop))
                return false;
        }
        return true;
    };
    var css = function(dom, prop) {
        var val = null;
        if(window.getComputedStyle) {
            val = window.getComputedStyle(dom, null)[prop];
        } else if(dom.currentStyle) {
            val = dom.currentStyle[prop];
        }
        return val;
    };
    var domDataAccessor = function(key, value) {
        if(!this._data)
            this._data = {};
        if(arguments.length === 2) {
            this._data[key] = value;
        } else
            return this._data[key];
    };
    var domTasks = new LinkedHashMap();

    var eventHandler = function(e) {
    	var task;
        var dom = e.srcElement || e.target;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId)
            return;
        var domTaskIt = domTasks.get(domId).getIterator();
        while(domTaskIt.hasMore()) {
            task = domTaskIt.nextValue();
            task.checkChange();
        }
    };
    var addEventHandler = function(id) {
        var task = taskQueue.get(id);
        var dom = task.domElem;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId) {
            domId = nextDomId();
            domDataAccessor.call(dom, 'domId', domId);
            domTasks.add(domId, new LinkedHashMap());
        }
        domTasks.get(domId).add(task.id, task);
        if(!domDataAccessor.call(dom, 'eventHandler')) {
            if( typeof (dom.onpropertychange) == "object") {
                dom.attachEvent("onpropertychange", eventHandler);
            } else if(UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6) {
                dom.addEventListener("DOMAttrModified", eventHandler);
            }
            domDataAccessor.call(dom, 'eventHandler', eventHandler);
        }
    };
    var removeFromEventHandler = function(task) {
        var dom = task.domElem;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId)
            return;

        if(domTasks.get(domId).has(task.id))
            domTasks.get(domId).remove(task.id);

        if(domTasks.get(domId).isEmpty()) {
            var eventHandler = domDataAccessor.call(dom, 'eventHandler');
            if( typeof (dom.onpropertychange) == "object") {
                dom.detachEvent("onpropertychange", eventHandler);
            } else if(UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6) {
                dom.removeEventListener("DOMAttrModified", eventHandler);
            }
            domDataAccessor.call(dom, 'eventHandler', null);
        }
    };
    var scannerInstance = undefined;
    var taskQueue = new LinkedHashMap();
    var scanner = function() {
        var taskItr = taskQueue.getIterator();
        var task;
        while(taskItr.hasMore()) {
            task = taskItr.nextValue();
            task.checkChange();
        }
    };
    var addIntervalTask = function(task) {
        if(!scannerInstance)
            scannerInstance = setInterval(scanner, 100);
        if(!taskQueue.has(task.id))
            taskQueue.add(task.id, task);
    };
    var removeIntervalTask = function(id) {
        if(taskQueue.has(id)) {
            taskQueue.remove(id);
        }
        if(taskQueue.isEmpty()) {
            clearInterval(scannerInstance);
            scannerInstance = undefined;
        }
    };
    var hookChange = function(task) {
        var dom = task.domElem;
        if( typeof (dom.onpropertychange) == "object" || (UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6)) {
            addEventHandler(task.id);
        } else {
            //for browsers not support dom attributes change event, add a iterval task to check properties changes.
            addIntervalTask(task);
        }
    };
    var __watcher = function(id) {
        var task = taskQueue.get(id);
        if(!task)
            return;
        var dom = task.domElem;
        if(!task.callback)
            return;

        var changed = false;
        var i = 0;
        var changedProps = [];
        for(var l = task.cssProps.length; i < l; i++) {
            var newVal = css(dom, task.cssProps[i]);
            if(task.lastestVals[i] != newVal) {
                task.lastestVals[i] = newVal;
                changed = true;
                changedProps.push(task.cssProps[i]);
            }
        }
        if(changed)
            //task.callback.call(caller, changedProps);
            task.callback(changedProps);
    };
    //var caller;
    var DomWatcher = {
        /**
         * watch a dom element on specific css properties, if change, excute callback func,
         * callback parameter is an array of changed properties
         *
         * @param dom element to watch
         * @param props css properties on element to watch, input as a string, properties should be seperated by comma ','
         * @param func function to execute on properties change, when calling DomWatcher.watch,
         *     ObjectUtils.proxy(func, this) is recommend for the callback function. i.e. DomWatcher.watch(dom,props, ObjectUtils.proxy(func, this));
         * @return generated watcher id
         */
        watch : function(dom, props, func) {
            //caller = this.watch.caller;
            var id = nextWatcherId();
            var checkChange = function() {
                __watcher(id);
            };
            var task = {
                id : id,
                domElem : dom,
                cssProps : props.split(","),
                lastestVals : [props.split(",").length],
                callback : func,
                checkChange : checkChange
            };

            for(var i = 0, len = task.cssProps.length; i < len; i++) {
                task.lastestVals[i] = css(dom, task.cssProps[i]);
            }
            if(!taskQueue.has(task.id))
                taskQueue.add(task.id, task);
            hookChange(task);
            return id;
        },
        unwatch : function(id) {
            var task = taskQueue.get(id);
            var dom = task.domElem;
            try {
                if( typeof (dom.onpropertychange) == "object" || (UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6)) {
                    removeFromEventHandler(task);
                } else
                    removeIntervalTask(task.id);
            }
            // ignore if element was already unbound
            catch (e) {
            }
        }
    };
    return (DomWatcher);
});sap.riv.module(
{
  qname : 'sap.viz.mvc.GestureDetector',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(FuncUtils) {
	/**
	 * The mask used to specify gesture detector's state
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState
	 * @class
	 */
	var ts = {
		/**
		 * Possible State. Gesture Detector is ready to detect gesture
		 * 
		 * @field
		 * 
		 */
		Possible : 0,
		/**
		 * Began State. Gesture Detector is ready to detect continuous gesture
		 * 
		 * @field
		 * 
		 */
		Began : 1,
		/**
		 * Began State. Gesture Detector is continuous to detect continuous
		 * gesture
		 * 
		 * @field
		 * 
		 */
		Changed : 2,
		/**
		 * Recognized State. Discrete Gesture is detected
		 * 
		 * @field
		 * 
		 */
		Recognized : 3,// Recognized == Ended
		/**
		 * Ended State. Continuous Gesture is detected
		 * 
		 * @field
		 * 
		 */
		Ended : 3,
		/**
		 * Ended State. Continuous Gesture is stop to detected
		 * 
		 * @field
		 * 
		 */
		Cancelled : 4,
		/**
		 * Ended State. Detector fails to detect in current touch sequence
		 * 
		 * @field
		 * 
		 */
		Failed : 5
	};

	/**
	 * The base abstract gesture detector class
	 * 
	 * @name sap.viz.mvc.GestureDetector
	 * @constructor
	 */
	var GestureDetector = function() {
		this._grOwnerComp;
		this._grEnabled = true;
		this._grTouchTotal = 0;
		this._grTouchTracker = {};
		this._grState = ts.Possible;
		this._grActions = [];
		this._grCancelTouches = true;
	};
	var grp = GestureDetector.prototype;

	grp._setOwnerComp_ = function(ownerComp) {
		this._grOwnerComp = ownerComp;
	};
	/**
	 * Get the attached UI component
	 * 
	 * @name sap.viz.mvc.GestureDetector#attachedComponent
	 * @function
	 * @returns {sap,riv.vizkit.UIComponent}
	 */
	grp.attachedComponent = function() {
		return this._grOwnerComp;
	};

	/**
	 * Add a gesture action function which will get triggered when gesture
	 * detected.
	 * 
	 * @name sap.viz.mvc.GestureDetector#addGestureAction
	 * @function
	 * @param {Function}
	 *            actionFn, function to be called when gesture detected.
	 * @returns {Boolean}
	 */
	grp.addGestureAction = function(actionFn) {
		var added = false;
		for ( var i = 0, len = this._grActions.length; i < len; i++) {
			if (this._grActions[i] === actionFn) {
				added = true;
				break;
			}
		}
		if (!added) {
			this._grActions.push(actionFn);
		}
		return !added;
	};

	/**
	 * Remove a previously added gesture action
	 * 
	 * @name sap.viz.mvc.GestureDetector#removeGestureAction
	 * @function
	 * @param {Function}
	 *            actionFn, the function to be removed.
	 * @returns {Boolean}
	 */
	grp.removeGestureAction = function(actionFn) {
		var found = false;
		for ( var i = 0, len = this._grActions.length; i < len; i++) {
			if (this._grActions[i] === actionFn) {
				found = true;
				this._grActions.splice(i, 1);
				break;
			}
		}
		return found;
	};

	/**
	 * Return the current global location of the gesture, the location is
	 * calculated as the center of the current touches. Caution: This function
	 * only return meaningful point value IF and ONLY IF the current state of
	 * this gesture detector is in Recognizing state, a.k.a Began, Changed,
	 * Cancelled, Ended, Recognized, otherwise undefined will return.
	 * 
	 * @function
	 * @returns {Object}
	 */
	grp.globalLocOfGesture = function() {
		var state = this.state();
		if (this._grEnabled
				&& (state === ts.Began || state === ts.Changed || state === ts.Cancelled || state === ts.Ended || state === ts.Recognized)) {
			var count = 0;
			var ttracker = this._grTouchTracker, xy;
			var x = y = 0;
			for ( var tId in ttracker) {
				xy = ttracker[tId].globalXY;
				x += xy.x;
				y += xy.y;
				count++;
			}
			if (count) {
				return {
					x : x / count,
					y : y / count
				};
			}
		} else {
			return;
		}
	};

	/**
	 * Return a list of identifier of touches currently involved in the gesture
	 * detection, Caution: This function only return meaningful array of touches
	 * IF and ONLY IF the current state of this gesture detector is in
	 * Recognizing state, a.k.a Began, Cancelled, Ended, Recognized, otherwise
	 * empty array will return.
	 * 
	 * @function
	 * @returns {Array}
	 */
	grp.involvedTouchePoints = function() {
		var ret = [];
		var state = this.state();
		if (this._grEnabled
				&& (state === ts.Began || state === ts.Cancelled || state === ts.Ended || state === ts.Recognized)) {
			var ttracker = this._grTouchTracker;
			for ( var tId in ttracker) {
				ret.push(tId);
			}
		}
		return ret;
	};

	/**
	 * Return the current global location of all the current touches, the
	 * location is calculated as the center of the touches currently contacting
	 * with the screen.
	 * 
	 * @function
	 * @returns {Object}
	 */
	grp.globalLocOfTouchPoints = function() {
		var count = 0;
		var ttracker = this._grTouchTracker, xy;
		var x = y = 0;
		for ( var tId in ttracker) {
			xy = ttracker[tId].globalXY;
			x += xy.x;
			y += xy.y;
			count++;
		}
		if (count) {
			return {
				x : x / count,
				y : y / count
			};
		}
	};

	/**
	 * Return the number of touches currently contacting with the screen
	 * 
	 * @function
	 * @returns {Number}
	 */
	grp.totalTouches = function() {
		return this._grTouchTotal;
	};

	/**
	 * Get or set whether canceling previous touches when a gesture detected.
	 * Default is yes.
	 * 
	 * @function
	 * @returns {Boolean|this}
	 */
	grp.cancelTouches = function(cancel) {
		if (cancel !== undefined) {
			this._grCancelTouches = cancel;
			return this;
		} else {
			return this._grCancelTouches;
		}
	};
	/**
	 * Get or set the enable status of the gesture detector. If the gesture
	 * detector is in detecting some continuous gesture it will immediately
	 * transit to cancelled state. Default is yes.
	 * 
	 * @function
	 * @returns {Boolean|this}
	 */
	grp.enable = function(enable) {
		if (enable !== undefined) {
			this._grEnabled = enable;
			if (!enable) {
				if (this._grState === ts.Began || this._grState === ts.Cancelled) {
					this.state(ts.Cancelled);
				} else {
					this.state(ts.Failed);
				}
			}
		} else {
			return this._grEnabled;
		}
	};

	grp.touchBegin = function(touchStartEvent) {
		var newTouches = touchStartEvent.changedTouches;
		var ttracker = this._grTouchTracker;
		var ownerComp = this._grOwnerComp;
		var pagePosition = ownerComp.pagePosition();
		for ( var i = 0, t, len = newTouches.length; i < len; i++) {
			t = newTouches.item(i);
			ttracker[t.identifier] = {
				globalXY : ownerComp.convertPointToGlobal({
					x : t.pageX - pagePosition.x,
					y : t.pageY - pagePosition.y
				})
			};
			this._grTouchTotal++;
		}
		if (this._grEnabled
				&& (this._grState === ts.Possible || this._grState === ts.Began || this._grState === ts.Changed)) {
			this.doTouchBegin(touchStartEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in moving phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#touchMove
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchMoveEvent
	 */
	grp.touchMove = function(touchMoveEvent) {
		if (this._grEnabled
				&& (this._grState === ts.Possible || this._grState === ts.Began || this._grState === ts.Changed)) {
			var movedTouches = touchMoveEvent.changedTouches;
			var ownerComp = this._grOwnerComp;
			var pagePosition = ownerComp.pagePosition();
			var ttracker = this._grTouchTracker;
			for ( var i = 0, t, len = movedTouches.length; i < len; i++) {
				t = movedTouches.item(i);
				if (ttracker[t.identifier]) {
					ttracker[t.identifier].globalXY = ownerComp.convertPointToGlobal({
						x : t.pageX - pagePosition.x,
						y : t.pageY - pagePosition.y
					});
				}
			}
			this.doTouchMove(touchMoveEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in ending phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#touchEnd
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchEndEvent
	 */
	grp.touchEnd = function(touchEndEvent) {
		var endedTouches = touchEndEvent.changedTouches;
		var ttracker = this._grTouchTracker;
		var ownerComp = this._grOwnerComp;
		var pagePosition = ownerComp.pagePosition();
		for ( var i = 0, t, tId, track, len = endedTouches.length; i < len; i++) {
			t = endedTouches.item(i);
			tId = t.identifier;
			track = ttracker[tId];
			if (track) {
				track.globalXY = ownerComp.convertPointToGlobal({
					x : t.pageX - pagePosition.x,
					y : t.pageY - pagePosition.y
				});
				this._grTouchTotal--;
			}
		}
		if (this._grEnabled
				&& (this._grState === ts.Possible || this._grState === ts.Began || this._grState === ts.Changed)) {
			this.doTouchEnd(touchEndEvent);
		}
		// Reset the detector only when all fingers lifted and in 'ending' state
		if (!this._grTouchTotal
				&& (this._grState === ts.Recognized || this._grState === ts.Failed || this._grState === ts.Cancelled)) {
			this.reset();
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in cancellation
	 * phase of a touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#touchCancel
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchCancelEvent
	 */
	grp.touchCancel = function(touchCancelEvent) {
		var cancelledTouches = touchCancelEvent.changedTouches;
		var ttracker = this._grTouchTracker;
		var ownerComp = this._grOwnerComp;
		var pagePosition = ownerComp.pagePosition();
		for ( var i = 0, t, tId, track, len = cancelledTouches.length; i < len; i++) {
			t = cancelledTouches.item(i);
			tId = t.identifier;
			track = ttracker[tId];
			if (track) {
				track.globalXY = ownerComp.convertPointToGlobal({
					x : t.pageX - pagePosition.x,
					y : t.pageY - pagePosition.y
				});
				this._grTouchTotal--;
			}
		}
		if (this._grEnabled
				&& (this._grState === ts.Possible || this._grState === ts.Began || this._grState === ts.Changed)) {
			this.doTouchCancel(touchCancelEvent);
		}
		// Reset the detector only when all fingers lifted and in 'ending' state
		if (!this._grTouchTotal
				&& (this._grState === ts.Recognized || this._grState === ts.Failed || this._grState === ts.Cancelled)) {
			this.reset();
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in start phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#doTouchBegin
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchStartEvent
	 */
	grp.doTouchBegin = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in moving phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#doTouchMove
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchMoveEvent
	 */
	grp.doTouchMove = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in ending phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#doTouchEnd
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchEndEvent
	 */
	grp.doTouchEnd = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in cancellation
	 * phase of a touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#doTouchCancel
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchCancelEvent
	 */
	grp.doTouchCancel = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to reset the internal state, before
	 * start to do next around recognition.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#reset
	 * @function
	 */
	grp.reset = function() {
		this._grState = ts.Possible;
		// this._grTouchTotal = 0;
		this._grTouchTracker = {};
	};
	/**
	 * Get the current state of gesture detector
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#state
	 * @function
	 * @param {sap.viz.mvc.GestureDetector.TransitionState}
	 *            transState
	 */
	grp.state = function(transState) {
		return this._grState;
	};

	/**
	 * Gesture Detector uses this method to set it's state. Subclass should set
	 * correct state at right time, usually in
	 * doTouchBegin/doTouchMove/doTouchEnd/doTouchCancel method.
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#_state_
	 * @function
	 * @param {sap.viz.mvc.GestureDetector.TransitionState}
	 *            transState
	 */
	grp._setState_ = function(transState) {
		switch (transState) {
		case ts.Possible:
			break;
		case ts.Began:
			this._grState = ts.Began;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			break;
		case ts.Changed:
			if (this._grState === ts.Began) {
				this._grState = ts.Changed;
			}
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			break;
		case ts.Cancelled:
			this._grState = ts.Cancelled;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			// this.reset();
			break;
		case ts.Failed:
			this._grState = ts.Failed;
			// this.reset();
			break;
		case ts.Ended:
		case ts.Recognized:
			this._grState = transState;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			// this.reset();
			break;
		}
	};

	GestureDetector.TransitionState = ts;
	return GestureDetector;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.VizFrame',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.GestureDetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.DomWatcher',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.Event',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.MouseEvent',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.TouchEvent',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Math',
  version : '4.0.0'
}
],
function Setup(FunctionUtils, ObjectUtils, UIComponent, GestureDetector, DomWatcher, Event, MouseEvent, TouchEvent,
		Math) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	var isInDomtree = function(node) {
		var bodyNode = undefined;
		do {
			if (node.nodeName == 'BODY') {
				bodyNode = node;
				break;
			} else {
				node = node.parentNode;
			}
		} while (node)
		return bodyNode;
	};

	var setFrame = function(vframe) {
		// set offset according to parent postion property
		var holder = vframe._holder;
		if (holder.css('position') == "static" || holder.css('position') == "fix") {
			var position = holder.position();
			vframe.frame({
				x : position.left,
				y : position.top,
				width : holder.width(),
				height : holder.height()
			});
		} else {
			vframe.frame({
				x : 0,
				y : 0,
				width : holder.width(),
				height : holder.height()
			});
		}
	};
	// callback on css change
	var func = function(changedProps) {
		for ( var i = 0, len = changedProps.length; i < len; i++) {
			if (changedProps[i] === "position") {
				setFrame(this);
				break;
			}
		}
	};

	var getHittedComponent = function(event) {
		var domEntity = $(event.target);
		while (!domEntity.data('selfComp')) {
		  if (!domEntity.length)
		    break;
			domEntity = domEntity.parent();
		}
		return domEntity.data('selfComp');
	};

	var ts = GestureDetector.TransitionState;
	var VizFrame = ObjectUtils
			.derive(
					UIComponent,
					{
						constructor : function(options) {
							if (options.container) {
								this._holder = $(options.container);
								if (!isInDomtree(this._holder.get(0))) {
									FunctionUtils.error('The holder DIV must be a child of Body element.');
								}
								// VizFrame's logical parent is always visible
								if (this._holder.css('display') === 'none') {
									this.markHide();
								}
								this.clipToBound(false);
								this._regDOMEventHandlers();
								this._holder.append(this._container);
								this.anchorPoint({
									x : 0,
									y : 0
								});
								setFrame(this);
								// watch position changes
								DomWatcher.watch(this._holder.get(0), "position", ObjectUtils.proxy(func, this));
								this._parentVisible = true;
								this._attached = true;
								// structure for event dispatching
								this._msTracking = [];
								this._touchSeqTracking = {};

							} else {
								throw new Error('you have to provide a container for viz frame');
							}
						},

						_regDOMEventHandlers : function() {
							this._container.bind('click', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('dblclick', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focusin', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focusout', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focus', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('blur', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mousedown', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseup', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseenter', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseleave', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mousemove', ObjectUtils.proxy(this._handleDomEvent, this));
							// Below events are supposed to be fired when the
							// element is attached/detached to/from document,
							// it's used to register touch listener correctly in
							// iOS Mobile Safari.
							this._container.bind('DOMNodeInsertedIntoDocument', ObjectUtils.proxy(
									this._registerDOMTouchHandler, this));
							this._container.bind('DOMNodeRemovedFromDocument', ObjectUtils.proxy(
									this._unregisterDOMTouchHandler, this));
						},

						_registerDOMTouchHandler : function() {
							this._container.bind('touchstart', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchmove', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchend', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchcancel', ObjectUtils.proxy(this._handleDomEvent, this));
						},

						_unregisterDOMTouchHandler : function() {
							this._container.unbind('touchstart');
							this._container.unbind('touchmove');
							this._container.unbind('touchend');
							this._container.unbind('touchcancel');
						},

						_handleDomEvent : function(event) {
							event.preventDefault();
							var hittedComp = getHittedComponent(event);
							switch (event.type) {
							case 'mousemove':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									var localPoint = {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									};
									if (this._msTracking.length) {
										if (this._msTracking[this._msTracking.length - 1] !== hittedComp) {
											var enteredComps = [];
											var entered = hittedComp;
											while (entered) {
												enteredComps.push(entered);
												entered = entered.superComponent();
											}
											var inCompCount = 0, checkFinished = false, minLen = Math.min(
													this._msTracking.length, enteredComps.length);
											while (true) {
												var left = undefined;
												if (!checkFinished
														&& this._msTracking[inCompCount] === enteredComps[enteredComps.length
																- 1 - inCompCount]) {
													inCompCount++;
													checkFinished = inCompCount === minLen;
												} else {
													while (this._msTracking.length > inCompCount) {
														left = this._msTracking.pop();
														var mlEvt = new MouseEvent('mouseleave', left, false, left
																.convertPointFromComp(localPoint, hittedComp), {
															x : event.pageX,
															y : event.pageY
														});
														mlEvt._setRelatedTarget_(hittedComp);
														left._fireMouseEvent_(mlEvt);
													}
													while (inCompCount < enteredComps.length) {
														var entered = enteredComps.shift();
														left = this._msTracking[enteredComps.length - 1];
														this._msTracking[enteredComps.length] = entered;
														var mlEvt = new MouseEvent('mouseenter', entered, false,
																entered.convertPointFromComp(localPoint, hittedComp), {
																	x : event.pageX,
																	y : event.pageY
																});
														mlEvt._setRelatedTarget_(left);
														entered._fireMouseEvent_(mlEvt);
													}
													break;
												}
											}
										}
									} else {
										var entered = hittedComp;
										do {
											this._msTracking.push(entered);
											entered._fireMouseEvent_(new MouseEvent('mouseenter', entered, false,
													localPoint, {
														x : event.pageX,
														y : event.pageY
													}));
											entered = entered.superComponent();
										} while (entered)
										this._msTracking.reverse();
									}
									hittedComp._fireMouseEvent_(new MouseEvent('mousemove', hittedComp, true,
											localPoint, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									while (this._msTracking.length) {
										var left = this._msTracking.pop();
										var framePagePosition = this.pagePosition();
										left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, {
											x : event.pageX - framePagePosition.x,
											y : event.pageY - framePagePosition.y
										}, {
											x : event.pageX,
											y : event.pageY
										}));
									}
								}
								break;
							case 'mouseleave':
								while (this._msTracking.length) {
									var left = this._msTracking.pop();
									var leftCompPageXY = left.pagePosition();
									left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, {
										x : event.pageX - leftCompPageXY.x,
										y : event.pageY - leftCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'mouseup':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									hittedComp._fireMouseEvent_(new MouseEvent('mouseup', hittedComp, true, {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'mousedown':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									hittedComp._fireMouseEvent_(new MouseEvent('mousedown', hittedComp, true, {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'dblclick':
								if (hittedComp) {
									if (this._focusedComp) {
										if (this._focusedComp.id() !== hittedComp.id()) {
											this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
											this._focusedComp._fireEvent_(new Event('focusout', this._focusedLayer,
													true));
											this._focusedComp = hittedComp;
											this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusin', this._focusedComp, true));
										}
									} else {
										this._focusedComp = hittedComp;
										this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusin', this._focusedComp, true));
									}
									var hittedCompPageXY = hittedComp.pagePosition();
									this._focusedComp._fireMouseEvent_(new MouseEvent('dblclick', this._focusedComp,
											true, {
												x : event.pageX - hittedCompPageXY.x,
												y : event.pageY - hittedCompPageXY.y
											}, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									if (this._focusedComp) {
										this._focusedComp._fireEvent_(new Event('blur', this._focusedLayer, false));
										this._focusedComp._fireEvent_(new Event('focusout', this._focusedLayer, true));
										this._focusedComp = undefined;
									}
								}
								break;
							case 'click':
								if (hittedComp) {
									if (this._focusedComp) {
										if (this._focusedComp.id() !== hittedComp.id()) {
											this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusout', this._focusedComp, true));
											this._focusedComp = hittedComp;
											this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusin', this._focusedComp, true));
										}
									} else {
										this._focusedComp = hittedComp;
										this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusin', this._focusedComp, true));
									}
									var hittedCompPageXY = hittedComp.pagePosition();
									this._focusedComp._fireMouseEvent_(new MouseEvent('click', this._focusedComp, true,
											{
												x : event.pageX - hittedCompPageXY.x,
												y : event.pageY - hittedCompPageXY.y
											}, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									if (this._focusedComp) {
										this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusout', this._focusedComp, true));
										this._focusedComp = undefined;
									}
								}
								break;
							case 'touchstart':
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									// 'false' means the touch hasn't been
									// marked
									// cancelled
									this._touchSeqTracking[touch.identifier] = false;
								}

								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								var touchEvent = TouchEvent.buildFromDomTouchEvent('touchstart', hittedComp,
										event.originalEvent);
								hittedComp._fireTouchEvent_(touchEvent);
								break;
							case 'touchmove':
								// Handle gesture Detection and fire touchmove
								// event when no gesture currently detected
								if (!this._handleGestureDetect(hittedComp, event.originalEvent)) {
									var touchEvent = TouchEvent.buildFromDomTouchEvent('touchmove', hittedComp,
											event.originalEvent);
									hittedComp._fireTouchEvent_(touchEvent);
								}
								break;
							case 'touchend':
								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								var uncancelledTouchesArray = [], cancelledTouchesArray = [], touchesArray = [], targetTouchesArray = [];
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									this._touchSeqTracking[touch.identifier] === true ? cancelledTouchesArray
											.push(touch) : uncancelledTouchesArray.push(touch);
									delete this._touchSeqTracking[touch.identifier];
								}

								if (uncancelledTouchesArray.length) {
									// Some touches are not cancelled, so we
									// have to split the event into two events,
									// one for cancelled touches, one for
									// uncancelled touches
									for ( var i = 0, touch, targetTouches = event.originalEvent.targetTouches, len = targetTouches.length; i < len; i++) {
										touch = targetTouches.item(i);
										targetTouchesArray.push(touch);
									}
									for ( var i = 0, touch, touches = event.originalEvent.touches, len = touches.length; i < len; i++) {
										touch = touches.item(i);
										touchesArray.push(touch);
									}
									var touchCancelEvent = TouchEvent.buildFrom3TouchArray('touchcancel', hittedComp,
											touchesArray, cancelledTouchesArray, targetTouchesArray);
									hittedComp._fireTouchEvent_(touchCancelEvent);
									var touchEndEvent = TouchEvent.buildFrom3TouchArray('touchend', hittedComp,
											touchesArray, uncancelledTouchesArray, targetTouchesArray);
									hittedComp._fireTouchEvent_(touchEndEvent);
								} else {
									// All ended touches are marked as cancelled
									var touchEvent = TouchEvent.buildFromDomTouchEvent('touchcancel', hittedComp,
											event.originalEvent);
									hittedComp._fireTouchEvent_(touchEvent);
								}
								// Fire touch event
								break;

							case 'touchcancel':
								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									delete this._touchSeqTracking[touch.identifier];
								}
								var touchEvent = TouchEvent.buildFromDomTouchEvent('touchcancel', hittedComp,
										event.originalEvent);
								hittedComp._fireTouchEvent_(touchEvent);
								break;
							}
						},

						_handleGestureDetect : function(hittedComponent, origTouchEvent) {
							var grs = [];
							var thisLevel = hittedComponent;
							// find the gesture recognizers responsible for the
							// gesture detection of the component hierarchy
							while (!thisLevel._gestureDetectors.length && thisLevel._superComp) {
								thisLevel = thisLevel._superComp;
							}
							grs = thisLevel._gestureDetectors;
							var someGestureDetected = false, gestureDetected, needToCancelTouches = false;
							for ( var i = 0, state, gd, len = grs.length; i < len; i++) {
								gd = grs[i];
								switch (origTouchEvent.type) {
								case 'touchstart':
									gd.touchBegin(origTouchEvent);
									break;
								case 'touchmove':
									gd.touchMove(origTouchEvent);
									break;
								case 'touchend':
									gd.touchEnd(origTouchEvent);
									break;
								case 'touchcancel':
									gd.touchCancel(origTouchEvent);
									break;
								}
								state = gd.state();
								gestureDetected = (state === ts.Began) || (state === ts.Changed)
										|| (state === ts.Recognized);
								someGestureDetected = someGestureDetected || gestureDetected;
								needToCancelTouches = needToCancelTouches || (gestureDetected && gd.cancelTouches());
							}
							if (needToCancelTouches) {
								for ( var i = 0, touch, changedTouches = origTouchEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									// Mark all changed touch as cancelled
									this._touchSeqTracking[touch.identifier] = true;
								}
							}
							return someGestureDetected;
						},

						hidden : function(hidden) {
							hidden ? this._holder.hide() : this._holder.show();
							if (hidden) {
								this.markHide();
							} else {
								this.markShow();
							}
						}
					});
	return VizFrame;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.ImageManager',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(ObjUtils, LinkedHashMap, FuncUtils) {
	/**
	 * The image object
	 * 
	 * @name sap.viz.mvc.Image
	 * @constructor
	 */
	var img = function(htmlImageElement) {
		this._imgEl = htmlImageElement;
	};

	/**
	 * Return the underlying htmlImageElement
	 * 
	 * @name sap.viz.mvc.Image#getBitmap
	 * @function
	 * @returns {HtmlImageElement}
	 */
	img.prototype.getBitmap = function() {
		return this._imgEl;
	};

	/**
	 * Get or set the visual width of the image
	 * 
	 * @name sap.viz.mvc.Image#width
	 * @param {undefined|Number}
	 *            width the new width of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the width
	 */
	img.prototype.width = function(width) {
		if (width !== undefined) {
			this._imgEl.width = width;
			return this;
		}
		return this._imgEl.width;
	};

	/**
	 * Get or set the visual height of the image
	 * 
	 * @name sap.viz.mvc.Image#height
	 * @param {undefined|Number}
	 *            height the new height of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the height
	 */
	img.prototype.height = function(height) {
		if (height !== undefined) {
			this._imgEl.height = height;
			return this;
		}
		return this._imgEl.height;
	};

	/**
	 * Get the intrinsic height of the image
	 * 
	 * @name sap.viz.mvc.Image#intrinsicHeight
	 * @returns {Number}
	 */
	img.prototype.intrinsicHeight = function() {
		return this._imgEl.naturalHeight;
	};

	/**
	 * Get the intrinsic width of the image
	 * 
	 * @name sap.viz.mvc.Image#intrinsicWidth
	 * @returns {Number}
	 */
	img.prototype.intrinsicWidth = function() {
		return this._imgEl.naturalWidth;
	};

	/**
	 * Get the url of the image
	 * 
	 * @name sap.viz.mvc.Image#url
	 * @returns {String} the url of the image
	 */
	img.prototype.url = function() {
		return this._imgEl.src;
	};

	var _imageCache = new LinkedHashMap();
	var _id2src = new LinkedHashMap();
	var _src2ids = {};

	/**
	 * This class defines global shared image manager used for loading external
	 * image. The loading process is asynchronously. The loaded images are
	 * indentified by src urls internally, and can shared within the all viz
	 * application. You must assign an id when loading an image. You can
	 * retrieve the loaded image by id only. the same image can be assigned
	 * multiple ids.
	 * 
	 * @name sap.viz.mvc.ImageManager
	 * @class
	 */
	var ImageManager = {
		/**
		 * Load an image designated by URL. The loading is asynchronized, the
		 * image will be available when the onComplete is called
		 * 
		 * @param {String}
		 *            id the caller-provided Id of the image to be loaded and
		 *            retrieved later.
		 * @param {String}
		 *            url the url of the image to be loaded
		 * @param {Function}
		 *            [onComplete], the on complete callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImage : function(id, url, onComplete) {
			if (id && url) {
				onComplete = onComplete || FuncUtils.noop;
				if (_id2src.has(id)) {
					if (_imageCache.get(_id2src.get(url))) {
						onComplete(true);
					}
				}
				var imgEl = new Image();
				imgEl.onabort = imgEl.onerror = function() {
					onComplete(false, {
						id : id,
						url : url
					});
				};
				imgEl.onload = ObjUtils.proxy(function() {
					var src = imgEl.src;
					if (!_imageCache.has(src)) {
						var imgObj = new img(imgEl);
						_id2src.add(id, src);
						_src2ids[src] = {
							ids : {
								id : id
							},
							length : 1
						};
						_imageCache.add(src, imgObj);
					} else {
						_id2src.add(id, imgEl.src);
						_src2ids[src].ids[id] = id;
						_src2ids[src].length++;
					}
					onComplete(true, {
						id : id,
						url : url
					});
				}, this);
				imgEl.src = url;
			}
		},
		/**
		 * Load an array of images concurrently. The loading is asynchronized,
		 * the images will be available when the onComplete is called
		 * 
		 * @param {Object[]}
		 *            urls the array of the image url to be loaded. The urls
		 *            should follow the format:
		 * 
		 * <pre>
		 * [ {
		 * 	id : 'IMAGE_ID',
		 * 	url : 'IMAGE_URL'
		 * } ]
		 * </pre>
		 * 
		 * @param {Function}
		 *            [onComplete] the on-complete function callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImages : function(urls, onProgress, onComplete) {
			onProgress = onProgress || FuncUtils.noop;
			onComplete = onComplete || FuncUtils.noop;
			var total = urls.length;
			if (total == 0) {
				onComplete(true);
			} else {
				var count = 0;
				var _stepFunction = function(isSuccessful, imgInfo) {
					count++;
					if (count < total) {
						onProgress(count / total, isSuccessful, imgInfo);
					} else {
						onComplete(true, imgInfo);
					}
				};
				for ( var i = 0, len = urls.length; i < len; i++) {
					ImageManager.loadImage(urls[i].id, urls[i].url, _stepFunction);
				}
			}
		},

		/**
		 * Check if the image has been loaded
		 * 
		 * @param {String}
		 *            id the id of the image to be checked
		 * @returns {Boolean}
		 */
		hasImage : function(id) {
			return _id2src.has(id);
		},

		/**
		 * Get the loaded image by its id, the caller has to ensure the image is
		 * loaded
		 * 
		 * @param {String}
		 *            id the id of the image to get
		 * @returns {sap.viz.mvc.Image}
		 */
		getImage : function(id) {
			if (_id2src.has(id)) {
				return _imageCache.get(_id2src.get(id));
			}
		},

		/**
		 * Remove the loaded image from internal cache
		 * 
		 * @param {String}
		 *            id the id of the image
		 */
		disposeImage : function(id) {
			if (_id2src.has(id)) {
				var src = _id2src.remove(id);
				delete _src2ids[src].ids[id];
				_src2ids[src].length--;
				if (_src2ids[src].length === 0) {
					delete _src2ids[src];
					_imageCache.remove(src);
				}
			}
		}
	};
	return ImageManager;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.VizApplication',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.Observable',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.ImageManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.VizFrame',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Logger',
  version : '4.0.0'
}
],
function Setup(Observable, FuncUtils, ObjectUtils, ImageManager, VizFrame, UIComponent, LOG) {

	var id = 0;
	function nextId() {
		return id++;
	}
	var Autosizing = UIComponent.Autosizing;
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	/**
	 * The main entry of a given visualization application. It implements most
	 * of the things that need to start a viz application, e.g. bootstrapping,
	 * preload images
	 * 
	 * @name sap.viz.mvc.VizApplication
	 * @constructor
	 * @param {Object}
	 *            options the options that needs to start the application
	 * @param {String}
	 *            options.wrapperDivEl the wrapper DIV element
	 * @param {Constructor}
	 *            options.delegateClass the constructor of your custom viz app
	 *            delegate
	 * @param {Object}
	 *            [launchOption] the additional option that will pass to the
	 *            {@link sap.viz.mvc.VizAppDelegate#appDidFinishLaunching}
	 */
	var VizApplication = function(options) {
		var _nextId = nextId();
		this._id = options.id ? options.id + '_' + _nextId : _nextId;
		LOG.debug("Chart Application[" + this._id + "] initializing.", "perf");
		if (!options.delegateClass) {
			FuncUtils.error('You have to specify a delegate for visualization custom behavior.');
		}
		if (!options.wrapperDivEl) {
			FuncUtils.error('You have to specify a div element for holding the visualization.');
		}
		this._vizFrame = new VizFrame({
			container : options.wrapperDivEl
		});
		//this._canvasForPrinting = CanvasHelper.createCanvasElement(1, 1);
		this._delegate = new options.delegateClass();
		var assets = this._delegate.getPreloadAssets();
		ImageManager.loadImages(assets, undefined, ObjectUtils.proxy(function() {
			this._delegate._afterLaunched(this, options.launchOption);
		}, this));
		var comsItr = this._vizFrame.subComponents().getIterator();
		while (comsItr.hasMore()) {
			LOG.debug("application[" + this._id + "]" + "component[" + comsItr.nextValue().id() + "] initialized.",
					"perf");
		}
		this._eventBridge = new Observable();
		this._addEvents(this._delegate.getSupportedEvents());

	};

	var ap = VizApplication.prototype;

	ap.id = function() {
		return this._id;
	};

	/**
	 * Get and set the size of the application
	 * 
	 * @name sap.viz.mvc.VizApplication#size
	 * @param {undefined|Object}
	 *            size undefined or new size of the application
	 * @returns {this|Object} when set the size the return is this object, when
	 *          get the size the return will be the size
	 * 
	 */
	ap.size = function(size) {
		if (size !== undefined) {
			this._vizFrame.size(size);
			return this;
		} else {
			return this._vizFrame.size();
		}
	};

	/**
	 * Get and set the visibility of the application
	 * 
	 * @name sap.viz.mvc.VizApplication#hidden
	 * @param {undefined|Boolean}
	 *            hidden undefined or boolean value indicating whether the
	 *            application should be hided.
	 * @returns {this|Object} when set the hidden status the return is this
	 *          object, when get the hidden status the return will be the
	 *          current hidden status.
	 * 
	 */
	ap.hidden = function(hidden) {
		if (hidden !== undefined) {
			if (this._vizFrame.hidden() !== hidden) {
				this._vizFrame.hidden(hidden);
			}
			return this;
		} else {
			return this._vizFrame.hidden();
		}
	};
	/**
	 * Get a list of event names the current visualization instance supports
	 * 
	 * @name sap.viz.mvc.VizApplication#getSupportedEvent
	 * @returns {Array} an array of event names supported
	 * 
	 */
	ap.getSupportedEvent = function() {
		return this._eventBridge.getSupportedEvents();
	};
	/**
	 * Add a listener to the supported event
	 * 
	 * @name sap.viz.mvc.VizApplication#addListener
	 * @param {String}
	 *            event the event to listen
	 * @param {Function}
	 *            listener the function to be called back when event occurs
	 * 
	 */
	ap.addListener = function(event, listener) {
		this._eventBridge.addListeners({
			eventName : event,
			listener : listener
		});
	};
	/**
	 * Remove an existing listener
	 * 
	 * @name sap.viz.mvc.VizApplication#removeListener
	 * @param {String}
	 *            event the event to listen
	 * @param {Function}
	 *            listener the existing function to be removed
	 * 
	 */
	ap.removeListener = function(event, listener) {
		this._eventBridge.removeListener(event, listener);
	};

	ap._addEvents = function(events) {
		for ( var i = 0, len = events.length; i < len; i++) {
			this._eventBridge.addEvents(events[i]);
		}
	};

	ap._fireEvent = function() {
		this._eventBridge.fireEvent.apply(this._eventBridge, arguments);
	};

	/**
	 * Get a list of public method names the current visualization instance
	 * supports
	 * 
	 * @name sap.viz.mvc.VizApplication#getPublicMethods
	 * @returns {Array} an array of public method names supported
	 * 
	 */
	ap.getPublicMethods = function() {
		return this._delegate.getSupportedMethods();
	};
	/**
	 * Invoke the public method of the current visualization with options
	 * 
	 * @name sap.viz.mvc.VizApplication#invokePublicMethod
	 * @param {String}
	 *            publicMethodName, the name of the public method.
	 * @param {Object}
	 *            [options] the options object is passed as argument.
	 */
	ap.invokePublicMethod = function(publicMethodName, options) {
		return this._delegate._invokePublicMethod(publicMethodName, options);
	};
	/**
	 * Apply a new theme to the visualization instance
	 * 
	 * @name sap.viz.mvc.VizApplication#applyTheme
	 * @deprecated
	 * @param {String}
	 *            theme, the name of the theme.
	 */
	ap.applyTheme = function(theme) {
		this._delegate._applyTheme(theme);
	};

	/**
	 * Get or set the properties of the current visualization instance.
	 * 
	 * @name sap.viz.mvc.VizApplication#properties
	 * @param {Object}
	 *            [propBag]
	 * @returns {Object}
	 */
	ap.properties = function(propBag) {
		if (propBag !== undefined) {
			this._delegate.updateProperties(propBag);
		}
		return this._delegate.getProperties();
	};

	/**
	 * Update dataset after chart created
	 * 
	 * @name sap.viz.mvc.VizApplication#setDataset
	 * @param {Object}
	 */
	ap.setDataset = function(dataset) {
		if (dataset) {
			this._delegate.setDataset(dataset);
		}
	};
	
	ap.getDataset = function() {
        return this._delegate.getDataset();
    };

	ap._setRootController = function(rootController) {
		if (rootController) {
			var rootUIComp = rootController.rootUIComponent();
			rootUIComp.frame(this._vizFrame.bounds());
			rootUIComp.autoresizingMask(Autosizing.FlexibleWidth | Autosizing.FlexibleHeight);
			this._vizFrame.addSubComponent(rootUIComp);
		}
	};

	return VizApplication;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.D3BasedComponent',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.0'
}
],
function Setup(ObjUtils, FuncUtils, UIComponent) {
	if (!d3) {
		FuncUtils.error('D3 cannot be found');
	}
	var initD3Root = function() {
		var width = this.width();
		var height = this.height();
		this._d3Root = d3.select(this._container[0]).append('svg').attr('width', width).attr('height', height);
	};
	/**
	 * This component initializes a SVG element acting as the root element for
	 * d3 based development.
	 * 
	 * @name sap.viz.mvc.D3BasedComponent
	 * @class
	 * @augments sap.viz.mvc.UIComponent
	 */
	var D3BasedComponent = ObjUtils.derive(UIComponent,
	/**
	 * @lends sap.viz.mvc.D3BasedComponent
	 */
	{
		constructor : function(options) {
			initD3Root.call(this);
		},

		doContentResize : function(oldSize, newSize) {
			if (oldSize.width !== newSize.width) {
				this._d3Root.attr('width', newSize.width);
			}
			if (oldSize.height !== newSize.height) {
				this._d3Root.attr('height', newSize.height);
			}
		},

		/**
		 * Returns the d3 container of the component, subclass should use this
		 * as the root container in d3 development
		 * 
		 * @final
		 * @name sap.viz.mvc.D3BasedComponent#getD3Root
		 * @function
		 * @returns {sap.viz.graphics.Canvas2DSurface}
		 */
		getD3Root : function() {
			return this._d3Root;
		}
	});
	return D3BasedComponent;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.UIController',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.0'
}
],
function Setup(FuncUtils, UIComponent) {
	/**
	 * The base class of Controller in VizKit MVC framework
	 * 
	 * @name sap.viz.mvc.UIController
	 * @constructor
	 * @param {Object}
	 *            options any arguments you want to pass in when initialize your
	 *            concrete subclass of controller
	 */
	var controller = function(options) {
		this._defaultWidth = 5;
		this._defaultHeight = 5;
		this._app;
		this._uiComp;
//		ThemeManager.on({
//			eventName : 'themechanged',
//			listener : this.doThemeChanged,
//			scope : this
//		});
	};

	var cp = controller.prototype;

	/**
	 * Return the root component of the hierarchy that this controller manages
	 * 
	 * @name sap.viz.mvc.UIController#rootUIComponent
	 * @function
	 * @returns {sap.viz.mvc.UIComponent}
	 */
	cp.rootUIComponent = function() {
		if (!this._uiComp) {
			this._uiComp = this.initUIComponent(this._defaultWidth, this._defaultHeight);
			this._uiComp.on({
				eventName : 'beforeShow',
				listener : this._handleBeforeShow,
				scope : this
			});
			this._uiComp.on({
				eventName : 'beforeHide',
				listener : this._handleBeforeHide,
				scope : this
			});
			this._uiComp.on({
				eventName : 'afterShow',
				listener : this._handleAfterShow,
				scope : this
			});
			this._uiComp.on({
				eventName : 'afterHide',
				listener : this._handleAfterHide,
				scope : this
			});
			this.afterUIComponentLoaded();
		}
		return this._uiComp;
	};

	cp._handleBeforeHide = function(hide) {
		this.beforeUIComponentDisappear();
	};

	cp._handleBeforeShow = function(hide) {
		this.beforeUIComponentAppear();
	};

	cp._handleAfterHide = function(hide) {
		this.afterUIComponentDisappear();
	};

	cp._handleAfterShow = function(hide) {
		this.afterUIComponentAppear();
	};

	cp._setApplication_ = function(application) {
		this._app = application;
	};

	/**
	 * Get the application instance
	 * 
	 * @name sap.viz.mvc.UIController#getApplication
	 * @function
	 * @returns {sap.viz.mvc.VizApplication}
	 */
	cp.getApplication = function() {
		return this._app;
	};
	/**
	 * Fire the event supported by application which is declared in
	 * {@link sap.viz.mvc.VizAppDelegate#getSupportedEvents}
	 * 
	 * @name sap.viz.mvc.UIController#fireAppEvent
	 * @function
	 */
	cp.fireAppEvent = function(event, arguments) {
		this._app._fireEvent(event, arguments);
	};

	/**
	 * Subclass should override this method to initialize its own UIComponent
	 * hierarchy and return the root UIComponent. The default implementation
	 * creates an empty UIComponent
	 * 
	 * @name sap.viz.mvc.UIController#initUIComponent
	 * @function
	 * @param {Number}
	 *            initWidth the initial width of the root component
	 * @param {Number}
	 *            initHeight the initial height of the root component
	 * 
	 */
	cp.initUIComponent = function(initWidth, initHeight) {
		return new UIComponent({
			size : {
				w : initWidth,
				h : initHeight
			}
		});
	};

	/**
	 * This method will be called after the root UIComponent initialized
	 * 
	 * @name sap.viz.mvc.UIController#afterUIComponentLoaded
	 * @function
	 */
	cp.afterUIComponentLoaded = FuncUtils.noop;

	/**
	 * This method will be called when the managed UIComponent will become
	 * visible via set the hidden property
	 * 
	 * @name sap.viz.mvc.UIController#beforeUIComponentAppear
	 * @function
	 */
	cp.beforeUIComponentAppear = FuncUtils.noop;

	/**
	 * This method will be called after the managed UIComponent became visible
	 * via set the hidden property
	 * 
	 * @name sap.viz.mvc.UIController#afterUIComponentAppear
	 * @function
	 */
	cp.afterUIComponentAppear = FuncUtils.noop;
	/**
	 * This method will be called when the managed UIComponent will become
	 * visible via set the hidden property
	 * 
	 * @name sap.viz.mvc.UIController#beforeUIComponentDisappear
	 * @function
	 */
	cp.beforeUIComponentDisappear = FuncUtils.noop;
	/**
	 * This method will be called after the managed UIComponent became visible
	 * via set the hidden property
	 * 
	 * @name sap.viz.mvc.UIController#afterUIComponentDisappear
	 * @function
	 */
	cp.afterUIComponentDisappear = FuncUtils.noop;

	/**
	 * This method will be called when user apply a new theme, and if and only
	 * if the controller is the root controller.
	 * 
	 * @name sap.viz.mvc.UIController#doThemeApplied
	 * @function
	 * @deprecated
	 * @param {String}
	 *            old the name of the old theme
	 * @param {String}
	 *            new the name of the new theme
	 */
	cp.doThemeApplied = FuncUtils.noop;

	/**
	 * This method will be called when user update the theme setting and if and
	 * only if the controller is the root controller.
	 * 
	 * @name sap.viz.mvc.UIController#doThemeUpdated
	 * @function
	 * @deprecated
	 * @param {String}
	 *            key the key of the updated property
	 * @param {Object}
	 *            oldValue the old value
	 * @param {Object}
	 *            newValue the new value
	 */
	cp.doThemeUpdated = FuncUtils.noop;
	/**
	 * This method will be called when user changes to another theme through 
	 * ThemeManager
	 * @name sap.viz.mvc.UIController#doThemeChanged
	 * @function
	 */
	cp.doThemeChanged = FuncUtils.noop;
	return controller;
});sap.riv.module(
{
  qname : 'sap.viz.core',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.UIController',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.D3BasedComponent',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.VizApplication',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.VizAppDelegate',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.0'
},
{  qname : 'sap.viz.load',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.xycontainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.BaseDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.EffectManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.config',
  version : '4.0.0'
},
{  qname : 'sap.viz.StyleManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.parseCSS',
  version : '4.0.0'
},
{  qname : 'sap.viz.TemplateManager',
  version : '4.0.0'
}
],
function Setup( TypeUtils, ObjectUtils, Objects, Functions, UIController, D3Component, VizApplication, VizAppDelegate, manifest, layout, loader, container, Feeder,BaseDataHandler, MultiAxesDataAdapter, EffectManager, langManager, CanvgConfig, StyleManager, parseCSS, TemplateManager) {

  function buildPropertiesTree(obj){
    var returnObj = {};
    for (var i in obj){
      if (obj.hasOwnProperty(i)){
        if (obj[i].supportedValueType === "Object"){
          returnObj[i] = buildPropertiesTree(obj[i].supportedValues);
        }
        else {
          returnObj[i] = obj[i].defaultValue;
        }
      }
    }
    return returnObj;
  }
  function mergeProperties(defaultProp, fullProp){
    var returnProp =Objects.extend(true,{},defaultProp);
    for (var i in defaultProp){
      if (defaultProp.hasOwnProperty(i)){
        if (typeof fullProp === 'object' && fullProp.hasOwnProperty(i)){
          if (defaultProp[i] !== null && typeof defaultProp[i] === 'object' && !(defaultProp[i] instanceof Array)) {
            returnProp[i] = mergeProperties(defaultProp[i],fullProp[i]);
          }
          else {
            if ((fullProp[i] !== undefined && fullProp[i] instanceof Array && defaultProp[i] instanceof Array) || 
                (fullProp[i] !== undefined && typeof fullProp[i] !== 'object')){
              returnProp[i] = fullProp[i];
            }
          }
        }
      }
    }
    return returnProp;
  }

  function extractProperties(modules, chartId){
    var defaultProperties = manifest.viz.get(chartId).allProperties();
    var mergedProperties = {};
    var tempKey;
    var tempProp = {};
    var i, j;
    for(i in modules){
      if (modules.hasOwnProperty(i)){
        if (modules[i].properties && !TypeUtils.isEmptyObject(modules[i].properties())){
          if (i.indexOf('[') > -1){
            if (parseInt(i[i.indexOf('[') + 1],10) > 0){
              continue;
            }
            else {
              tempKey = i.substring(0,i.indexOf('[')) + i.substring(i.indexOf(']') + 1);
            }
          }
          else {
            tempKey = i;
          }
          for (j in defaultProperties){
            if (defaultProperties.hasOwnProperty(j)){
              if (defaultProperties[j].moduleRefPath === tempKey){
                tempProp = buildPropertiesTree(defaultProperties[j]);
                mergedProperties[j] = mergeProperties(tempProp, modules[i].properties());
              }
            }
          }
        }
      }
    }
    return mergedProperties;

  }
  
  function load(moduleId) {
    return manifest.module.get(moduleId).execute();
  }
  

  function dispatchData(moduleConfig, data) {
    var result;
    if (moduleConfig) {
      var dataConfig = moduleConfig.data;
      if (dataConfig) {
        result = data.createDataAdapterForModule(dataConfig);
      }
    }
    return result;
  }
  
  /* Represents the root component. */
  var ChartComponent = ObjectUtils.derive(D3Component, {
    constructor : function ( options ) {
      this._config = options.config;      // Chart configuration
      this._data = options.data;          // Transformed data set
      this._inputProperties = options.options; // Chart properties
      this._properties = {};
      //TODO: support empty data set in module level 
      if(this._data.emptyDataset() === true){
         return;
      }
      
      this._canvas_rootThreshold = d3.select(document.createElement('div')), this._canvas_rootThreshold.append('svg');
      this._canvas_root = d3.select(document.createElement('canvas')).style('width', 0).style('height', 0);
      this._container.prepend(this._canvas_root.node());
      var m_canvg_config = CanvgConfig.get(this._config.id)? CanvgConfig.get(this._config.id): {} ; 
      this._max_svg =  CanvgConfig.enableCanvg() && m_canvg_config.max_svg? m_canvg_config.max_svg : Number.POSITIVE_INFINITY ;
      if(this._data.dataPointCount() > this._max_svg){
        this._root =  this._canvas_rootThreshold.select('svg');
        this._compoennt_status = 'canvg';
      }else{
        this._root = this.getD3Root();      // D3 selection
        this._compoennt_status = 'svg';
      }
      this._modules = {};                 // Chart sub components
      this._subModuleNames = [];    // used to update sub modules when data update
      this._subControllers = [];  //used to update controllers when data update
      this._effectManager = null;
      this._styleManager = new StyleManager();
      this._initialize(options.style);

      //@Alex Su
      this._propertiesIsNewest = false;
      this._outputProperties = {};
      
      this._langManagerListener = {
        fn : this._localeChanged,
        scope : this
      };
      
      this._dispatch = d3.dispatch('dataTruncation');
      
      langManager.addListener(this._langManagerListener);
      
      this._attachEvents(options);
    },
    
    _attachEvents : function(options){
      var events = options.events;
      
      for(var obj in events){
        if(events.hasOwnProperty){
          this.attachEvent(obj, events[obj].fn, events[obj].scope);
        }
      }
    },
    
    //event register strategy
    //1. when modules A, B, C in the same level has this event type dispatch, register this event type on all modules.
    //2. If the module A contain other modules B, C and A, B, C all has this event type dispatch, only register event on this module.
    //3. Also there are event on chart controller, and the event name in chart controller should be unique.
    attachEvent : function(evtType, callback, scope){
      var modules = this.modules(), hittedModules = {};
      var dispatch = this._dispatch;
      
      //we support optional namespace in evtType
      var i = evtType.indexOf(".");
      var typeToCheck = i > 0 ? evtType.substring(0, i) : evtType;
      
      //first check the event on chart controller
      if(dispatch[typeToCheck]){
        dispatch.on(typeToCheck, function(){
          callback.apply(scope, arguments);
        });
      }
      
      for(var m in modules){
        if(modules.hasOwnProperty(m)){
          var slist = m.split('.'),  index = slist.length - 1;
          if(modules[m].dispatch && modules[m].dispatch()[typeToCheck]){
            
            for(var t = 0; t <= index; t++){
              if(hittedModules[t] && hittedModules[t][slist.slice(0, t).toString()]){
                break;
              }
            }
            //if t is larger than index, it means do not exist the parent modules has this event type dispatch.
            if(t > index){
              if(!hittedModules[slist.length]){
                hittedModules[slist.length] = {};
              }
            hittedModules[slist.length][slist.toString()] = modules[m];
            modules[m].dispatch().on(evtType, function(){
              callback.apply(scope, arguments);
            });
            }
          }
        }
      }
    },
    
    _updateSubModules : function(parentModule) {
      //clean all current submodules
      for(var i = 0, len = this._subModuleNames.length; i < len; i++){
        delete this._modules[this._subModuleNames[i]];
      }
      this._subModuleNames.length = 0;
      if(parentModule.modules){
        var subModules = parentModule.modules();
        var sname;                              
        for ( var m in subModules ) {
          if ( subModules.hasOwnProperty(m) ) {
            sname = 'main.' + m;
            this._subModuleNames.push(sname);
            this._modules[sname] = subModules[m];
          }
        }
      }
    },
    
    _updateSubControllers : function(parentModule) {
      for(var i = 0, len = this._subControllers.length; i < len; i++){
        this._modules[this._subControllers[i]].module(parentModule);
      }
    },
    
    //////////////////////Can be moved to base container///////////////////
    _resolveProperties : function(nodeConfig, isContainer){
      var props = {}, // Empty properties basket
          propsCat,   // Property category node
          usrProps,   // User set properties
          sysProps;   // Predefined properties in configure node
      if(isContainer){
        //Jimmy/8/15/2012 pay attention to the property structure, for container we will pass
        //all properties instead of properties under propsCat only.
        if ( nodeConfig ) {
          propsCat = nodeConfig.propertyCategory;
          usrProps = this._properties;
          sysProps = {};
          sysProps[propsCat] = nodeConfig.properties;
          Objects.extend( true, props, sysProps, usrProps );
        }else{
          props = this._properties;
        }
      }else{
        if ( nodeConfig ) {
          propsCat = nodeConfig.propertyCategory;
          usrProps = this._properties[ propsCat ];
          sysProps = nodeConfig.properties;
          // User properties will override predefined properties 
          // upon a merge. FIXME handle array values (Raised by Jimmy)
          Objects.extend( true, props, sysProps, usrProps );
        }
      }
      return props;
    },
    
    _updateProperties : function (id, isContainer){
      var moduleManifest = this._config.modules; // Module configurations
      var props, nodeConfig, propsCat;
      if ( moduleManifest[id] && this._modules[id] ) {
        nodeConfig = moduleManifest[id].configure;
        if (isContainer){
          props = this._properties;
        }
        else {
          if (nodeConfig){
            propsCat = nodeConfig.propertyCategory;
            props = Objects.extend(true, {}, this._properties[propsCat ]);
          }
          else{
            props = {};
          }
        }
        this._modules[id].properties(props);
      }
    },
    
    //TO FIX: delete this
    _updateControllerProperties : function (id){
      var controllersManifest = this._config.modules.main.controllers; // Module configurations
      
      if(controllersManifest === undefined){
        return;
      }
      
      var props, nodeConfig;
      var path = 'main.' + id;
      if ( controllersManifest[id] && this._modules[path] ) {
        nodeConfig = controllersManifest[id].configure;
        props = this._resolveProperties (nodeConfig);
        this._modules[path].properties(props);
      }
    },
    
    //////////////////////Can be moved to base container///////////////////
    
    _initialize : function (style) {
      this._mergeInputProperties();
      //initial effect manager first
      this._effectManager = new EffectManager(this._root.append("svg:defs"), this._data.fakeData());
      
      var ctx = {
        effectManager : this._effectManager,
        styleManager : this._styleManager
      };
      
      this._styleManager.update(style);

      function load(moduleId) {
        return manifest.module.get(moduleId).execute(ctx);
      }
      
      var moduleManifest = this._config.modules; // Module configurations
      var props, nodeController,nodeConfig; // The 'controller' node of modules 
      // Feed data to components for size calculation.
      var legend, legendData = {};
      if ( moduleManifest.legend ) {
         legendData = dispatchData(moduleManifest.legend, this._data);
        legend = load( moduleManifest.legend.id );
        nodeConfig = moduleManifest.legend.configure;
        props = this._resolveProperties(nodeConfig);
        this._modules.legend = legend.data(legendData).properties(props);
        this._root.append('g').attr('class', 'legend');
      }
      
      if ( moduleManifest.sizeLegend ) {
         legendData = dispatchData(moduleManifest.sizeLegend, this._data);
        legend = load( moduleManifest.sizeLegend.id );
        nodeConfig = moduleManifest.sizeLegend.configure;
        props = this._resolveProperties(nodeConfig);
        this._modules.sizeLegend = legend.data(legendData).properties(props);
        this._root.append('g').attr('class', 'sizeLegend');
      }
      
      if ( moduleManifest.title ) {
        var title = load( moduleManifest.title.id );
        nodeConfig = moduleManifest.title.configure;
        props = this._resolveProperties(nodeConfig);
        this._modules.title = title.properties(props);
        this._root.append('g').attr('class', 'title');
      }
      
      if ( moduleManifest.main ) {
        var container = load( moduleManifest.main.id );
        nodeConfig = moduleManifest.main.configure;
        
        //FIXME currently it's hard coded here we assume the plot is container, actually we should
          //check the plot type
        props = this._resolveProperties(nodeConfig, true);
        this._modules.main = container.data(this._data)
                            .config(moduleManifest.main)
                            .properties(props);
        
        // Merge Ian Li's fix to make canvg waiting for chart modules' initialized event
        if(this._modules.main.dispatch && this._modules.main.dispatch()['initialized']){
            var _self = this;
            this._modules.main.dispatch().on('initialized.sap.core', function(){
              _self._exportToCanvas.apply(_self);
            });
          }
          
        this._root.append('g').attr('class', 'main');
        var containerModules = this._modules.main
                              .parent(this._root.select('.main'));
        
        this._updateSubModules(containerModules);
                
        //Jimmy/8/22/2012 we introduce controller module which can be configured to any module (except controller module of course)
        //as for now, we only add the support to container. TODO
        
        nodeController = moduleManifest.main.controllers;
        if(nodeController){
          for(var nc in nodeController){
            if(nodeController.hasOwnProperty(nc)){
              var controller = load(nodeController[nc].id);
              var controllerConfig =  nodeController[nc].configure;
              var propsCat,usrProps,sysProps;
              controller().module(this._modules['main']);
              props = {};
              propsCat = controllerConfig.propertyCategory;
              usrProps = this._properties[ propsCat ];
              sysProps = controllerConfig.properties;
              Objects.extend( true, props, sysProps, usrProps );
              controller.properties(props);
              this._subControllers.push('main.' + nc);
              this._modules['main.' + nc] = controller;
            }
          }
        }   
      }
      
      if ( moduleManifest.tooltip ) {
        var tooltip = load( moduleManifest.tooltip.id );
        nodeConfig = moduleManifest.tooltip.configure;
        props = this._resolveProperties(nodeConfig);
        this._modules.tooltip = tooltip(this._container[0]).properties(props);
      }
     
    },

    // Current layout policy doesn't pass component references
    // to the layout functions, hence only component size and
    // layout preferences are passed and only layout solution
    // is expected to be returned.
    _doLayout : function ( newSize, actualLayout ) {
      var vgap = 8, padding = 20; //2em . 1em = 10px in sdk
      // reduce padding when chart size is small
      if (newSize.width < padding * 10) {
          padding = newSize.width / 10;
      }
      if (newSize.height < padding * 10) {
          padding = newSize.height / 10;
      }
      var preferences = {};
      
      if ( this._modules.title ) {
        preferences.north = { size : this._modules.title.getPreferredSize() };
      }
      //FIXME Elliott/8/20/2012, need support different legend position
      var preferenceEast = { width : 0, height: 0, minWidth: 0, maxSizeConstant: 1 }, 
        sizeLegendPS = { 
            width : 0, 
            height: 0,
            titleSize : {
                width : 0,
                height : 0
            }
        },
        legendPS = { 
            width : 0, 
            height: 0,
            titleSize : {
                width : 0,
                height : 0
            }
        };
      if ( this._modules.legend ) {
        legendPS = this._modules.legend.getPreferredSize(newSize);
        preferenceEast.width = Math.max ( preferenceEast.width, legendPS.width );
        preferenceEast.height = Math.max ( preferenceEast.height, legendPS.height );
        preferenceEast.minWidth = Math.max ( preferenceEast.minWidth, legendPS.minWidth );
        preferenceEast.minHeight = legendPS.minHeight;
        preferenceEast.maxSizeConstant = Math.min ( preferenceEast.maxSizeConstant, legendPS.maxSizeConstant );
      }
      
      preferences.east = { size : preferenceEast };
      if ( this._modules.main ) {
        preferences.center = {};
      }

      function layoutSolution() {
        return layout({
          type : 'border',
          hgap : 8,
          vgap : vgap,
          bias : 'north', // default bias is north
          size : {
            width : newSize.width,
            height : newSize.height
          },
          padding : [ padding, padding, padding, padding ],
          prefs : preferences
        });
      }

      var solution = layoutSolution();

      // by Jia Liu
      // only for size legend.
      if (actualLayout && this._modules.sizeLegend && this._modules.sizeLegend.isVisible()) {
        if (solution.center) {
          // only update size for container to force container layout
          // internally
          this._modules.main.width(solution.center.bounds.width)
              .height(solution.center.bounds.height);
  
          // call container's API infoForSizeLegend to calculate correct
          // max bubble size and size legend size
          sizeLegendPS = this._modules.sizeLegend.getPreferredSize(
              newSize, vgap + 2 * padding, this._modules.main
                  .infoForSizeLegend());
          var legendWidth = Math.max(sizeLegendPS.width, legendPS.width);
          preferenceEast.width = legendWidth < newSize.width * 1/3 ? legendWidth : newSize.width * 1/3;
          preferenceEast.height = sizeLegendPS.height;
          preferenceEast.minWidth = sizeLegendPS.minWidth;
          preferenceEast.minHeight = sizeLegendPS.minHeight;
  
          // use size legend size as preferred size to layout again
          solution = layoutSolution();
        }
      }      
      
      if ( solution.north ) {
        this._root.select('.title').attr('visibility', 'visible').attr('transform', 
          'translate(' + solution.north.bounds.x + 
          ', ' + solution.north.bounds.y + ')');
        this._modules.title
          .width(solution.north.bounds.width)
          .height(solution.north.bounds.height);
      } else {
          this._root.select('.title').attr('visibility', 'hidden');
      }

      if ( solution.east ) {
        var eastHeight = solution.east.bounds.height; 
        var eastY = solution.east.bounds.y;
        var sizeLegendHeight = 0;
        var showSizeLegendTitle = true;
        if (sizeLegendPS.height + 8 + legendPS.height > solution.east.bounds.height) {
            showSizeLegendTitle = sizeLegendPS.titleSize.height < sizeLegendPS.height * 1/3 && sizeLegendPS.titleSize.height < solution.east.bounds.height * 1/3;
            
        }
        
        if ( this._modules.sizeLegend ) {
            this._modules.sizeLegend.hide(false);
          this._root.select('.sizeLegend').attr('transform', 
          'translate(' + solution.east.bounds.x + 
          ', '+ eastY +')');
          
          sizeLegendHeight = sizeLegendPS.height;
          if (!showSizeLegendTitle) {
              this._modules.sizeLegend.hideTitle();
              sizeLegendHeight -= sizeLegendPS.titleSize.height;
          }
          
          this._modules.sizeLegend
            .width(solution.east.bounds.width)
            .height(sizeLegendHeight);
          //FIXME Elliott/8/20/2012, hard code padding here
          eastY = eastY + sizeLegendHeight + 8;
      }
      
      var showLegendTitle = true;
      if ((sizeLegendHeight > 0 ? sizeLegendHeight + 8 : 0) + legendPS.height > solution.east.bounds.height) {
          showLegendTitle = legendPS.titleSize.height < (eastHeight - sizeLegendPS.height) * 0.3;
      }
        
        if ( this._modules.legend ) {
          this._modules.legend.hide(false);
          this._root.select('.legend').attr('transform', 
          'translate(' + solution.east.bounds.x + 
          ', '+ eastY +')');
          
          if (!showLegendTitle) {
              this._modules.legend.hideTitle();
          }
          
          this._modules.legend
            .width(solution.east.bounds.width)
            .height(eastHeight - sizeLegendPS.height);
        }
      } else {
          if (this._modules.legend) {
              this._modules.legend.hide(true);
          }
          if (this._modules.sizeLegend) {
              this._modules.sizeLegend.hide(true);
          }
      }
      
      if ( solution.center ) {
        this._root.select('.main').attr('transform', 
          'translate(' + solution.center.bounds.x + 
          ', ' + solution.center.bounds.y + ')');
        this._modules.main
          .width(solution.center.bounds.width, (actualLayout === undefined ) ? true : undefined)
          .height(solution.center.bounds.height,  (actualLayout === undefined ) ? true : undefined);
          
        if ( this._modules.tooltip ) {
          this._modules.tooltip.plotArea(solution.center.bounds).zone(newSize);
        }
      }
    },
    
    _updateAllProperties : function(){
      this._mergeInputProperties();
      this._updateSubModuleProperties();
    },
    
    //TODO: refactor this hard code
    _updateSubModuleProperties:function(){
      this._updateProperties('legend');
      this._updateProperties('title');
      this._updateProperties('sizeLegend');
      this._updateProperties('tooltip');
      this._updateProperties('main', true);
      this._updateControllerProperties('interaction');
      this._updateControllerProperties('geoController');      
    },
    
    _mergeInputProperties:function (){
      Objects.extend(true, this._properties, this._inputProperties);
      this._mergeCanvgProperties();      
    },
    
    _mergeCanvgProperties:function (){
      if(CanvgConfig.enableCanvg() && this._data.dataPointCount() >= this._max_svg){
        var temp = {};
        //TODO: currently, can not get property cateogry in geo chart by this._config.getChartPropCate(),
        //we use plotArea instead of this function 
        temp['plotArea'] = {
            animation: {
              dataLoading: false,
              dataUpdating: false
            }
        };
        Objects.extend(true, this._properties, temp);
      }
    },
    
    render : function(){
      //TODO: support empty data set in module level 
      if(this._data.emptyDataset() === true){
         return;
      }
      
      this._relayout(this.size());
      this._paint();
    },
    
    _localeChanged : function(){
      //update the data of modules to let the module have change to make up locale string again.
       var moduleManifest = this._config.modules;
         var ddata = dispatchData(moduleManifest.legend, this._data);
         if(ddata) {
            this._modules.legend.data(ddata);
         }
         ddata = dispatchData(moduleManifest.sizeLegend, this._data);
         if(ddata) {
            this._modules.sizeLegend.data(ddata);
         }
         ddata = dispatchData(moduleManifest.title, this._data);
         if(ddata) {
            this._modules.title.data(ddata);
         }
          this._modules.main.data(this._data); 
         
      this._updateAllProperties();
      this.render();
    },
    
    properties : function (_) {
      if ( !arguments.length ) {
        if (!this._propertiesIsNewest){
          this._outputProperties = extractProperties(this._modules, this._config.id);
          this._propertiesIsNewest = true;
        }
        return this._outputProperties;
      }
      this._propertiesIsNewest = false;
      this._inputProperties = _;
      
      //update properties
      this._updateAllProperties();
    },
    
    style : function (_) {
      if ( !arguments.length ) {
        return this._styleManager.style;
      }
      
      this._styleManager.update(parseCSS(_));
    },
    
    data : function (_) {
      if ( !arguments.length ) {
        return this._data;
      }
     
      this._data = _;
      
      this._effectManager.ghostEffect(this._data.fakeData());
      
      //currenty, we should update properties when reset dataset. As when change the component mode from svg to canvg, we should disable all animation
      this._updateAllProperties();
      
      //switch canvg mode to svg mode when change the size of dataset
      if(CanvgConfig.enableCanvg() &&this._data.dataPointCount() >= this._max_svg &&  this._compoennt_status === 'svg') { //svg => canvg
        //turn to canvg mode, switch  svg node and fake svg node
        //1. 
        this._root = this._d3Root;
        $(this._d3Root.node()).remove();
        this._d3Root = this._canvas_rootThreshold.select('svg');
        $(this._d3Root.node()).remove();
       // $(this._canvas_rootThreshold.node()).append(this._root.node());
        if(this._canvas_rootThreshold.select('svg').node() === null){
          this._canvas_rootThreshold.node().appendChild(this._root.node());
        }else{
          $(this._root.node()).insertBefore(this._canvas_rootThreshold.select('svg').node());
        }
        if(d3.select(this._container.get(0)).select('svg').node() === null){
          this._container.get(0).appendChild(this._d3Root.node());
        }else{
          $(this._d3Root.node()).insertBefore( d3.select(this._container.get(0)).select('svg').node());
        }
        
        this._compoennt_status = 'canvg';
      } else if (CanvgConfig.enableCanvg() && this._data.dataPointCount() < this._max_svg && this._compoennt_status === 'canvg'){// canvg => svg
        //clear the canvas and reset the size of canvas
        this._canvas_root.node().getContext('2d').clearRect(0, 0, this._canvas_root.node().width, this._canvas_root.node().height);
        this._canvas_root.style('width', 0), this._canvas_root.style('height', 0);
        this._canvas_root.attr('width', 0), this._canvas_root.attr('height', 0);
        
        this._d3Root = d3.select(this._container.get(0)).select('svg');
        this._root =  this._canvas_rootThreshold.select('svg');
        this._root.remove();
        $(this._root.node()).insertBefore(this._d3Root.node());
        this._canvas_rootThreshold.insert("svg", "svg").attr('width', this.size().width).attr('height', this.size().height);
        
        this._d3Root.remove();
        this._d3Root = this._root;
        this._compoennt_status = 'svg';
      }
      
      //redispatch data
      var moduleManifest = this._config.modules;
      var ddata = dispatchData(moduleManifest.legend, this._data);
      if(ddata) {
        this._modules.legend.data(ddata);
      }
      ddata = dispatchData(moduleManifest.sizeLegend, this._data);
      if(ddata) {
        this._modules.sizeLegend.data(ddata);  
      }
      ddata = dispatchData(moduleManifest.title, this._data);
      if(ddata) {
        this._modules.title.data(ddata);
      }
      
      this._modules.main.data(this._data);
      
      //after we reset data, we need update submodules as they may
      //have changed during data update
      //TODO a potential optimization here: if we split data update and schema data updata
      //we can skip module update when only data has been updated 
      this._updateSubModules(this._modules.main);
      this._updateSubControllers(this._modules.main);
    },
    
    modules : function () {
      return this._modules;
    },
    
    _relayout : function(newSize){
      this._doLayout(newSize);
      this._loadDependencies();
      //Jimmy/8/20/2012, scales may be different after dependencies have been resolved,
      //so we layout again to use the latest scales
      //see tablecontainer#158(//JIMMY/8/8/2012) for axis case. we also have the case for
      //bubble size legend. it should be able to be optimized in the future 
      this._doLayout(newSize, true);
    },
    
    // Callback invoked by platform upon the occurrence of a resizing event.
    doContentResize : function ( oldSize, newSize ) {
      this.callParent('doContentResize', oldSize, newSize);
      this.render();
    },
    
    _expandDependencyDefs : function(item){
      var defs = [];
      var sourceModule = item['sourceModule'];
      var targetModule = item['targetModule'];
      var expandedSourceModules = this._expandModulePath(sourceModule);
      var expandedTargetModules = this._expandModulePath(targetModule);
      if(expandedSourceModules.length > 1 && expandedTargetModules.length > 1){
        if(expandedSourceModules.length !== expandedTargetModules.length){
          Functions.error('Error on resolving dependency:' + sourceModule + ',' + targetModule);
        }else{
          for(var i = 0, len = expandedSourceModules.length; i < len; i++){
            defs.push({
              'sourceModule' : expandedSourceModules[i],
              'targetModule' : expandedTargetModules[i],
              'source' : item['source'],
              'target' : item['target'],
              'type' : item['type'],
              'listener' : item['listener']
            });
          }
        }
      }else{
        //we are sure that one of the loop will execute only once, and we don't care which one
        for(var n = 0, nlen = expandedSourceModules.length; n < nlen; n++){
          for(var j = 0, jlen = expandedTargetModules.length; j < jlen; j++){
            defs.push({
              'sourceModule' : expandedSourceModules[n],
              'targetModule' : expandedTargetModules[j],
              'source' : item['source'],
              'target' : item['target'],
              'type' : item['type'],
              'listener' : item['listener']
            });
          }
        }
      }
      
      //FIXME jimmy/8/8/2012 if both sourceModule and targetModule have
      //been expanded, and they have different number of items, what should
      //we do? do cartesian product? currently we simply throw exception
      return defs;
    },
    
    //nodeN.nodeN-1.nodeN-2...node1, for each nodeN,
    //if we have several entities for it, we should expand it
    _expandModulePath : function(path){
      var pathArray = path.split('.');
      var currentPrefix = [];
      var currentExpand = [];
      for(var i = 0, len = pathArray.length; i < len; i++){
        var j = 0, jlen = currentPrefix.length;
        do
          {
            var pathI = jlen > 0 ? [currentPrefix[j], pathArray[i]].join('.') : pathArray[i];
            if(TypeUtils.isArray(this._modules[pathI])){
              //we have to expand this, and we may have undefined items in the array
              for(var k = 0, klen = this._modules[pathI].length; k < klen; k++){
                if(this._modules[pathI][k]){
                  var newPrefix = jlen > 0 ? [currentPrefix[j], pathArray[i] + '[' + k + ']'].join('.') : pathArray[i] + '[' + k + ']';
                  currentExpand.push(newPrefix);
                }
              }
            }else{
              //put it in directly
              currentExpand.push(pathI);
            }
            j++;
          }
        while(j < jlen);
        var refTemp = currentPrefix;
        currentPrefix = [].concat(currentExpand);
        currentExpand.length = 0;
        refTemp.length = 0;
      }
      return currentPrefix;  
    },

    _expandModules : function(){
      var modules = this._modules;
      var result = [];
      for(var p in modules){
        if (modules.hasOwnProperty(p)) { 
          var m = modules[p];
          if(TypeUtils.isArray(m)) {
            for (var i = 0; i < m.length; i++) {
              result[p + '[' + i + ']'] = m[i];
            }
          } else {
            result[p] = m; 
          }
        }
      }
        
      return result;
    },
    
    // Configures various kinds of module dependencies.
    _loadDependencies : function () {
      var dependencies = this._config.dependencies, item, i;
      var attrs = dependencies.attributes || [],
          events = dependencies.events || [];
      
      var expandedDefs, expandedDef;
      
      // Resolve attributes.
      /*
     * [jimmy/8/8/2012]each node in the path may have several entities
     * like main.plot, we may create several main.plots
     * (here the xycontainer), by using 'main.plot.xAxis'
     * here we actually means for xAxis in each main.plot
     * 
     * in the future, we may need support more complicated dependency resolving
     * like 'the 3rd xycontainer's xAxis', can be described
     * as main.plot[2].xAxis
     */
      var modules = this._expandModules();
      
      for ( i = 0; i < attrs.length; i++ ) {
        item = attrs[i];
        if( item === null ){
          continue;
        }
        expandedDefs = this._expandDependencyDefs(item);
        for(var j = 0, jlen = expandedDefs.length; j < jlen; j++) {
          expandedDef = expandedDefs[j];
          if ( modules[ expandedDef['sourceModule'] ] && modules[ expandedDef['targetModule'] ] ) {
            if ( typeof modules[ expandedDef['sourceModule'] ][ expandedDef['source'] ] === 'function' &&
                 typeof modules[ expandedDef['targetModule'] ][ expandedDef['target'] ] === 'function' ) {
              modules[ expandedDef['targetModule'] ][ expandedDef['target'] ]( 
                modules[ expandedDef['sourceModule']][ expandedDef['source']]() );
            } else {
              Functions.error('dependency configuration error');
            }
          } else {
            Functions.error('dependency configuration error');
          }
        }
      }
      
      // Resolve events.
      for ( i = 0; i < events.length; i++ ) {
        item = events[i];
        expandedDefs = this._expandDependencyDefs(item);
        for(var n = 0, nlen = expandedDefs.length; n < nlen; n++) {
          expandedDef = expandedDefs[n];
          if ( modules[ expandedDef['targetModule'] ] && modules[ expandedDef['sourceModule'] ] ) {
            if ( typeof modules[ expandedDef['targetModule'] ][ expandedDef['listener'] ] === 'function' &&
                 typeof modules[ expandedDef['sourceModule'] ] === 'function' ) {
                   if(typeof modules[ expandedDef['sourceModule'] ].dispatch === 'function'){
                      modules[ expandedDef['sourceModule'] ].dispatch().on(expandedDef['type'] + '.' + expandedDef['targetModule'] + '.' + n, 
                        modules[ expandedDef['targetModule'] ][ expandedDef['listener'] ]);
                   } else {
                     Functions.error('dependency configuration error:' + expandedDef['sourceModule'] + ' does not support event!');
                   }
            } else {
              Functions.error('dependency configuration error');
            }
          } else {
            Functions.error('dependency configuration error: source or target does not exist!');
          }
        }
      }
    },
        
    _paint : function () {
      if ( this._modules.title ) {
        this._root.select('.title').call(this._modules.title);
      } 
      if ( this._modules.legend ) {
        this._root.select('.legend')
          .datum(this._modules.legend.data())
          .call(this._modules.legend);
      }
      if ( this._modules.sizeLegend ) {
        this._root.select('.sizeLegend')
          .datum(this._modules.sizeLegend.data())
          .call(this._modules.sizeLegend);
      }
      if ( this._modules.main ) {
        this._root.select('.main')
          .datum(this._modules.main.data())
          .call(this._modules.main);
      }
      
    },
    
    // Merge Ian Li's fix to make canvg waiting for chart modules' initialized event
    _exportToCanvas: function(){
      if(CanvgConfig.enableCanvg() && this._compoennt_status === 'canvg'){
        this._root.attr( 'height', this.size().height);
        this._root.attr('width', this.size().width);
        //set the d3root svg size to 0
        this._d3Root.attr( 'height', 0);
        this._d3Root.attr('width', 0);
        this._canvas_rootThreshold.selectAll('title').remove();
        if(canvg) {
          canvg(this._canvas_root.node(), this._canvas_rootThreshold.html(), { ignoreMouse: true, ignoreAnimation: true });
          
          this._dispatch.dataTruncation();
        }
      }
    },
    
    /**
     * Loops over events configuration of each module
     * and return the events types.
     * 
     * @function
     * @returns {Array} Array of supported event types
     */
    getSupportedEvents : function () {
      var events = [];
      var modules = this._config.modules;
      
      function getEventDefs( modules ) {
        for ( var m in modules ) {
          if ( modules.hasOwnProperty(m) ) {
            if(!modules[m]) {
                continue;
            }
              
            var module = manifest.module.get(modules[m].id);
            if ( module && module.events ) {
              events.push({
                sourceId : modules[m].id,
                source : {},
                evtTypes : module.events
              });
            }
            // Continue searching for composite module like a container
            if ( modules[m].modules ) {
                getEventDefs(modules[m].modules);
            } 
          }
        }
      }
      getEventDefs(modules);
      return events;
    },
    
    destroy : function(){
      langManager.removeListener(this._langManagerListener);
      this.removeFromSuperComponent();
    }
  });
  
  /* Represents the chart controller. */
  var ChartController = ObjectUtils.derive(UIController, {
    constructor : function ( options ) {
      this._parseOptions(options);
    },
    
    _parseOptions : function ( options ) {
      if ( !manifest.viz.get(options.vizType) ) {
        Functions.error('Invalid vizType');  
      } 
      this._dataset = options.dataset ? options.dataset : {};
      this._options = options.option;
      this._vizType = options.vizType;
      this._dataFeeding = options.feeding;
      this._style = options.style;
      this._events = options.events;
    },
    
    initUIComponent : function ( width, height ) {
      var config = manifest.viz.get(this._vizType);
    this._cc_component = new ChartComponent({
        id : 'rootComponent',
        data : this._dataset,
        dataFeeding : this._dataFeeding,
        config : config,
        options : this._options,
        clipToBound : true,
        size : { w : width, h : height },
        style : this._style,
        events : this._events
      });
        
      
      return this._cc_component;
    },
    
    getSupportedEvents : function () {
      return this._cc_component.getSupportedEvents();
    },
    
    setDataset : function ( dataset ) {
      this._cc_component.data(dataset);
    },
    
    doThemeChanged : function(){
      this._cc_component.themeChanged();
    },
    
    updateProperties : function (props) {
      this._cc_component.properties(props);
    },
    
    getProperties : function() {
      return this._cc_component.properties();
    },
    
    style : function () {
      return this._cc_component.style.apply(this._cc_component, arguments);
    },
    
    render : function(){
      this._cc_component.render();
    },
    
    destroy : function(){
      this._cc_component.destroy();
    },

    /**
     * [05-Jan-2013 Nick] FIXME Temp work around for datalabel when the chart animation is disabled
     */
    afterUIComponentAppear : function(){
      var props = this._cc_component.properties();
      var func;
      if(!props.plotArea || !props.plotArea.animation || !props.plotArea.animation.dataLoading){
        if(!this._cc_component.modules()){
           return;
        }
        
        var plot = this._cc_component.modules()['main.plot'];
        if(TypeUtils.isArray(plot)){
          for(var i = 0; i<plot.length; i++){
            if(TypeUtils.isExist(plot[i])){
              func = plot[i].modules()['plot'].afterUIComponentAppear;
              if(TypeUtils.isExist(func)){
                func();
              }
            }
          }
        }else{
          func = plot.afterUIComponentAppear;
          if(TypeUtils.isExist(func)){
            func();
          }
        }
      }
  }
    
  });
  
  /* Represents the application delegate class. */
  var AppDelegate = ObjectUtils.derive(VizAppDelegate, {
    appDidFinishLaunching : function ( app, launchOptions ) {
      // Format data set from data feeds.
      this._vc_vizType = launchOptions.vizType;
      this._vc_dataset = launchOptions.data.rawData;
      this._vc_feeding = launchOptions.feeding;
      this._vc_properties = launchOptions.options;
      var datapointCount =  this._vc_dataset.getDataPointCount();
      var vc_config = CanvgConfig.get(this._vc_vizType) ?CanvgConfig.get(this._vc_vizType) : {} ;
      this.max_canvas = CanvgConfig.enableCanvg() && vc_config.max_canvas ? vc_config.max_canvas : Number.POSITIVE_INFINITY;
      var dataAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding, this.max_canvas);
    this._controller = new ChartController({
          vizType : this._vc_vizType,
          dataset : dataAdapter,
          option : launchOptions.options, // Chart properties,
          style : launchOptions.style,
          events : launchOptions.events
    });  
      
      this.registerPublicMethod('update', this._vc_update);
      this.registerPublicMethod('destroy', this._vc_destroy);
      this.registerPublicMethod('getStyle', this._vc_getStyle);
    },
    
    _vc_createAdapter : function(vizType, rawData, feeding, upperLimit) {
      var feeder = Feeder(manifest.viz.get(vizType).allFeeds(true), rawData, feeding);
      var dataHandler = new BaseDataHandler(feeder, rawData, upperLimit);
      var feeds = feeder.getFeeds();
      var dataAdapter = new MultiAxesDataAdapter(feeder.getBindingInfo());
      dataAdapter.fakeData(rawData.hasFakeData());
      dataAdapter.emptyDataset(rawData.isEmptyDataset());
      dataAdapter.dataPointCount(rawData.getDataPointCount());
      var id, dataItems;
      for ( var i = 0, len = feeds.length; i < len; i++ ) {
      id = feeds[i].feedId();
        dataItems = dataHandler.getFeedValues(id);
        if(dataItems !== null){
          if(feeds[i].type() === "Dimension"){
            dataAdapter.addAnalysisAxis({values:dataItems, index: feeds[i].getIndex() - 1});
          }else{
            dataAdapter.addMeasureValuesGroup({values:dataItems, index: feeds[i].getIndex() - 1});
          }
        }     
      }
      return dataAdapter;
    },
    
    _vc_getStyle : function() {
      return this._controller.style();
    },
    
    _vc_update : function(updates) {
      if(updates){
        var needRender = false;
        //TODO Jimmy/9/19/2012 finish update property workflow
        //especially properties like 'numberOfDimensionsInColumn' which will
        //affect the structure, and ideally, we need merge all updates into one
        //function in each module, currently we still call them separately  
        if(updates.properties) {
          if(this._controller){
            this._vc_properties = updates.properties;
            this._controller.updateProperties(this._vc_properties);
            needRender = true;
          }
        }
        
        if(updates.style) {
            this._controller.style(updates.style);
            needRender = true;
        }
        
        if(updates.data || updates.feeding) {
          if(updates.data) {
              this._vc_dataset = updates.data;
          }
          if(updates.feeding) {
              this._vc_feeding = updates.feeding;
          }
          var newAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding, this.max_canvas);
          this._controller.setDataset(newAdapter);
          needRender = true;
        }
        if(needRender)
        {
          this._controller.render();
        }
      }
    },
    
    rootController : function () {
      return this._controller;
    },
    
    getSupportedEvents : function () {
      return this._controller.getSupportedEvents();
    },
    
    setDataset : function ( dataset ) {
      this._vc_dataset = dataset;
      var newAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding);
      this._controller.setDataset(newAdapter);
    },
    
    getDataset : function (){
      return this._vc_dataset;
    },
    
    updateProperties : function (props) {
      if(this._controller){
        this._vc_properties = props;
        this._controller.updateProperties(this._vc_properties);
      }
    },
    
    getProperties : function() {
      return this._controller.getProperties();
    },
    
    _vc_destroy : function(){
      this._controller.destroy();
    }    
  });
  
  var riv = 
  /**
     * @lends sap.viz.core
     */
  {
        /**
         * @constructs
         */
        constructor : function() {

        },
        
        /**
         * @ignore 
         */
        instances : [], // Stores references to chart applications for easy processing of global events.
        
        /**
         * The main entry point of creating a chart.
         * @param {Object} usrOptions
         * <pre>
         * {
         *   type: 'viz/bar', //see propDoc.html for all supported viz chart types
         *   options: {}, //see propDoc.html for all supported options for each viz type
         *   style: {}, //see propDoc.html for all supported css items for each viz type
         *   container: HTMLDivElement, // HTMLDivElement is the container of viz chart in html
         *   data: {@link sap.viz.data.CrosstableDataset},
         *   feeding: {@link sap.viz.VizInstance#feeding}
         * }
         * </pre>
         * @returns {Object} vizApplication instance {@link sap.viz.VizInstance}
         */
        createViz : function ( usrOptions ) {
          var _eventsListeners = {}; //holder event lister
          var _feeding = usrOptions.feeding;
          
          var viz = 
          /**
           * @lends sap.viz.VizInstance.prototype
           */
          {
            /**
             * it can only be created by {@link sap.viz.core}
             * @constructs
             */
            constructor : function() {
    
            },
            
            /**
             * add event listener. one eventType can only have one listener, to register multiple listeners to a certain eventType you
             * have to add additional namespace after the eventType, such as 'selectData.foo' or 'selectData.bar'
             * @param {String} evtType see propDoc.html for supported events for each kind of chart
             * @param {Function} callback listener function
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            on : function ( evtType, callback, scope ) {
              _eventsListeners[evtType] = {
                  callback : callback,
                  scope: scope
              };
              viz.app.getDelegate().rootController().rootUIComponent().attachEvent(evtType, callback, scope);
              
              return viz;
            },
            
            /**
             * Get/set chart size.
             * @param {Object} size {width:xx, height:xx}
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            size : function (size) {
              if ( !arguments.length ) {
                  return viz.app.size();  
              }
              viz.app.size(size);
              
              return viz;
            },
            
            /**
             * Get/set chart data.
             * @param {Object} data {@link sap.viz.data.CrosstableDataset} 
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            data : function (data) {
              if ( !arguments.length ) {
                  return viz.app.getDataset();  
              }
              viz.update({
                data : data
              });
              
              //rebind event listener as upon data update, sub plots may be recreated
              for(var evt in _eventsListeners){
               if(_eventsListeners.hasOwnProperty(evt)){
                 viz.on(evt, _eventsListeners[evt].callback, _eventsListeners[evt].scope);
               }
              }
              
              return viz;
            },
            
            /**
             * Get/set chart properties.
             * @ignore
             * @param {Object} props see propDoc.html
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            properties : function (props) {
              if ( !arguments.length ){
                return viz.app.properties();  
              } 
              viz.update({
                properties : props
              });
              
              return viz;
            },
            
            /**
             * Get/set chart style.
             * @param {Object} style the style object
             * @returns {Object} {@link sap.viz.VizInstance}
             * @example
             * chartInstance.style({
             *  '.viz-title-label' : {
             *      fill : '#FF0000'
             *   }
             * });
             */
            style : function (style) {
              if ( !arguments.length ){
                return viz.app.invokePublicMethod('getStyle');  
              } 
              viz.update({
                style : style
              });
              
              return viz;
            },
            
            /**
             * Get/set data feeding info
             * @param {Object} feedingObj in the following structure: 
             *  <pre>
             *  {
                  'feedid'   : feedid  // feed id for example 'RegionColor', see propDoc.html
                  'binding'   :[ {
                      'type' : 'analysisAxis' | 'measureValueGroup' | 'measureNamesDimension',
                      'index':  Number 
                  }]
                }
                </pre>
               @returns {Object} {@link sap.viz.VizInstance} 
             */
            feeding : function(feedingObj) {
              if( !arguments.length ) {
                  return _feeding;
              } 
              
              _feeding = feedingObj;
              viz.update({
                feeding : feedingObj
              });
              
              return viz;
            },
            
            /**
             * Update various items in one go.
             * @param {Object} updates {data: {@link sap.viz.data.CrosstableDataset}, feeding: feedingObj, style: cssObject}
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            update : function ( updates ) {
              if(updates){
                //we actually support use a null value to clear current feeding and switch to use
                //auto feed
                if(TypeUtils.isDefined(updates.feeding)) {
                  _feeding = updates.feeding;
                }
                viz.app.invokePublicMethod('update', updates);
              }
              return viz;
            },
            

            /**
             * Destroy this chart instance. This will remove all dom
             * nodes of chart and its listeners.
             */
            destroy : function() {
              riv.instances.splice(riv.instances.indexOf(this), 1);
              viz.app.invokePublicMethod('destroy');
            },
            
            /**
             * export chart instance into a JSON object which contains
             * all information of the chart including type, data, properties
             * style, feeding and size
             */
            toJSON : function() {
              var doc = {};
              doc.type = usrOptions.type;
              doc.data = viz.app.getDataset();
              doc.properties = viz.app.properties(); 
              doc.style = viz.app.invokePublicMethod('getStyle');
              doc.feeding = _feeding;
              doc.size = viz.app.size();
              return doc;	
            }
          };
          
          var template = TemplateManager.current();
          
          var type = usrOptions.type;
          
          viz.app = new VizApplication({
            wrapperDivEl : usrOptions.container,
            delegateClass : AppDelegate,
            launchOption : {
              vizType : type,
              options : Objects.extend(true, null, template.props(type), usrOptions.options),
              style : Objects.extend(true, null, template.css, parseCSS(usrOptions.style)),
              data : { rawData : usrOptions.data },
              feeding : usrOptions.feeding || usrOptions.dataFeeding, /* dataFeeding for backward compatibility*/ 
              events : usrOptions.events
            }
          });          

          Object.defineProperty(viz, "type", {
            value : type,
            enumerable : true
          });
          
          viz.app.getDelegate = function () {
            return this._delegate;
          };
          riv.instances.push(viz);
          return viz;
        },
        
        /**
         * Destroy chart.
         * @param {Object...} viz instances to be destroyed
         */
        destroyViz : function(){
          for(var i=-1, j = arguments.length;++i<j;) {
              arguments[i].destroy(); 
          }
        },
        
        /**
         * load chart from JSON into a div
         * @param {Object...} viz json document
         * @param {Object...} div object to contain the visualization
         */
        loadViz : function(doc, container){
          var option = {};
          option.container = container;
          option.type = doc.type;
          option.options = doc.properties;
          option.data = doc.data;
          option.style = doc.style;
          option.feeding = doc.feeding;
           
          this.createViz(option); 
        },
        
        /**
         * export chart instance into a JSON object which contains
         * all information of the chart including type, data, properties
         * style, feeding and size
         * @param {Object...} {@link sap.viz.VizInstance}
         */
        exportViz : function(chart){
          return chart.toJSON();           
        }
  }; 
  
  return riv;
});sap.riv.module(
{
  qname : 'sap.viz.env',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Logger',
  version : '4.0.0'
},
{  qname : 'sap.viz.config',
  version : '4.0.0'
},
{  qname : 'sap.viz.Locale',
  version : '4.0.0'
}
],
function Setup(TypeUtils, LOG,  config, Locale) {
    var _setLogLevel = function(_level) {
        if(TypeUtils.isExist(_level)) {
            LOG.setLevel(_level);
        }
    };
    var _initLogger = function(options) {
        if(!options) {
            return;
        }
            
        if(options.enable) {
            LOG.enable();
        }
           
        if(!options.appenders){
             return;
        }
           
        for(var i = 0, l = options.appenders.length; i < l; i++) {
            var appender = options.appenders[i];
            if(appender.appenderKey) {
                 LOG.addAppender(appender.appenderKey, appender.appender);    
            }
               
            else {
                 LOG.addAppender(appender.appender);
            }
               
        }
        // LOG.addAppender('analyzerAppender', new AnalyzerAppender());
        // LOG.addAppender("ajaxApp", new LOG.AjaxAppender("http://localhost:8800"));
        // LOG.getAppender("ajaxApp").setLevel(LOG.LEVEL.DEBUG);
        //LOG.getAppender("[default]").setLevel(_level);
    };
    
    var _initLocal = function(options, callback){
      Locale.locale(options.locale, callback);
    };
    
    var env =
    /**
     * @lends sap.viz.Environment
     */
    {
        /**
         * @constructs
         */
        constructor : function() {

        },
        /**
         * initialize visualization environment
         * @param {Object}
         *            option {locale:'en_US'}
         *
         */
        initialize : function(option, callback) {
          if (!option) {
              return;  
          }
            _initLogger(option.log);
            if (option.locale){
              _initLocal(option, callback);
            } else {
                   if(callback) {
                       callback.call();
                   }
            }
            config.enableCanvg(option.enableCanvg);
            // _setLogLevel(option.log);
        },
        
        /**
         * @ignore
         * @param enable
         */
        setLoggerEnable : function(enable) {
            if(enable === true) {
                 LOG.enable();
            }
               
            else if(enable === false) {
                 LOG.disable();    
            }
               
        },
        
        /**
         * @ignore
         * @returns TODO: add desc
         */
        addLogAppender : function() {
            if(arguments.length === 1) {
                return LOG.addAppender(arguments[0]);
            }
                
            else if(arguments.length === 2) {
                return LOG.addAppender(arguments[0], arguments[1]);
            }
               
        },
        
        /**
         * @ignore
         * @param key
         * @returns TODO: add desc
         */
        removeLogAppender : function(key) {
            return LOG.removeAppender(key);
        }
    };

    return env;
});sap.riv.module(
{
  qname : 'sap.viz.util.LogAnalyzer',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.0'
}
],

function Setup(LinkedHashMap) {
    
    var firstChartStartTime;
    var chartStartTime = {};
    var chartAppMap = {};
    var chartAppComMap = {};
    var chartMap = new LinkedHashMap();
    var chartStartP = /Chart\[(.+?)\]\sinitializing\./;
    var chartMapP = /Chart\[(.+?)\]application\[(.+?)\]\sinitialized\./;
    var chartAppComMapP = /application\[(.+?)\]component\[(.+?)\]\sinitialized\./;
    var chartSubP = /chartComponent\[(.+?)\]subComponent\[(.+?)\]initialized\./;
    var comP = /layer\[(.+?)\]rendering\send\./;
    var timeP = /#(\d+)#/;

    function chartFinished(comItr) {
        while(comItr.hasMore()) {
            if(comItr.nextValue() === -1)
                return false;
        }
        return true;
    }

    function max(nums) {
        var m = nums[0];
        var length = nums.length;
        for(var i = 1; i < length; i++) {
            m = nums[i] > m ? nums[i] : m;
        }
        return m;
    }
    
    function formatMsg(logTime, logLevel, logCate, logMsg) {
        return '#' + logTime + '#' + logMsg;
    }

    var LogAnalyzer = {
        analyze : function(logTime, logLevel, logCate, logMsg) {
            if(logCate!=="perf")
                return;
            var log = formatMsg(logTime, logLevel, logCate, logMsg);
            var m = chartStartP.exec(log);
            if(m) {
                var st = timeP.exec(log)[1];
                chartStartTime[m[1]] = st;
                firstChartStartTime = firstChartStartTime || st;
                return;
            }
            m = chartAppComMapP.exec(log);
            if(m) {
                chartAppComMap[m[2]] = m[1];
                return;
            }
            m = chartMapP.exec(log);
            if(m) {
                chartAppMap[m[2]] = m[1];
                return;
            }
            m = chartSubP.exec(log);
            if(m) {
                if(!chartMap.has(m[1])) {
                    chartMap.add(m[1], new LinkedHashMap());
                }
                chartMap.get(m[1]).add(m[2], -1);
                return;
            }
            m = comP.exec(log);
            if(m) {
                var timeStamp = timeP.exec(log)[1];
                var chartItr = chartMap.getIterator();
                while(chartItr.hasMore()) {
                    var chart = chartItr.next();
                    var componentMap = chart.value;
                    if(componentMap.has(m[1]) && componentMap.get(m[1]) === -1) {
                        componentMap.add(m[1], timeStamp);
                        var comItr = componentMap.getIterator();
                        if(chartFinished(comItr)) {
                            comItr.reset();
                            var endTimes = [];
                            while(comItr.hasMore()) {
                                endTimes.push(comItr.nextValue());
                            }
                            var chartKey = chartAppMap[chartAppComMap[chart.key]];
                            var start = chartStartTime[chartKey], end = timeStamp;
                            chartMap.remove(chart.key);
                            return ("chart[" + chartKey + "] start time:" + start + " end time:" + end + " time consume[" + (end - start) + "] total consume["+(end - firstChartStartTime)+"]");
                        }
                    }
                }
            }
        }
    };
    return LogAnalyzer;
});sap.riv.module(
{
  qname : 'sap.viz.modules.axis.DataModule',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(TextUtils, NumberUtils) {

    var reBuildDataModule = function(_options)
    {
        var dataModule = null;
        console.log("reBuildDataModule");
        return dataModule;
    };

    return ({
        //public functions
        reBuildDataModule : reBuildDataModule,
    });
});sap.riv.module(
{
  qname : 'sap.viz.data.description.AnalysisAxis',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.data.description.DimensionLabels',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
 function Setup(DimensionLabels, FunctionUtils, TypeUtils){
   
   var AnalysisAxis = function(data){
     this._dimensionLabels = [];
     this.init(data);
    
   };
   
   AnalysisAxis.prototype.init = function(data){
     
       for(var i = 0; i < data.length; i++){
         this._dimensionLabels[i] = new DimensionLabels(data[i]["name"], data[i]["type"]? data[i]["type"] : "Dimension",
                                                    data[i]["values"] );
         
         this._dimensionLabels[i].fake( data[i]["isFake"] ? data[i]["isFake"] : false);
         this._dimensionLabels[i].infos( data[i]["infos"] ? data[i]["infos"] : null);
       }
   };
   
   AnalysisAxis.prototype.getDimensionLabels = function(){
     return this._dimensionLabels;
   };
   
   AnalysisAxis.prototype.getType = function(){
     return "analysisAxis";
   };
   
   AnalysisAxis.prototype.validate  = function(){
      
      var labels = 1;
      var dimensions = this.getDimensionLabels();
      for(var i = 0; i < dimensions.length;i++){
        if(i === 0){
           labels = dimensions[i].getValues().length;
           if(TypeUtils.isExist(dimensions[i].infos()) && labels !== dimensions[i].infos().length){
              FunctionUtils.error(dimensions[i].getId() + " wrong infos count");
           }
        }
        else{
         if(labels !== dimensions[i].getValues().length){
            FunctionUtils.error(dimensions[i].getId() + " wrong dimension labels count");
         }
         
         if(TypeUtils.isExist(dimensions[i].infos()) && labels !== dimensions[i].infos().length){
                FunctionUtils.error(dimensions[i].getId() + " wrong infos count");
         }
        }
      }
      
      return labels;
     
   };
   
   AnalysisAxis.prototype.hasFakeData = function(){
      var dimensions = this.getDimensionLabels();
      for(var i = 0; i < dimensions.length;i++){
        if(dimensions[i].fake()){
           return true;
        }
      }
      
      return false;
   };
   
   return AnalysisAxis;
 });sap.riv.module(
{
  qname : 'sap.viz.data.description.MeasureValues',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.description.DataContainer',
  version : '4.0.0'
}
],
 function Setup(ObjUtils, DataContainer){
   
   /**
    * @private
    * @name sap.viz.data.description.MeasureValues
    */
     var MeasureValues = ObjUtils.derive(DataContainer, {
      
       /** 
        * @constructor
        * @param uid    identifier of measure values, usually name
        * @param values 
        */
       constructor : function ( uid, values ) {
           this._values = values;
       },
       
         getValues : function(){
           return this._values;
         }
    
    });
     
     
     
     return MeasureValues;
});sap.riv.module(
{
  qname : 'sap.viz.data.description.MeasureValuesGroup',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.data.description.MeasureValues',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
 function Setup(MeasureValues, FunctionUtils){
   
   var MeasureValuesGroup = function(data){
       this._measureValues = [];
       this.init(data);
   };
   
   MeasureValuesGroup.prototype.init = function(data){
     
       for(var i = 0; i < data.length; i++){
           this._measureValues[i] = new MeasureValues(data[i]["name"], data[i]["values"]);
           this._measureValues[i].fake(data[i]["isFake"] ? data[i]["isFake"] : false);
           this._measureValues[i].infos(data[i]["infos"] ? data[i]["infos"] : null);
       }
   };
   
   MeasureValuesGroup.prototype.getMeasureValues = function(){
       return this._measureValues;
   };
   
   MeasureValuesGroup.prototype.getType = function(){
       return "measureValuesGroup";
   };
   
   MeasureValuesGroup.prototype.validate  = function(labels){
       
      var measures, value, i, j;
      if (!arguments.length){
        var label = [1,1];
        measures = this.getMeasureValues();
        for(i = 0; i < measures.length;i++){
          value = measures[i].getValues();
          if(i === 0){
           if(value.length !== label[1]){
              FunctionUtils.error(measures[i].getId() + " wrong values count in aa2. should be " + label[1]);
           }
           
           label[0] = value[0].length;
           
          }else{
            if(value.length !== label[1]){
               FunctionUtils.error(measures[i].getId() + " wrong values count in aa2. should be " + label[1]);
            }
            
            for(j = 0; j < value.length; j++){
              if(value[j].length !== label[0] ){
                 FunctionUtils.error(measures[i].getId() + " wrong values count in aa1. should be " + label[0]);
              }
            }  
          }
          
        }
        
        return label;
        
      }else{
        measures = this.getMeasureValues();
        for(i = 0; i < measures.length;i++){
          value = measures[i].getValues();
          if(value.length !== labels[1]){
             FunctionUtils.error(measures[i].getId() + " wrong values count in aa2. should be " + labels[1]);
          }
          
          for(j = 0; j < value.length; j++){
            if(value[j].length !== labels[0] ){
               FunctionUtils.error(measures[i].getId() + " wrong values count in aa1. should be " + labels[0]);
            }
          }
        }
      }
     
   };
   
   MeasureValuesGroup.prototype.hasFakeData = function(){
      var measures = this.getMeasureValues();
      for(var i = 0; i < measures.length;i++){
        if(measures[i].fake()){
           return true;
        }
      }
      
      return false;
   };
   
   return MeasureValuesGroup;
 });sap.riv.module(
{
  qname : 'sap.viz.data.info.Handler',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(ObjectUtils, TypeUtils) {
  var ANALYSISAXIS = "analysisAxis";
  var MEASUREVALUESGROUP = "measureValuesGroup";
  var handler = {};
  var _handlers = {};
  /*
   {
   'analysisAxis': [{
   'index': 1,
   'data': [{
   'name': 'Product',
   'values': ['Car', 'Truck', 'Motorcycle', 'Bicycle']
   }]
   }, {
   'index' : 2,
   'data': [{
   'name': 'Country',
   'values': ['China', 'USA']
   }, {
   'name': 'Year',
   'values': ['2001', '2001']
   }]
   }],
   'measureValuesGroup': [{
   'index': 1,
   'data': [{
   'name': 'Profit',
   'values': [[25, 136, 23, 116], [58, 128, 43, 73]]
   }, {
   'name': 'Revenue',
   'values': [[50, 236, 43, 126], [158, 228, 143, 183]]
   }]
   }]};
   * */
  
  function findInJson(jsondata, targetname){
    var anax = jsondata[ANALYSISAXIS].concat(jsondata[MEASUREVALUESGROUP]);
    var ret = [];
    anax.forEach(function(ana, idx){
      var anad = ana.data;
      anad.forEach(function(d, didx){
        if(d.name === targetname){
          ret.push(d);
        }
      }, this);
    }, this);
    return ret;
  }
  
  var customlabel = {
    'type' : 'customlabel',
    /*'value': [{
     'name': 'Country', //dimension name
     'mapping': {'CHN', {'type': 'url', 'val': 'http://xxxx/xxxx.png'},
     'GER', {'type': 'string', 'val': 'Germany'},
     'FRA', {'type': 'string', 'val': 'France'}} //support both string and url
     }] //you can have several mappings, it will be merged inside crosstable dataset. no info will be created (existed will be deleted) if the mapping value is same as the original value.*/
    'process' : function(value, jsondata) {
      var iterate, dname, finds, mapping, m, dvalues, mappingfound, removeinfo;
      for(var i = 0, len = value.length; i < len; i++) {
        iterate = value[i];
        dname = iterate.name;
        finds = findInJson(jsondata, dname);
        finds.forEach(function(d, tdidx) {
          //if no infos exist, create one, delete it if no info found
          mappingfound = false;
          if(!d.infos){
            removeinfo = true;
            d.infos = [];
          }
          
          dvalues = d.values;          
          mapping = iterate.mapping;
          dvalues.forEach(function(v, idx) {
            if(mapping[v]){
              if(mapping[v].type === 'string' && mapping[v].val === v){
                //we won't create mapping for it. existing mapping should be deleted
                if(d.infos[idx]){
                  delete d.infos[idx][customlabel.type];
                  //if it becomes empty, set it to undefined
                  if(TypeUtils.isEmptyObject(d.infos[idx])){
                    d.infos[idx] = undefined;
                  }
                } 
              }else{
                mappingfound = true;
                d.infos[idx] = d.infos[idx] ? d.infos[idx] : {};
                d.infos[idx][customlabel.type] = mapping[v];  
              }
            }else{
              if(!d.infos[idx]){
                d.infos[idx] = undefined;
              }
            }  
          }, this);

          if(removeinfo && !mappingfound){
            delete d.infos;
          }
        }, this);
      }
    },
    
    'merge' : function(jsondata){
      var ret = {};
      ret.type = customlabel.type;
      ret.value = [];
      var anax = jsondata[ANALYSISAXIS];
      var found;
      anax.forEach(function(ana, idx){
        var anad = ana.data;
        anad.forEach(function(d, didx){
          if(d.infos){
            var dmapping = {};
            dmapping.name = d.name;
            dmapping.mapping = {};
            found = false;
            d.infos.forEach(function(dinfo, dinfoidx){
              if(dinfo && dinfo[customlabel.type]){
                found = true;
                dmapping.mapping[d.values[dinfoidx]] = dinfo[customlabel.type];
              }
            }, this);
            if(found){
              ret.value.push(dmapping);
            }
          }
        }, this);
      }, this);
      if(ret.value.length > 0){
        return ret;
      }  
    },
    
    'remove' : function(jsondata){
      var anax = jsondata[ANALYSISAXIS];
      var stillHasInfo = false;
      anax.forEach(function(ana, idx){
        var anad = ana.data;
        anad.forEach(function(d, didx){
          if(d.infos){
            stillHasInfo = false;
            d.infos.forEach(function(dinfo, dinfoidx){
              if(dinfo){
                delete dinfo[customlabel.type];
                if(TypeUtils.isEmptyObject(dinfo)){
                  d.infos[dinfoidx] = undefined;
                }else{
                  stillHasInfo = true;
                }
              }
            }, this);
            if(!stillHasInfo){
              delete d.infos;
            }
          }
        }, this);
      }, this);
    }
  };

  handler.register = function(hndl) {
    _handlers[hndl.type] = hndl;
  };

  handler.get = function(type) {
    return _handlers[type];
  };
  
  /*
   * call each handler to extract corresponding info to an object and return
   */
  handler.mergeInfo = function(jsondata){
    var iter, ret = [], mr;
    for(var type in _handlers){
      if(_handlers.hasOwnProperty(type)){
        iter = _handlers[type];
        mr = iter.merge(jsondata);
        if(mr){
          //return a copy, intend to use ObjectUtils as we want to deep copy the array
          ret.push(ObjectUtils.extend(true, {}, mr));
        }
      }
    }
    return ret;
  };
  
  handler.register(customlabel);
  
  return handler;

});sap.riv.module(
{
  qname : 'sap.viz.data.CrosstableDataset',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.description.AnalysisAxis',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.description.MeasureValuesGroup',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.info.Handler',
  version : '4.0.0'
}
],
 function Setup(Feeder, TypeUtils, FunctionUtils, AnalysisAxis, MeasureValuesGroup, Handler){
 
   var TYPE   =    'type';
   var NAME   =    'name';
   var VALUES =    'values';
   
   var FEEDID =  'feedId';
   var MND    =  'MeasureNamesDimension';
   
   var ANALYSISAXIS = "analysisAxis";
   var MEASUREVALUESGROUP = "measureValuesGroup";
      
   function getMeasureValueDataPointCount(measureValue){
         var values = measureValue.getValues();
     
         return values.length > 0 ? values.length * values[0].length : 0;
   }
   
   /**
    * @name sap.viz.data.CrosstableDataset
    * @constructor
     */
   function crossTableDataSet(){
        this._analysisAxis = [];
        this._measureValuesGroup = [];
        this._dataSet = {};
        this._emptyDataset = false;
   }
   
   /**
    * Get/Set data
    * @name sap.viz.data.CrosstableDataset#data
    * @param data
    *        data with metaData and rawData
    * @returns {Object} {@link sap.viz.data.CrosstableDataset}
    */
   crossTableDataSet.prototype.data = function(data){
     if(!arguments.length){
       return this._dataSet;
     }
     this._analysisAxis = [];
     this._measureValuesGroup = [];
     this._dataSet = data;
     this.init(this._dataSet);
     return this;
   };
   
   //@deprecated
   crossTableDataSet.prototype.setData = function(in_data){
     this.data(in_data);
   };
   
   /**
    get/set additional info for the crosstable dataset
    @param {Object}info {
       'type': 'customlabel'|'geo'
       'value': [{
          'name': 'Country', //dimension name
          'mapping': {'CHN', {'type': 'url', 'val': 'http://xxxx/xxxx.png'},
                      'GER', {'type': 'string', 'val': 'Germany'},
                      'FRA', {'type': 'string', 'val': 'France'}} //support both string and url
       }] //you can have several mappings, it will be merged inside crosstable dataset. no info will be created (existed will be deleted) if the mapping value is same as the original value.
    }
    @returns {Object} return a copy of current additional info if no param provided
   */
   crossTableDataSet.prototype.info = function(info){
     if(!arguments.length){
       return Handler.mergeInfo(this._dataSet);
     }
     
     if(info && info.type){
       var handler = Handler.get(info.type);
       if(handler){
         handler.process(info.value, this._dataSet);
       }
       //Jimmy, 12/28/2012, AnalysisAxis reads info reference from this._dataset.
       //here the reference may be deleted (in clearInfo) and recreated(here), to make sure AnalysisAxis
       //still can get the right infos, we recreate them.
       //or we can optimize it to save infos in analysisAxis and merge them when we get data and info?
      this._analysisAxis = [];
      this._measureValuesGroup = [];
      this.init(this._dataSet);
     }
     return this;
   };
   
    /**
      clear specific additional info for the crosstable dataset
      @param {String}type "customlabel"||"geo" 
    */
    crossTableDataSet.prototype.clearInfo = function(type){
      if(type){
       var handler = Handler.get(type);
       if(handler){
         handler.remove(this._dataSet);
       }
      }
      return this;  
    };
   
   crossTableDataSet.prototype.init = function(data){
      if(!data || !data[MEASUREVALUESGROUP] || (data[ANALYSISAXIS] && !data[MEASUREVALUESGROUP])){
       //FIX ME Remove when multihandler is available
       return;// FunctionUtils.error("dataset is empty or invalid");
      }
      var aaLabels = [1,1];

      
      var axes = data[ANALYSISAXIS];
      var i = 0;
      var mvgs, mvg, mv;
      if(axes){
        if(axes.length > 2){
         FunctionUtils.error("could not accept more than 2 axes");
        }
        
        for(;i < axes.length; i++){
          var axis = axes[i];
          var axisIndex = axis["index"];
          if(axisIndex !== 1 && axisIndex !== 2){
           FunctionUtils.error("Axis index should be 1 or 2");
          }
          
          if(this._analysisAxis[axisIndex - 1]){
           FunctionUtils.error("Axis " + axisIndex + " already exists");
          }
          
          var aa = new AnalysisAxis(axis["data"]);
          aaLabels[axisIndex - 1] = aa.validate();
          this._analysisAxis[axisIndex - 1] = aa;
          
        }
        
       //TODO handle if only meta data exist in data set when layout
       if(aaLabels[0] === 0){
          aaLabels[1] = 0;
          this._emptyDataset = true;
       }

        mvgs = data[MEASUREVALUESGROUP];
        for(i = 0;i < mvgs.length; i++){
          mvg = mvgs[i];
          var mvgIndex = mvg["index"];
          if(this._measureValuesGroup[mvgIndex - 1]){
            FunctionUtils.error("MeausreValuesGroup " + mvgIndex + " already exists");
          }
          
          mv =  new MeasureValuesGroup(mvg["data"]);
          mv.validate(aaLabels);
          this._measureValuesGroup[mvgIndex - 1] = mv;
        }
      }else{ // no axes case
        
        mvgs = data[MEASUREVALUESGROUP];
        for(i = 0;i < mvgs.length; i++){
          mvg = mvgs[i];
          mv =  new MeasureValuesGroup(mvg["data"]);
          if(i === 0){
            aaLabels = mv.validate();
          }  
          else{
            mv.validate(aaLabels);
          }
          
          this._measureValuesGroup[mvg["index"] - 1] = mv;
        }
      }
      
      
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getAnalysisAxisCount
    * @ignore 
    */
   crossTableDataSet.prototype.getAnalysisAxisCount = function(){
      return this._analysisAxis.length;    
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getAnalysisAxisByIdx
    * @ignore
    * @param index 
    */
   crossTableDataSet.prototype.getAnalysisAxisByIdx = function(index){
     return this._analysisAxis[index];
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getMeasureValuesGroupCount
    * @ignore 
    */
   crossTableDataSet.prototype.getMeasureValuesGroupCount = function(){
      return this._measureValuesGroup.length;    
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getMeasureValuesGroupByIdx
    * @ignore
    * @param index 
    */
   crossTableDataSet.prototype.getMeasureValuesGroupByIdx = function(index){
     return this._measureValuesGroup[index];
   };
   
   /**
      * @name sap.viz.data.CrosstableDataset#hasFakeData
      * @ignore
      */
   crossTableDataSet.prototype.hasFakeData = function(){
     for(var i = 0; i < this._measureValuesGroup.length; i++){
       if(this._measureValuesGroup[i].hasFakeData()){
        return true;
       }
     }
     
     for(i = 0; i < this._analysisAxis.length; i++){
       if(this._analysisAxis[i].hasFakeData()){
        return true;
       }
     }
     
     return false;
   };
   
   /**
      * @name sap.viz.data.CrosstableDataset#getDataPointCount
      * @ignore
      */
   crossTableDataSet.prototype.getDataPointCount = function(){
     
     var dpCount = 0;
     var mvDPCount = getMeasureValueDataPointCount(this._measureValuesGroup[0].getMeasureValues()[0]);
     for(var i = 0; i < this._measureValuesGroup.length; i++){
       dpCount +=  mvDPCount * this._measureValuesGroup[i].getMeasureValues().length;
     }
     
     return dpCount;
   };
   
    /**
      * @name sap.viz.data.CrosstableDataset#isEmptyDataSet
      * @ignore
    */
   crossTableDataSet.prototype.isEmptyDataset = function(){
      return this._emptyDataset;
   };
   
    return crossTableDataSet;
 });sap.viz.lang.langManager.register({id:'dev',value: {IDS_DEFAULTMND:"All Measures",IDS_DEFAULTCHARTTITLE:"Title of Chart",IDS_ISNOVALUE:"No value",IDS_BARCHART:"Bar Chart",IDS_COMBINATIONCHART:"Combined Column Line Chart",IDS_DUALBARCHART:"Bar Chart with 2 X-Axes",IDS_DUALCOMBINATIONCHART:"Combined Column Line Chart with 2 Y-Axes",IDS_DUALHORIZONTALCOMBINATIONCHART:"Combined Bar Line Chart with 2 X-Axes",IDS_DUALHORIZONTALLINECHART:"Horizontal Line Chart with 2 X-Axes",IDS_DIUALLINECHART:"Line Chart with 2 Y-Axes",IDS_DUALPERCENTAGESTACKEDBARCHART:"100% Stacked Bar Chart with 2 X-Axes",IDS_DUALSTACKEDVERTICALBARCHART:"Stacked Column Chart with 2 Y-Axes",IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART:"100% Stacked Column Chart with 2 Y-Axes",IDS_DUALSTACKEDBARCHART:"Stacked Bar Chart with 2 X-Axes",IDS_DUALVERTICALBARCHART:"Column Chart with 2 Y-Axes",IDS_HORIZONTALBOXPLOTCHART:"Horizontal Box Plot",IDS_HORIZONTALCOMBINATIONCHART:"Combined Bar Line Chart",IDS_HORIZONTALLINECHART:"Horizontal Line Chart",IDS_HORIZONTALWATERFALLCHART:"Horizontal Waterfall Chart",IDS_HORIZONTALSTACKEDWATERFALL:"Horizontal Stacked Waterfall Chart",IDS_LINECHART:"Line Chart",IDS_PERCENTAGESTACKEDBARCHART:"100% Stacked Bar Chart",IDS_PERCENTAGESTACKEDVERTICALBARCHART:"100% Stacked Column Chart",IDS_SPARKLINECHART:"Spark Line Chart (POC)",IDS_STACKEDBARCHART:"Stacked Bar Chart",IDS_STACKEDVERTICALBARCHART:"Stacked Column Chart",IDS_STACKEDWATERFALLCHART:"Stacked Waterfall Chart",IDS_VARIANTBARCHART:"Variant Bar Chart (POC)",IDS_VERTICALBARCHART:"Column Chart",IDS_VERTICALBOXPLOTCHART:"Box Plot",IDS_WATERFALLCHART:"Waterfall Chart",IDS_DONUTCHART:"Donut Chart",IDS_PIECHART:"Pie Chart",IDS_BASEBUBBLECHART:"Base Scatter Chart",IDS_BUBBLECHART:"Bubble Chart",IDS_SCATTERCHART:"Scatter Plot",IDS_BASECHART:"Base Chart",IDS_BASEHORIZONTALCHART:"Base horizontal XY Chart",IDS_BASEVERTICALCHART:"Base Vertical XY Chart",IDS_BASEMULTIPLECHART:"Base Multiple Chart",IDS_BASEMULTIPLEXYCHART:"Base Multiple XY Chart",IDS_BASESINGLECHART:"Base Single Chart",IDS_HEATMAPCHART:"Heat Map",IDS_TREEMAPCHART:"Tree Map",IDS_MULTIBARCHART:"Multiple Bar Chart",IDS_MULTIBUBBLECHART:"Multiple Bubble Chart",IDS_MULTIDONUTCHART:"Multiple Donut Chart",IDS_MULTIDUALBARCHART:"Multiple Bar Chart with 2 X-Axes",IDS_MULTIDUALHORIZONTALLINECHART:"Multiple Horizontal Line Chart with 2 X-Axes",IDS_MULTIDUALLINECHART:"Multiple Line Chart with 2 Y-Axes",IDS_MULTIDUALPERCENTAGESTACKEDBARCHART:"Multiple 100% Stacked Bar Chart with 2 X-Axes",IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART:"Multiple 100% Stacked Column Chart with 2 Y-Axes",IDS_MULTIDUALSTACKEDBARCHART:"Multiple Stacked Bar Chart with 2 X-Axes",IDS_MULTIDUALSTACKEDVERTICALBARCHART:"Multiple Stacked Column Chart with 2 Y-Axes",IDS_MULTIDUALVERTICALBARCHART:"Multiple Column Chart with 2 Y-Axes",IDS_MULTIHORIZONTALLINECHART:"Multiple Horizontal Line Chart",IDS_MULTILINECHART:"Multiple Line Chart",IDS_MULTIPERCENTAGESTACKEDBARCHART:"Multiple 100% Stacked Bar Chart",IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART:"Multiple 100% Stacked Column Chart",IDS_MULTIPIECHART:"Multiple Pie Chart",IDS_MULTISCATTERCHART:"Multiple Scatter Plot",IDS_MULTISTACKEDBARCHART:"Multiple Stacked Bar Chart",IDS_MULTISTACKEDVERTICALBARCHART:"Multiple Stacked Column Chart",IDS_MULTIVERTICALBARCHART:"Multiple Column Chart",IDS_MULTIRADARCHART:"Multiple Radar Chart",IDS_RADARCHART:"Radar Chart",IDS_SCATTERMATRIXCHART:"Scatter Matrix Chart",IDS_TAGCLOUDCHART:"Tag Cloud",IDS_MEKKOCHART:"Mekko chart",IDS_HORIZONTALMEKKOCHART:"Horizontal Mekko Chart",IDS_PERCENTAGEMEKKOCHART:"100% Mekko Chart",IDS_PERCENTAGEHORIZONTALMEKKOCHART:"100% Horizontal Mekko Chart",IDS_REGIONCOLOR:"Region Color",IDS_PRIMARYVALUES:"Primary Values",IDS_SECONDARYVALUES:"Secondary Values",IDS_AXISLABELS:"Axis Labels",IDS_RECTANGLETITLE:"Rectangle Title",IDS_RECTANGLEWEIGHT:"Rectangle Weight",IDS_RECTANGLECOLOR:"Rectangle Color",IDS_TAGNAME:"Tag Name",IDS_TAGWEIGHT:"Tags Weight",IDS_TAGFAMILY:"Tags Family",IDS_CATEGORYAXIS:"Axis Labels Category",IDS_REGIONSHAPE:"Region Shape",IDS_BUBBLEWIDTH:"Bubble Width",IDS_BUBBLEHEIGHT:"Bubble Height",IDS_RADARAXES:"Radar Axes",IDS_RADARAXESVALUE:"Radar Axes Values",IDS_PIESECTORCOLORNAME:"Sector Color",IDS_PIESECTORSIZE:"Sector Size",IDS_MAINLABELAXISNAME:"Main Category Axis",IDS_SECONDARYAXISLABELNAME:"Secondary Category Axis",IDS_SELECTABILITY:"selectability",IDS_PRIMARYVALUECOLORPALETTE:"primaryValuesColorPalette",IDS_SECONDARYVALUESCOLORPALETTE:"secondaryValuesColorPalette",IDS_DRAWINGEFFECT:"drawingEffect",IDS_TOOLTIPVISIBLE:"tooltipVisible",IDS_ENABLEROUNDCORNER:"enableRoundCorner",IDS_ANIMATION:"animation",IDS_DATALOADING:"dataLoading",IDS_DATAUPDATING:"dataUpdating",IDS_BAR:"bar",IDS_LINE:"line",IDS_WIDTH:"width",IDS_HOVERLINEVISIBLE:"hoverlineVisible",IDS_MARKER:"marker",IDS_VISIBLE:"visible",IDS_SHAPE:"shape",IDS_SIZE:"size",IDS_HEADERVISIBLE:"headerVisible",IDS_AXISVISIBLE:"axisVisible",IDS_GRIDVISIBLE:"gridVisible",IDS_COLUMNSEQUENCE:"columnSequence",IDS_COLUMNCONFIG:"columnConfig",IDS_STARTCOLUMN:"startColumn",IDS_LABEL:"label",IDS_VALUEFORMAT:"valueFormat",IDS_ENDCOLUMN:"endColumn",IDS_HIGHCOLUMN:"highColumn",IDS_LOWCOLUMN:"lowColumn",IDS_LINECONFIG:"lineConfig",IDS_MARKERS:"markers",IDS_FILLVISIBLE:"fillVisible",IDS_REFINEVISIBLE:"reflineVisible",IDS_MODE:"mode",IDS_TITLE:"title",IDS_TEXT:"text",IDS_GRIDLINE:"gridline",IDS_SHOWFIRSTLINE:"showFirstLine",IDS_TYPE:"type",IDS_FORMAT:"format",IDS_POSITION:"position",IDS_BORDER:"border",IDS_STARTCOLOR:"startcolor",IDS_ENDCOLOR:"endcolor",}});